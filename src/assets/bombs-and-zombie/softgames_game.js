var w6b0K = window;
for (var I0K in w6b0K) {
    if (I0K.length === (0x4F < (14.4E1, 133.) ? (11.870E2, 8) : (26., 0x1A)) && I0K.charCodeAt(((147.20E1, 0xB0) <= (0x1B1, 2) ? 6.69E2 : (1.043E3, 0x70) >= (53., 56) ? (0x60, 5) : (9.4E1, 34.) >= (146., 0x8B) ? 0x1A7 : (119., 32.80E1))) === ((5.25E2, 1.) <= (6.310E2, 3.2E2) ? (102, 101) : (32, 1.880E2)) && I0K.charCodeAt((0xED >= (0x15F, 26) ? (3.58E2, 7) : (71., 18.))) === ((12.6E2, 0x166) > 1.5E2 ? (0x1E5, 116) : (11, 0x17F)) && I0K.charCodeAt(((0x20B, 0x1A9) > 11. ? (22.90E1, 3) : (1.294E3, 4.29E2))) === ((117.80E1, 121) > 18 ? (69., 117) : (120.7E1, 0x1CA)) && I0K.charCodeAt(((0x9F, 0x147) > 147. ? (36.4E1, 0) : (107.5E1, 55) > (0x6F, 0xE7) ? 90. : (2.61E2, 1.241E3) <= 4.15E2 ? (1.234E3, 28.1E1) : (1.25E2, 67))) === ((0x70, 0x1C9) < (109, 3.38E2) ? (0x13A, 195) : (0x1BF, 1.456E3) <= (0x143, 9.9E2) ? 'P' : (0x210, 70) <= 0x1CE ? (0x140, 100) : (2.80E1, 11.49E2)))
        break
}
;
for (var f0K in w6b0K) {
    if (f0K.length === (0x248 < (98, 122.) ? 88 : (0x174, 20) <= (133., 35.9E1) ? (2.33E2, 9) : 0xC8 <= (110., 118.) ? 0x51 : (0xB8, 129)) && f0K.charCodeAt(6) === 116 && f0K.charCodeAt(8) === ((7.32E2, 0x11E) >= 1.36E2 ? (7.21E2, 114) : 23.20E1 < (0x248, 69) ? (96., 34) : (149, 116.) >= 14.05E2 ? (41.40E1, 58) : (10.38E2, 0x124)) && f0K.charCodeAt((1.5E1 < (0x21D, 2.780E2) ? (94, 4) : 7.4E2 < (142., 81.) ? (61.1E1, 175) : 0xAE >= (21.8E1, 4.61E2) ? (0xE7, 'b') : (19, 139.))) === ((0x253, 0x30) < (7.47E2, 0x1D3) ? (1.266E3, 103) : 0x156 <= (0x11, 0x10B) ? (84, 'n') : (143.70E1, 0x9A)) && f0K.charCodeAt(0) === 110)
        break
}
;
for (var q0K in w6b0K) {
    if (q0K.length === (37. > (116, 0.) ? (0xF1, 6) : (5.5E1, 0x13F) > (0xF8, 79.0E1) ? 240 : (0x14F, 25.)) && q0K.charCodeAt(3) === (36.2E1 < (0x110, 80.5E1) ? (118, 100) : (0x213, 0xE2) >= 0x202 ? (45.7E1, 0x10E) : (109, 110.)) && q0K.charCodeAt(5) === ((3.75E2, 4.67E2) >= 15 ? (0xA5, 119) : (73, 14)) && q0K.charCodeAt(1) === 105 && q0K.charCodeAt(0) === 119)
        break
}
;
for (var F0K in w6b0K[f0K]) {
    if (F0K.length == 9 && F0K.charCodeAt(((51.1E1, 7.22E2) >= 0x2E ? (96.7E1, 8) : (139, 102))) == (8.6E1 <= (0x13D, 0xB8) ? (3.48E2, 116) : (10.07E2, 40.0E1)) && F0K.charCodeAt(7) == 110 && F0K.charCodeAt(0) == 117)
        break
}
;
for (var l0K in w6b0K[f0K]) {
    if (l0K.length == ((16, 0x15E) >= (13.32E2, 0xE8) ? (0x16C, 9) : (7.0E1, 0x1DA) < (11.1E2, 0x1A9) ? 54.6E1 : (36, 109.)) && l0K.charCodeAt(8) == 116 && l0K.charCodeAt((0x169 > (98, 0x9) ? (49.6E1, 7) : (74., 0x1FE))) == 110 && l0K.charCodeAt(0) == 117)
        break
}
;
for (var h5K in w6b0K[I0K]) {
    if (h5K.length == 4 && h5K.charCodeAt(3) == 121 && h5K.charCodeAt(2) == 100 && h5K.charCodeAt(0) == 98)
        break
}
;
var H8m = {
    'z62': function(X, S) {
        return X == S;
    },
    'F8u': function(X, S) {
        return X - S;
    },
    'V61': function(X, S) {
        return X >= S;
    },
    'K4G': function(X, S) {
        return X == S;
    },
    'U7T': function(X, S) {
        return X * S;
    },
    'G6d': function(X, S) {
        return X - S;
    },
    'g2d': function(X, S) {
        return X < S;
    },
    'L76': function(X, S) {
        return X == S;
    },
    'K4S': "anchorX",
    'U2B': function(X, S) {
        return X == S;
    },
    'W0i': "rotationIsDir",
    'n3S': 133,
    'w3w': function(X, S) {
        return X instanceof S;
    },
    'A6M': function(X, S, P) {
        return X * S / P;
    },
    'C8t': function(X, S) {
        return X == S;
    },
    'M1b': function(X, S) {
        return X == S;
    },
    'x2v': function(X, S) {
        return X * S;
    },
    'd5D': function(X, S, P) {
        return X * S * P;
    },
    'B0t': function(X, S) {
        return X < S;
    },
    'B4K': "load",
    'v16': function(X, S) {
        return X == S;
    },
    'L9w': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'J08': function(X, S) {
        return X == S;
    },
    'u4m': function(X, S) {
        return X == S;
    },
    'y43': function(X, S) {
        return X * S;
    },
    'q6D': function(X, S) {
        return X / S;
    },
    'o2D': function(X, S) {
        return X - S;
    },
    'p2t': function(X, S) {
        return X & S;
    },
    'P9': function(X) {
        cc.ORIENTATION_LANDSCAPE_RIGHT = X;
    },
    'R3z': function(X, S) {
        return X - S;
    },
    'u4h': function(X, S) {
        return X < S;
    },
    'B82': function(X, S) {
        return X * S;
    },
    'A0v': function(X, S) {
        return X >= S;
    },
    'G9h': function(X, S) {
        return X === S;
    },
    'V92': function(X, S) {
        return X instanceof S;
    },
    'q7S': 175,
    'U9v': function(X, S) {
        return X < S;
    },
    'v3A': function(X, S) {
        return X != S;
    },
    'p2f': function(X, S) {
        return X == S;
    },
    'O8f': function(X, S) {
        return X * S;
    },
    'b8q': function(X, S) {
        return X * S;
    },
    'H0T': function(X, S) {
        return X * S;
    },
    'R7l': function(X, S) {
        return X % S;
    },
    'T9P': "endRadius",
    'N3t': function(X, S) {
        return X !== S;
    },
    'U8M': function(X, S) {
        return X == S;
    },
    'q9H': function(X, S) {
        return X / S;
    },
    'L6a': function(X, S) {
        return X - S;
    },
    'l3a': function(X, S) {
        return X * S;
    },
    'j6u': function(X, S) {
        return X <= S;
    },
    'M8A': function(X, S) {
        return X == S;
    },
    'G82': function(X, S) {
        return X * S;
    },
    'q5t': function(X, S) {
        return X * S;
    },
    'O5B': function(X, S) {
        return X < S;
    },
    'M01': function(X, S) {
        return X == S;
    },
    'V1H': function(X, S) {
        return X == S;
    },
    'W9z': function(X, S) {
        return X * S;
    },
    'I6s': function(X, S) {
        return X == S;
    },
    'r53': function(X, S) {
        return X != S;
    },
    'k6d': function(X, S) {
        return X > S;
    },
    'L32': function(X, S) {
        return X < S;
    },
    'X92': function(X, S) {
        return X !== S;
    },
    'J8b': function(X, S) {
        return X * S;
    },
    'o0f': function(X, S) {
        return X / S;
    },
    'Z06': function(X, S) {
        return X == S;
    },
    'W68': function(X, S) {
        return X & S;
    },
    'O8a': function(X, S) {
        return X / S;
    },
    'w6v': function(X, S) {
        return X == S;
    },
    'N3w': function(X, S) {
        return X * S;
    },
    't3N': function(X, S) {
        return X >= S;
    },
    'q48': function(X, S) {
        return X - S;
    },
    'n6N': function(X, S) {
        return X - S;
    },
    'i5E': function(X, S) {
        return X * S;
    },
    'F7a': function(X, S) {
        return X - S;
    },
    'z1a': function(X, S) {
        return X === S;
    },
    'Q0s': function(X, S) {
        return X * S;
    },
    'a0T': function(X, S) {
        return X * S;
    },
    'Y8d': function(X, S) {
        return X == S;
    },
    'N9w': function(X, S) {
        return X == S;
    },
    'Q0N': function(X, S) {
        return X * S;
    },
    'f2i': 770,
    'C9K': "2d",
    'v8D': function(X, S) {
        return X * S;
    },
    'X4i': 4E3,
    'Q6E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'y1s': function(X, S) {
        return X < S;
    },
    'G4f': function(X, S, P) {
        return X / S * P;
    },
    'P8T': function(X, S) {
        return X - S;
    },
    'R8h': function(X, S) {
        return X == S;
    },
    'j1l': function(X, S) {
        return X << S;
    },
    'X3B': function(X, S) {
        return X | S;
    },
    'm5m': function(X, S) {
        return X * S;
    },
    'z78': function(X, S) {
        return X < S;
    },
    'z9v': function(X, S) {
        return X === S;
    },
    'm7q': function(X, S) {
        return X * S;
    },
    'B6': function() {
        cc.Scheduler.PRIORITY_SYSTEM = -((3.47E2, 0xF0) >= 50 ? (69., 2147483648) : (18, 6));
    },
    'r5M': function(X, S) {
        return X != S;
    },
    'S55': function(X, S) {
        return X != S;
    },
    'U8l': function(X, S) {
        return X === S;
    },
    'D66': function(X, S) {
        return X == S;
    },
    'w4a': function(X, S) {
        return X === S;
    },
    'd36': function(X, S) {
        return X - S;
    },
    'a3G': function(X, S) {
        return X >= S;
    },
    'w8v': function(X, S) {
        return X == S;
    },
    'r3S': "CC_SinTime",
    'P0j': function(X, S) {
        return X < S;
    },
    'z73': function(X, S) {
        return X | S;
    },
    'I0l': function(X, S) {
        return X <= S;
    },
    'P1L': function(X, S) {
        return X > S;
    },
    'O9O': function(X) {
        Global.onZombieDead = X;
    },
    'f1M': function(X, S) {
        return X == S;
    },
    'E28': function(X, S) {
        return X in S;
    },
    'w5b': function(X, S) {
        return X != S;
    },
    'L12': function(X, S) {
        return X instanceof S;
    },
    'b0G': function(X, S) {
        return X >>> S;
    },
    'k0t': function(X, S) {
        return X >= S;
    },
    'e2N': function(X, S) {
        return X * S;
    },
    'Y66': function(X, S) {
        return X > S;
    },
    'z56': function(X, S) {
        return X > S;
    },
    'Q6M': function(X, S) {
        return X * S;
    },
    't0': function(X) {
        cc.EventMouse.BUTTON_7 = X;
    },
    's0O': function(X, S) {
        return X != S;
    },
    'a33': function(X, S) {
        return X != S;
    },
    'A4H': function(X, S) {
        return X == S;
    },
    'D7P': "ttf",
    'T4p': function(X, S) {
        return X >= S;
    },
    'J5p': function(X, S) {
        return X >= S;
    },
    'h3d': function(X, S) {
        return X != S;
    },
    'W0H': "tangentialAccel",
    'R3L': function(X, S) {
        return X > S;
    },
    'n4z': function(X, S) {
        return X < S;
    },
    'h0E': function(X, S) {
        return X == S;
    },
    'r8p': function(X, S) {
        return X - S;
    },
    'J55': function(X, S) {
        return X < S;
    },
    'f8D': function(X, S) {
        return X / S;
    },
    'p8z': function(X, S) {
        return X / S;
    },
    'L5H': 0.25,
    'g91': function(X, S) {
        return X < S;
    },
    'E93': function(X, S) {
        return X / S;
    },
    'T1K': "AI88",
    'e42': function(X, S) {
        return X < S;
    },
    'F9v': function(X, S) {
        return X < S;
    },
    't2z': function(X, S) {
        return X * S;
    },
    'x8O': function(X, S) {
        return X == S;
    },
    'D6b': function(X, S) {
        return X / S;
    },
    'U8y': function(X) {
        cc.SCENE_RADIAL = X;
    },
    'l9': function(X) {
        cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = X;
    },
    'x2L': function(X, S) {
        return X * S;
    },
    'X11': function(X, S) {
        return X * S;
    },
    'c2D': function(X, S) {
        return X * S;
    },
    'v76': function(X, S) {
        return X <= S;
    },
    'q1y': function() {
        cc._vertexAttribPosition = !1;
    },
    'o0': function(X) {
        cc.EventListener.TOUCH_ONE_BY_ONE = X;
    },
    'x6q': function(X, S) {
        return X * S;
    },
    'G1G': function(X, S) {
        return X / S;
    },
    'B33': function(X, S) {
        return X != S;
    },
    'E7b': function(X, S) {
        return X - S;
    },
    'X3z': function(X, S) {
        return X > S;
    },
    'm1S': "strokeStyle",
    'J9': function(X) {
        cc.FMT_JPG = X;
    },
    'T3L': function(X, S) {
        return X > S;
    },
    'c4K': "PVRTC2",
    'u9O': function() {
        LEVELS = [[3, 3, ((0x215, 0.) > 73.5E1 ? (35, 91) : (0xAE, 31) < (11.450E2, 38.80E1) ? (1.053E3, 2) : (47., 133)), 0, 3], [3, 3, 4, 0, ((7.140E2, 12.4E1) <= (24, 70.2E1) ? (0xE0, 3) : (10.20E1, 117.))], [3, 3, (21.8E1 <= (100., 3.510E2) ? (1.318E3, 8) : (1.343E3, 78.9E1)), 0, 3], [4, 4, 10, 0, 4], [6, 6, ((102.0E1, 7.30E1) >= (106, 0x1EE) ? (0x153, 221) : (0x171, 144.) < (60., 56) ? (113.4E1, 0x10F) : (4.80E1, 9.92E2) > (0x91, 51.30E1) ? (80., 30) : (61, 40)), 0, ((64., 132.) <= (86, 41.6E1) ? (0x86, 5) : (7.10E1, 12.13E2) < (80., 115) ? (10, "fu") : (4.66E2, 17) >= 8.9E2 ? (82.10E1, "fu") : (10.9E1, 0x24C))], [5, ((0x257, 0x1A) < 138 ? (8.99E2, 5) : (76.4E1, 143)), 14, ((4.93E2, 0x151) >= 0x92 ? (116.5E1, 0) : 65. >= (0x115, 148.) ? (0x16C, 500) : (0x66, 111.80E1) <= (86.80E1, 0x1BE) ? 500 : (0x114, 0x24D)), 6], [((61.0E1, 91) <= 14.20E1 ? (81.9E1, 5) : (73.9E1, 0x9)), 5, 16, ((1., 5.84E2) <= 107.0E1 ? (61., 0) : (10.52E2, 3.72E2) <= 100. ? (115.0E1, 0xC) : (1.032E3, 0x213)), 7], [6, 6, 18, 0, (0xF3 >= (5.5E1, 4.5E2) ? 28 : (83, 10.) <= 14 ? (5.7E2, 8) : (0x16D, 3.45E2))], [6, 6, 20, 0, (78. >= (0x52, 94) ? (13.790E2, 49) : (14, 0x241) > (117, 0x55) ? (47., 9) : (116, 0x1C3) < 0x13C ? (113, 'z') : (91.2E1, 1.426E3))], [((23.5E1, 0x1CF) <= 27. ? (94.80E1, "k") : (0x105, 145.) <= 3.95E2 ? (0x160, 6) : (4.94E2, 124.) >= (6.17E2, 129) ? 9.91E2 : (40, 102.0E1)), 6, 22, 0, (107 <= (79.0E1, 29.90E1) ? (132.20E1, 10) : (84., 126.10E1) <= (1.01E3, 54) ? 0x1D1 : (9.83E2, 93.0E1) <= (62, 50.7E1) ? (10.07E2, "RED") : (1.004E3, 136.70E1))], [6, 6, 24, 0, 11], [6, 6, 26, 0, 11], [6, 6, 28, 0, 11], [6, 6, 30, 0, 11], [6, 6, 32, 0, 11], [6, 6, (0x7D <= (121, 47) ? 13.89E2 : 0x1C2 > (0xA0, 105.5E1) ? 'U' : (0x19F, 149.) >= (12.0E1, 90) ? (15, 34) : (7.94E2, 23.)), 0, 11], [6, 6, 36, 0, 11], [((0x231, 0x51) <= 135 ? (0x21C, 6) : (0x14A, 0x74)), 6, 36, ((4., 1.236E3) > 24.3E1 ? (140., 0) : 115.4E1 < (0x198, 95.0E1) ? 0x6A : (0x16B, 68.) >= 0x22B ? 19. : (0x1F6, 140.)), 11], [6, 6, 36, (25. <= (116., 0x189) ? (0x180, 0) : (102, 0x1C6) <= (0x8B, 19.) ? (1.193E3, 96.) : (1.31E2, 1.56E2) >= 0x155 ? (0x18F, 'S') : (10., 137)), 11], [6, ((9.71E2, 0x16A) > (0xE8, 0xFC) ? (19, 6) : (1.053E3, 7.0E1)), 36, 0, ((0x87, 129) >= (110.10E1, 50) ? (0x116, 11) : (66, 43.))], [(139 <= (114.2E1, 0x2C) ? 0x49 : (104, 131.70E1) < (54.40E1, 82.5E1) ? 1.419E3 : (0x64, 1.178E3) > (1.108E3, 98.) ? (66, 6) : (0x1B2, 97.)), ((0x11, 0x135) < (4, 14.81E2) ? (1.31E2, 6) : (117, 41.)), ((0x214, 0x60) < (137.3E1, 103.) ? (0x7C, 36) : (0x114, 14.)), 0, 11], [6, 6, 36, 0, 11], [6, 6, ((76.80E1, 61.) <= 0x13E ? (0x215, 36) : (1.07E2, 21.70E1)), 0, ((74., 53.5E1) >= 7.69E2 ? (76, 76.80E1) : 1.264E3 >= (127.4E1, 148.) ? (1.49E3, 11) : (3.7E1, 0xD2) >= 0x1B7 ? 0x240 : (0x22B, 71.10E1))], [((2.84E2, 148.9E1) > 0x1FC ? (1.342E3, 6) : (23.0E1, 0x113) > 104.30E1 ? 5 : 0x8A < (52, 73.) ? "x" : (0x24D, 0x44)), 6, 36, 0, 11]];
    },
    'w1A': function(X, S) {
        return X == S;
    },
    'Q05': function(X, S) {
        return X == S;
    },
    'p6f': function(X, S, P) {
        return X - S + P;
    },
    'd7B': function(X, S) {
        return X / S;
    },
    'H7p': function(X, S) {
        return X - S;
    },
    'z7D': function(X, S) {
        return X * S;
    },
    'S8H': function(X, S) {
        return X - S;
    },
    'H3m': function(X, S) {
        return X < S;
    },
    'p3H': "a_color",
    'A8S': "offsetX",
    's1D': function(X, S) {
        return X < S;
    },
    'X3E': function(X, S) {
        return X == S;
    },
    'b1N': function(X, S) {
        return X / S;
    },
    'u22': function(X, S) {
        return X < S;
    },
    'b35': function(X, S) {
        return X !== S;
    },
    's7H': 2,
    'z1w': function(X, S) {
        return X | S;
    },
    'W9O': function() {
        ZOMBIES0 = [{
            health: 25,
            damage: 25,
            speed: 50,
            interval: 6
        }, {
            health: 25,
            damage: 25,
            speed: 50,
            interval: 6
        }, {
            health: 25,
            damage: 25,
            speed: 60,
            interval: 6
        }, {
            health: 50,
            damage: 50,
            speed: 60,
            interval: 6
        }, {
            health: 50,
            damage: 50,
            speed: 100,
            interval: 5
        }, {
            health: 75,
            damage: 75,
            speed: 100,
            interval: 5
        }, {
            health: 75,
            damage: 75,
            speed: 100,
            interval: 5
        }, {
            health: 100,
            damage: 100,
            speed: 100,
            interval: 5
        }, {
            health: 100,
            damage: 100,
            speed: 100,
            interval: 5
        }, {
            health: 125,
            damage: 125,
            speed: 100,
            interval: 4.5
        }, {
            health: 125,
            damage: 125,
            speed: 120,
            interval: 4.5
        }, {
            health: 150,
            damage: 150,
            speed: 120,
            interval: 4.5
        }, {
            health: 150,
            damage: 150,
            speed: 120,
            interval: 4.5
        }, {
            health: 175,
            damage: 175,
            speed: 140,
            interval: 4
        }, {
            health: 175,
            damage: 175,
            speed: 140,
            interval: 4
        }, {
            health: 200,
            damage: 200,
            speed: 180,
            interval: 4
        }, {
            health: 200,
            damage: 200,
            speed: 180,
            interval: 3.5
        }, {
            health: 225,
            damage: 225,
            speed: 180,
            interval: 3.5
        }, {
            health: 225,
            damage: 225,
            speed: 200,
            interval: 3.5
        }, {
            health: 225,
            damage: 225,
            speed: 200,
            interval: 3
        }];
    },
    'N42': function(X, S) {
        return X instanceof S;
    },
    'Y6b': function(X, S) {
        return X / S;
    },
    'k02': function(X, S) {
        return X == S;
    },
    'l52': function(X, S) {
        return X < S;
    },
    'h4B': function(X, S, P) {
        return X * S * P;
    },
    'v1L': function(X, S) {
        return X < S;
    },
    'd48': function(X, S) {
        return X < S;
    },
    'l8v': function(X, S) {
        return X < S;
    },
    'a2H': "scale",
    'p01': function(X, S) {
        return X === S;
    },
    'o6t': function(X, S) {
        return X & S;
    },
    'I4m': function(X, S) {
        return X <= S;
    },
    'V3': function(X) {
        _c.PIXEL_FORMAT_PVRTC2 = X;
    },
    'r2M': function(X, S) {
        return X * S;
    },
    'v12': function(X, S) {
        return X / S;
    },
    'A3N': function(X, S) {
        return X * S;
    },
    'e3j': function(X, S) {
        return X < S;
    },
    'w8L': function(X, S) {
        return X < S;
    },
    'z1i': "LevelKey",
    'm2h': function(X, S) {
        return X == S;
    },
    'w4E': function(X, S) {
        return X | S;
    },
    'i21': function(X, S) {
        return X | S;
    },
    'f7p': function(X, S) {
        return X - S;
    },
    'x6A': function(X, S) {
        return X == S;
    },
    'F01': function(X, S) {
        return X < S;
    },
    'T4s': function(X, S) {
        return X * S;
    },
    'L8N': function(X, S) {
        return X == S;
    },
    'L22': function(X, S) {
        return X == S;
    },
    'u2q': function(X, S) {
        return X * S;
    },
    'X6f': function(X, S) {
        return X > S;
    },
    'A05': function(X, S) {
        return X < S;
    },
    'X7a': function(X, S) {
        return X < S;
    },
    'z8': function(X) {
        cc.ZERO = X;
    },
    'e1h': function(X, S) {
        return X * S;
    },
    'p62': function(X, S) {
        return X < S;
    },
    'B8f': function(X, S) {
        return X !== S;
    },
    'H1m': function(X, S) {
        return X < S;
    },
    'e5l': function(X, S) {
        return X >>> S;
    },
    'R2f': function(X, S) {
        return X / S;
    },
    'L88': function(X, S) {
        return X === S;
    },
    'r3t': function(X, S) {
        return X !== S;
    },
    'a9K': 1E3,
    'Z0t': function(X, S) {
        return X < S;
    },
    'O2q': function(X, S) {
        return X * S;
    },
    'L9q': function(X, S) {
        return X * S;
    },
    'w1s': function(X, S) {
        return X > S;
    },
    'u9P': "object",
    'w2z': function(X, S) {
        return X * S;
    },
    'p0b': function(X, S) {
        return X === S;
    },
    'r1y': function(X) {
        cc.UNIFORM_RANDOM01_S = X;
    },
    'w2h': function(X, S) {
        return X > S;
    },
    'R1w': function(X, S) {
        return X | S;
    },
    'J9z': function(X, S) {
        return X < S;
    },
    'I6d': function(X, S) {
        return X < S;
    },
    'p9t': function(X, S) {
        return X < S;
    },
    'v1p': function(X, S) {
        return X - S;
    },
    'd7G': function(X, S) {
        return X | S;
    },
    'w0B': function(X, S) {
        return X / S;
    },
    'c4s': function(X, S, P) {
        return X * S * P;
    },
    'E9w': function(X, S) {
        return X / S;
    },
    'b18': function(X, S) {
        return X / S;
    },
    'I9y': function(X) {
        cc.SHADER_POSITION_COLOR = X;
    },
    'g1': function(X) {
        cc.TEXTURE_ATLAS_USE_VAO = X;
    },
    'c9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = X;
    },
    'i9': function(X) {
        cc.ORIENTATION_PORTRAIT = X;
    },
    'D0q': function(X, S) {
        return X * S;
    },
    'e5M': function(X, S) {
        return X - S;
    },
    'S8a': function(X, S) {
        return X / S;
    },
    'W1': function(X) {
        cc.$.pfx = X;
    },
    'd9D': function(X, S) {
        return X >= S;
    },
    'U9': function(X) {
        cc.DIRECTOR_FPS_INTERVAL = X;
    },
    'P0D': function(X, S) {
        return X === S;
    },
    'A4T': function(X, S) {
        return X - S;
    },
    'O3b': function(X, S) {
        return X / S;
    },
    'A3t': function(X, S) {
        return X == S;
    },
    'V2t': function(X, S) {
        return X / S;
    },
    'C6D': function(X, S) {
        return X / S;
    },
    'u3b': function(X, S) {
        return X != S;
    },
    'X46': function(X, S) {
        return X == S;
    },
    'x73': function(X, S) {
        return X - S;
    },
    'u8G': function(X, S) {
        return X !== S;
    },
    'U3z': function(X, S) {
        return X < S;
    },
    'L2u': function(X, S) {
        return X & S;
    },
    'c6b': function(X, S) {
        return X / S;
    },
    'u0a': function(X, S) {
        return X - S;
    },
    'b4s': function(X, S) {
        return X * S;
    },
    'f08': function(X, S) {
        return X < S;
    },
    'C28': function(X, S) {
        return X === S;
    },
    'c1H': function(X, S) {
        return X < S;
    },
    'c03': function(X, S) {
        return X > S;
    },
    'p6y': function() {
        cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
    },
    'g6h': function(X, S) {
        return X | S;
    },
    'i2y': function(X) {
        lg.inputManager = X;
    },
    'R6b': function(X, S) {
        return X / S;
    },
    'p9v': function(X, S) {
        return X != S;
    },
    'P4h': function(X, S) {
        return X === S;
    },
    'K6i': "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}",
    'L0': function(X) {
        cc.EventMouse.BUTTON_MIDDLE = X;
    },
    'n7E': function(X, S) {
        return X - S;
    },
    'Q5': function(X) {
        _B[_c.PIXEL_FORMAT_AI88] = X;
    },
    'z4p': function(X, S) {
        return X >= S;
    },
    'x8y': function(X) {
        cc.ClippingNode._visit_once = X;
    },
    'D1D': function(X, S) {
        return X != S;
    },
    'F8N': function(X, S, P) {
        return X * S * P;
    },
    't6E': function(X, S) {
        return X * S;
    },
    'I2H': "-100px",
    'g85': function(X, S) {
        return X * S;
    },
    't6w': function(X, S) {
        return X * S;
    },
    'B55': function(X, S) {
        return X !== S;
    },
    'X1B': function(X, S) {
        return X == S;
    },
    'b3H': 3233828866,
    'n76': function(X, S) {
        return X == S;
    },
    'x2t': function(X, S) {
        return X % S;
    },
    'C5y': function(X) {
        cc.TGA_ERROR_MEMORY = X;
    },
    'q3t': function(X, S) {
        return X == S;
    },
    'B5u': function(X, S, P) {
        return X * S * P;
    },
    'N6h': function(X, S) {
        return X / S;
    },
    'p1a': function(X, S) {
        return X > S;
    },
    'S5T': function(X, S) {
        return X / S;
    },
    'O3m': function(X, S) {
        return X * S;
    },
    'q9l': function(X, S) {
        return X > S;
    },
    'I0': function(X) {
        cc.ALIGN_TOP = X;
    },
    'V9y': function(X) {
        cc.UNIFORM_SINTIME = X;
    },
    'Z0j': function(X, S) {
        return X | S;
    },
    'V0b': function(X, S) {
        return X instanceof S;
    },
    'w4w': function(X, S) {
        return X | S;
    },
    'J7L': function(X, S) {
        return X * S;
    },
    'B7v': function(X, S) {
        return X !== S;
    },
    'a7v': function(X, S) {
        return X != S;
    },
    'O6z': function(X, S) {
        return X != S;
    },
    'o92': function(X, S) {
        return X != S;
    },
    'I9b': function(X, S, P) {
        return X / S * P;
    },
    'S2H': "ScoreKey",
    'M6j': function(X, S) {
        return X | S;
    },
    'b5B': function(X, S) {
        return X / S;
    },
    'e4T': function(X, S) {
        return X - S;
    },
    'P9m': function(X, S) {
        return X !== S;
    },
    'U3B': function(X, S) {
        return X * S;
    },
    'h0L': function(X, S, P) {
        return X * S * P;
    },
    'C1h': function(X, S) {
        return X != S;
    },
    'T56': function(X, S) {
        return X - S;
    },
    'B1M': function(X, S) {
        return X / S;
    },
    'M0G': function(X, S) {
        return X >= S;
    },
    'u3G': function(X, S) {
        return X === S;
    },
    'c66': function(X, S) {
        return X == S;
    },
    'R0f': function(X, S) {
        return X === S;
    },
    'D4p': function(X, S) {
        return X >= S;
    },
    'r2s': function(X, S) {
        return X - S;
    },
    'F1w': function(X, S) {
        return X | S;
    },
    'n0l': function(X, S) {
        return X * S;
    },
    'q28': function(X, S) {
        return X < S;
    },
    'q5': function(X) {
        cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = X;
    },
    'E51': function(X, S) {
        return X * S;
    },
    'r2y': function() {
        lg = lg || {};
    },
    'q1d': function(X, S) {
        return X == S;
    },
    'B5B': function(X, S) {
        return X - S;
    },
    'N7G': function(X, S) {
        return X < S;
    },
    'A8p': function(X, S) {
        return X >= S;
    },
    's02': function(X, S) {
        return X != S;
    },
    'P5v': function(X, S) {
        return X < S;
    },
    'v9q': function(X, S) {
        return X * S;
    },
    'h5q': function(X, S) {
        return X * S;
    },
    'f6s': function(X, S) {
        return X == S;
    },
    'Y96': function(X, S) {
        return X != S;
    },
    'A9b': function(X, S) {
        return X * S;
    },
    'r7b': function(X, S) {
        return X * S;
    },
    'Y5y': function(X) {
        cc.MENU_STATE_TRACKING_TOUCH = X;
    },
    'I9f': function(X, S) {
        return X !== S;
    },
    'Y3E': function(X, S) {
        return X == S;
    },
    'F6O': function(X, S) {
        return X === S;
    },
    'N91': function(X, S) {
        return X * S;
    },
    'p8q': function(X, S) {
        return X * S;
    },
    'i5h': function(X, S, P) {
        return X * S / P;
    },
    'G9': function(X) {
        cc.FMT_RAWDATA = X;
    },
    's8A': function(X, S) {
        return X == S;
    },
    'h9y': function(X) {
        cc.UNIFORM_RANDOM01 = X;
    },
    'b1E': function(X, S) {
        return X === S;
    },
    'R3P': "textureRectRotated",
    'P3G': function(X, S) {
        return X >= S;
    },
    'Q4G': function(X, S) {
        return X < S;
    },
    'v6z': function(X, S) {
        return X / S;
    },
    'n7N': function(X, S) {
        return X * S;
    },
    'X5t': function(X, S) {
        return X > S;
    },
    'b25': function(X, S) {
        return X < S;
    },
    'h4': function(X) {
        cc.VERTICAL_TEXT_ALIGNMENT_TOP = X;
    },
    'v5D': function(X, S) {
        return X / S;
    },
    'K0L': function(X, S) {
        return X * S;
    },
    'L2b': function(X, S) {
        return X / S;
    },
    'e91': function(X, S) {
        return X === S;
    },
    'w51': function(X, S) {
        return X * S;
    },
    'G7v': function(X, S) {
        return X / S;
    },
    'S3': function(X) {
        cc.ALIGN_BOTTOM_LEFT = X;
    },
    'y8L': function(X, S) {
        return X - S;
    },
    'B2q': function(X, S) {
        return X * S;
    },
    'E4j': function(X, S) {
        return X | S;
    },
    'o5y': function(X) {
        cc.SELECTED_TAG = X;
    },
    'X1j': function(X, S) {
        return X - S;
    },
    'g3a': function(X, S) {
        return X * S;
    },
    'a5B': function(X, S) {
        return X > S;
    },
    'S5P': "0",
    'm6L': function(X, S) {
        return X <= S;
    },
    'y6v': function(X, S) {
        return X instanceof S;
    },
    'r93': function(X, S) {
        return X - S;
    },
    'q71': function(X, S) {
        return X * S;
    },
    'M3M': function(X, S) {
        return X < S;
    },
    'K9H': function(X, S) {
        return X == S;
    },
    's2L': function(X, S) {
        return X * S;
    },
    'l3N': function(X, S) {
        return X * S;
    },
    'C5P': 8801,
    's7K': "json",
    'r5m': function(X, S) {
        return X / S;
    },
    'I3f': function(X, S) {
        return X instanceof S;
    },
    'x1N': function(X, S) {
        return X & S;
    },
    's78': function(X, S) {
        return X | S;
    },
    'V8z': function(X, S) {
        return X * S;
    },
    'y5t': function(X, S) {
        return X * S;
    },
    'p2D': function(X, S) {
        return X / S;
    },
    'w4B': function(X, S) {
        return X >> S;
    },
    'c4v': function(X, S) {
        return X < S;
    },
    'z4d': function(X, S, P) {
        return X / S * P;
    },
    'g0L': function(X, S) {
        return X * S;
    },
    'N2i': "up",
    'b7h': function(X, S) {
        return X !== S;
    },
    'H8i': 60,
    'o1B': function(X, S) {
        return X != S;
    },
    'J7M': function(X, S, P) {
        return X * S * P;
    },
    'M8u': function(X, S) {
        return X - S;
    },
    'y6L': function(X, S) {
        return X != S;
    },
    'k75': function(X, S) {
        return X != S;
    },
    'T2w': function(X, S) {
        return X === S;
    },
    'y2': function(X) {
        cc.SHADER_POSITION_COLOR_FRAG = X;
    },
    'd53': function(X, S) {
        return X !== S;
    },
    'd3a': function(X, S) {
        return X - S;
    },
    'q9j': function(X, S) {
        return X < S;
    },
    'X9L': function(X, S) {
        return X * S;
    },
    'L8': function(X) {
        cc.FLT_EPSILON = X;
    },
    'D0z': function(X, S) {
        return X * S;
    },
    'l2a': function(X, S) {
        return X * S;
    },
    'p72': function(X, S) {
        return X >= S;
    },
    'O5L': function(X, S) {
        return X > S;
    },
    'M8d': function(X, S) {
        return X === S;
    },
    'S9K': 1073741824,
    'm9T': function(X, S) {
        return X * S;
    },
    's46': function(X, S) {
        return X == S;
    },
    'd9T': function(X, S) {
        return X * S;
    },
    'N4B': function(X, S) {
        return X | S;
    },
    'o03': function(X, S) {
        return X | S;
    },
    't05': function(X, S) {
        return X < S;
    },
    'R1l': function(X, S) {
        return X < S;
    },
    'm98': function(X, S) {
        return X != S;
    },
    'S4m': function(X, S) {
        return X >= S;
    },
    'N9B': function(X, S) {
        return X * S;
    },
    'v9y': function(X) {
        cc.UNIFORM_COSTIME = X;
    },
    'a7L': function(X, S) {
        return X * S;
    },
    'S5s': function(X, S) {
        return X * S;
    },
    'Y63': function(X, S) {
        return X * S;
    },
    'R78': function(X, S) {
        return X == S;
    },
    'N05': function(X, S) {
        return X < S;
    },
    'S82': function(X, S) {
        return X === S;
    },
    'w0s': function(X, S) {
        return X * S;
    },
    'k2T': function(X, S) {
        return X == S;
    },
    'K28': function(X, S) {
        return X == S;
    },
    'k6a': function(X, S) {
        return X > S;
    },
    'd4E': function(X, S) {
        return X > S;
    },
    'j2m': function(X, S, P, O) {
        return X * S * P * O;
    },
    'y53': function(X, S) {
        return X * S;
    },
    'D13': function(X, S) {
        return X < S;
    },
    'w5O': function(X, S) {
        return X == S;
    },
    'Q3j': function(X, S) {
        return X < S;
    },
    'J7B': function(X, S) {
        return X | S;
    },
    'g5O': function(X, S) {
        return X == S;
    },
    'j3p': function(X, S) {
        return X === S;
    },
    'M5d': function(X, S) {
        return X != S;
    },
    'h4f': function(X, S, P) {
        return X / S * P;
    },
    'X5y': function(X) {
        cc.PARTICLE_TYPE_GROUPED = X;
    },
    'A2S': "g",
    'i7t': function(X, S, P) {
        return X * S / P;
    },
    'g2N': function(X, S) {
        return X * S;
    },
    'D73': function(X, S) {
        return X == S;
    },
    'm3N': function(X, S) {
        return X * S;
    },
    'E3l': function(X, S) {
        return X | S;
    },
    'R9u': function(X, S, P) {
        return X * S * P;
    },
    'X2t': function(X, S) {
        return X instanceof S;
    },
    'd5l': function(X, S) {
        return X in S;
    },
    'k5E': function(X, S) {
        return X * S;
    },
    'j7T': function(X, S) {
        return X * S;
    },
    'D8q': function(X, S) {
        return X * S;
    },
    'N8m': function(X, S) {
        return X != S;
    },
    'n1m': function(X, S) {
        return X >= S;
    },
    'g28': function(X, S) {
        return X == S;
    },
    'e0E': function(X, S) {
        return X == S;
    },
    'X9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_FRAG = X;
    },
    'l2f': function(X, S) {
        return X !== S;
    },
    'm4d': function(X, S) {
        return X == S;
    },
    'n8w': function(X, S) {
        return X * S;
    },
    'F6B': function(X, S) {
        return X < S;
    },
    'S9q': function(X, S) {
        return X * S;
    },
    'a31': function(X, S) {
        return X * S;
    },
    'u55': function(X, S) {
        return X < S;
    },
    'P9h': function(X, S) {
        return X * S;
    },
    'i1': function(X) {
        cc.RETINA_DISPLAY_SUPPORT = X;
    },
    'Z2y': function() {
        lg = lg || {};
    },
    'd06': function(X, S) {
        return X / S;
    },
    'z3h': function(X, S) {
        return X < S;
    },
    's4t': function(X, S) {
        return X - S;
    },
    'V1l': function(X, S) {
        return X >>> S;
    },
    'w65': function(X, S) {
        return X instanceof S;
    },
    'c56': function(X, S) {
        return X < S;
    },
    'T63': function(X, S) {
        return X * S;
    },
    'Y18': function(X, S) {
        return X / S;
    },
    'K65': function(X, S) {
        return X < S;
    },
    'a3m': function(X, S) {
        return X * S;
    },
    'I15': function(X, S) {
        return X * S;
    },
    'h1q': function(X, S) {
        return X * S;
    },
    'W0t': function(X, S) {
        return X < S;
    },
    'm1q': function(X, S) {
        return X * S;
    },
    'k4b': function(X, S, P) {
        return X - S + P;
    },
    'H9P': "running",
    'R8y': function(X) {
        cc.SCENE_FADE = X;
    },
    'z3S': "ogg",
    'E5G': function(X, S) {
        return X === S;
    },
    'a1m': function(X, S) {
        return X < S;
    },
    'Q7b': function(X, S) {
        return X * S;
    },
    'R6u': function(X, S) {
        return X * S;
    },
    'K3l': function(X, S) {
        return X % S;
    },
    'q7O': function(X, S) {
        return X != S;
    },
    'Q4j': function(X, S) {
        return X < S;
    },
    'w6T': function(X, S) {
        return X / S;
    },
    'D0b': function(X, S) {
        return X - S;
    },
    'i68': function(X, S) {
        return X == S;
    },
    'X4t': function(X, S) {
        return X < S;
    },
    'U96': function(X, S) {
        return X != S;
    },
    'm86': function(X, S) {
        return X == S;
    },
    'Y0': function(X) {
        cc.EventListener.MOUSE = X;
    },
    'F4f': function(X, S, P) {
        return X / S * P;
    },
    'Z1L': function(X, S) {
        return X - S;
    },
    'v4O': function(X, S) {
        return X instanceof S;
    },
    'f3S': "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}",
    'T0q': function(X, S) {
        return X * S;
    },
    'T18': function(X, S) {
        return X != S;
    },
    'i5T': function(X, S) {
        return X / S;
    },
    'r7f': function(X, S) {
        return X === S;
    },
    'A0E': function(X, S) {
        return X != S;
    },
    'Z2b': function(X, S) {
        return X / S;
    },
    't2N': function(X, S) {
        return X * S;
    },
    'I1m': function(X, S) {
        return X != S;
    },
    'i8S': "tileHeight",
    'g9D': function(X, S) {
        return X / S;
    },
    't8v': function(X, S) {
        return X != S;
    },
    'a32': function(X, S) {
        return X == S;
    },
    'j73': function(X, S) {
        return X / S;
    },
    'Q8L': function(X, S) {
        return X > S;
    },
    'R35': function(X, S) {
        return X === S;
    },
    'H1t': function(X, S) {
        return X - S;
    },
    'j45': function(X, S) {
        return X * S;
    },
    'Q4w': function(X, S) {
        return X - S;
    },
    'A93': function(X, S) {
        return X | S;
    },
    'b0b': function(X, S) {
        return X === S;
    },
    'V5N': function(X, S) {
        return X * S;
    },
    'J8j': function(X, S) {
        return X >> S;
    },
    'z6y': function(X) {
        cc.TMX_PROPERTY_OBJECTGROUP = X;
    },
    'g6L': function(X, S) {
        return X * S;
    },
    'B7M': function(X, S) {
        return X < S;
    },
    'f0j': function(X, S) {
        return X === S;
    },
    'c1j': function(X, S) {
        return X === S;
    },
    'c3p': function(X, S) {
        return X & S;
    },
    'L0d': function(X, S) {
        return X / S;
    },
    'M8O': function(X, S) {
        return X instanceof S;
    },
    'K8i': "active",
    'K3N': function(X, S) {
        return X !== S;
    },
    'U6u': function(X, S) {
        return X > S;
    },
    'i22': function(X, S) {
        return X == S;
    },
    'p2H': "b",
    'm4f': function(X, S, P) {
        return X / S * P;
    },
    'l93': function(X, S) {
        return X != S;
    },
    'L7p': function(X, S) {
        return X - S;
    },
    'h2f': function(X, S) {
        return X !== S;
    },
    'i9i': 40,
    'H9S': "cascadeOpacity",
    'J7K': ":",
    'C9M': function(X, S) {
        return X / S;
    },
    'b8A': function(X, S) {
        return X / S;
    },
    'n0j': function(X, S) {
        return X & S;
    },
    'E0v': function(X, S) {
        return X >= S;
    },
    'F2t': function(X, S) {
        return X * S;
    },
    'A9H': function(X, S) {
        return X < S;
    },
    'z63': function(X, S) {
        return X != S;
    },
    'H7H': 6,
    'Q2z': function(X, S) {
        return X * S;
    },
    'u1L': function(X, S) {
        return X > S;
    },
    'z8h': function(X, S) {
        return X !== S;
    },
    'i75': function(X, S) {
        return X == S;
    },
    'F3s': function(X, S) {
        return X * S;
    },
    'l53': function(X, S) {
        return X !== S;
    },
    'D0O': function(X, S) {
        return X - S;
    },
    'n75': function(X, S) {
        return X === S;
    },
    'e5w': function(X, S) {
        return X | S;
    },
    'a0M': function(X, S, P, O) {
        return X * S * P / O;
    },
    'G55': function(X, S) {
        return X == S;
    },
    'D83': function(X, S, P, O) {
        return X * S * P * O;
    },
    'J8H': function(X, S) {
        return X == S;
    },
    'K0v': function(X, S) {
        return X == S;
    },
    'k8D': function(X, S) {
        return X == S;
    },
    'H7S': "director_after_visit",
    'X9v': function(X, S) {
        return X == S;
    },
    'D4L': function(X, S) {
        return X !== S;
    },
    'k7b': function(X, S) {
        return X * S;
    },
    'e9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = X;
    },
    'b3s': function(X, S) {
        return X * S;
    },
    'R63': function(X, S) {
        return X != S;
    },
    'P3f': function(X, S) {
        return X < S;
    },
    'K0p': function(X, S) {
        return X - S;
    },
    'P3m': function(X, S) {
        return X * S;
    },
    'S5B': function(X, S) {
        return X * S;
    },
    'g0p': function(X, S) {
        return X - S;
    },
    'S22': function(X, S) {
        return X < S;
    },
    'p3p': function(X, S) {
        return X === S;
    },
    'n3m': function(X, S) {
        return X * S;
    },
    'E5A': function(X, S) {
        return X != S;
    },
    'r1A': function(X, S) {
        return X == S;
    },
    'A0B': function(X, S) {
        return X & S;
    },
    'H9h': function(X, S) {
        return X * S;
    },
    'd5O': function(X, S) {
        return X < S;
    },
    'X03': function(X, S) {
        return X == S;
    },
    'Q3N': function(X, S) {
        return X * S;
    },
    'k6': function(X) {
        cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = X;
    },
    'U6O': function(X, S) {
        return X != S;
    },
    'e05': function(X, S) {
        return X == S;
    },
    'a08': function(X, S) {
        return X & S;
    },
    'C2d': function(X, S) {
        return X === S;
    },
    'o0b': function(X, S) {
        return X === S;
    },
    'j3z': function(X, S) {
        return X instanceof S;
    },
    'o2y': function() {
        lg._oldGamePauseState = !1;
    },
    'b56': function(X, S) {
        return X / S;
    },
    'p8O': function(X, S) {
        return X instanceof S;
    },
    'g7m': function(X, S) {
        return X >= S;
    },
    'z1H': function(X, S) {
        return X * S;
    },
    'L9O': function(X) {
        Global.time = X;
    },
    'b63': function(X, S) {
        return X / S;
    },
    'c8z': function(X, S) {
        return X * S;
    },
    'Y1T': function(X, S) {
        return X * S;
    },
    'T78': function(X, S) {
        return X & S;
    },
    'j8d': function(X, S) {
        return X === S;
    },
    'h91': function(X, S) {
        return X * S;
    },
    'w9a': function(X, S) {
        return X | S;
    },
    'c3s': function(X, S) {
        return X * S;
    },
    'e5f': function(X, S) {
        return X < S;
    },
    'E6p': function(X, S) {
        return X >= S;
    },
    'p2m': function(X, S) {
        return X / S;
    },
    'e7q': function(X, S) {
        return X * S;
    },
    'a4u': function(X, S) {
        return X * S;
    },
    'R2w': function(X, S) {
        return X * S;
    },
    'v82': function(X, S) {
        return X / S;
    },
    'v9O': function() {
        Global.zWaves = [{
            type: "1,2",
            count: 8,
            interval: "2,3",
            waveInterval: 5
        }, {
            type: "1,2,3",
            count: 10,
            interval: "2,3",
            waveInterval: 5
        }, {
            type: "1,2,4",
            count: 10,
            interval: "2,3",
            waveInterval: 5
        }, {
            type: "3,4",
            count: 10,
            interval: "2,3",
            waveInterval: 4
        }, {
            type: "3,5",
            count: 10,
            interval: "2,3",
            waveInterval: 4
        }, {
            type: "4,5",
            count: 15,
            interval: "2,3",
            waveInterval: 3
        }, {
            type: "4,6",
            count: 15,
            interval: "2,3",
            waveInterval: 3
        }, {
            type: "8,9,10",
            count: 20,
            interval: "2,3",
            waveInterval: 2
        }, {
            type: "11",
            count: 1,
            interval: "1,2",
            waveInterval: 1
        }];
    },
    'O1b': function(X, S) {
        return X / S;
    },
    'R0b': function(X, S) {
        return X instanceof S;
    },
    'D3i': "txt",
    'g3S': 128,
    'u6a': function(X, S) {
        return X * S;
    },
    'O26': function(X, S) {
        return X != S;
    },
    'U78': function(X, S) {
        return X >> S;
    },
    's45': function(X, S) {
        return X - S;
    },
    'D2l': function(X, S, P, O) {
        return X * S * P / O;
    },
    'M1T': function(X, S) {
        return X - S;
    },
    'G3O': function(X, S) {
        return X == S;
    },
    'Z4u': function(X, S) {
        return X * S;
    },
    'A5l': function(X, S) {
        return X >= S;
    },
    'e0s': function(X, S) {
        return X * S;
    },
    'I1v': function(X, S) {
        return X < S;
    },
    's66': function(X, S) {
        return X * S;
    },
    'j92': function(X, S) {
        return X != S;
    },
    'P41': function(X, S) {
        return X !== S;
    },
    'c6i': "skewX",
    'I2z': function(X, S) {
        return X <= S;
    },
    'i8w': function(X, S) {
        return X / S;
    },
    'g51': function(X, S) {
        return X * S;
    },
    'y6E': function(X, S) {
        return X < S;
    },
    'U83': function(X, S) {
        return X * S;
    },
    'c9t': function(X, S) {
        return X - S;
    },
    'j4f': function(X, S, P) {
        return X / S * P;
    },
    'e6h': function(X, S) {
        return X / S;
    },
    'q0E': function(X, S) {
        return X >= S;
    },
    'f8G': function(X, S) {
        return X === S;
    },
    'I3A': function(X, S) {
        return X instanceof S;
    },
    'x6l': function(X, S, P) {
        return X << S >>> P;
    },
    'G3m': function(X, S) {
        return X * S;
    },
    'r0s': function(X, S) {
        return X * S;
    },
    'F2w': function(X, S) {
        return X * S;
    },
    'j46': function(X, S) {
        return X / S;
    },
    'E9E': function(X, S) {
        return X < S;
    },
    'N6L': function(X, S) {
        return X - S;
    },
    'K0s': function(X, S) {
        return X * S;
    },
    'C7z': function(X, S) {
        return X === S;
    },
    'p9': function() {
        cc._rendererInitialized = !1;
    },
    'b2v': function(X, S) {
        return X == S;
    },
    'y9D': function(X, S) {
        return X - S;
    },
    'f4z': function(X, S) {
        return X != S;
    },
    'Y1E': function(X, S) {
        return X - S;
    },
    'w7A': function(X, S) {
        return X != S;
    },
    'h3l': function(X, S, P, O) {
        return X | S | P | O;
    },
    'G0a': function(X, S) {
        return X * S;
    },
    'W12': function(X, S) {
        return X / S;
    },
    'R1T': function(X, S) {
        return X * S;
    },
    'q3j': function(X, S) {
        return X < S;
    },
    'j81': function(X, S) {
        return X !== S;
    },
    'V72': function(X, S) {
        return X instanceof S;
    },
    'd4H': function(X, S) {
        return X > S;
    },
    'm0p': function(X, S) {
        return X - S;
    },
    'O0j': function(X, S) {
        return X <= S;
    },
    'K3j': function(X, S) {
        return X < S;
    },
    'B5P': 2.5,
    'd2p': function(X, S) {
        return X !== S;
    },
    'i8D': function(X, S) {
        return X < S;
    },
    'f3A': function(X, S) {
        return X instanceof S;
    },
    'D81': function(X, S) {
        return X !== S;
    },
    'e8v': function(X, S) {
        return X < S;
    },
    'X2m': function(X, S, P, O) {
        return X * S * P * O;
    },
    'Z0h': function(X, S, P) {
        return X * S * P;
    },
    'Q6L': function(X, S) {
        return X - S;
    },
    'U0f': function(X, S) {
        return X - S;
    },
    'K05': function(X, S) {
        return X < S;
    },
    'x6f': function(X, S) {
        return X * S;
    },
    'J7N': function(X, S) {
        return X * S;
    },
    'g9E': function(X, S) {
        return X == S;
    },
    'V1N': function(X, S) {
        return X < S;
    },
    'w2i': "absolute",
    'p6P': "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}",
    'y2a': function(X, S) {
        return X * S;
    },
    'L4y': function() {
        cc.Codec.GZip.cpdext = [0, ((0x53, 39) <= (143, 143) ? (97., 0) : (58.7E1, 80.) < (0x3D, 37.) ? 107 : (102., 7E0) > (107, 71.) ? 6.36E2 : (7.0E1, 5.25E2)), 0, 0, 1, 1, 2, 2, 3, ((50.2E1, 131.) <= 145 ? (0x157, 3) : (133, 18.3E1)), 4, 4, 5, 5, 6, 6, 7, ((76, 67) < 104 ? (69., 7) : (0x1E7, 81)), 8, 8, 9, 9, (14.97E2 > (0xEA, 119.) ? (6.0E2, 10) : (0x74, 80.9E1)), 10, 11, 11, 12, 12, 13, 13];
    },
    'Q6': function() {
        cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
    },
    'm4B': function(X, S) {
        return X | S;
    },
    'e48': function(X, S) {
        return X << S;
    },
    's3L': function(X, S) {
        return X * S;
    },
    'd2a': function(X, S) {
        return X * S;
    },
    'U8h': function(X, S) {
        return X < S;
    },
    'e9M': function(X, S) {
        return X != S;
    },
    'l6y': function() {
        lg = lg || {};
    },
    'p4t': function(X, S) {
        return X instanceof S;
    },
    'P2B': function(X, S) {
        return X != S;
    },
    'i2B': function(X, S) {
        return X != S;
    },
    'u82': function(X, S) {
        return X - S;
    },
    'V9t': function(X, S) {
        return X == S;
    },
    'Y3B': function(X, S) {
        return X instanceof S;
    },
    'P9s': function(X, S) {
        return X instanceof S;
    },
    'w7K': 5888,
    't4a': function(X, S) {
        return X < S;
    },
    'A7m': function(X, S) {
        return X < S;
    },
    'X8': function(X) {
        cc.BLEND_DST = X;
    },
    'Y1j': function(X, S) {
        return X === S;
    },
    'p0z': function(X, S) {
        return X / S;
    },
    'a55': function(X, S) {
        return X < S;
    },
    'Y7D': function(X, S) {
        return X * S;
    },
    'V8u': function(X, S) {
        return X - S;
    },
    'f8a': function(X, S) {
        return X != S;
    },
    'i0d': function(X, S) {
        return X === S;
    },
    'c3B': function(X, S) {
        return X == S;
    },
    'P7N': function(X, S) {
        return X * S;
    },
    'C1S': 0.2,
    'l8p': function(X, S) {
        return X >= S;
    },
    'e5G': function(X, S) {
        return X | S;
    },
    'a5s': function(X, S) {
        return X * S;
    },
    'K6E': function(X, S) {
        return X - S;
    },
    'W0D': function(X, S) {
        return X < S;
    },
    'p66': function(X, S) {
        return X / S;
    },
    'o3M': function(X, S) {
        return X - S;
    },
    'V78': function(X, S) {
        return X | S;
    },
    'u6h': function(X, S) {
        return X / S;
    },
    'b7a': function(X, S) {
        return X - S;
    },
    'e7b': function(X, S) {
        return X * S;
    },
    'B1L': function(X, S) {
        return X == S;
    },
    'G3G': function(X, S) {
        return X != S;
    },
    'U0q': function(X, S) {
        return X * S;
    },
    'R03': function(X, S) {
        return X / S;
    },
    'X2w': function(X, S) {
        return X * S;
    },
    'K9D': function(X, S) {
        return X / S;
    },
    'm9b': function(X, S) {
        return X * S;
    },
    'z1T': function(X, S) {
        return X - S;
    },
    'k6y': function(X) {
        cc.TMX_LAYER_ATTRIB_GZIP = X;
    },
    'B0T': function(X, S) {
        return X / S;
    },
    's8M': function(X, S) {
        return X - S;
    },
    'A8t': function(X, S) {
        return X == S;
    },
    'N5i': "speed",
    'e3w': function(X, S) {
        return X < S;
    },
    'Y56': function(X, S) {
        return X >= S;
    },
    'd3t': function(X, S) {
        return X instanceof S;
    },
    'G9z': function(X, S) {
        return X * S;
    },
    'L02': function(X, S) {
        return X instanceof S;
    },
    'P6N': function(X, S) {
        return X * S;
    },
    'S3P': "-",
    'R6j': function(X, S) {
        return X | S;
    },
    'I22': function(X, S) {
        return X < S;
    },
    'b0m': function(X, S) {
        return X * S;
    },
    'j6f': function(X, S) {
        return X != S;
    },
    'w2s': function(X, S) {
        return X - S;
    },
    'S76': function(X, S) {
        return X < S;
    },
    'U95': function(X, S) {
        return X * S;
    },
    'n26': function(X, S) {
        return X != S;
    },
    'o8u': function(X, S) {
        return X < S;
    },
    'w2a': function(X, S) {
        return X == S;
    },
    'Q1z': function(X, S) {
        return X * S;
    },
    'f5h': function(X, S) {
        return X / S;
    },
    'u9A': function(X, S) {
        return X instanceof S;
    },
    'Y8l': function(X, S) {
        return X < S;
    },
    'Z1t': function(X, S) {
        return X < S;
    },
    'Y3T': function(X, S) {
        return X * S;
    },
    's25': function(X, S) {
        return X < S;
    },
    'j5a': function(X, S) {
        return X * S;
    },
    'S21': function(X, S) {
        return X / S;
    },
    'Z0u': function(X, S) {
        return X == S;
    },
    'W5T': function(X, S) {
        return X > S;
    },
    'S4l': function(X, S) {
        return X > S;
    },
    'e28': function(X, S) {
        return X >= S;
    },
    'O9i': 25,
    'u7E': function(X, S) {
        return X < S;
    },
    'I1S': "layerHeight",
    'q2a': function(X, S) {
        return X * S;
    },
    'h1i': "sourcePos",
    'T3i': "top",
    'A52': function(X, S) {
        return X <= S;
    },
    'K91': function(X, S) {
        return X < S;
    },
    'X0q': function(X, S) {
        return X * S;
    },
    'X1T': function(X, S) {
        return X * S;
    },
    'N9a': function(X, S) {
        return X | S;
    },
    'C13': function(X, S) {
        return X * S;
    },
    'H1p': function(X, S) {
        return X - S;
    },
    'n1G': function(X, S) {
        return X >= S;
    },
    'Z3G': function(X, S) {
        return X !== S;
    },
    't9M': function(X, S) {
        return X != S;
    },
    'C5G': function(X, S) {
        return X < S;
    },
    'O2l': function(X, S) {
        return X * S;
    },
    'R0A': function(X, S) {
        return X instanceof S;
    },
    'c7a': function(X, S) {
        return X === S;
    },
    'w4d': function(X, S) {
        return X | S;
    },
    'i3h': function(X, S, P) {
        return X * S / P;
    },
    'K0B': function(X, S) {
        return X != S;
    },
    'q42': function(X, S) {
        return X == S;
    },
    'q3y': function(X) {
        cc.PARTICLE_MODE_RADIUS = X;
    },
    'Y4p': function(X, S) {
        return X - S;
    },
    'Q9w': function(X, S) {
        return X < S;
    },
    'B1p': function(X, S) {
        return X - S;
    },
    'c1w': function(X, S) {
        return X | S;
    },
    'g4H': function(X, S) {
        return X == S;
    },
    'f8j': function(X, S) {
        return X < S;
    },
    'q6v': function(X, S) {
        return X == S;
    },
    'F5N': function(X, S) {
        return X * S;
    },
    'e2H': "en",
    'r36': function(X, S) {
        return X / S;
    },
    'v0t': function(X, S) {
        return X < S;
    },
    'F8z': function(X, S) {
        return X * S;
    },
    'n3q': function(X, S) {
        return X * S;
    },
    'g4a': function(X, S) {
        return X < S;
    },
    'c7w': function(X, S) {
        return X * S;
    },
    'k23': function(X, S) {
        return X * S;
    },
    'O8j': function(X, S) {
        return X << S;
    },
    'i4h': function(X, S) {
        return X < S;
    },
    'H4O': function(X, S) {
        return X instanceof S;
    },
    'E5w': function(X, S) {
        return X * S;
    },
    'T8d': function(X, S) {
        return X == S;
    },
    'N6M': function(X, S) {
        return X > S;
    },
    'Q28': function(X, S) {
        return X >= S;
    },
    'H5L': function(X, S) {
        return X == S;
    },
    'Q4a': function(X, S) {
        return X == S;
    },
    'H4B': function(X, S) {
        return X < S;
    },
    'g6T': function(X, S) {
        return X * S;
    },
    'a0w': function(X, S) {
        return X * S;
    },
    'C6T': function(X, S) {
        return X - S;
    },
    'w5m': function(X, S) {
        return X < S;
    },
    'S9u': function(X, S) {
        return X < S;
    },
    't4H': function(X, S) {
        return X == S;
    },
    'B1v': function(X, S) {
        return X != S;
    },
    'i4A': function(X, S) {
        return X == S;
    },
    'r91': function(X, S) {
        return X / S;
    },
    'F8q': function(X, S) {
        return X * S;
    },
    'V7l': function(X, S) {
        return X / S;
    },
    'g2p': function(X, S) {
        return X < S;
    },
    'c45': function(X, S) {
        return X * S;
    },
    'S7p': function(X, S) {
        return X - S;
    },
    'Q5A': function(X, S) {
        return X instanceof S;
    },
    'a7p': function(X, S) {
        return X - S;
    },
    'E1q': function(X, S) {
        return X * S;
    },
    'E2a': function(X, S) {
        return X - S;
    },
    'A2a': function(X, S) {
        return X - S;
    },
    'M6b': function(X, S) {
        return X == S;
    },
    'y36': function(X, S) {
        return X < S;
    },
    'K7z': function(X, S) {
        return X / S;
    },
    'A0p': function(X, S) {
        return X - S;
    },
    'l3d': function(X, S) {
        return X - S;
    },
    'e4M': function(X, S) {
        return X / S;
    },
    'A5q': function(X, S) {
        return X * S;
    },
    'W8j': function(X, S) {
        return X < S;
    },
    'e1u': function(X, S) {
        return X * S;
    },
    'd9H': function(X, S) {
        return X == S;
    },
    'd2h': function(X, S) {
        return X == S;
    },
    'P3q': function(X, S) {
        return X * S;
    },
    'H5T': function(X, S) {
        return X * S;
    },
    'n1p': function(X, S) {
        return X === S;
    },
    'i8b': function(X, S) {
        return X != S;
    },
    'q5A': function(X, S) {
        return X != S;
    },
    'k5s': function(X, S) {
        return X * S;
    },
    'w3N': function(X, S) {
        return X > S;
    },
    'G4O': function(X, S) {
        return X == S;
    },
    'Y81': function(X, S) {
        return X !== S;
    },
    't8M': function(X, S) {
        return X - S;
    },
    'Z0w': function(X, S) {
        return X * S;
    },
    'V1b': function(X, S) {
        return X <= S;
    },
    'T8O': function(X, S) {
        return X == S;
    },
    'C8p': function(X, S) {
        return X >= S;
    },
    'b4E': function(X, S) {
        return X < S;
    },
    'o9L': function(X, S) {
        return X * S;
    },
    's3S': "mp3",
    'y9l': function(X, S) {
        return X < S;
    },
    'v0w': function(X, S) {
        return X << S;
    },
    'G0d': function(X, S) {
        return X / S;
    },
    'e8L': function(X, S) {
        return X < S;
    },
    'T02': function(X, S) {
        return X > S;
    },
    'B0l': function(X, S) {
        return X * S;
    },
    'u6G': function(X, S) {
        return X === S;
    },
    'Z76': function(X, S) {
        return X == S;
    },
    'b3B': function(X, S) {
        return X == S;
    },
    'j0m': function(X, S) {
        return X * S;
    },
    'e8m': function(X, S) {
        return X / S;
    },
    'A36': function(X, S) {
        return X != S;
    },
    'M95': function(X, S) {
        return X * S;
    },
    'n3G': function(X, S) {
        return X != S;
    },
    'k1G': function(X, S) {
        return X == S;
    },
    'i2O': function(X, S) {
        return X === S;
    },
    'O1M': function(X, S) {
        return X * S;
    },
    'U7j': function(X, S) {
        return X >= S;
    },
    'V7h': function(X, S) {
        return X * S;
    },
    'T1T': function(X, S) {
        return X * S;
    },
    'X9j': function(X, S) {
        return X / S;
    },
    'B4f': function(X, S, P) {
        return X / S * P;
    },
    'u3P': 2147483648,
    'y48': function(X, S) {
        return X < S;
    },
    'Q3d': function(X, S) {
        return X instanceof S;
    },
    'q7b': function(X, S) {
        return X - S;
    },
    'b5d': function(X, S) {
        return X < S;
    },
    'e7h': function(X, S) {
        return X > S;
    },
    'c9O': function(X) {
        Global.level2 = X;
    },
    'f1v': function(X, S) {
        return X == S;
    },
    'l5A': function(X, S) {
        return X == S;
    },
    'K6L': function(X, S) {
        return X > S;
    },
    'v1M': function(X, S) {
        return X - S;
    },
    'a5v': function(X, S) {
        return X instanceof S;
    },
    'H6G': function(X, S) {
        return X | S;
    },
    'M0M': function(X, S, P) {
        return X - S + P;
    },
    'y0p': function(X, S) {
        return X - S;
    },
    'N13': function(X, S) {
        return X * S;
    },
    'q8v': function(X, S) {
        return X != S;
    },
    'b3L': function(X, S) {
        return X * S;
    },
    'N7S': 160,
    'R0m': function(X, S) {
        return X * S;
    },
    'F3p': function(X, S) {
        return X >= S;
    },
    'F4N': function(X, S) {
        return X * S;
    },
    'H0H': "TransitionPageTurn",
    'b0O': function(X, S) {
        return X != S;
    },
    'Y9L': function(X, S) {
        return X * S;
    },
    'I2q': function(X, S) {
        return X * S;
    },
    'p5P': "name",
    'u15': function(X, S) {
        return X == S;
    },
    'A5G': function(X, S) {
        return X === S;
    },
    'G12': function(X, S) {
        return X / S;
    },
    'G1p': function(X, S) {
        return X - S;
    },
    'L8b': function(X, S) {
        return X - S;
    },
    'W32': function(X, S) {
        return X != S;
    },
    'I68': function(X, S) {
        return X & S;
    },
    'C9w': function(X, S) {
        return X - S;
    },
    'Y01': function(X, S) {
        return X === S;
    },
    'X45': function(X, S) {
        return X == S;
    },
    'Z0D': function(X, S) {
        return X == S;
    },
    'd43': function(X, S, P, O) {
        return X * S * P * O;
    },
    'W2E': function(X, S) {
        return X / S;
    },
    'G4z': function(X, S) {
        return X / S;
    },
    'v2l': function(X, S) {
        return X === S;
    },
    'b03': function(X, S) {
        return X | S;
    },
    'N38': function(X, S) {
        return X == S;
    },
    'g43': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'D56': function(X, S) {
        return X / S;
    },
    'x1H': function(X, S) {
        return X / S;
    },
    'N4d': function(X, S) {
        return X | S;
    },
    'r4G': function(X, S) {
        return X < S;
    },
    'e7G': function(X, S) {
        return X / S;
    },
    'v8f': function(X, S) {
        return X * S;
    },
    'B6a': function(X, S) {
        return X * S;
    },
    'a8E': function(X, S) {
        return X > S;
    },
    'f1m': function(X, S) {
        return X < S;
    },
    'D5': function(X) {
        _M[_c.PIXEL_FORMAT_RGB5A1] = X;
    },
    'b2t': function(X, S) {
        return X == S;
    },
    'R62': function(X, S) {
        return X < S;
    },
    'Z3b': function(X, S) {
        return X / S;
    },
    'S3q': function(X, S) {
        return X * S;
    },
    'f9q': function(X, S) {
        return X * S;
    },
    'o73': function(X, S) {
        return X * S;
    },
    'e3D': function(X, S) {
        return X != S;
    },
    'b9i': 13,
    'n2i': "lg.Animator",
    'x9t': function(X, S) {
        return X < S;
    },
    'A1u': function(X, S) {
        return X - S;
    },
    'o1S': "_",
    'p5N': function(X, S) {
        return X == S;
    },
    'x8i': 0.001,
    'X9': function() {
        cc._isNodeJs = "undefined" !== typeof require && require("fs");
    },
    's8h': function(X, S) {
        return X < S;
    },
    'R8A': function(X, S) {
        return X >= S;
    },
    'L3A': function(X, S) {
        return X != S;
    },
    'H8f': function(X, S, P) {
        return X / S * P;
    },
    'r6D': function(X, S) {
        return X == S;
    },
    'E9u': function(X, S) {
        return X < S;
    },
    'c4t': function(X, S) {
        return X < S;
    },
    'J4S': "label",
    'Q1K': "ShaderPositionTexture_uColor",
    'W6z': function(X, S) {
        return X - S;
    },
    'J9m': function(X, S) {
        return X < S;
    },
    'q85': function(X, S) {
        return X == S;
    },
    'J5v': function(X, S) {
        return X < S;
    },
    'O2u': function(X, S) {
        return X != S;
    },
    'Z75': function(X, S) {
        return X === S;
    },
    'c5d': function(X, S) {
        return X instanceof S;
    },
    'R9p': function(X, S) {
        return X < S;
    },
    'f4G': function(X, S) {
        return X == S;
    },
    'K4w': function(X, S) {
        return X | S;
    },
    'Y1B': function(X, S) {
        return X * S;
    },
    'V5d': function(X, S) {
        return X == S;
    },
    'f3q': function(X, S) {
        return X * S;
    },
    'L6d': function(X, S) {
        return X < S;
    },
    'w8p': function(X, S) {
        return X >= S;
    },
    'l2m': function(X, S, P, O) {
        return X * S * P * O;
    },
    'y3N': function(X, S) {
        return X >= S;
    },
    'E4d': function(X, S) {
        return X != S;
    },
    'm0E': function(X, S) {
        return X > S;
    },
    'M3u': function(X, S) {
        return X % S;
    },
    'a2u': function(X, S) {
        return X !== S;
    },
    't9N': function(X, S, P) {
        return X | S | P;
    },
    'i3u': function(X, S, P) {
        return X * S / P;
    },
    'i7E': function(X, S) {
        return X < S;
    },
    'F8A': function(X, S) {
        return X / S;
    },
    'O16': function(X, S) {
        return X == S;
    },
    'k9A': function(X, S) {
        return X == S;
    },
    'T0f': function(X, S) {
        return X < S;
    },
    'q38': function(X, S) {
        return X > S;
    },
    'u0d': function(X, S) {
        return X === S;
    },
    'K2s': function(X, S) {
        return X - S;
    },
    'O76': function(X, S) {
        return X < S;
    },
    'V66': function(X, S) {
        return X * S;
    },
    'X4N': function(X, S) {
        return X / S;
    },
    'M1N': function(X, S) {
        return X == S;
    },
    'p1j': function(X, S) {
        return X > S;
    },
    'D5j': function(X, S) {
        return X - S;
    },
    'p0H': "text/vbscript",
    'm8t': function(X, S) {
        return X < S;
    },
    'P2T': function(X, S) {
        return X - S;
    },
    'Y5d': function(X, S) {
        return X == S;
    },
    'e7f': function(X, S) {
        return X > S;
    },
    'v9s': function(X, S) {
        return X / S;
    },
    'h52': function(X, S) {
        return X >= S;
    },
    'C6t': function(X, S) {
        return X * S;
    },
    'z5': function(X) {
        _B[_c.PIXEL_FORMAT_RGBA8888] = X;
    },
    'e7': function(X) {
        cc.ResolutionPolicy.UNKNOWN = X;
    },
    'm1z': function(X, S) {
        return X * S;
    },
    'X1H': function(X, S) {
        return X < S;
    },
    'f9m': function(X, S) {
        return X === S;
    },
    'h4j': function(X, S) {
        return X | S;
    },
    'X6t': function(X, S) {
        return X / S;
    },
    'R4t': function(X, S) {
        return X * S;
    },
    'B3q': function(X, S) {
        return X * S;
    },
    's1H': function(X, S) {
        return X < S;
    },
    'b1y': function() {
        cc._currentProjectionMatrix = -((0x1F9, 12.8E1) >= 144. ? 'e' : (60, 0x121) >= (0x15F, 0x9C) ? (104., 1) : (0xCF, 0x246));
    },
    'O9A': function(X, S) {
        return X == S;
    },
    'n6z': function(X, S) {
        return X * S;
    },
    'q65': function(X, S) {
        return X < S;
    },
    'r3d': function(X, S) {
        return X == S;
    },
    'f4O': function(X, S) {
        return X >= S;
    },
    'N5M': function(X, S) {
        return X != S;
    },
    'l1u': function(X, S) {
        return X - S;
    },
    't8p': function(X, S) {
        return X - S;
    },
    'K3': function(X) {
        cc.ALIGN_BOTTOM_RIGHT = X;
    },
    'p3E': function(X, S) {
        return X <= S;
    },
    't5m': function(X, S) {
        return X * S;
    },
    'b4N': function(X, S) {
        return X * S;
    },
    'r0L': function(X, S) {
        return X * S;
    },
    'F4b': function(X, S) {
        return X * S;
    },
    'D4b': function(X, S) {
        return X > S;
    },
    'N6l': function(X, S) {
        return X < S;
    },
    'J3': function(X) {
        _c.PIXEL_FORMAT_I8 = X;
    },
    'X58': function(X, S) {
        return X == S;
    },
    'V5': function(X) {
        cc.g_NumberOfDraws = X;
    },
    'T61': function(X, S) {
        return X / S;
    },
    'N5f': function(X, S) {
        return X / S;
    },
    'P5p': function(X, S) {
        return X >= S;
    },
    't9O': function(X) {
        Global.bestScore = X;
    },
    'w0L': function(X, S) {
        return X * S;
    },
    'T9p': function(X, S) {
        return X <= S;
    },
    'J9h': function(X, S) {
        return X === S;
    },
    'y7H': 7,
    'p8l': function(X, S) {
        return X - S;
    },
    'E91': function(X, S) {
        return X === S;
    },
    'G06': function(X, S) {
        return X - S;
    },
    'z6A': function(X, S) {
        return X < S;
    },
    'X96': function(X, S) {
        return X == S;
    },
    'e0': function(X) {
        cc.EventListener.UNKNOWN = X;
    },
    'h4T': function(X, S) {
        return X - S;
    },
    'U8z': function(X, S) {
        return X * S;
    },
    'v9z': function(X, S) {
        return X * S;
    },
    'I6G': function(X, S) {
        return X < S;
    },
    'I4q': function(X, S) {
        return X * S;
    },
    'H2b': function(X, S) {
        return X / S;
    },
    'c7T': function(X, S) {
        return X * S;
    },
    'z8z': function(X, S) {
        return X / S;
    },
    'q7A': function(X, S) {
        return X == S;
    },
    'J6N': function(X, S) {
        return X * S;
    },
    'O1m': function(X, S) {
        return X == S;
    },
    'y4T': function(X, S) {
        return X - S;
    },
    'c0z': function(X, S) {
        return X instanceof S;
    },
    'R7d': function(X, S) {
        return X / S;
    },
    'h9w': function(X, S) {
        return X - S;
    },
    'B8a': function(X, S) {
        return X / S;
    },
    'k5': function(X) {
        _M[_c.PIXEL_FORMAT_AI88] = X;
    },
    'E5M': function(X, S) {
        return X < S;
    },
    'a23': function(X, S) {
        return X !== S;
    },
    'J3O': function(X, S) {
        return X != S;
    },
    'W7s': function(X, S) {
        return X - S;
    },
    'k21': function(X, S) {
        return X | S;
    },
    'M8q': function(X, S) {
        return X * S;
    },
    'F2B': function(X, S) {
        return X < S;
    },
    'a3A': function(X, S) {
        return X == S;
    },
    'y1d': function(X, S) {
        return X instanceof S;
    },
    'p7l': function(X, S) {
        return X * S;
    },
    'F7D': function(X, S) {
        return X << S;
    },
    'a3L': function(X, S, P) {
        return X * S * P;
    },
    'P7i': "scoreTxt",
    'W33': function(X, S) {
        return X != S;
    },
    'h7q': function(X, S) {
        return X * S;
    },
    'o3T': function(X, S) {
        return X * S;
    },
    'G8f': function(X, S) {
        return X * S;
    },
    'E9l': function(X, S) {
        return X <= S;
    },
    'd91': function(X, S) {
        return X < S;
    },
    'I2T': function(X, S) {
        return X <= S;
    },
    'b0A': function(X, S) {
        return X != S;
    },
    'Z5v': function(X, S) {
        return X > S;
    },
    'J1L': function(X, S) {
        return X < S;
    },
    'Q0E': function(X, S) {
        return X < S;
    },
    'z5t': function(X, S) {
        return X & S;
    },
    'b2N': function(X, S) {
        return X instanceof S;
    },
    'S1G': function(X, S) {
        return X == S;
    },
    'M6B': function(X, S) {
        return X * S;
    },
    'p5': function(X) {
        _B[_c.PIXEL_FORMAT_RGBA4444] = X;
    },
    'S9z': function(X, S) {
        return X < S;
    },
    'U58': function(X, S) {
        return X == S;
    },
    'C1u': function(X, S) {
        return X - S;
    },
    'k7N': function(X, S) {
        return X * S;
    },
    's0K': 255,
    'M8M': function(X, S) {
        return X === S;
    },
    'e9O': function() {
        Global.zombies = [];
    },
    'O82': function(X, S) {
        return X | S;
    },
    'S4S': "topLeft",
    'H6M': function(X, S) {
        return X - S;
    },
    's1': function() {
        cc.$.translate = cc.$.hd ? function(X) {
            return "translate3d(" + X.x + "px, " + X.y + "px, 0) ";
        } : function(X) {
            return "translate(" + X.x + "px, " + X.y + "px) ";
        };
    },
    'G7E': function(X, S) {
        return X <= S;
    },
    'H5p': function(X, S) {
        return X >= S;
    },
    's9O': function() {
        Global.zLevels = [[1, 1, 1, 1, 1], [1, 2, 1, 2, ((62., 117) < 2.1E2 ? (31, 1) : (0x172, 141.70E1))], [2, 1, 2, 1, 2], [((0x96, 0x1A5) < 0x17C ? 0x9E : (78, 109.) >= 0x1E4 ? (0x17B, 112.) : 0x1D5 <= (2.19E2, 0x1F3) ? (0xC2, 2) : (57.40E1, 8.8E2)), 2, 2, 2, 2], [1, ((9.01E2, 12.3E1) > 1.1E1 ? (76., 1) : 0xFE >= (0x37, 1.232E3) ? (10.07E2, 5) : 0x70 < (17.6E1, 104) ? "Z" : (127., 94.)), 1, 3, 3], [2, 2, (12.70E1 > (124., 85) ? (81, 2) : (117., 0.)), 3, ((0x1F5, 0x8A) > (1.226E3, 1.193E3) ? (56, 86) : 0xB <= (0x17E, 6.12E2) ? (107, 3) : 0x1DE < (0x172, 0x89) ? 20 : (4, 1.089E3))], [1, 4, (0x1BD < (25, 114) ? (65, "R") : (7.19E2, 0x1DC) <= (2.7E1, 106) ? 0x163 : 34 < (18., 0x18F) ? (0x222, 1) : (19.3E1, 34)), ((14.93E2, 0x13F) >= (0x12B, 0x9B) ? (103., 2) : 0x246 >= (65., 8.09E2) ? (12.23E2, 2.260E2) : 56. < (54.2E1, 0x37) ? (94.10E1, 179) : (1.067E3, 11.69E2)), 3], [((29, 87) >= 0x1CF ? 0x9A : 9.97E2 > (0x6F, 0x17) ? (0x8B, 2) : (0x6E, 40.)), 4, 2, 3, 3], [2, 4, 3, 1, ((1.05E3, 0xAD) > 45. ? (71.60E1, 4) : (3.43E2, 81.2E1) <= (0x95, 0x203) ? "Z" : (70, 0xA2))], [3, 4, 1, 3, 4], [4, ((0xCC, 0x22A) > 9E0 ? (127., 3) : (130.8E1, 0x1A7) < 125. ? (126, 8.64E2) : (75.0E1, 84.60E1)), 2, 2, 5], [4, 4, 3, 3, 5], [4, 1, ((105., 0x5A) > (13.89E2, 1.295E3) ? 0x13C : (0x1BC, 3.2E2) <= 14.530E2 ? (0x252, 5) : (42, 53) >= (0x1B2, 0x5D) ? (132, 0xA7) : (77, 146)), 1, 5], [4, 2, (48. < (0x16D, 108.) ? (0x38, 5) : (4.0E1, 0x18B)), 2, 5], [4, 3, 5, ((0x12D, 119) <= (1.438E3, 7E0) ? (57, 630) : (7.30E1, 142) > 57.5E1 ? 10.73E2 : 83.5E1 >= (2.780E2, 0x65) ? (0x1ED, 3) : (0xB5, 84.)), ((104., 117.) < (95, 0xED) ? (99, 6) : (92., 12.21E2))], [5, 3, 3, 6, 4, 6], [6, (91.80E1 > (113, 57.) ? (123, 3) : (107, 0x234) < 41. ? (0x8E, 0x11D) : (0xE4, 106.60E1)), 3, 6, ((0x1C8, 0xCA) <= (119.0E1, 145.) ? (5.59E2, 163) : (137., 10.9E2) >= 122. ? (47.1E1, 4) : (98, 58)), 6], [((0x115, 0x1E) > 1.274E3 ? (53.1E1, 273) : (11.69E2, 53.0E1) < 9.14E2 ? (98.30E1, 6) : (17, 23.)), 4, 3, (82. <= (35.5E1, 0x1C5) ? (114, 6) : (11.75E2, 53)), 4, 6], [6, 4, 5, ((13.52E2, 34.5E1) < (24., 0xB0) ? 7.63E2 : 126 > (7., 46.) ? (0x19B, 6) : (116., 7.)), ((97.0E1, 4.65E2) >= (0xA7, 66) ? (0x186, 4) : (13.0E2, 0x1F)), (0x1F7 > (49., 3) ? (0xE3, 6) : (0x165, 4.74E2) < (0x36, 16.90E1) ? 0x199 : 143 >= (85.60E1, 1.1520E3) ? 7 : (19., 0x1E5))], [5, 1, 3, 3, ((2.63E2, 72) >= 80. ? 50 : (78., 1.258E3) >= 135. ? (134, 6) : (58.5E1, 0x21F)), 1, ((10.60E1, 12.64E2) > 9. ? (8.08E2, 4) : (15, 2.4E2)), (0x147 >= (143.1E1, 0xCC) ? (9., 6) : 0x23B < (0x1F7, 0x1DC) ? 0x135 : (18, 134.))], [5, 1, 3, 3, 6, 1, ((44.7E1, 90.80E1) > (0xC0, 40) ? (135, 4) : (0x202, 145)), ((55.5E1, 0xF6) <= (120., 1.062E3) ? (143., 7) : (110., 86.7E1))], [6, 5, (0x5D <= (0x17F, 8) ? 107 : (0x92, 9) <= 64 ? (2.25E2, 1) : (88.30E1, 0x131) <= (71, 0x63) ? 2.87E2 : (0x81, 38.30E1)), 3, 3, 6, 1, 7, 7], [6, 5, 1, 3, 3, 6, ((0x164, 133.) >= 35.9E1 ? (32, 0xEC) : 83 > (79., 2.5E2) ? (6.76E2, 59) : 125 <= (0, 0xE1) ? (31, 1) : (15, 1.3900E3)), 6, 1, 7, (117 >= (9, 7) ? (0x250, 8) : (0xE4, 74.5E1) < 0x5D ? (51, 115) : (74.3E1, 21.90E1) > (0x196, 1.157E3) ? (0x156, 'F') : (14.58E2, 0x1C1))], [6, 5, 1, 3, 3, 6, 1, 6, (88. < (108, 0x224) ? (17., 1) : 1.489E3 <= (149., 3.89E2) ? (8.38E2, 'k') : (0x115, 2.02E2)), 7, ((0x1F4, 129.70E1) >= 89.10E1 ? (0x1C4, 9) : (6.73E2, 9.36E2) < 0x143 ? (91, 'G') : (102.5E1, 36)), 1]];
    },
    'O0w': function(X, S) {
        return X * S;
    },
    't6L': function(X, S) {
        return X > S;
    },
    'J23': function(X, S) {
        return X !== S;
    },
    'f9z': function(X, S) {
        return X * S;
    },
    'H5h': function(X, S) {
        return X / S;
    },
    'd65': function(X, S) {
        return X < S;
    },
    'z2f': function(X, S) {
        return X == S;
    },
    'r7z': function(X, S) {
        return X / S;
    },
    'r2G': function(X, S) {
        return X === S;
    },
    'b3l': function(X, S, P, O) {
        return X | S | P | O;
    },
    'S6d': function(X, S) {
        return X == S;
    },
    'S41': function(X, S) {
        return X !== S;
    },
    'D3E': function(X, S) {
        return X != S;
    },
    'd0v': function(X, S) {
        return X == S;
    },
    'M0O': function(X, S) {
        return X != S;
    },
    'Y46': function(X, S) {
        return X == S;
    },
    'M4E': function(X, S) {
        return X / S;
    },
    'U35': function(X, S) {
        return X == S;
    },
    'J7H': "endColorVar",
    'F7w': function(X, S) {
        return X < S;
    },
    'a2l': function(X, S) {
        return X < S;
    },
    'J9y': function(X) {
        cc.VERTEX_ATTRIB_MAX = X;
    },
    'V0H': "charCount",
    'h8t': function(X, S) {
        return X instanceof S;
    },
    'g4w': function(X, S) {
        return X * S;
    },
    'K1q': function(X, S) {
        return X * S;
    },
    'e2M': function(X, S) {
        return X == S;
    },
    'z6u': function(X, S) {
        return X <= S;
    },
    'V8y': function(X) {
        cc.TRANSITION_ORIENTATION_UP_OVER = X;
    },
    's1N': function(X, S) {
        return X / S;
    },
    'e2z': function(X, S) {
        return X * S;
    },
    'M1l': function(X, S) {
        return X > S;
    },
    'o3L': function(X, S) {
        return X == S;
    },
    'v2u': function(X, S) {
        return X * S;
    },
    'A91': function(X, S) {
        return X * S;
    },
    'D8O': function(X, S) {
        return X == S;
    },
    'B7p': function(X, S) {
        return X - S;
    },
    'V7T': function(X, S) {
        return X * S;
    },
    'w9M': function(X, S) {
        return X == S;
    },
    'e1s': function(X, S) {
        return X >= S;
    },
    'R0K': "opacityModifyRGB",
    'y0E': function(X, S) {
        return X != S;
    },
    'N4D': function(X, S) {
        return X < S;
    },
    'i3m': function(X, S) {
        return X * S;
    },
    'K3w': function(X, S) {
        return X > S;
    },
    'q5q': function(X, S) {
        return X * S;
    },
    'z3v': function(X, S) {
        return X * S;
    },
    'M8z': function(X, S) {
        return X * S;
    },
    'P3b': function(X, S) {
        return X != S;
    },
    's8s': function(X, S) {
        return X in S;
    },
    'Q6D': function(X, S) {
        return X / S;
    },
    'G8G': function(X, S) {
        return X * S;
    },
    'y6': function(X) {
        cc.kmScalar = X;
    },
    'n5D': function(X, S) {
        return X / S;
    },
    'o7T': function(X, S) {
        return X * S;
    },
    'X8h': function(X, S) {
        return X < S;
    },
    'I5E': function(X, S) {
        return X * S;
    },
    'L7t': function(X, S) {
        return X < S;
    },
    'x3i': 49153,
    'A9E': function(X, S) {
        return X / S;
    },
    'A5t': function(X, S) {
        return X / S;
    },
    'y93': function(X, S) {
        return X * S;
    },
    'Z26': function(X, S) {
        return X != S;
    },
    'c3E': function(X, S) {
        return X != S;
    },
    'h1h': function(X, S) {
        return X != S;
    },
    'f5L': function(X, S) {
        return X / S;
    },
    'a9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_COLOR_VERT = X;
    },
    'a3O': function(X, S) {
        return X === S;
    },
    'K5G': function(X, S) {
        return X > S;
    },
    'L4A': function(X, S) {
        return X - S;
    },
    'b5j': function(X, S) {
        return X - S;
    },
    'G9P': "lg.Button",
    'S1P': "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform sampler2D CC_Texture0; \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    // mimic: glAlphaFunc(GL_GREATER)           \n    //pass if ( incoming_pixel \x3e\x3d CC_alpha_value ) \x3d\x3e fail if incoming_pixel \x3c CC_alpha_value   \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}",
    'g0E': function(X, S) {
        return X < S;
    },
    'K4E': function(X, S) {
        return X * S;
    },
    'B0j': function(X, S) {
        return X << S;
    },
    'Y5u': function(X, S, P) {
        return X * S * P;
    },
    'e6E': function(X, S) {
        return X * S;
    },
    'n6d': function(X, S) {
        return X === S;
    },
    'V9L': function(X, S) {
        return X * S;
    },
    'e5b': function(X, S) {
        return X - S;
    },
    'w7G': function(X, S) {
        return X > S;
    },
    'U1B': function(X, S) {
        return X / S;
    },
    'p5a': function(X, S) {
        return X / S;
    },
    'a5p': function(X, S) {
        return X >= S;
    },
    'T25': function(X, S) {
        return X !== S;
    },
    'M56': function(X, S) {
        return X / S;
    },
    'X8s': function(X, S) {
        return X instanceof S;
    },
    'p9j': function(X, S) {
        return X < S;
    },
    'Z9z': function(X, S) {
        return X * S;
    },
    'E9M': function(X, S) {
        return X === S;
    },
    'U61': function(X, S) {
        return X | S;
    },
    'U46': function(X, S) {
        return X == S;
    },
    'M92': function(X, S) {
        return X != S;
    },
    'o6u': function(X, S) {
        return X * S;
    },
    'Q0p': function(X, S) {
        return X - S;
    },
    'Y73': function(X, S) {
        return X / S;
    },
    'F9L': function(X, S) {
        return X < S;
    },
    'S4f': function(X, S, P) {
        return X / S * P;
    },
    'v1': function() {
        cc.$.trans = cc.$.pfx + "Transform";
    },
    't0v': function(X, S) {
        return X / S;
    },
    'q1A': function(X, S) {
        return X - S;
    },
    'n9m': function(X, S) {
        return X != S;
    },
    's5u': function(X, S) {
        return X == S;
    },
    'Z9N': function(X, S, P, O) {
        return X | S | P | O;
    },
    'q86': function(X, S) {
        return X == S;
    },
    'q13': function(X, S) {
        return X < S;
    },
    'F61': function(X, S) {
        return X | S;
    },
    'N8L': function(X, S) {
        return X - S;
    },
    'Z8T': function(X, S, P) {
        return X * S * P;
    },
    'z6l': function(X, S) {
        return X >= S;
    },
    'o7t': function(X, S) {
        return X < S;
    },
    'y7P': ".",
    'd9': function(X) {
        cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = X;
    },
    'c6u': function(X, S) {
        return X - S;
    },
    'f6z': function(X, S) {
        return X > S;
    },
    's7a': function(X, S) {
        return X * S;
    },
    'H3H': "O",
    'E9': function(X) {
        cc.FMT_WEBP = X;
    },
    't9E': function(X, S) {
        return X < S;
    },
    'H88': function(X, S) {
        return X < S;
    },
    'n08': function(X, S) {
        return X << S;
    },
    'f2E': function(X, S) {
        return X - S;
    },
    'E36': function(X, S) {
        return X < S;
    },
    'V1E': function(X, S) {
        return X instanceof S;
    },
    'b4p': function(X, S) {
        return X >= S;
    },
    'E0': function(X) {
        cc._EventListenerMouse.LISTENER_ID = X;
    },
    'F3y': function(X) {
        cc.PARTICLE_TYPE_FREE = X;
    },
    'M63': function(X, S) {
        return X * S;
    },
    'N2G': function(X, S) {
        return X * S;
    },
    'm3l': function(X, S) {
        return X < S;
    },
    'N98': function(X, S) {
        return X | S;
    },
    'h3': function(X) {
        _M[_c.PIXEL_FORMAT_RGBA8888] = X;
    },
    'U8d': function(X, S) {
        return X == S;
    },
    'L8f': function(X, S) {
        return X != S;
    },
    'v3m': function(X, S) {
        return X * S;
    },
    'G3A': function(X, S) {
        return X != S;
    },
    'K36': function(X, S) {
        return X != S;
    },
    'z03': function(X, S) {
        return X < S;
    },
    'S8j': function(X, S) {
        return X >>> S;
    },
    'V58': function(X, S) {
        return X == S;
    },
    'T8P': "radialAccelVar",
    'q51': function(X, S) {
        return X / S;
    },
    'f0T': function(X, S, P, O) {
        return X - S - P - O;
    },
    'l4j': function(X, S) {
        return X - S;
    },
    'l7b': function(X, S) {
        return X < S;
    },
    'm8L': function(X, S) {
        return X - S;
    },
    'g52': function(X, S) {
        return X == S;
    },
    's83': function(X, S) {
        return X < S;
    },
    'T0O': function(X, S) {
        return X == S;
    },
    'j96': function(X, S) {
        return X == S;
    },
    'b7': function(X) {
        cc.EventMouse.MOVE = X;
    },
    'h38': function(X, S) {
        return X > S;
    },
    't5O': function(X, S) {
        return X == S;
    },
    'R1E': function(X, S) {
        return X !== S;
    },
    'e4K': "fontName",
    'i4z': function(X, S) {
        return X * S;
    },
    'C0M': function(X, S) {
        return X * S;
    },
    'c0h': function(X, S) {
        return X !== S;
    },
    'z0G': function(X, S) {
        return X * S;
    },
    'V45': function(X, S) {
        return X - S;
    },
    'O06': function(X, S) {
        return X < S;
    },
    'Q53': function(X, S) {
        return X != S;
    },
    'I3b': function(X, S) {
        return X - S;
    },
    'o43': function(X, S, P, O) {
        return X * S * P * O;
    },
    'T8h': function(X, S) {
        return X === S;
    },
    'o8q': function(X, S) {
        return X * S;
    },
    'd0s': function(X, S) {
        return X * S;
    },
    'K9B': function(X, S) {
        return X < S;
    },
    'u3f': function(X, S) {
        return X instanceof S;
    },
    'e2E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'y5m': function(X, S) {
        return X * S;
    },
    'L31': function(X, S) {
        return X === S;
    },
    'k1L': function(X, S) {
        return X > S;
    },
    'f5H': "hidden",
    'z81': function(X, S) {
        return X !== S;
    },
    'v9m': function(X, S) {
        return X === S;
    },
    'b1l': function(X, S) {
        return X < S;
    },
    't6v': function(X, S) {
        return X - S;
    },
    'H5v': function(X, S) {
        return X - S;
    },
    'I6N': function(X, S) {
        return X * S;
    },
    'T2L': function(X, S) {
        return X * S;
    },
    'o1N': function(X, S) {
        return X * S;
    },
    'p4v': function(X, S) {
        return X != S;
    },
    'j7d': function(X, S) {
        return X / S;
    },
    'I0w': function(X, S) {
        return X < S;
    },
    'w4j': function(X, S) {
        return X << S;
    },
    'z96': function(X, S) {
        return X < S;
    },
    'O2B': function(X, S, P) {
        return X * S / P;
    },
    'w0N': function(X, S) {
        return X > S;
    },
    'u7v': function(X, S) {
        return X >= S;
    },
    'O31': function(X, S) {
        return X === S;
    },
    'l2p': function(X, S) {
        return X < S;
    },
    'e7M': function(X, S, P) {
        return X * S * P;
    },
    'e85': function(X, S) {
        return X * S;
    },
    'u7p': function(X, S) {
        return X - S;
    },
    'O08': function(X, S) {
        return X < S;
    },
    'R8T': function(X, S, P) {
        return X * S * P;
    },
    'n5z': function(X, S) {
        return X < S;
    },
    'c9j': function(X, S) {
        return X === S;
    },
    'd0E': function(X, S) {
        return X < S;
    },
    'M7h': function(X, S) {
        return X * S;
    },
    'E7q': function(X, S) {
        return X * S;
    },
    'T9K': "?",
    'O32': function(X, S) {
        return X > S;
    },
    'u8E': function(X, S) {
        return X != S;
    },
    'b2L': function(X, S) {
        return X * S;
    },
    'c0G': function(X, S) {
        return X * S;
    },
    'w5f': function(X, S) {
        return X < S;
    },
    'N85': function(X, S) {
        return X > S;
    },
    'D8l': function(X, S) {
        return X === S;
    },
    'S0l': function(X, S) {
        return X / S;
    },
    'D25': function(X, S) {
        return X == S;
    },
    'q6t': function(X, S) {
        return X * S;
    },
    'w4i': "clearColorVal",
    'O12': function(X, S) {
        return X / S;
    },
    'd7m': function(X, S) {
        return X < S;
    },
    'n88': function(X, S) {
        return X / S;
    },
    'g9M': function(X, S) {
        return X < S;
    },
    'U01': function(X, S) {
        return X === S;
    },
    'E6D': function(X, S) {
        return X > S;
    },
    'A6L': function(X, S) {
        return X != S;
    },
    'G6h': function(X, S) {
        return X === S;
    },
    'h1S': 0.1,
    'J0a': function(X, S) {
        return X > S;
    },
    'S3m': function(X, S) {
        return X * S;
    },
    'D1M': function(X, S) {
        return X * S;
    },
    'c0q': function(X, S) {
        return X * S;
    },
    'i7s': function(X, S) {
        return X * S;
    },
    'x2D': function(X, S) {
        return X - S;
    },
    'C6w': function(X, S) {
        return X * S;
    },
    'V46': function(X, S) {
        return X == S;
    },
    'V3z': function(X, S) {
        return X % S;
    },
    'K6s': function(X, S) {
        return X - S;
    },
    'o3s': function(X, S) {
        return X * S;
    },
    'h1s': function(X, S) {
        return X < S;
    },
    'x81': function(X, S) {
        return X !== S;
    },
    'E9y': function(X) {
        cc.UNIFORM_TIME = X;
    },
    'U66': function(X, S) {
        return X != S;
    },
    'w6h': function(X, S) {
        return X === S;
    },
    'B5s': function(X, S) {
        return X - S;
    },
    'U63': function(X, S) {
        return X === S;
    },
    'U03': function(X, S) {
        return X / S;
    },
    'D1j': function(X, S) {
        return X < S;
    },
    'D6A': function(X, S) {
        return X == S;
    },
    'K5f': function(X, S) {
        return X == S;
    },
    'k8H': function(X, S) {
        return X * S;
    },
    'U0b': function(X, S) {
        return X == S;
    },
    'W2m': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'H9u': function(X, S, P) {
        return X * S * P;
    },
    'F1b': function(X, S) {
        return X - S;
    },
    'f32': function(X, S) {
        return X instanceof S;
    },
    'v68': function(X, S) {
        return X != S;
    },
    'h0z': function(X, S) {
        return X == S;
    },
    'e5y': function(X) {
        cc.NORMAL_TAG = X;
    },
    'R6A': function(X, S) {
        return X / S;
    },
    'd0M': function(X, S, P) {
        return X * S * P;
    },
    'v2H': "bombs",
    'O6y': function(X) {
        cc.TMX_TILE_VERTICAL_FLAG = X;
    },
    'e0p': function(X, S) {
        return X - S;
    },
    'D9L': function(X, S) {
        return X * S;
    },
    'E9B': function(X, S) {
        return X >= S;
    },
    'r1S': "color",
    'm2G': function(X, S) {
        return X === S;
    },
    'E8T': function(X, S, P) {
        return X * S * P;
    },
    'c4L': function(X, S) {
        return X > S;
    },
    'S1p': function(X, S) {
        return X - S;
    },
    'V0m': function(X, S) {
        return X >= S;
    },
    'F1T': function(X, S) {
        return X == S;
    },
    'Q6v': function(X, S) {
        return X == S;
    },
    'm2N': function(X, S) {
        return X !== S;
    },
    'e51': function(X, S) {
        return X / S;
    },
    'u76': function(X, S) {
        return X == S;
    },
    'Q6P': "png",
    'o4v': function(X, S) {
        return X != S;
    },
    'H9': function(X) {
        cc.COCOSNODE_RENDER_SUBPIXEL = X;
    },
    'g6s': function(X, S) {
        return X < S;
    },
    'p95': function(X, S) {
        return X >= S;
    },
    't3t': function(X, S) {
        return X == S;
    },
    'j8P': "texture",
    't5w': function(X, S) {
        return X === S;
    },
    'm6M': function(X, S) {
        return X - S;
    },
    'z1u': function(X, S) {
        return X - S;
    },
    'p1E': function(X, S) {
        return X === S;
    },
    'u3q': function(X, S) {
        return X * S;
    },
    'E5P': "font",
    'g9B': function(X, S) {
        return X < S;
    },
    'V3h': function(X, S) {
        return X / S;
    },
    'c1y': function(X) {
        cc.SHADER_POSITION_UCOLOR = X;
    },
    'R2D': function(X, S) {
        return X / S;
    },
    'x25': function(X, S) {
        return X != S;
    },
    'E7z': function(X, S) {
        return X / S;
    },
    'Y7j': function(X, S) {
        return X >= S;
    },
    'D3H': "width",
    'A1h': function(X, S) {
        return X * S;
    },
    'a9N': function(X, S) {
        return X == S;
    },
    't7z': function(X, S) {
        return X < S;
    },
    'x6m': function(X, S) {
        return X - S;
    },
    'P08': function(X, S) {
        return X > S;
    },
    'w8m': function(X, S) {
        return X != S;
    },
    'y9O': function() {
        Global.data = [[15, 15, 15, 15], null];
    },
    'a4h': function(X, S) {
        return X === S;
    },
    'b0h': function(X, S) {
        return X < S;
    },
    'C91': function(X, S) {
        return X < S;
    },
    'H41': function(X, S) {
        return X < S;
    },
    'V81': function(X, S) {
        return X !== S;
    },
    'O5s': function(X, S) {
        return X * S;
    },
    'z6b': function(X, S) {
        return X / S;
    },
    'F96': function(X, S) {
        return X / S;
    },
    'f4m': function(X, S) {
        return X - S;
    },
    'f5y': function(X) {
        cc.TMX_LAYER_ATTRIB_NONE = X;
    },
    'm9E': function(X, S) {
        return X / S;
    },
    'X61': function(X, S) {
        return X == S;
    },
    'O0T': function(X, S) {
        return X > S;
    },
    'P5u': function(X, S) {
        return X == S;
    },
    'd5q': function(X, S) {
        return X * S;
    },
    'p46': function(X, S) {
        return X < S;
    },
    'W55': function(X, S) {
        return X | S;
    },
    'q2M': function(X, S) {
        return X - S;
    },
    'k0d': function(X, S) {
        return X / S;
    },
    'N1S': "jpg",
    'K52': function(X, S) {
        return X instanceof S;
    },
    'k1S': "BLUE",
    'F0O': function(X, S) {
        return X != S;
    },
    'R1N': function(X, S) {
        return X < S;
    },
    'C86': function(X, S) {
        return X == S;
    },
    'n15': function(X, S) {
        return X * S;
    },
    'X7w': function(X, S) {
        return X * S;
    },
    'k2f': function(X, S, P) {
        return X - S + P;
    },
    'k0w': function(X, S) {
        return X * S;
    },
    'H4f': function(X, S, P) {
        return X / S * P;
    },
    'l4a': function(X, S) {
        return X == S;
    },
    'w71': function(X, S) {
        return X == S;
    },
    'B9f': function(X, S) {
        return X | S;
    },
    'K5M': function(X, S) {
        return X | S;
    },
    'b9N': function(X, S) {
        return X * S;
    },
    'G1v': function(X, S) {
        return X < S;
    },
    'J4u': function(X, S) {
        return X * S;
    },
    'd6L': function(X, S) {
        return X * S;
    },
    'a2j': function(X, S) {
        return X === S;
    },
    'm4a': function(X, S) {
        return X === S;
    },
    'A2z': function(X, S) {
        return X / S;
    },
    'q2m': function(X, S) {
        return X * S;
    },
    'o01': function(X, S) {
        return X != S;
    },
    'y5i': "A8",
    'Q6y': function(X) {
        cc.TMX_TILE_DIAGONAL_FLAG = X;
    },
    'l7M': function(X, S) {
        return X === S;
    },
    'v3w': function(X, S) {
        return X / S;
    },
    'j8s': function(X, S) {
        return X - S;
    },
    't2A': function(X, S) {
        return X == S;
    },
    'j2t': function(X, S) {
        return X - S;
    },
    'N4w': function(X, S) {
        return X - S;
    },
    'e4H': function(X, S) {
        return X > S;
    },
    'i4m': function(X, S) {
        return X <= S;
    },
    'A6v': function(X, S) {
        return X == S;
    },
    's4s': function(X, S) {
        return X * S;
    },
    'J9q': function(X, S) {
        return X * S;
    },
    'j1u': function(X, S, P) {
        return X * S * P;
    },
    'Z9d': function(X, S) {
        return X > S;
    },
    'g8m': function(X, S) {
        return X < S;
    },
    'Z7L': function(X, S) {
        return X * S;
    },
    'm52': function(X, S) {
        return X < S;
    },
    'v6M': function(X, S) {
        return X / S;
    },
    'x1w': function(X, S) {
        return X * S;
    },
    'N9E': function(X, S) {
        return X < S;
    },
    'm3D': function(X, S) {
        return X / S;
    },
    'l3u': function(X, S, P) {
        return X * S * P;
    },
    'L2E': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'j6O': function(X, S) {
        return X == S;
    },
    'B6N': function(X, S) {
        return X > S;
    },
    'g3l': function(X, S) {
        return X <= S;
    },
    'I5p': function(X, S) {
        return X < S;
    },
    'C5M': function(X, S) {
        return X - S;
    },
    'F8M': function(X, S) {
        return X === S;
    },
    'l7O': function(X, S) {
        return X != S;
    },
    'r5b': function(X, S) {
        return X != S;
    },
    'o6i': "a_position",
    'Z83': function(X, S, P) {
        return X * S * P;
    },
    'm5w': function(X, S) {
        return X < S;
    },
    'O0t': function(X, S) {
        return X < S;
    },
    'P7L': function(X, S) {
        return X * S;
    },
    'v6G': function(X, S) {
        return X === S;
    },
    'b6O': function(X, S) {
        return X < S;
    },
    'r4K': "BLACK",
    'k5p': function(X, S) {
        return X >= S;
    },
    'J7i': 100,
    'p1l': function(X, S) {
        return X === S;
    },
    'p0q': function(X, S) {
        return X * S;
    },
    'j7': function(X) {
        cc.ResolutionPolicy.FIXED_HEIGHT = X;
    },
    'X1a': function(X, S) {
        return X != S;
    },
    'S9f': function(X, S) {
        return X | S;
    },
    'o8O': function(X, S) {
        return X == S;
    },
    'P2b': function(X, S) {
        return X / S;
    },
    'B4q': function(X, S) {
        return X * S;
    },
    'y52': function(X, S) {
        return X < S;
    },
    'g5A': function(X, S) {
        return X == S;
    },
    'm9a': function(X, S) {
        return X | S;
    },
    'E8m': function(X, S) {
        return X != S;
    },
    'L5T': function(X, S) {
        return X * S;
    },
    'T11': function(X, S) {
        return X / S;
    },
    'p03': function(X, S) {
        return X | S;
    },
    'j9v': function(X, S) {
        return X - S;
    },
    'Q1u': function(X, S) {
        return X * S;
    },
    'M1E': function(X, S) {
        return X instanceof S;
    },
    'y1A': function(X, S) {
        return X == S;
    },
    'q9b': function(X, S, P) {
        return X / S * P;
    },
    'Q5t': function(X, S) {
        return X > S;
    },
    'H26': function(X, S) {
        return X != S;
    },
    't1h': function(X, S) {
        return X * S;
    },
    'w86': function(X, S) {
        return X * S;
    },
    'Y9p': function(X, S) {
        return X < S;
    },
    'B4m': function(X, S) {
        return X == S;
    },
    'l9a': function(X, S) {
        return X == S;
    },
    'm1h': function(X, S) {
        return X === S;
    },
    'p78': function(X, S) {
        return X * S;
    },
    'd1z': function(X, S) {
        return X * S;
    },
    'Q93': function(X, S) {
        return X / S;
    },
    'F35': function(X, S) {
        return X < S;
    },
    'T5j': function(X, S) {
        return X - S;
    },
    'M1D': function(X, S) {
        return X == S;
    },
    'y3a': function(X, S) {
        return X * S;
    },
    'w91': function(X, S) {
        return X < S;
    },
    'c1D': function(X, S) {
        return X < S;
    },
    'x58': function(X, S) {
        return X - S;
    },
    'l2G': function(X, S) {
        return X == S;
    },
    'x63': function(X, S) {
        return X !== S;
    },
    'h5G': function(X, S) {
        return X < S;
    },
    'Z8H': function(X, S) {
        return X == S;
    },
    'T6A': function(X, S) {
        return X > S;
    },
    'Y6m': function(X, S) {
        return X * S;
    },
    'J88': function(X, S) {
        return X === S;
    },
    'Q1q': function(X, S) {
        return X * S;
    },
    'h8v': function(X, S) {
        return X <= S;
    },
    'O7L': function(X, S) {
        return X * S;
    },
    'Y4f': function(X, S, P) {
        return X / S * P;
    },
    'U4M': function(X, S) {
        return X * S;
    },
    'C8S': "__cc_mouse",
    'c8l': function(X, S) {
        return X != S;
    },
    'o5d': function(X, S) {
        return X != S;
    },
    'P7E': function(X, S) {
        return X == S;
    },
    'W23': function(X, S) {
        return X < S;
    },
    'g2z': function(X, S) {
        return X == S;
    },
    'k41': function(X, S) {
        return X !== S;
    },
    'w48': function(X, S) {
        return X <= S;
    },
    'b4L': function(X, S) {
        return X * S;
    },
    'g1P': "MAGENTA",
    'p3z': function(X, S) {
        return X < S;
    },
    'W0a': function(X, S) {
        return X * S;
    },
    'V7a': function(X, S) {
        return X * S;
    },
    'd6p': function(X, S) {
        return X >= S;
    },
    'A1': function() {
        cc.$.hd = !0;
    },
    'y4w': function(X, S) {
        return X | S;
    },
    'Z2T': function(X, S) {
        return X < S;
    },
    'W5E': function(X, S) {
        return X > S;
    },
    'B2y': function() {
        lg = lg || {};
    },
    'S7E': function(X, S) {
        return X < S;
    },
    'a68': function(X, S) {
        return X << S;
    },
    'i3O': function(X, S) {
        return X < S;
    },
    'C4B': function(X, S) {
        return X | S;
    },
    'S0w': function(X, S) {
        return X < S;
    },
    'v1m': function(X, S) {
        return X > S;
    },
    'Y6': function(X) {
        cc.LabelTTF._checkRegEx = X;
    },
    'H2T': function(X, S) {
        return X * S;
    },
    'J1M': function(X, S) {
        return X / S;
    },
    'C48': function(X, S) {
        return X != S;
    },
    'm4D': function(X, S) {
        return X === S;
    },
    'R58': function(X, S) {
        return X & S;
    },
    'g5l': function(X, S) {
        return X === S;
    },
    'w38': function(X, S) {
        return X < S;
    },
    'F1E': function(X, S) {
        return X / S;
    },
    'G6z': function(X, S) {
        return X - S;
    },
    'I7s': function(X, S) {
        return X * S;
    },
    'U4b': function(X, S) {
        return X == S;
    },
    'C5q': function(X, S) {
        return X * S;
    },
    'k12': function(X, S) {
        return X instanceof S;
    },
    'E05': function(X, S) {
        return X != S;
    },
    'Z33': function(X, S) {
        return X != S;
    },
    'S7': function(X) {
        cc.ResolutionPolicy.NO_BORDER = X;
    },
    'N6T': function(X, S) {
        return X * S;
    },
    'N0E': function(X, S) {
        return X == S;
    },
    'v4z': function(X, S) {
        return X == S;
    },
    'z58': function(X, S) {
        return X < S;
    },
    'z9p': function(X, S) {
        return X <= S;
    },
    'J8y': function(X) {
        cc.PROGRESS_TEXTURE_COORDS_COUNT = X;
    },
    'F7h': function(X, S) {
        return X !== S;
    },
    'I2E': function(X, S) {
        return X | S;
    },
    'c92': function(X, S) {
        return X !== S;
    },
    'G9s': function(X, S) {
        return X / S;
    },
    'U8O': function(X, S) {
        return X == S;
    },
    'H3': function(X) {
        _M[_c.PIXEL_FORMAT_RGB565] = X;
    },
    'I1L': function(X, S) {
        return X < S;
    },
    'f9d': function(X, S) {
        return X * S;
    },
    'N5w': function(X, S) {
        return X * S;
    },
    'r7P': "flippedX",
    'v5H': "topRight",
    'j8q': function(X, S) {
        return X * S;
    },
    'w5G': function(X, S) {
        return X === S;
    },
    'D5N': function(X, S) {
        return X - S;
    },
    'k4O': function(X, S) {
        return X - S;
    },
    'p92': function(X, S) {
        return X === S;
    },
    'g98': function(X, S) {
        return X == S;
    },
    'M5j': function(X, S) {
        return X > S;
    },
    'S5z': function(X, S) {
        return X - S;
    },
    'B8b': function(X, S) {
        return X < S;
    },
    'T2y': function() {
        lg = lg || {};
    },
    'g5M': function(X, S) {
        return X - S;
    },
    'Z2u': function(X, S) {
        return X !== S;
    },
    'U9y': function(X) {
        cc.UNIFORM_SAMPLER = X;
    },
    'z7d': function(X, S) {
        return X === S;
    },
    'R92': function(X, S) {
        return X == S;
    },
    'o7d': function(X, S) {
        return X / S;
    },
    'm4T': function(X, S) {
        return X - S;
    },
    'M35': function(X, S) {
        return X < S;
    },
    'v9d': function(X, S) {
        return X < S;
    },
    'W31': function(X, S) {
        return X * S;
    },
    'P8D': function(X, S) {
        return X == S;
    },
    'Y7w': function(X, S) {
        return X | S;
    },
    'D6B': function(X, S) {
        return X * S;
    },
    'V3L': function(X, S) {
        return X - S;
    },
    'y8m': function(X, S) {
        return X | S;
    },
    'o0O': function(X, S) {
        return X < S;
    },
    'E4K': "children",
    'A9D': function(X, S) {
        return X < S;
    },
    'R45': function(X, S) {
        return X / S;
    },
    'G5D': function(X, S) {
        return X / S;
    },
    'U0O': function(X, S) {
        return X != S;
    },
    'K48': function(X, S) {
        return X / S;
    },
    'b2D': function(X, S) {
        return X / S;
    },
    'i08': function(X, S) {
        return X <= S;
    },
    's9v': function(X, S) {
        return X * S;
    },
    'n32': function(X, S) {
        return X <= S;
    },
    'W7E': function(X, S) {
        return X < S;
    },
    'C3j': function(X, S) {
        return X < S;
    },
    'X2A': function(X, S, P) {
        return X * S / P;
    },
    'b8O': function(X, S) {
        return X < S;
    },
    'Y9': function(X) {
        ClassManager.compileSuper.ClassManager = X;
    },
    'h5H': "LayerColor",
    'I4h': function(X, S) {
        return X * S;
    },
    'r0': function(X) {
        cc.EventListener.KEYBOARD = X;
    },
    'e98': function(X, S) {
        return X / S;
    },
    'c2P': "mainShop",
    'D3p': function(X, S) {
        return X >> S;
    },
    'D4v': function(X, S) {
        return X == S;
    },
    'e2': function(X) {
        cc.KM_PLANE_TOP = X;
    },
    'f31': function(X, S) {
        return X * S;
    },
    'B8N': function(X, S) {
        return X == S;
    },
    'G5': function(X) {
        cc.DEFAULT_SPRITE_BATCH_CAPACITY = X;
    },
    'r05': function(X, S) {
        return X != S;
    },
    'T4v': function(X, S) {
        return X - S;
    },
    'v7p': function(X, S) {
        return X - S;
    },
    'Y6E': function(X, S, P) {
        return X * S * P;
    },
    'd9a': function(X, S) {
        return X | S;
    },
    't52': function(X, S) {
        return X >= S;
    },
    'c8': function() {
        cc.RECT_POINTS_TO_PIXELS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(X) {
            var S = cc.CONTENT_SCALE_FACTOR();
            return cc.rect(X.x * S, X.y * S, X.width * S, X.height * S);
        } : function(X) {
            return X;
        };
    },
    'O2b': function(X, S) {
        return X / S;
    },
    'g6': function(X) {
        cc.DEVICE_MAX_ORIENTATIONS = X;
    },
    'c6A': function(X, S) {
        return X == S;
    },
    'v5E': function(X, S) {
        return X * S;
    },
    'T3h': function(X, S) {
        return X < S;
    },
    'C1d': function(X, S) {
        return X == S;
    },
    'v0u': function(X, S, P) {
        return X / S * P;
    },
    'Q2M': function(X, S) {
        return X * S;
    },
    'F4t': function(X, S) {
        return X < S;
    },
    'k4u': function(X, S) {
        return X - S;
    },
    'K9O': function(X) {
        Global.level = X;
    },
    'A53': function(X, S) {
        return X != S;
    },
    's0q': function(X, S) {
        return X * S;
    },
    'E4B': function(X, S) {
        return X | S;
    },
    'l7G': function(X, S) {
        return X * S;
    },
    'H8D': function(X, S) {
        return X / S;
    },
    'D6m': function(X, S) {
        return X == S;
    },
    'V6B': function(X, S) {
        return X !== S;
    },
    'j83': function(X, S) {
        return X * S;
    },
    'B16': function(X, S) {
        return X == S;
    },
    'j5y': function(X) {
        cc.CURRENT_ITEM = X;
    },
    'w7h': function(X, S) {
        return X > S;
    },
    'c95': function(X, S) {
        return X != S;
    },
    't4P': "cascadeColor",
    'J76': function(X, S) {
        return X == S;
    },
    'G22': function(X, S) {
        return X == S;
    },
    'f5D': function(X, S) {
        return X * S;
    },
    'l9E': function(X, S) {
        return X - S;
    },
    's7t': function(X, S) {
        return X < S;
    },
    'D1': function(X) {
        cc.TEXTURE_NPOT_SUPPORT = X;
    },
    'C2z': function(X, S, P) {
        return X * S / P;
    },
    'W88': function(X, S) {
        return X != S;
    },
    'i9m': function(X, S) {
        return X === S;
    },
    'Y0b': function(X, S) {
        return X == S;
    },
    'o2P': "res/music/menu.mp3",
    'r4B': function(X, S) {
        return X | S;
    },
    'L33': function(X, S) {
        return X | S;
    },
    'X9P': 775,
    'h3t': function(X, S) {
        return X < S;
    },
    'I4A': function(X, S) {
        return X != S;
    },
    'R6q': function(X, S) {
        return X * S;
    },
    'N36': function(X, S) {
        return X < S;
    },
    'u8b': function(X, S) {
        return X - S;
    },
    'T7j': function(X, S) {
        return X < S;
    },
    'j0h': function(X, S) {
        return X === S;
    },
    's1l': function(X, S) {
        return X !== S;
    },
    'a9O': function(X) {
        Global.bombSlotGap = X;
    },
    'r3D': function(X, S) {
        return X != S;
    },
    'B4s': function(X, S, P) {
        return X / S * P;
    },
    's3z': function(X, S) {
        return X - S;
    },
    'J3b': function(X, S) {
        return X / S;
    },
    'Q9B': function(X, S) {
        return X * S;
    },
    'r42': function(X, S) {
        return X instanceof S;
    },
    'o1j': function(X, S) {
        return X < S;
    },
    'P4l': function(X, S) {
        return X <= S;
    },
    'J2u': function(X, S) {
        return X !== S;
    },
    'X5d': function(X, S) {
        return X != S;
    },
    't7h': function(X, S) {
        return X !== S;
    },
    'X7T': function(X, S) {
        return X * S;
    },
    'a8f': function(X, S) {
        return X - S;
    },
    'w2d': function(X, S) {
        return X == S;
    },
    'V2': function(X) {
        cc.current_stack = X;
    },
    'o3B': function(X, S) {
        return X / S;
    },
    'Z3y': function(X) {
        _p = X;
    },
    'O6N': function(X, S) {
        return X * S;
    },
    'g05': function(X, S) {
        return X < S;
    },
    'z1E': function(X, S) {
        return X * S;
    },
    'T0h': function(X, S) {
        return X * S;
    },
    'f5v': function(X, S) {
        return X > S;
    },
    'Y6q': function(X, S) {
        return X * S;
    },
    'x45': function(X, S) {
        return X - S;
    },
    'b8M': function(X, S) {
        return X === S;
    },
    'F1y': function() {
        cc._vertexAttribTexCoords = !1;
    },
    'i1t': function(X, S) {
        return X - S;
    },
    'I8w': function(X, S) {
        return X < S;
    },
    'i0w': function(X, S) {
        return X * S;
    },
    'V4E': function(X, S) {
        return X / S;
    },
    'Y0A': function(X, S) {
        return X != S;
    },
    'Z5p': function(X, S) {
        return X >= S;
    },
    'T5y': function(X) {
        cc.DEFAULT_PADDING = X;
    },
    'o9p': function(X, S) {
        return X < S;
    },
    'v9h': function(X, S) {
        return X * S;
    },
    'H8j': function(X, S) {
        return X & S;
    },
    'k4M': function(X, S) {
        return X / S;
    },
    'E9j': function(X, S) {
        return X < S;
    },
    'S9w': function(X, S, P, O) {
        return X * S * P * O;
    },
    'W9A': function(X, S) {
        return X == S;
    },
    'Y7a': function(X, S) {
        return X > S;
    },
    'm7b': function(X, S) {
        return X * S;
    },
    'I4G': function(X, S) {
        return X === S;
    },
    's1B': function(X, S) {
        return X / S;
    },
    'J8N': function(X, S) {
        return X == S;
    },
    'L1v': function(X, S) {
        return X - S;
    },
    'T2t': function(X, S) {
        return X == S;
    },
    'S1L': function(X, S) {
        return X < S;
    },
    'p0O': function(X, S) {
        return X == S;
    },
    'm9B': function(X, S) {
        return X >= S;
    },
    'D8h': function(X, S) {
        return X == S;
    },
    'c4p': function(X, S) {
        return X - S;
    },
    'U5P': 1E5,
    'U1y': function() {
        cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    },
    'P4K': 275,
    'O7N': function(X, S) {
        return X * S;
    },
    'u6s': function(X, S) {
        return X * S;
    },
    'R0i': "x",
    'T3u': function(X, S) {
        return X < S;
    },
    'R7M': function(X, S) {
        return X / S;
    },
    'C9O': function() {
        Global.zEnemies = [{
            coins: 10,
            maxHealth: 10,
            damage: 5,
            speed: 100,
            walkFPS: 10,
            lost: 1,
            assetID: "BombZombie"
        }, {
            coins: 10,
            maxHealth: 20,
            damage: 10,
            speed: 75,
            walkFPS: 10,
            lost: 1,
            assetID: "Zombie0"
        }, {
            coins: 20,
            maxHealth: 20,
            damage: 10,
            speed: 75,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie1"
        }, {
            coins: 20,
            maxHealth: 20,
            damage: 15,
            speed: 50,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie2"
        }, {
            coins: 20,
            maxHealth: 30,
            damage: 20,
            speed: 40,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie3"
        }, {
            coins: 20,
            maxHealth: 30,
            damage: 20,
            speed: 40,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie4"
        }, {
            coins: 20,
            maxHealth: 40,
            damage: 25,
            speed: 25,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie5"
        }, {
            coins: 20,
            maxHealth: 50,
            damage: 25,
            speed: 25,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie6"
        }, {
            coins: 20,
            maxHealth: 60,
            damage: 30,
            speed: 15,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie7"
        }, {
            coins: 20,
            maxHealth: 70,
            damage: 30,
            speed: 15,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie8"
        }, {
            coins: 20,
            maxHealth: 100,
            damage: 50,
            speed: 10,
            walkFPS: 10,
            lost: 2,
            assetID: "Zombie9"
        }];
    },
    'y2s': function(X, S) {
        return X >= S;
    },
    'c6l': function(X, S) {
        return X >= S;
    },
    'T0b': function(X, S) {
        return X == S;
    },
    'B8B': function(X, S) {
        return X === S;
    },
    'i2H': "u_color",
    'd52': function(X, S) {
        return X instanceof S;
    },
    'L9h': function(X, S) {
        return X !== S;
    },
    's3v': function(X, S) {
        return X < S;
    },
    'T96': function(X, S) {
        return X - S;
    },
    't2a': function(X, S) {
        return X * S;
    },
    'S23': function(X, S) {
        return X / S;
    },
    'm6w': function(X, S) {
        return X * S;
    },
    'E43': function(X, S) {
        return X / S;
    },
    'g2G': function(X, S) {
        return X >= S;
    },
    'b8l': function(X, S) {
        return X * S;
    },
    'f26': function(X, S) {
        return X != S;
    },
    'j6q': function(X, S) {
        return X * S;
    },
    'z0H': 0.01,
    'h5l': function(X, S) {
        return X >= S;
    },
    'S1y': function(X) {
        cc.SHADER_POSITION_LENGTHTEXTURECOLOR = X;
    },
    'n5s': function(X, S) {
        return X * S;
    },
    'w6L': function(X, S) {
        return X != S;
    },
    'E5q': function(X, S) {
        return X * S;
    },
    'r1d': function(X, S) {
        return X == S;
    },
    'I1': function() {
        cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
    },
    'n43': function(X, S, P, O) {
        return X * S * P * O;
    },
    'C7b': function(X, S) {
        return X < S;
    },
    'J7v': function(X, S) {
        return X === S;
    },
    'l38': function(X, S) {
        return X - S;
    },
    'X8A': function(X, S) {
        return X * S;
    },
    'o7j': function(X, S) {
        return X > S;
    },
    'z92': function(X, S) {
        return X != S;
    },
    'E48': function(X, S) {
        return X != S;
    },
    'h5t': function(X, S) {
        return X < S;
    },
    'Z5': function(X) {
        _B[_c.PIXEL_FORMAT_RGB5A1] = X;
    },
    'K1m': function(X, S) {
        return X - S;
    },
    'h6L': function(X, S) {
        return X > S;
    },
    'A3y': function(X) {
        _p.Inflate.BufferType = X.Inflate.BufferType;
    },
    'q7f': function(X, S) {
        return X / S;
    },
    'C7O': function(X, S) {
        return X == S;
    },
    'R1H': function(X, S) {
        return X * S;
    },
    'W7': function(X) {
        cc.Event.MOUSE = X;
    },
    'D3B': function(X, S) {
        return X / S;
    },
    'f8E': function(X, S) {
        return X === S;
    },
    'A2d': function(X, S) {
        return X == S;
    },
    'e6T': function(X, S) {
        return X / S;
    },
    'T1H': function(X, S) {
        return X == S;
    },
    'd7z': function(X, S) {
        return X > S;
    },
    'R2t': function(X, S) {
        return X * S;
    },
    'i4q': function(X, S) {
        return X * S;
    },
    'c1S': "barChangeRate",
    'q9D': function(X, S) {
        return X - S;
    },
    'R5N': function(X, S) {
        return X * S;
    },
    'Y4N': function(X, S) {
        return X * S;
    },
    'K0E': function(X, S) {
        return X == S;
    },
    'J6z': function(X, S) {
        return X * S;
    },
    'W5y': function(X) {
        cc.TGA_ERROR_INDEXED_COLOR = X;
    },
    'e2s': function(X, S) {
        return X - S;
    },
    'p73': function(X, S) {
        return X * S;
    },
    'K6h': function(X, S) {
        return X | S;
    },
    'E9b': function(X, S) {
        return X == S;
    },
    'L55': function(X, S) {
        return X < S;
    },
    'j1T': function(X, S) {
        return X * S;
    },
    'C2i': '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
    'N21': function(X, S) {
        return X * S;
    },
    'v22': function(X, S) {
        return X < S;
    },
    'C0N': function(X, S) {
        return X * S;
    },
    'S0t': function(X, S) {
        return X >= S;
    },
    'j62': function(X, S) {
        return X < S;
    },
    'R8l': function(X, S) {
        return X < S;
    },
    'j7j': function(X, S) {
        return X * S;
    },
    'I6M': function(X, S) {
        return X < S;
    },
    'W22': function(X, S) {
        return X < S;
    },
    'w9b': function(X, S) {
        return X * S;
    },
    'h2M': function(X, S) {
        return X - S;
    },
    'T1D': function(X, S) {
        return X == S;
    },
    'f5p': function(X, S) {
        return X >= S;
    },
    'a4O': function(X, S) {
        return X >= S;
    },
    'M9L': function(X, S) {
        return X * S;
    },
    'r5f': function(X, S) {
        return X == S;
    },
    't8i': "shadowBlur",
    'N2s': function(X, S) {
        return X - S;
    },
    'd5A': function(X, S) {
        return X > S;
    },
    'j25': function(X, S) {
        return X != S;
    },
    'A1f': function(X, S) {
        return X === S;
    },
    'm5q': function(X, S) {
        return X * S;
    },
    'n5y': function(X) {
        cc.TGA_OK = X;
    },
    'G6H': 500,
    'D6l': function(X, S) {
        return X >= S;
    },
    'Y2y': function(X) {
        SPACE_CHAR_GAP = X;
    },
    'd7i': "webkit",
    'l0B': function(X, S) {
        return X | S;
    },
    'C6u': function(X, S, P, O) {
        return X * S * P / O;
    },
    'L8w': function(X, S) {
        return X | S;
    },
    'y5y': function(X) {
        cc.TMX_ORIENTATION_HEX = X;
    },
    'q8L': function(X, S) {
        return X === S;
    },
    'F9u': function(X, S, P) {
        return X * S * P;
    },
    'F7t': function(X, S) {
        return X / S;
    },
    'J9s': function(X, S) {
        return X in S;
    },
    'W0u': function(X, S) {
        return X / S;
    },
    'Y7t': function(X, S) {
        return X < S;
    },
    'l42': function(X, S) {
        return X < S;
    },
    'X9p': function(X, S) {
        return X >>> S;
    },
    'r3j': function(X, S) {
        return X < S;
    },
    'z66': function(X, S) {
        return X / S;
    },
    'b81': function(X, S) {
        return X !== S;
    },
    'f7H': 9,
    'y2A': function(X, S) {
        return X != S;
    },
    'G5p': function(X, S) {
        return X >= S;
    },
    'c8u': function(X, S) {
        return X - S;
    },
    'i8f': function(X, S) {
        return X === S;
    },
    'L0T': function(X, S) {
        return X < S;
    },
    'K8v': function(X, S) {
        return X < S;
    },
    'N51': function(X, S) {
        return X / S;
    },
    'M3L': function(X, S) {
        return X < S;
    },
    'z2t': function(X, S) {
        return X >> S;
    },
    't7A': function(X, S) {
        return X == S;
    },
    'U4N': function(X, S) {
        return X * S;
    },
    't9T': function(X, S) {
        return X == S;
    },
    'x4P': "bottomRight",
    'F7T': function(X, S) {
        return X * S;
    },
    'A2M': function(X, S) {
        return X < S;
    },
    'q0p': function(X, S) {
        return X - S;
    },
    'K38': function(X, S) {
        return X > S;
    },
    'e1z': function(X, S) {
        return X * S;
    },
    'p6b': function(X, S) {
        return X / S;
    },
    'f9h': function(X, S) {
        return X !== S;
    },
    'R8z': function(X, S) {
        return X * S;
    },
    'L3O': function(X, S) {
        return X != S;
    },
    'k55': function(X, S) {
        return X == S;
    },
    'w2G': function(X, S) {
        return X / S;
    },
    'Y4s': function(X, S) {
        return X > S;
    },
    'R2L': function(X, S) {
        return X * S;
    },
    'm7z': function(X, S) {
        return X === S;
    },
    'I0j': function(X, S) {
        return X < S;
    },
    'p61': function(X, S) {
        return X * S;
    },
    'G0j': function(X, S) {
        return X & S;
    },
    'Q85': function(X, S) {
        return X * S;
    },
    'b9v': function(X, S) {
        return X == S;
    },
    'm3t': function(X, S) {
        return X != S;
    },
    'J1m': function(X, S) {
        return X < S;
    },
    'y4l': function(X, S) {
        return X * S;
    },
    'v8a': function(X, S) {
        return X == S;
    },
    'y0': function(X) {
        cc.NODE_ON_EXIT = X;
    },
    'b11': function(X, S) {
        return X !== S;
    },
    'g8y': function(X) {
        cc.IMAGE_FORMAT_RAWDATA = X;
    },
    'd3d': function(X, S) {
        return X === S;
    },
    'u23': function(X, S) {
        return X * S;
    },
    'G1L': function(X, S) {
        return X * S;
    },
    'B26': function(X, S) {
        return X == S;
    },
    's1G': function(X, S) {
        return X * S;
    },
    'k0u': function(X, S, P) {
        return X / S * P;
    },
    'q0': function(X) {
        cc.s_globalOrderOfArrival = X;
    },
    'T5d': function(X, S) {
        return X < S;
    },
    'k88': function(X, S) {
        return X != S;
    },
    'T4t': function(X, S) {
        return X < S;
    },
    'x0b': function(X, S) {
        return X * S;
    },
    'q53': function(X, S) {
        return X != S;
    },
    'n3b': function(X, S) {
        return X != S;
    },
    'P8B': function(X, S) {
        return X === S;
    },
    'Z43': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'C9a': function(X, S) {
        return X * S;
    },
    'b21': function(X, S) {
        return X * S;
    },
    'T01': function(X, S) {
        return X == S;
    },
    's7d': function(X, S) {
        return X / S;
    },
    'h1z': function(X, S) {
        return X * S;
    },
    'D0m': function(X, S) {
        return X * S;
    },
    'K4B': function(X, S) {
        return X == S;
    },
    'A71': function(X, S) {
        return X * S;
    },
    'e9b': function(X, S) {
        return X * S;
    },
    'A6E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'E42': function(X, S) {
        return X < S;
    },
    'B5p': function(X, S) {
        return X >= S;
    },
    'n2y': function() {
        lg = lg || {};
    },
    'i2T': function(X, S) {
        return X == S;
    },
    'n0d': function(X, S) {
        return X === S;
    },
    'K71': function(X, S) {
        return X == S;
    },
    'n0L': function(X, S) {
        return X * S;
    },
    'W2O': function(X, S) {
        return X === S;
    },
    'f0t': function(X, S) {
        return X / S;
    },
    'v8T': function(X, S, P) {
        return X * S * P;
    },
    'm2z': function(X, S) {
        return X * S;
    },
    'v6N': function(X, S) {
        return X > S;
    },
    'k9d': function(X, S) {
        return X - S;
    },
    'U4p': function(X, S) {
        return X - S;
    },
    'i2q': function(X, S) {
        return X * S;
    },
    't1A': function(X, S) {
        return X == S;
    },
    'n8j': function(X, S) {
        return X >>> S;
    },
    'n0w': function(X, S) {
        return X >= S;
    },
    'Y2f': function(X, S) {
        return X == S;
    },
    'd9i': "selected_over",
    'W1M': function(X, S) {
        return X * S;
    },
    'l8T': function(X, S, P) {
        return X * S * P;
    },
    'e6S': "canvas",
    'r86': function(X, S) {
        return X - S;
    },
    'P8N': function(X, S) {
        return X !== S;
    },
    'g3D': function(X, S) {
        return X instanceof S;
    },
    'P2l': function(X, S) {
        return X < S;
    },
    'L2T': function(X, S) {
        return X == S;
    },
    'G16': function(X, S) {
        return X >= S;
    },
    'Y6B': function(X, S) {
        return X * S;
    },
    'S2u': function(X, S) {
        return X & S;
    },
    'o9G': function(X, S) {
        return X << S;
    },
    'd6h': function(X, S) {
        return X | S;
    },
    'd1d': function(X, S) {
        return X * S;
    },
    'J3A': function(X, S) {
        return X != S;
    },
    'w6y': function(X) {
        cc.TMX_PROPERTY_TILE = X;
    },
    'R3': function(X) {
        _c.PIXEL_FORMAT_RGBA4444 = X;
    },
    'q6H': "radial",
    'y5f': function(X, S) {
        return X === S;
    },
    'k7L': function(X, S) {
        return X * S;
    },
    'j6A': function(X, S) {
        return X != S;
    },
    'A2B': function(X, S, P) {
        return X * S / P;
    },
    'A98': function(X, S) {
        return X / S;
    },
    'D6G': function(X, S) {
        return X === S;
    },
    'o62': function(X, S) {
        return X < S;
    },
    'V0A': function(X, S) {
        return X != S;
    },
    'p7D': function(X, S) {
        return X * S;
    },
    'F3z': function(X, S) {
        return X * S;
    },
    'j58': function(X, S) {
        return X < S;
    },
    'K9l': function(X, S) {
        return X >= S;
    },
    'D6y': function(X) {
        cc.TMX_PROPERTY_NONE = X;
    },
    'L9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_VERT = X;
    },
    'h6E': function(X, S) {
        return X / S;
    },
    'z3E': function(X, S) {
        return X != S;
    },
    'm28': function(X, S) {
        return X >= S;
    },
    'L5p': function(X, S) {
        return X >= S;
    },
    'y4D': function(X, S) {
        return X > S;
    },
    'Q7q': function(X, S) {
        return X * S;
    },
    'p0f': function(X, S) {
        return X / S;
    },
    'f8w': function(X, S) {
        return X * S;
    },
    'E8t': function(X, S) {
        return X == S;
    },
    'O8B': function(X, S) {
        return X !== S;
    },
    'h9b': function(X, S) {
        return X * S;
    },
    'V5u': function(X, S) {
        return X < S;
    },
    'J4A': function(X, S) {
        return X != S;
    },
    'I2y': function(X) {
        Global.health = X;
    },
    'g8P': " ",
    'z4b': function(X, S) {
        return X - S;
    },
    'J5B': function(X, S) {
        return X | S;
    },
    'O5v': function(X, S) {
        return X != S;
    },
    'y2M': function(X, S) {
        return X < S;
    },
    'C8v': function(X, S) {
        return X == S;
    },
    'o6m': function(X, S) {
        return X * S;
    },
    'l9j': function(X, S) {
        return X - S;
    },
    'v6f': function(X, S) {
        return X * S;
    },
    'u9h': function(X, S) {
        return X !== S;
    },
    's2B': function(X, S) {
        return X < S;
    },
    'K7q': function(X, S) {
        return X * S;
    },
    'u2O': function(X, S) {
        return X >= S;
    },
    'M2D': function(X, S) {
        return X < S;
    },
    'U1T': function(X, S) {
        return X == S;
    },
    'O7s': function(X, S) {
        return X * S;
    },
    'A9j': function(X, S) {
        return X | S;
    },
    'd3P': 225,
    'j56': function(X, S) {
        return X / S;
    },
    'i6N': function(X, S) {
        return X * S;
    },
    'C1s': function(X, S) {
        return X < S;
    },
    'n4q': function(X, S) {
        return X * S;
    },
    'z2L': function(X, S) {
        return X * S;
    },
    'h0M': function(X, S) {
        return X * S;
    },
    'S1v': function(X, S) {
        return X != S;
    },
    'J5L': function(X, S) {
        return X > S;
    },
    'd7h': function(X, S) {
        return X !== S;
    },
    'j18': function(X, S) {
        return X == S;
    },
    'S2T': function(X, S) {
        return X == S;
    },
    'U4K': "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}",
    'v4': function(X) {
        cc.TEXT_ALIGNMENT_RIGHT = X;
    },
    'u6': function(X) {
        cc.LabelTTF.__labelHeightDiv.style.lineHeight = X;
    },
    'Q3a': function(X, S) {
        return X * S;
    },
    'a7P': "selectedImage",
    'c1a': function(X, S) {
        return X === S;
    },
    'B15': function(X, S) {
        return X < S;
    },
    't7m': function(X, S) {
        return X == S;
    },
    'J3q': function(X, S) {
        return X * S;
    },
    'q0s': function(X, S) {
        return X * S;
    },
    'u5E': function(X, S) {
        return X < S;
    },
    'J06': function(X, S) {
        return X != S;
    },
    'r98': function(X, S) {
        return X / S;
    },
    'M45': function(X, S) {
        return X - S;
    },
    'R11': function(X, S) {
        return X / S;
    },
    'X6l': function(X, S) {
        return X - S;
    },
    'T0A': function(X, S) {
        return X != S;
    },
    'z1P': 1.32,
    'H6N': function(X, S) {
        return X == S;
    },
    'L26': function(X, S) {
        return X == S;
    },
    'G68': function(X, S) {
        return X == S;
    },
    'L1G': function(X, S) {
        return X === S;
    },
    'g5m': function(X, S) {
        return X < S;
    },
    'R6P': "#",
    'D95': function(X, S) {
        return X * S;
    },
    't0s': function(X, S) {
        return X * S;
    },
    'L4u': function(X, S) {
        return X - S;
    },
    'K9b': function(X, S) {
        return X * S;
    },
    'm5G': function(X, S) {
        return X - S;
    },
    'z5d': function(X, S) {
        return X instanceof S;
    },
    'R3M': function(X, S) {
        return X | S;
    },
    'g2h': function(X, S) {
        return X | S;
    },
    'T5': function(X) {
        _B[_c.PIXEL_FORMAT_PVRTC2] = X;
    },
    'M3E': function(X, S) {
        return X <= S;
    },
    'L08': function(X, S) {
        return X == S;
    },
    's3T': function(X, S) {
        return X / S;
    },
    'I26': function(X, S) {
        return X - S;
    },
    't8m': function(X, S) {
        return X > S;
    },
    'e9E': function(X, S) {
        return X === S;
    },
    'u8K': 289,
    'V63': function(X, S) {
        return X - S;
    },
    'W2l': function(X, S) {
        return X === S;
    },
    'a3': function() {
        cc.PVRHaveAlphaPremultiplied_ = !1;
    },
    'h6m': function(X, S) {
        return X * S;
    },
    'E0N': function(X, S) {
        return X * S;
    },
    'E2H': "woff",
    'O75': function(X, S) {
        return X == S;
    },
    'D9v': function(X, S) {
        return X >>> S;
    },
    'Q8M': function(X, S, P) {
        return X * S / P;
    },
    'N5': function(X) {
        _B[_c.PIXEL_FORMAT_PVRTC4] = X;
    },
    'G8a': function(X, S) {
        return X < S;
    },
    'e6w': function(X, S) {
        return X * S;
    },
    'v7N': function(X, S) {
        return X * S;
    },
    'a1b': function(X, S) {
        return X == S;
    },
    'm6G': function(X, S) {
        return X == S;
    },
    'k7E': function(X, S) {
        return X < S;
    },
    'r4H': function(X, S) {
        return X == S;
    },
    'M3T': function(X, S) {
        return X * S;
    },
    'D0f': function(X, S) {
        return X < S;
    },
    'r4D': function(X, S) {
        return X === S;
    },
    'W6f': function(X, S) {
        return X * S;
    },
    's5a': function(X, S) {
        return X > S;
    },
    'T4N': function(X, S) {
        return X * S;
    },
    'u1m': function(X, S) {
        return X >= S;
    },
    'b2B': function(X, S) {
        return X != S;
    },
    'k0P': "text",
    'g4y': function() {
        cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, ((26, 145.1E1) >= 1.389E3 ? (0x1EC, 7) : (76., 9.67E2)), ((36, 0x95) <= 28. ? (1.029E3, 18) : 0xED <= (0x109, 5.59E2) ? (79., 9) : (0xD2, 0x15)), (0x19A >= (2.5E1, 55.) ? (141, 13) : 71.0E1 <= (1.499E3, 3E0) ? 106.0E1 : (0x1C3, 13.68E2) >= 13.98E2 ? (0x9B, 18761) : (3.1E1, 41)), 17, 25, ((66.7E1, 134.) < 0x14C ? (0x22E, 33) : (0x170, 7) >= 91 ? (0xE1, 25.6E1) : (2.7E1, 0x24A) <= (3.87E2, 98) ? "C" : (1.112E3, 0xA4)), 49, 65, 97, 129, 193, 257, 385, ((119.5E1, 4.55E2) < 0x22E ? (97., 513) : 50 >= (55.1E1, 140) ? (0x122, 143.0E1) : (0x1B1, 15) >= (36.0E1, 18) ? (1.23E3, 1.296E3) : (0xA0, 134.9E1)), 769, 1025, 1537, 2049, 3073, 4097, 6145, ((35.80E1, 0x200) < (4.84E2, 0xE0) ? 14.97E2 : (61., 12.07E2) > (61, 66.0E1) ? (86.4E1, 8193) : (12.96E2, 90)), 12289, ((1.3E3, 5.) < (0x1F6, 0x11D) ? (0x123, 16385) : (33.7E1, 0x5A)), 24577];
    },
    'W9m': function(X, S) {
        return X | S;
    },
    'y9w': function(X, S) {
        return X < S;
    },
    'g5u': function(X, S, P) {
        return X * S * P;
    },
    'S2B': function(X, S) {
        return X != S;
    },
    'C51': function(X, S) {
        return X / S;
    },
    'g5G': function(X, S) {
        return X >= S;
    },
    'j9j': function(X, S) {
        return X < S;
    },
    'y1u': function(X, S) {
        return X - S;
    },
    'l7A': function(X, S) {
        return X != S;
    },
    'W9h': function(X, S) {
        return X * S;
    },
    'v2O': function(X, S) {
        return X === S;
    },
    'g65': function(X, S) {
        return X != S;
    },
    'x66': function(X, S) {
        return X < S;
    },
    'A5M': function(X, S) {
        return X - S;
    },
    'y2h': function(X, S) {
        return X == S;
    },
    'P1v': function(X, S) {
        return X % S;
    },
    'E9N': function(X, S) {
        return X < S;
    },
    'X7d': function(X, S) {
        return X === S;
    },
    'g9H': function(X, S) {
        return X == S;
    },
    'b9t': function(X, S) {
        return X != S;
    },
    'o6f': function(X, S) {
        return X * S;
    },
    'K5b': function(X, S) {
        return X != S;
    },
    'O1': function(X) {
        cc.LABELATLAS_DEBUG_DRAW = X;
    },
    'o0G': function(X, S) {
        return X >= S;
    },
    'u8B': function(X, S) {
        return X !== S;
    },
    'U1G': function(X, S) {
        return X == S;
    },
    'k8b': function(X, S) {
        return X == S;
    },
    'k9P': "CC_PMatrix",
    't6h': function(X, S) {
        return X | S;
    },
    'D9t': function(X, S) {
        return X - S;
    },
    'R9G': function(X, S) {
        return X !== S;
    },
    'F2N': function(X, S) {
        return X / S;
    },
    'd2d': function(X, S) {
        return X != S;
    },
    'E3N': function(X, S) {
        return X * S;
    },
    'q2h': function(X, S) {
        return X * S;
    },
    'b6b': function(X, S) {
        return X / S;
    },
    'P7S': 166,
    'z18': function(X, S) {
        return X / S;
    },
    'X4p': function(X, S) {
        return X - S;
    },
    'l91': function(X, S) {
        return X * S;
    },
    'W2b': function(X, S) {
        return X / S;
    },
    'u6d': function(X, S) {
        return X < S;
    },
    'S2b': function(X, S) {
        return X === S;
    },
    'N1h': function(X, S) {
        return X === S;
    },
    'V0L': function(X, S, P) {
        return X * S * P;
    },
    'y1K': "lineWidth",
    'H0D': function(X, S) {
        return X == S;
    },
    'q1s': function(X, S) {
        return X < S;
    },
    'G5B': function(X, S) {
        return X / S;
    },
    'C98': function(X, S) {
        return X / S;
    },
    'B0i': "false",
    'E2P': "0px",
    'W7L': function(X, S) {
        return X * S;
    },
    'k5T': function(X, S) {
        return X > S;
    },
    'd8m': function(X, S) {
        return X == S;
    },
    'G0L': function(X, S, P) {
        return X * S * P;
    },
    'D3s': function(X, S) {
        return X * S;
    },
    'k9h': function(X, S) {
        return X != S;
    },
    'm5t': function(X, S) {
        return X !== S;
    },
    'G1i': "px",
    'F0m': function(X, S) {
        return X * S;
    },
    'C9i': "boundingHeight",
    'M6q': function(X, S) {
        return X * S;
    },
    't0N': function(X, S) {
        return X >= S;
    },
    'd6E': function(X, S) {
        return X | S;
    },
    'Z8a': function(X, S) {
        return X / S;
    },
    'C4K': "PVRTC4",
    'N2p': function(X, S) {
        return X - S;
    },
    'O1L': function(X, S) {
        return X > S;
    },
    'b78': function(X, S) {
        return X == S;
    },
    'H6P': null,
    'I5P': 32768,
    'b01': function(X, S) {
        return X < S;
    },
    'J8f': function(X, S) {
        return X / S;
    },
    'T0m': function(X, S) {
        return X >= S;
    },
    'r2h': function(X, S) {
        return X == S;
    },
    's2w': function(X, S) {
        return X * S;
    },
    'B0w': function(X, S) {
        return X * S;
    },
    'p2L': function(X, S) {
        return X * S;
    },
    'h3j': function(X, S) {
        return X > S;
    },
    'e3': function(X) {
        w6b0K[q0K]._c = X.Texture2D;
    },
    'm7m': function(X, S) {
        return X !== S;
    },
    'J3H': "placeHolder",
    'l1s': function(X, S) {
        return X != S;
    },
    'U1': function(X) {
        cc.PI = X.PI;
    },
    'b7t': function(X, S) {
        return X == S;
    },
    's1b': function(X, S) {
        return X % S;
    },
    'M7T': function(X, S) {
        return X * S;
    },
    'H8w': function(X, S) {
        return X * S;
    },
    'R9y': function(X) {
        cc.UNIFORM_MVMATRIX = X;
    },
    'u5v': function(X, S) {
        return X - S;
    },
    'S33': function(X, S) {
        return X | S;
    },
    'K86': function(X, S) {
        return X != S;
    },
    'S2': function(X) {
        cc.kmEpsilon = X;
    },
    'O5': function(X) {
        _B[_c.PIXEL_FORMAT_I8] = X;
    },
    'Q5l': function(X, S) {
        return X < S;
    },
    't7f': function(X, S) {
        return X >= S;
    },
    'c96': function(X, S) {
        return X == S;
    },
    'T6B': function(X, S) {
        return X < S;
    },
    'q7H': 4,
    's9i': 18,
    'x3': function() {
        cc.Texture2D = cc._renderType === cc._RENDER_TYPE_WEBGL ? cc.Texture2DWebGL : cc.Texture2DCanvas;
    },
    'R8s': function(X, S) {
        return X < S;
    },
    'h1d': function(X, S) {
        return X != S;
    },
    'H3D': function(X, S, P) {
        return X * S * P;
    },
    'Y5a': function(X, S) {
        return X / S;
    },
    'n3f': function(X, S) {
        return X !== S;
    },
    'K2d': function(X, S) {
        return X < S;
    },
    'U5z': function(X, S, P, O) {
        return X * S * P * O;
    },
    'j1j': function(X, S) {
        return X - S;
    },
    'i82': function(X, S) {
        return X !== S;
    },
    'R2': function(X) {
        cc.KM_GL_MODELVIEW = X;
    },
    'N71': function(X, S) {
        return X * S;
    },
    'o1l': function(X, S) {
        return X - S;
    },
    'G0t': function(X, S) {
        return X >= S;
    },
    'q9y': function(X) {
        cc.SHADER_POSITION_TEXTURECOLOR = X;
    },
    'N6p': function(X, S) {
        return X < S;
    },
    'k33': function(X, S) {
        return X | S;
    },
    'i9A': function(X, S) {
        return X == S;
    },
    'B3A': function(X, S) {
        return X * S;
    },
    'W82': function(X, S) {
        return X === S;
    },
    'Z68': function(X, S) {
        return X | S;
    },
    'i0t': function(X, S) {
        return X - S;
    },
    'Y35': function(X, S) {
        return X < S;
    },
    'A1z': function(X, S) {
        return X / S;
    },
    'z8q': function(X, S) {
        return X * S;
    },
    'x7w': function(X, S) {
        return X | S;
    },
    'O4h': function(X, S) {
        return X > S;
    },
    'R46': function(X, S) {
        return X < S;
    },
    'Z3m': function(X, S) {
        return X * S;
    },
    'Z4z': function(X, S) {
        return X < S;
    },
    'V7w': function(X, S) {
        return X < S;
    },
    'U0G': function(X, S) {
        return X > S;
    },
    'k3G': function(X, S) {
        return X >= S;
    },
    'K8m': function(X, S) {
        return X == S;
    },
    'L82': function(X, S) {
        return X | S;
    },
    's2y': function(X) {
        Global.Blood = X;
    },
    'n23': function(X, S) {
        return X < S;
    },
    'V62': function(X, S) {
        return X instanceof S;
    },
    'N3d': function(X, S) {
        return X == S;
    },
    'H1L': function(X, S) {
        return X < S;
    },
    'W': function(X) {
        _p = X;
    },
    'M4s': function(X, S) {
        return X * S;
    },
    'p9L': function(X, S) {
        return X * S;
    },
    'R3v': function(X, S) {
        return X <= S;
    },
    'y6y': function() {
        lg = lg || {};
    },
    's7h': function(X, S) {
        return X * S;
    },
    'C3a': function(X, S) {
        return X * S;
    },
    'U3E': function(X, S) {
        return X < S;
    },
    'M7': function(X) {
        cc.Event.ACCELERATION = X;
    },
    'U0u': function(X, S, P) {
        return X / S * P;
    },
    'U4t': function(X, S) {
        return X * S;
    },
    'D7w': function(X, S) {
        return X * S;
    },
    'H8G': function(X, S) {
        return X == S;
    },
    'y9b': function(X, S) {
        return X * S;
    },
    'I4S': 150,
    'S5L': function(X, S) {
        return X - S;
    },
    'i5v': function(X, S) {
        return X <= S;
    },
    'h2s': function(X, S) {
        return X <= S;
    },
    'n1t': function(X, S) {
        return X < S;
    },
    'a1t': function(X, S) {
        return X - S;
    },
    's9G': function(X, S) {
        return X < S;
    },
    'd6y': function(X) {
        cc.TMX_PROPERTY_LAYER = X;
    },
    'c46': function(X, S) {
        return X == S;
    },
    'F8f': function(X, S, P) {
        return X / S * P;
    },
    'C38': function(X, S) {
        return X < S;
    },
    'B0a': function(X, S) {
        return X > S;
    },
    'p3T': function(X, S) {
        return X * S;
    },
    'z46': function(X, S) {
        return X == S;
    },
    'M2L': function(X, S) {
        return X * S;
    },
    'm2y': function() {
        lg = lg || {};
    },
    'w2p': function(X, S) {
        return X < S;
    },
    'o61': function(X, S) {
        return X * S;
    },
    'e2G': function(X, S) {
        return X * S;
    },
    'X2i': "vector",
    'h0s': function(X, S) {
        return X * S;
    },
    'U1D': function(X, S) {
        return X == S;
    },
    'B8T': function(X, S) {
        return X / S;
    },
    'U4E': function(X, S) {
        return X < S;
    },
    'c58': function(X, S) {
        return X < S;
    },
    'k1v': function(X, S) {
        return X != S;
    },
    'k2O': function(X, S) {
        return X === S;
    },
    'r4L': function(X, S, P) {
        return X * S * P;
    },
    'a2b': function(X, S) {
        return X / S;
    },
    'A51': function(X, S) {
        return X === S;
    },
    'J3G': function(X, S) {
        return X < S;
    },
    'G9d': function(X, S) {
        return X == S;
    },
    'M8s': function(X, S) {
        return X != S;
    },
    'j1B': function(X, S) {
        return X != S;
    },
    'k3O': function(X, S) {
        return X != S;
    },
    'r7m': function(X, S) {
        return X > S;
    },
    'Y0G': function(X, S) {
        return X > S;
    },
    'u88': function(X, S) {
        return X / S;
    },
    'V96': function(X, S) {
        return X - S;
    },
    't4M': function(X, S) {
        return X === S;
    },
    'd5f': function(X, S) {
        return X == S;
    },
    'e3P': "fontSize",
    'C4a': function(X, S) {
        return X != S;
    },
    'N5A': function(X, S) {
        return X != S;
    },
    'z5N': function(X, S) {
        return X !== S;
    },
    'i9K': "fillStyle",
    'f6H': "layerWidth",
    'Z9h': function(X, S) {
        return X === S;
    },
    'H9K': "CC_Time",
    'b1H': function(X, S) {
        return X == S;
    },
    'w5h': function(X, S, P) {
        return X * S / P;
    },
    'J5E': function(X, S) {
        return X * S;
    },
    'k6N': function(X, S) {
        return X < S;
    },
    'H9d': function(X, S) {
        return X * S;
    },
    'F1l': function(X, S) {
        return X > S;
    },
    'I0t': function(X, S) {
        return X - S;
    },
    'P6y': function(X) {
        cc.TMX_PROPERTY_OBJECT = X;
    },
    'X0': function(X) {
        cc.EventMouse.BUTTON_RIGHT = X;
    },
    'K7f': function(X, S) {
        return X < S;
    },
    'i2i': "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}",
    'U3L': function(X, S) {
        return X * S;
    },
    'q4': function(X) {
        w6b0K[q0K]._p = X.color;
    },
    'C9b': function(X, S) {
        return X * S;
    },
    'f0N': function(X, S) {
        return X * S;
    },
    'b0S': "bottomLeft",
    'v1t': function(X, S) {
        return X / S;
    },
    'M0b': function(X, S) {
        return X * S;
    },
    'j6t': function(X, S) {
        return X != S;
    },
    'Y9G': function(X, S) {
        return X instanceof S;
    },
    'I1M': function(X, S) {
        return X != S;
    },
    'j0b': function(X, S) {
        return X < S;
    },
    'c7M': function(X, S, P) {
        return X * S * P;
    },
    's1j': function(X, S) {
        return X | S;
    },
    'k66': function(X, S, P) {
        return X / S * P;
    },
    'L9A': function(X, S) {
        return X == S;
    },
    'T1l': function(X, S) {
        return X < S;
    },
    'G15': function(X, S) {
        return X - S;
    },
    'a5z': function(X, S) {
        return X % S;
    },
    'W21': function(X, S) {
        return X * S;
    },
    'm9i': 31,
    's7u': function(X, S, P) {
        return X / S * P;
    },
    'C6L': function(X, S) {
        return X == S;
    },
    'l7z': function(X, S) {
        return X == S;
    },
    'p8u': function(X, S) {
        return X - S;
    },
    'd6P': "shadowOpacity",
    'f3O': function(X, S) {
        return X != S;
    },
    'K1y': function(X) {
        cc.SHADER_POSITION_TEXTUREA8COLOR = X;
    },
    'O0P': "GREEN",
    'M5y': function(X) {
        cc.TGA_ERROR_READING_FILE = X;
    },
    'm48': function(X, S) {
        return X | S;
    },
    'w9D': function(X, S) {
        return X >= S;
    },
    'z61': function(X, S) {
        return X * S;
    },
    'j1P': "mapWidth",
    'x1a': function(X, S) {
        return X === S;
    },
    'z1M': function(X, S, P) {
        return X * S * P;
    },
    'O8H': function(X, S) {
        return X == S;
    },
    'b45': function(X, S) {
        return X - S;
    },
    'v6s': function(X, S) {
        return X * S;
    },
    'm2a': function(X, S) {
        return X / S;
    },
    'm0': function(X) {
        cc.EventListener.CUSTOM = X;
    },
    'I8H': function(X, S) {
        return X == S;
    },
    'N1d': function(X, S) {
        return X !== S;
    },
    'V7j': function(X, S) {
        return X > S;
    },
    'X1S': "ShaderPositionLengthTextureColor",
    'w0p': function(X, S) {
        return X - S;
    },
    'w6M': function(X, S) {
        return X != S;
    },
    'w6w': function(X, S) {
        return X * S;
    },
    'Q7z': function(X, S) {
        return X !== S;
    },
    'u6z': function(X, S) {
        return X / S;
    },
    'D96': function(X, S) {
        return X != S;
    },
    'w42': function(X, S) {
        return X * S;
    },
    'Y11': function(X, S) {
        return X / S;
    },
    'l9l': function(X, S) {
        return X | S;
    },
    'I8j': function(X, S) {
        return X < S;
    },
    'V3M': function(X, S, P) {
        return X - S - P;
    },
    'I8m': function(X, S, P) {
        return X * S * P;
    },
    'n9q': function(X, S) {
        return X * S;
    },
    'u2': function(X) {
        cc.SHADER_POSITION_UCOLOR_VERT = X;
    },
    'F4p': function(X, S) {
        return X - S;
    },
    'j6B': function(X, S) {
        return X * S;
    },
    'x3z': function(X, S) {
        return X < S;
    },
    'y4d': function(X, S) {
        return X * S;
    },
    'F83': function(X, S, P, O) {
        return X * S * P * O;
    },
    'G5z': function(X, S) {
        return X * S;
    },
    'p96': function(X, S) {
        return X - S;
    },
    'B5v': function(X, S) {
        return X == S;
    },
    'D3M': function(X, S) {
        return X * S;
    },
    'T0M': function(X, S) {
        return X * S;
    },
    'a9d': function(X, S) {
        return X / S;
    },
    'b8u': function(X, S) {
        return X - S;
    },
    'H82': function(X, S) {
        return X - S;
    },
    'Q7G': function(X, S) {
        return X < S;
    },
    'w5A': function(X, S) {
        return X * S;
    },
    'z0b': function(X, S) {
        return X * S;
    },
    'H6T': function(X, S, P) {
        return X * S * P;
    },
    'r2d': function(X, S) {
        return X == S;
    },
    'l3i': 320,
    'F6f': function(X, S) {
        return X * S;
    },
    'a6z': function(X, S) {
        return X < S;
    },
    'H0P': "__cc_touch_one_by_one",
    'M72': function(X, S) {
        return X == S;
    },
    'u4q': function(X, S) {
        return X * S;
    },
    'O88': function(X, S) {
        return X / S;
    },
    'l5O': function(X, S) {
        return X == S;
    },
    'E2': function(X) {
        cc.KM_GL_TEXTURE = X;
    },
    'N5D': function(X, S, P) {
        return X * S * P;
    },
    'k5v': function(X, S) {
        return X < S;
    },
    'M4t': function(X, S) {
        return X / S;
    },
    'd0B': function(X, S) {
        return X & S;
    },
    'p8A': function(X, S) {
        return X === S;
    },
    'F0h': function(X, S) {
        return X == S;
    },
    'x6O': function(X, S) {
        return X == S;
    },
    'r0p': function(X, S) {
        return X - S;
    },
    'K2a': function(X, S) {
        return X * S;
    },
    'D1u': function(X, S) {
        return X < S;
    },
    'f7B': function(X, S) {
        return X & S;
    },
    'L8T': function(X, S) {
        return X / S;
    },
    'd0N': function(X, S) {
        return X >= S;
    },
    'L21': function(X, S) {
        return X | S;
    },
    'x7T': function(X, S) {
        return X * S;
    },
    'z3s': function(X, S) {
        return X * S;
    },
    'l8L': function(X, S) {
        return X / S;
    },
    'm6T': function(X, S) {
        return X * S;
    },
    'e5A': function(X, S) {
        return X instanceof S;
    },
    'N6D': function(X, S) {
        return X * S;
    },
    'i3A': function(X, S) {
        return X == S;
    },
    'E3S': 139,
    'z6': function(X) {
        cc.Director.EVENT_AFTER_UPDATE = X;
    },
    'b7d': function(X, S) {
        return X === S;
    },
    'b2w': function(X, S) {
        return X === S;
    },
    'N5q': function(X, S) {
        return X * S;
    },
    'z9L': function(X, S) {
        return X * S;
    },
    'U3T': function(X, S) {
        return X * S;
    },
    'r2p': function(X, S) {
        return X === S;
    },
    'A5O': function(X, S) {
        return X == S;
    },
    'c73': function(X, S) {
        return X - S;
    },
    'w7m': function(X, S) {
        return X - S;
    },
    'u0j': function(X, S) {
        return X < S;
    },
    'N7': function(X) {
        cc.Touch.ALL_AT_ONCE = X;
    },
    'h6w': function(X, S) {
        return X * S;
    },
    'S32': function(X, S) {
        return X == S;
    },
    'X8u': function(X, S) {
        return X - S;
    },
    'd8t': function(X, S) {
        return X < S;
    },
    'q93': function(X, S) {
        return X == S;
    },
    'q2G': function(X, S) {
        return X == S;
    },
    'e3d': function(X, S) {
        return X === S;
    },
    'X0j': function(X, S, P) {
        return X - S + P;
    },
    'e6M': function(X, S) {
        return X != S;
    },
    'l1q': function(X, S) {
        return X * S;
    },
    'l2h': function(X, S) {
        return X < S;
    },
    'G0': function(X) {
        cc._EventListenerKeyboard.LISTENER_ID = X;
    },
    'F3B': function(X, S) {
        return X == S;
    },
    'z6q': function(X, S) {
        return X * S;
    },
    'q6L': function(X, S) {
        return X > S;
    },
    'e9T': function(X, S) {
        return X > S;
    },
    'q9a': function(X, S) {
        return X == S;
    },
    'z45': function(X, S) {
        return X * S;
    },
    'A8v': function(X, S) {
        return X < S;
    },
    'R6m': function(X, S, P) {
        return X * S / P;
    },
    'd9b': function(X, S) {
        return X / S;
    },
    'a4A': function(X, S) {
        return X * S;
    },
    'W0T': function(X, S) {
        return X * S;
    },
    'E4': function(X) {
        cc.TEXT_ALIGNMENT_LEFT = X;
    },
    's4E': function(X, S) {
        return X === S;
    },
    'n2P': "enabled",
    'E2p': function(X, S) {
        return X < S;
    },
    'g4T': function(X, S) {
        return X * S;
    },
    'Y5N': function(X, S) {
        return X | S;
    },
    'L0S': "Invalid matrix mode specified",
    'F6b': function(X, S) {
        return X / S;
    },
    'n9h': function(X, S) {
        return X === S;
    },
    'b46': function(X, S) {
        return X == S;
    },
    'x7a': function(X, S) {
        return X * S;
    },
    'q9E': function(X, S) {
        return X - S;
    },
    'w6H': "__cc_keyboard",
    'i6j': function(X, S) {
        return X <= S;
    },
    'y42': function(X, S) {
        return X < S;
    },
    'f9A': function(X, S) {
        return X instanceof S;
    },
    'I0a': function(X, S) {
        return X * S;
    },
    'G4A': function(X, S) {
        return X != S;
    },
    'O3G': function(X, S) {
        return X > S;
    },
    't1z': function(X, S) {
        return X * S;
    },
    'l4D': function(X, S) {
        return X * S;
    },
    'D2y': function(X) {
        lg.assetsManager = X;
    },
    'B9z': function(X, S) {
        return X * S;
    },
    'X6b': function(X, S) {
        return X == S;
    },
    'E5l': function(X, S) {
        return X >= S;
    },
    'X1u': function(X, S) {
        return X < S;
    },
    'N7u': function(X, S) {
        return X == S;
    },
    'e1y': function(X) {
        cc.UNIFORM_TIME_S = X;
    },
    's2v': function(X, S) {
        return X - S;
    },
    'z8A': function(X, S) {
        return X != S;
    },
    'I3i': "target",
    'o3p': function(X, S) {
        return X === S;
    },
    'f4h': function(X, S) {
        return X < S;
    },
    'b1b': function(X, S) {
        return X == S;
    },
    'l0E': function(X, S) {
        return X == S;
    },
    'Z7h': function(X, S, P) {
        return X * S * P;
    },
    'd2z': function(X, S) {
        return X * S;
    },
    'm1y': function(X) {
        cc.ATTRIBUTE_NAME_COLOR = X;
    },
    'n1K': "selected",
    'y8v': function(X, S) {
        return X <= S;
    },
    'z7l': function(X, S) {
        return X - S;
    },
    'E0E': function(X, S) {
        return X != S;
    },
    'i23': function(X, S) {
        return X / S;
    },
    'H8E': function(X, S) {
        return X / S;
    },
    'N7O': function(X, S) {
        return X == S;
    },
    'X0b': function(X, S) {
        return X >= S;
    },
    'U7l': function(X, S) {
        return X - S;
    },
    'h8p': function(X, S) {
        return X - S;
    },
    'e9l': function(X, S) {
        return X > S;
    },
    'k3S': 127,
    'q8t': function(X, S) {
        return X < S;
    },
    'u1v': function(X, S) {
        return X == S;
    },
    'U0h': function(X, S) {
        return X != S;
    },
    'V95': function(X, S) {
        return X * S;
    },
    'S7N': function(X, S) {
        return X * S;
    },
    'x3v': function(X, S) {
        return X / S;
    },
    'I1P': "xml",
    'a75': function(X, S) {
        return X == S;
    },
    'y5q': function(X, S) {
        return X * S;
    },
    'k22': function(X, S) {
        return X != S;
    },
    'g1h': function(X, S) {
        return X !== S;
    },
    'J0t': function(X, S) {
        return X >= S;
    },
    't38': function(X, S) {
        return X >> S;
    },
    'X8O': function(X, S) {
        return X == S;
    },
    'U5u': function(X, S, P) {
        return X * S * P;
    },
    'u5B': function(X, S, P) {
        return X * S / P;
    },
    'c9p': function(X, S) {
        return X <= S;
    },
    'z0f': function(X, S) {
        return X < S;
    },
    'X72': function(X, S) {
        return X !== S;
    },
    'R7T': function(X, S) {
        return X * S;
    },
    'J16': function(X, S) {
        return X * S;
    },
    'O6G': function(X, S) {
        return X * S;
    },
    'U3y': function() {
        cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE = -1;
    },
    'j9L': function(X, S) {
        return X * S;
    },
    'P8S': "YELLOW",
    'T5N': function(X, S) {
        return X == S;
    },
    'A8m': function(X, S) {
        return X > S;
    },
    'R4p': function(X, S) {
        return X - S;
    },
    'A6l': function(X, S) {
        return X - S;
    },
    'V7H': "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}",
    'c6z': function(X, S, P, O) {
        return X * S * P * O;
    },
    'i5B': function(X, S) {
        return X / S;
    },
    'a8H': function(X, S) {
        return X - S;
    },
    'Q7u': function(X, S) {
        return X * S;
    },
    'g8M': function(X, S) {
        return X !== S;
    },
    'l1h': function(X, S) {
        return X != S;
    },
    'q9': function(X) {
        cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = X;
    },
    'S9S': "normalImage",
    'G9A': function(X, S) {
        return X != S;
    },
    'A42': function(X, S) {
        return X < S;
    },
    'k6j': function(X, S) {
        return X < S;
    },
    'H4h': function(X, S) {
        return X > S;
    },
    'x9p': function(X, S) {
        return X << S;
    },
    'r1h': function(X, S) {
        return X === S;
    },
    'Z3O': function(X, S) {
        return X === S;
    },
    'f4u': function(X, S) {
        return X * S;
    },
    'S15': function(X, S) {
        return X * S;
    },
    'J7S': 400,
    'r9S': "Bomb0 Bomb1 Bomb2 Bomb3 Bomb4 Bomb5 Bomb6 Bomb7 Bomb8 Bomb9 Bomb10 Bomb11 Bomb12 Bomb13 Bomb14 Bomb15 Bomb16 Bomb17",
    'c18': function(X, S) {
        return X / S;
    },
    'c8q': function(X, S) {
        return X * S;
    },
    'Y6t': function(X, S) {
        return X <= S;
    },
    'O8y': function(X) {
        cc.ClippingNode._layer = X;
    },
    'S2i': "ms",
    'p7t': function(X, S) {
        return X < S;
    },
    'H1S': "offsetY",
    'V2f': function(X, S) {
        return X != S;
    },
    'Y0z': function(X, S) {
        return X <= S;
    },
    'x7d': function(X, S) {
        return X / S;
    },
    'D7T': function(X, S) {
        return X * S;
    },
    's6B': function(X, S) {
        return X < S;
    },
    'd4j': function(X, S) {
        return X % S;
    },
    'o1H': function(X, S) {
        return X == S;
    },
    'n1': function(X) {
        cc.$.pfx = X;
    },
    'z6f': function(X, S) {
        return X != S;
    },
    's8O': function(X, S) {
        return X < S;
    },
    'F1': function(X) {
        cc.UINT_MAX = X;
    },
    'p3s': function(X, S) {
        return X === S;
    },
    'B8j': function(X, S) {
        return X & S;
    },
    'q5m': function(X, S) {
        return X == S;
    },
    'Z4h': function(X, S) {
        return X != S;
    },
    'C7m': function(X, S) {
        return X | S;
    },
    'p2v': function(X, S) {
        return X < S;
    },
    'I3w': function(X, S) {
        return X | S;
    },
    'A3d': function(X, S) {
        return X === S;
    },
    'F2': function(X) {
        cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = X;
    },
    'j3E': function(X, S) {
        return X <= S;
    },
    'a6': function(X) {
        cc.defaultFPS = X;
    },
    'D7M': function(X, S) {
        return X < S;
    },
    'U8T': function(X, S, P) {
        return X * S * P;
    },
    't6G': function(X, S, P) {
        return X / S * P;
    },
    'N5h': function(X, S, P) {
        return X * S / P;
    },
    'f6d': function(X, S) {
        return X < S;
    },
    't4i': 51,
    'X2L': function(X, S) {
        return X * S;
    },
    'I06': function(X, S) {
        return X - S;
    },
    'v2E': function(X, S) {
        return X < S;
    },
    'c7': function(X) {
        cc.ResolutionPolicy.EXACT_FIT = X;
    },
    'T3B': function(X, S) {
        return X < S;
    },
    'u6P': "string",
    'i7p': function(X, S) {
        return X >= S;
    },
    'P26': function(X, S) {
        return X == S;
    },
    'u2S': 35,
    'N1f': function(X, S) {
        return X * S;
    },
    'l05': function(X, S) {
        return X & S;
    },
    'D2f': function(X, S) {
        return X != S;
    },
    'r2H': "tmx",
    'O8N': function(X, S) {
        return X instanceof S;
    },
    'y85': function(X, S) {
        return X == S;
    },
    't4D': function(X, S) {
        return X / S;
    },
    'U4s': function(X, S) {
        return X * S;
    },
    'P3O': function(X, S) {
        return X == S;
    },
    'f88': function(X, S) {
        return X - S;
    },
    'V0G': function(X, S) {
        return X >= S;
    },
    'd4K': 274,
    'N7m': function(X, S) {
        return X !== S;
    },
    'F1N': function(X, S) {
        return X / S;
    },
    'r2P': 635,
    'L0D': function(X, S) {
        return X == S;
    },
    'o7a': function(X, S) {
        return X < S;
    },
    'N7b': function(X, S) {
        return X * S;
    },
    'h6l': function(X, S) {
        return X === S;
    },
    'L9d': function(X, S) {
        return X - S;
    },
    'I1t': function(X, S) {
        return X - S;
    },
    'z2i': "totalQuads",
    'A5m': function(X, S) {
        return X * S;
    },
    'f2q': function(X, S) {
        return X * S;
    },
    'F7i': "CC_CosTime",
    'n5': function(X) {
        cc.Texture2D.defaultPixelFormat = X.PIXEL_FORMAT_DEFAULT;
    },
    'b7l': function(X, S) {
        return X * S;
    },
    'Q3D': function(X, S) {
        return X != S;
    },
    'V6q': function(X, S) {
        return X * S;
    },
    'x8': function(X) {
        cc.ONE_MINUS_DST_COLOR = X;
    },
    'z7T': function(X, S) {
        return X * S;
    },
    'u7s': function(X, S) {
        return X - S;
    },
    'n1L': function(X, S) {
        return X / S;
    },
    'y0z': function(X, S) {
        return X != S;
    },
    'W5v': function(X, S) {
        return X == S;
    },
    'K4f': function(X, S, P) {
        return X / S * P;
    },
    'Z6d': function(X, S) {
        return X < S;
    },
    'h5M': function(X, S) {
        return X - S;
    },
    'a9A': function(X, S) {
        return X == S;
    },
    'R2y': function() {
        lg = lg || {};
    },
    'U5': function(X) {
        cc.DIRECTOR_PROJECTION_DEFAULT = X.DIRECTOR_PROJECTION_3D;
    },
    't85': function(X, S) {
        return X * S;
    },
    'Q86': function(X, S) {
        return X - S;
    },
    'M3i': "Jacob__Codec__Base64",
    'q7G': function(X, S) {
        return X < S;
    },
    'P68': function(X, S) {
        return X << S;
    },
    'd8v': function(X, S) {
        return X >= S;
    },
    'Z5B': function(X, S) {
        return X % S;
    },
    'n7p': function(X, S) {
        return X - S;
    },
    'O6d': function(X, S) {
        return X == S;
    },
    'o2f': function(X, S) {
        return X !== S;
    },
    'h1P': "gameCanvas",
    'E1f': function(X, S) {
        return X === S;
    },
    'e2a': function(X, S) {
        return X * S;
    },
    'E2M': function(X, S) {
        return X < S;
    },
    'e6v': function(X, S) {
        return X == S;
    },
    'n5h': function(X, S) {
        return X / S;
    },
    'x1D': function(X, S) {
        return X == S;
    },
    'h7i': 90,
    'i4l': function(X, S) {
        return X < S;
    },
    'Z1p': function(X, S) {
        return X === S;
    },
    'P6a': function(X, S) {
        return X * S;
    },
    'q4j': function(X, S) {
        return X < S;
    },
    'D0M': function(X, S, P) {
        return X * S * P;
    },
    'h2h': function(X, S) {
        return X * S;
    },
    'd8L': function(X, S) {
        return X > S;
    },
    'd6T': function(X, S) {
        return X / S;
    },
    'u33': function(X, S) {
        return X != S;
    },
    'N8p': function(X, S) {
        return X >= S;
    },
    'u5s': function(X, S) {
        return X - S;
    },
    'u12': function(X, S) {
        return X / S;
    },
    'k1': function(X) {
        cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = X;
    },
    'I6S': "quads",
    'l2d': function(X, S) {
        return X - S;
    },
    'n2j': function(X, S) {
        return X > S;
    },
    'm2d': function(X, S) {
        return X < S;
    },
    'n6a': function(X, S) {
        return X * S;
    },
    'c81': function(X, S) {
        return X !== S;
    },
    'n2q': function(X, S) {
        return X * S;
    },
    'Q1h': function(X, S) {
        return X === S;
    },
    'W0w': function(X, S) {
        return X == S;
    },
    'a1G': function(X, S) {
        return X <= S;
    },
    'H2z': function(X, S) {
        return X > S;
    },
    't9i': "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n",
    'j1H': function(X, S) {
        return X / S;
    },
    'r5t': function(X, S) {
        return X <= S;
    },
    'm85': function(X, S) {
        return X < S;
    },
    'x11': function(X, S) {
        return X / S;
    },
    'k4z': function(X, S) {
        return X * S;
    },
    'c78': function(X, S) {
        return X / S;
    },
    'H0a': function(X, S) {
        return X - S;
    },
    'A9w': function(X, S) {
        return X | S;
    },
    'd4w': function(X, S) {
        return X | S;
    },
    'c2t': function(X, S) {
        return X < S;
    },
    't93': function(X, S) {
        return X | S;
    },
    'O8w': function(X, S) {
        return X | S;
    },
    'k9f': function(X, S) {
        return X / S;
    },
    'Y9v': function(X, S) {
        return X < S;
    },
    'i4O': function(X, S) {
        return X > S;
    },
    'W06': function(X, S) {
        return X < S;
    },
    'D6f': function(X, S) {
        return X / S;
    },
    'I5L': function(X, S) {
        return X > S;
    },
    'O8G': function(X, S) {
        return X < S;
    },
    'O5z': function(X, S) {
        return X - S;
    },
    'T7a': function(X, S) {
        return X < S;
    },
    'd1h': function(X, S) {
        return X !== S;
    },
    'F95': function(X, S) {
        return X === S;
    },
    'y9H': function(X, S) {
        return X - S;
    },
    'K6D': function(X, S) {
        return X / S;
    },
    'r0E': function(X, S) {
        return X == S;
    },
    'X1M': function(X, S) {
        return X * S;
    },
    'E71': function(X, S) {
        return X * S;
    },
    'J4E': function(X, S, P) {
        return X * S / P;
    },
    'f8H': function(X, S) {
        return X == S;
    },
    'v32': function(X, S) {
        return X instanceof S;
    },
    'v3O': function(X, S) {
        return X !== S;
    },
    'J8a': function(X, S) {
        return X === S;
    },
    'q5l': function(X, S) {
        return X >= S;
    },
    'T6b': function(X, S) {
        return X / S;
    },
    'G26': function(X, S) {
        return X == S;
    },
    'x95': function(X, S) {
        return X == S;
    },
    'X4f': function(X, S, P) {
        return X / S * P;
    },
    'j7w': function(X, S) {
        return X | S;
    },
    'Y2m': function(X, S) {
        return X < S;
    },
    'l9i': 12,
    'u8D': function(X, S) {
        return X / S;
    },
    'C0v': function(X, S) {
        return X < S;
    },
    'f0l': function(X, S) {
        return X <= S;
    },
    'd3D': function(X, S) {
        return X == S;
    },
    'f1S': 0.7,
    'e9D': function(X, S) {
        return X <= S;
    },
    'F3h': function(X, S) {
        return X != S;
    },
    'v1y': function(X) {
        cc.VERTEX_ATTRIB_FLAG_COLOR = X;
    },
    's58': function(X, S) {
        return X == S;
    },
    'D1a': function(X, S) {
        return X != S;
    },
    'r9H': function(X, S) {
        return X - S;
    },
    'c6G': function(X, S, P) {
        return X / S * P;
    },
    'f2j': function(X, S) {
        return X >= S;
    },
    'B0D': function(X, S) {
        return X === S;
    },
    'x1E': function(X, S) {
        return X == S;
    },
    'n5p': function(X, S) {
        return X >= S;
    },
    'l1z': function(X, S) {
        return X / S;
    },
    't2h': function(X, S) {
        return X > S;
    },
    'w98': function(X, S) {
        return X / S;
    },
    'Y62': function(X, S) {
        return X < S;
    },
    'e65': function(X, S) {
        return X == S;
    },
    'T9L': function(X, S) {
        return X * S;
    },
    'V9P': "startRadiusVar",
    'K1z': function(X, S) {
        return X * S;
    },
    'u2m': function(X, S, P, O) {
        return X * S * P * O;
    },
    'g4K': 270,
    'b9S': "Menu",
    'd4B': function(X, S) {
        return X != S;
    },
    'P1G': function(X, S) {
        return X - S;
    },
    'a7N': function(X, S) {
        return X * S;
    },
    'E4T': function(X, S) {
        return X - S;
    },
    'v2': function() {
        cc.initialized = !1;
    },
    'r6y': function() {
        cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
    },
    'F0L': function(X, S) {
        return X * S;
    },
    'U0P': "scaleY",
    'C53': function(X, S) {
        return X * S;
    },
    'L4d': function(X, S) {
        return X * S;
    },
    'v5h': function(X, S) {
        return X / S;
    },
    'e1f': function(X, S) {
        return X | S;
    },
    'f5z': function(X, S) {
        return X * S;
    },
    'J5T': function(X, S) {
        return X / S;
    },
    'J4K': "totalParticles",
    'W8b': function(X, S) {
        return X < S;
    },
    'E8p': function(X, S) {
        return X - S;
    },
    'N9H': function(X, S) {
        return X / S;
    },
    'R0': function(X) {
        cc._EventListenerAcceleration.LISTENER_ID = X;
    },
    'x62': function(X, S) {
        return X < S;
    },
    'o45': function(X, S) {
        return X * S;
    },
    'i5L': function(X, S) {
        return X * S;
    },
    'V0z': function(X, S, P) {
        return X * S % P;
    },
    'p8y': function() {
        cc.ACTION_TAG_INVALID = -1;
    },
    'o8A': function(X, S) {
        return X === S;
    },
    'i1L': function(X, S) {
        return X > S;
    },
    'D6': function(X) {
        cc.Director.EVENT_PROJECTION_CHANGED = X;
    },
    'C4D': function(X, S) {
        return X > S;
    },
    'm38': function(X, S) {
        return X > S;
    },
    'Y92': function(X, S) {
        return X === S;
    },
    'B4h': function(X, S) {
        return X == S;
    },
    'N3y': function(X) {
        _p.Deflate = X.Deflate;
    },
    'r4a': function(X, S) {
        return X != S;
    },
    'u5D': function(X, S) {
        return X != S;
    },
    'R6O': function(X, S) {
        return X == S;
    },
    'g6y': function(X) {
        cc.TMX_LAYER_ATTRIB_ZLIB = X;
    },
    'L0t': function(X, S) {
        return X - S;
    },
    'Q36': function(X, S) {
        return X <= S;
    },
    'R2v': function(X, S) {
        return X - S;
    },
    'c7D': function(X, S) {
        return X * S;
    },
    'l71': function(X, S) {
        return X * S;
    },
    'C6l': function(X, S) {
        return X - S;
    },
    'F5a': function(X, S) {
        return X < S;
    },
    'W9q': function(X, S) {
        return X * S;
    },
    'G8j': function(X, S) {
        return X & S;
    },
    's9p': function(X, S) {
        return X < S;
    },
    'Y1y': function(X) {
        cc.UNIFORM_SAMPLER_S = X;
    },
    'V0': function(X) {
        cc._EventListenerTouchOneByOne.LISTENER_ID = X;
    },
    'w5': function(X) {
        _B[_c.PIXEL_FORMAT_RGB565] = X;
    },
    'd8M': function(X, S) {
        return X * S;
    },
    'i3b': function(X, S) {
        return X / S;
    },
    'G8b': function(X, S) {
        return X * S;
    },
    'm05': function(X, S) {
        return X < S;
    },
    'b6j': function(X, S) {
        return X & S;
    },
    'h3M': function(X, S, P) {
        return X - S - P;
    },
    'x2w': function(X, S) {
        return X / S;
    },
    'i5u': function(X, S) {
        return X < S;
    },
    'a9q': function(X, S) {
        return X * S;
    },
    'h2A': function(X, S) {
        return X < S;
    },
    'T8A': function(X, S) {
        return X < S;
    },
    'W5p': function(X, S) {
        return X >= S;
    },
    'c0': function(X) {
        cc.EventMouse.BUTTON_5 = X;
    },
    'W9s': function(X, S) {
        return X / S;
    },
    's6': function(X) {
        cc.LabelTTF.__labelHeightDiv.style.top = X;
    },
    'w52': function(X, S) {
        return X === S;
    },
    'N6f': function(X, S) {
        return X * S;
    },
    'r7u': function(X, S) {
        return X * S;
    },
    'X13': function(X, S) {
        return X * S;
    },
    'y1z': function(X, S) {
        return X / S;
    },
    'r1f': function(X, S) {
        return X / S;
    },
    'l6v': function(X, S) {
        return X < S;
    },
    'X8d': function(X, S) {
        return X == S;
    },
    'H3M': function(X, S) {
        return X == S;
    },
    'v15': function(X, S) {
        return X - S;
    },
    'S4q': function(X, S) {
        return X * S;
    },
    'U3': function(X) {
        _M[_c.PIXEL_FORMAT_RGB888] = X;
    },
    'l1A': function(X, S) {
        return X in S;
    },
    'f3m': function(X, S) {
        return X < S;
    },
    'S83': function(X, S, P) {
        return X * S * P;
    },
    'd4G': function(X, S) {
        return X < S;
    },
    'z0z': function(X, S) {
        return X / S;
    },
    'P15': function(X, S) {
        return X * S;
    },
    'b5y': function(X) {
        cc.TMX_ORIENTATION_ISO = X;
    },
    'o1w': function(X, S) {
        return X * S;
    },
    'O1G': function(X, S) {
        return X < S;
    },
    'N7P': "reversed",
    'Y4t': function(X, S) {
        return X < S;
    },
    'Q9S': "1.192092896e-07F",
    'T6q': function(X, S) {
        return X * S;
    },
    'z8d': function(X, S) {
        return X == S;
    },
    'v0T': function(X, S) {
        return X * S;
    },
    't5f': function(X, S) {
        return X == S;
    },
    'z6B': function(X, S) {
        return X * S;
    },
    's5N': function(X, S) {
        return X > S;
    },
    'H9A': function(X, S) {
        return X == S;
    },
    'P9q': function(X, S) {
        return X * S;
    },
    'W2T': function(X, S) {
        return X / S;
    },
    'Z41': function(X, S) {
        return X === S;
    },
    'Z5L': function(X, S) {
        return X != S;
    },
    'o5N': function(X, S) {
        return X * S;
    },
    'a6S': "lg.SimpleButton",
    'e4w': function(X, S) {
        return X - S;
    },
    'n3y': function(X) {
        _p.Inflate = X.Inflate;
    },
    'S16': function(X, S) {
        return X instanceof S;
    },
    'J7s': function(X, S) {
        return X * S;
    },
    'J3f': function(X, S) {
        return X !== S;
    },
    'F72': function(X, S) {
        return X == S;
    },
    'w2H': "ShaderPositionColor",
    'Q9M': function(X, S) {
        return X != S;
    },
    'q1O': function(X, S) {
        return X instanceof S;
    },
    'n1M': function(X, S) {
        return X / S;
    },
    'e6p': function(X, S) {
        return X < S;
    },
    'f9i': 14,
    'S4u': function(X, S) {
        return X <= S;
    },
    'Z6S': "RGB5A1",
    'q8y': function(X) {
        cc.Codec.GZip.LITERALS = X;
    },
    'M18': function(X, S) {
        return X / S;
    },
    'T4b': function(X, S) {
        return X * S;
    },
    'i15': function(X, S) {
        return X * S;
    },
    'G5H': "selectedIndex",
    'g3t': function(X, S) {
        return X >= S;
    },
    'S3f': function(X, S) {
        return X != S;
    },
    'i7L': function(X, S) {
        return X * S;
    },
    'V6O': function(X, S) {
        return X == S;
    },
    'S12': function(X, S) {
        return X / S;
    },
    'D0G': function(X, S) {
        return X * S;
    },
    'Y2t': function(X, S) {
        return X / S;
    },
    'o83': function(X, S, P, O) {
        return X * S * P * O;
    },
    'x9j': function(X, S) {
        return X - S;
    },
    'S8E': function(X, S) {
        return X / S;
    },
    'C36': function(X, S) {
        return X >= S;
    },
    'J0': function(X) {
        cc.EventListener.ACCELERATION = X;
    },
    'V9G': function(X, S) {
        return X < S;
    },
    'r9T': function(X, S) {
        return X < S;
    },
    'T83': function(X, S) {
        return X / S;
    },
    'K7h': function(X, S) {
        return X != S;
    },
    'o7l': function(X, S) {
        return X / S;
    },
    'A4a': function(X, S) {
        return X < S;
    },
    't6D': function(X, S) {
        return X / S;
    },
    'a8N': function(X, S) {
        return X == S;
    },
    'I8E': function(X, S) {
        return X / S;
    },
    'B5T': function(X, S) {
        return X * S;
    },
    'E6l': function(X, S) {
        return X * S;
    },
    'w9P': "tangentialAccelVar",
    'w1h': function(X, S) {
        return X * S;
    },
    'a9u': function(X, S) {
        return X - S;
    },
    'G8y': function(X) {
        cc.TRANSITION_ORIENTATION_LEFT_OVER = X;
    },
    'i8a': function(X, S) {
        return X / S;
    },
    'h8K': 288,
    'x56': function(X, S) {
        return X - S;
    },
    'F9t': function(X, S) {
        return X != S;
    },
    'G0u': function(X, S) {
        return X == S;
    },
    'j7t': function(X, S) {
        return X < S;
    },
    'S8T': function(X, S) {
        return X / S;
    },
    'a1y': function(X) {
        cc.UNIFORM_MVPMATRIX_S = X;
    },
    'h5w': function(X, S) {
        return X * S;
    },
    'L3': function(X) {
        cc.ALIGN_RIGHT = X;
    },
    'o0q': function(X, S) {
        return X * S;
    },
    'H5E': function(X, S) {
        return X * S;
    },
    'Q9O': function(X) {
        USER_INFO_KEY = X;
    },
    'H3i': "Layer",
    'a2': function(X) {
        cc.KM_PLANE_BOTTOM = X;
    },
    'Q4H': function(X, S) {
        return X < S;
    },
    'm7A': function(X, S) {
        return X instanceof S;
    },
    'C65': function(X, S) {
        return X != S;
    },
    'a1i': "mapHeight",
    'y0B': function(X, S) {
        return X < S;
    },
    'B3m': function(X, S) {
        return X * S;
    },
    'G8D': function(X, S) {
        return X * S;
    },
    'J31': function(X, S) {
        return X * S;
    },
    'Q6p': function(X, S) {
        return X !== S;
    },
    'o5D': function(X, S) {
        return X * S;
    },
    'G2E': function(X, S) {
        return X / S;
    },
    'T7d': function(X, S) {
        return X / S;
    },
    'W8H': function(X, S) {
        return X * S;
    },
    's1E': function(X, S) {
        return X == S;
    },
    'w3a': function(X, S) {
        return X - S;
    },
    'D2t': function(X, S) {
        return X < S;
    },
    's81': function(X, S) {
        return X !== S;
    },
    'E4a': function(X, S) {
        return X < S;
    },
    'W41': function(X, S) {
        return X * S;
    },
    'a88': function(X, S) {
        return X === S;
    },
    'Y1H': function(X, S) {
        return X == S;
    },
    'k2B': function(X, S) {
        return X < S;
    },
    'E5': function(X) {
        cc.DIRECTOR_PROJECTION_2D = X;
    },
    'G1M': function(X, S) {
        return X > S;
    },
    'G0w': function(X, S) {
        return X > S;
    },
    'a3q': function(X, S) {
        return X * S;
    },
    'o63': function(X, S) {
        return X != S;
    },
    'W4O': function(X, S) {
        return X instanceof S;
    },
    'D62': function(X, S) {
        return X < S;
    },
    'b3u': function(X, S, P) {
        return X * S * P;
    },
    'Q0L': function(X, S) {
        return X > S;
    },
    'Y2S': "reverseDir",
    'q9w': function(X, S) {
        return X == S;
    },
    'm5S': "height",
    'n4h': function(X, S) {
        return X < S;
    },
    'R0G': function(X, S) {
        return X | S;
    },
    't3D': function(X, S) {
        return X != S;
    },
    'D0H': "rotationY",
    'a41': function(X, S) {
        return X !== S;
    },
    'q4a': function(X, S) {
        return X == S;
    },
    'A1A': function(X, S) {
        return X instanceof S;
    },
    'l6A': function(X, S) {
        return X == S;
    },
    'V8s': function(X, S) {
        return X in S;
    },
    'y6t': function(X, S) {
        return X * S;
    },
    'g6z': function(X, S, P, O) {
        return X * S * P * O;
    },
    'p1H': function(X, S) {
        return X == S;
    },
    'r9': function() {
        cc._isContextMenuEnable = !1;
    },
    'W26': function(X, S) {
        return X == S;
    },
    'u7S': 170,
    'R3s': function(X, S) {
        return X === S;
    },
    'O2j': function(X, S) {
        return X << S;
    },
    'e4d': function(X, S) {
        return X | S;
    },
    'v0D': function(X, S) {
        return X == S;
    },
    'A7G': function(X, S) {
        return X < S;
    },
    'w6': function() {
        cc.Director.firstUseDirector = !0;
    },
    'G9y': function(X) {
        cc.UNIFORM_MVPMATRIX = X;
    },
    'V2v': function(X, S) {
        return X == S;
    },
    'M03': function(X, S) {
        return X | S;
    },
    'e9i': 24,
    'f7N': function(X, S) {
        return X < S;
    },
    'w7B': function(X, S) {
        return X | S;
    },
    'E6t': function(X, S) {
        return X < S;
    },
    'r9w': function(X, S) {
        return X / S;
    },
    'F3E': function(X, S) {
        return X < S;
    },
    'z13': function(X, S) {
        return X * S;
    },
    'R4K': "skewY",
    'B9A': function(X, S) {
        return X == S;
    },
    'W1v': function(X, S) {
        return X != S;
    },
    'I23': function(X, S) {
        return X | S;
    },
    'e86': function(X, S) {
        return X < S;
    },
    'A7S': "disabled",
    'F8h': function(X, S) {
        return X <= S;
    },
    'P2q': function(X, S) {
        return X * S;
    },
    'J9i': 32,
    'u5y': function(X) {
        cc.TMX_ORIENTATION_ORTHO = X;
    },
    'W1L': function(X, S) {
        return X * S;
    },
    't7K': "selected_down",
    'F8O': function(X, S) {
        return X == S;
    },
    'O33': function(X, S) {
        return X != S;
    },
    'u8a': function(X, S) {
        return X < S;
    },
    'p3u': function(X, S) {
        return X < S;
    },
    'H4q': function(X, S) {
        return X * S;
    },
    'W3q': function(X, S) {
        return X * S;
    },
    'q3a': function(X, S) {
        return X * S;
    },
    'r6i': "style",
    'y28': function(X, S) {
        return X < S;
    },
    'T3E': function(X, S) {
        return X < S;
    },
    'y1q': function(X, S) {
        return X * S;
    },
    'W8E': function(X, S) {
        return X != S;
    },
    't2S': "normal",
    'h3i': "rotatePerS",
    'h7M': function(X, S) {
        return X > S;
    },
    's35': function(X, S) {
        return X < S;
    },
    'E1z': function(X, S) {
        return X * S;
    },
    'Y9P': "3.402823466e+38F",
    'z9': function(X) {
        cc.ORIENTATION_LANDSCAPE_LEFT = X;
    },
    'j13': function(X, S, P) {
        return X * S / P;
    },
    'k8T': function(X, S) {
        return X / S;
    },
    'H2y': function(X) {
        Global.earthPositon = X;
    },
    'R6t': function(X, S, P) {
        return X / S * P;
    },
    'V2w': function(X, S) {
        return X === S;
    },
    'e7z': function(X, S) {
        return X < S;
    },
    'M9t': function(X, S) {
        return X == S;
    },
    'k3m': function(X, S) {
        return X * S;
    },
    'f2z': function(X, S) {
        return X < S;
    },
    'o7w': function(X, S) {
        return X | S;
    },
    'o1T': function(X, S) {
        return X * S;
    },
    'Z6': function() {
        cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
    },
    'H32': function(X, S) {
        return X instanceof S;
    },
    'E1y': function(X) {
        cc.VERTEX_ATTRIB_FLAG_NONE = X;
    },
    't1q': function(X, S) {
        return X * S;
    },
    'L5E': function(X, S) {
        return X * S;
    },
    'a5y': function(X) {
        cc.ZOOM_ACTION_TAG = X;
    },
    'C8m': function(X, S) {
        return X != S;
    },
    'R4L': function(X, S, P) {
        return X * S * P;
    },
    'L6j': function(X, S) {
        return X < S;
    },
    'A0s': function(X, S) {
        return X - S;
    },
    'a76': function(X, S) {
        return X == S;
    },
    'D8u': function(X, S) {
        return X - S;
    },
    'X81': function(X, S) {
        return X !== S;
    },
    'M1B': function(X, S) {
        return X * S;
    },
    'C5O': function(X, S) {
        return X === S;
    },
    'w2y': function() {
        lg._resourcesLoaded = [];
    },
    'S8G': function(X, S) {
        return X !== S;
    },
    'o1E': function(X, S) {
        return X - S;
    },
    'o3E': function(X, S) {
        return X < S;
    },
    'x0h': function(X, S, P) {
        return X * S * P;
    },
    'j3v': function(X, S) {
        return X / S;
    },
    'v8b': function(X, S) {
        return X - S;
    },
    'G5L': function(X, S) {
        return X >= S;
    },
    'r5G': function(X, S) {
        return X < S;
    },
    'q0u': function(X, S, P) {
        return X / S * P;
    },
    'J2j': function(X, S) {
        return X - S;
    },
    'i32': function(X, S) {
        return X - S;
    },
    's6A': function(X, S) {
        return X / S;
    },
    'M0A': function(X, S) {
        return X != S;
    },
    'a0D': function(X, S) {
        return X != S;
    },
    'z3u': function(X, S) {
        return X - S;
    },
    'G2y': function(X) {
        Global.BingDate = X;
    },
    'g3N': function(X, S) {
        return X < S;
    },
    'h3N': function(X, S) {
        return X * S;
    },
    'v8y': function(X) {
        cc.TRANSITION_ORIENTATION_DOWN_OVER = X;
    },
    'z8S': "DrawingPrimitive.drawCardinalSpline() not implement!",
    'g3j': function(X, S) {
        return X === S;
    },
    'd2A': function(X, S) {
        return X != S;
    },
    'n4O': function(X, S) {
        return X instanceof S;
    },
    'a6a': function(X, S) {
        return X * S;
    },
    'k1N': function(X, S) {
        return X & S;
    },
    'R1B': function(X, S) {
        return X * S;
    },
    'W8N': function(X, S) {
        return X != S;
    },
    'z95': function(X, S) {
        return X != S;
    },
    'v9A': function(X, S) {
        return X instanceof S;
    },
    'Z4E': function(X, S) {
        return X / S;
    },
    'H9q': function(X, S) {
        return X * S;
    },
    'H08': function(X, S) {
        return X | S;
    },
    'M9v': function(X, S) {
        return X === S;
    },
    'L8B': function(X, S) {
        return X < S;
    },
    'x1': function(X) {
        cc.LABELBMFONT_DEBUG_DRAW = X;
    },
    'h85': function(X, S) {
        return X * S;
    },
    'j9p': function(X, S) {
        return X * S;
    },
    'C71': function(X, S) {
        return X * S;
    },
    'q3d': function(X, S) {
        return X > S;
    },
    'I1f': function(X, S, P) {
        return X / S * P;
    },
    'U8q': function(X, S) {
        return X * S;
    },
    'T3v': function(X, S) {
        return X - S;
    },
    'K51': function(X, S) {
        return X * S;
    },
    'r4T': function(X, S) {
        return X - S;
    },
    'B7K': 5889,
    't9l': function(X, S) {
        return X <= S;
    },
    'C2s': function(X, S) {
        return X == S;
    },
    'g1A': function(X, S) {
        return X == S;
    },
    'b1w': function(X, S) {
        return X != S;
    },
    'r7G': function(X, S) {
        return X / S;
    },
    'E2z': function(X, S) {
        return X < S;
    },
    'e1i': 10,
    'H7v': function(X, S) {
        return X == S;
    },
    'p3L': function(X, S) {
        return X > S;
    },
    'Z5T': function(X, S) {
        return X * S;
    },
    'f7L': function(X, S) {
        return X * S;
    },
    'B4l': function(X, S) {
        return X << S;
    },
    'd1s': function(X, S) {
        return X & S;
    },
    'M9S': "startRadius",
    'Z08': function(X, S) {
        return X & S;
    },
    'B0K': 250,
    'k0a': function(X, S) {
        return X * S;
    },
    'F18': function(X, S) {
        return X / S;
    },
    'n22': function(X, S) {
        return X < S;
    },
    'X4K': "number",
    'E7O': function(X, S) {
        return X == S;
    },
    't6T': function(X, S) {
        return X * S;
    },
    'U6j': function(X, S) {
        return X & S;
    },
    't0E': function(X, S) {
        return X < S;
    },
    'G4q': function(X, S) {
        return X * S;
    },
    'm0N': function(X, S) {
        return X > S;
    },
    'X2y': function(X) {
        lg.language = X;
    },
    'r8K': "capacity",
    'P7p': function(X, S) {
        return X === S;
    },
    'T7T': function(X, S) {
        return X * S;
    },
    'y7A': function(X, S) {
        return X - S;
    },
    'X7D': function(X, S) {
        return X * S;
    },
    'd0p': function(X, S) {
        return X - S;
    },
    'Y95': function(X, S) {
        return X - S;
    },
    'o66': function(X, S) {
        return X >= S;
    },
    'z2y': function(X) {
        lg.currentScene = X;
    },
    'w93': function(X, S) {
        return X | S;
    },
    'r1u': function(X, S) {
        return X - S;
    },
    'e52': function(X, S) {
        return X === S;
    },
    'j2v': function(X, S) {
        return X | S;
    },
    'K0P': "/",
    'o58': function(X, S) {
        return X <= S;
    },
    'D01': function(X, S) {
        return X * S;
    },
    'u9q': function(X, S) {
        return X * S;
    },
    'K8': function() {
        cc.CONTENT_SCALE_FACTOR = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
            return cc.director.getContentScaleFactor();
        } : function() {
            return ( 0x231 < (39., 68) ? (0x115, "G") : (97, 0xCC) >= (80., 53.) ? (46, 1) : (0E0, 14.) >= (0xC2, 67.) ? (37., 0xDE) : (4.86E2, 41.90E1)) ;
        };
    },
    'P6j': function(X, S) {
        return X < S;
    },
    'X83': function(X, S) {
        return X * S;
    },
    'r38': function(X, S) {
        return X & S;
    },
    'Z31': function(X, S) {
        return X * S;
    },
    'G3P': "quad",
    'H7L': function(X, S) {
        return X * S;
    },
    'F1S': 0.6,
    'N6s': function(X, S) {
        return X - S;
    },
    'r71': function(X, S) {
        return X * S;
    },
    'S9G': function(X, S, P) {
        return X - S - P;
    },
    'H4m': function(X, S) {
        return X >= S;
    },
    'u7K': "ORANGE",
    'k2j': function(X, S) {
        return X & S;
    },
    'H8H': function(X, S) {
        return X == S;
    },
    'n9f': function(X, S) {
        return X < S;
    },
    'H7E': function(X, S) {
        return X <= S;
    },
    'i6H': 998,
    'L5B': function(X, S) {
        return X / S;
    },
    'o11': function(X, S) {
        return X / S;
    },
    'O23': function(X, S) {
        return X === S;
    },
    'i5y': function(X) {
        cc.ITEM_SIZE = X;
    },
    'K1A': function(X, S) {
        return X == S;
    },
    'g3w': function(X, S) {
        return X < S;
    },
    'Q5q': function(X, S) {
        return X * S;
    },
    'o8z': function(X, S) {
        return X * S;
    },
    'p3h': function(X, S) {
        return X | S;
    },
    'B7N': function(X, S) {
        return X * S;
    },
    'a0a': function(X, S) {
        return X * S;
    },
    'z1B': function(X, S) {
        return X == S;
    },
    'K7G': function(X, S) {
        return X | S;
    },
    'V7D': function(X, S) {
        return X % S;
    },
    'j1D': function(X, S) {
        return X == S;
    },
    'A7O': function(X, S) {
        return X & S;
    },
    'A65': function(X, S) {
        return X < S;
    },
    'd0j': function(X, S, P) {
        return X - S + P;
    },
    'W9d': function(X, S) {
        return X < S;
    },
    'D3z': function(X, S) {
        return X - S;
    },
    'y7': function(X) {
        cc.EventMouse.UP = X;
    },
    'y7b': function(X, S) {
        return X - S;
    },
    'x3p': function(X, S) {
        return X === S;
    },
    'r0B': function(X, S) {
        return X & S;
    },
    'p8s': function(X, S) {
        return X >= S;
    },
    'e4D': function(X, S) {
        return X === S;
    },
    'T35': function(X, S) {
        return X === S;
    },
    'D5y': function(X) {
        cc.PARTICLE_DEFAULT_CAPACITY = X;
    },
    'G7N': function(X, S) {
        return X * S;
    },
    'T6j': function(X, S) {
        return X | S;
    },
    'N9b': function(X, S) {
        return X * S;
    },
    'z4t': function(X, S) {
        return X < S;
    },
    'N6v': function(X, S) {
        return X instanceof S;
    },
    'p4P': "pixelsWidth",
    'h8y': function(X) {
        cc.ADJUST_FACTOR = X;
    },
    'G7L': function(X, S) {
        return X * S;
    },
    'U5a': function(X, S) {
        return X < S;
    },
    'D45': function(X, S) {
        return X * S;
    },
    'V4f': function(X, S, P) {
        return X / S * P;
    },
    'L1K': "rotation",
    'd8': function(X) {
        cc.ONE = X;
    },
    'Z7v': function(X, S) {
        return X <= S;
    },
    'P0T': function(X, S) {
        return X * S;
    },
    'E5m': function(X, S) {
        return X * S;
    },
    'u9d': function(X, S) {
        return X == S;
    },
    'Y02': function(X, S) {
        return X < S;
    },
    'x7t': function(X, S) {
        return X == S;
    },
    'l2i': 771,
    'G41': function(X, S) {
        return X * S;
    },
    'L0w': function(X, S) {
        return X < S;
    },
    'O0u': function(X, S) {
        return X == S;
    },
    'Q5b': function(X, S) {
        return X - S;
    },
    'h9l': function(X, S) {
        return X - S;
    },
    'E13': function(X, S) {
        return X * S;
    },
    'T1a': function(X, S) {
        return X / S;
    },
    'y4a': function(X, S) {
        return X == S;
    },
    'J68': function(X, S) {
        return X < S;
    },
    'u5S': "ignoreAnchor",
    'I3G': function(X, S) {
        return X >= S;
    },
    'U1H': function(X, S) {
        return X == S;
    },
    'U2D': function(X, S) {
        return X / S;
    },
    'F02': function(X, S) {
        return X - S;
    },
    'I88': function(X, S) {
        return X <= S;
    },
    'b4M': function(X, S, P, O) {
        return X * S * P / O;
    },
    'F2L': function(X, S) {
        return X * S;
    },
    'm42': function(X, S) {
        return X != S;
    },
    'M2t': function(X, S) {
        return X / S;
    },
    'w3D': function(X, S) {
        return X != S;
    },
    'y5w': function(X, S, P) {
        return X * S * P;
    },
    'C5w': function(X, S) {
        return X * S;
    },
    'A86': function(X, S) {
        return X != S;
    },
    'x8z': function(X, S) {
        return X / S;
    },
    'R2m': function(X, S, P, O) {
        return X * S * P * O;
    },
    'G4u': function(X, S) {
        return X * S;
    },
    'Q6w': function(X, S) {
        return X * S;
    },
    'd6v': function(X, S) {
        return X - S;
    },
    'G7i': 96,
    'm53': function(X, S) {
        return X != S;
    },
    'v9i': 17,
    'M3y': function(X) {
        cc.PARTICLE_SHAPE_MODE = X;
    },
    'e6L': function(X, S) {
        return X > S;
    },
    'X9O': function(X) {
        Global.maxTime = X;
    },
    'q2A': function(X, S) {
        return X < S;
    },
    'i6d': function(X, S) {
        return X > S;
    },
    'D4N': function(X, S) {
        return X / S;
    },
    'p6i': "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}",
    'i1G': function(X, S) {
        return X < S;
    },
    'I41': function(X, S) {
        return X != S;
    },
    'Q7f': function(X, S) {
        return X < S;
    },
    'k7t': function(X, S) {
        return X * S;
    },
    'E0s': function(X, S) {
        return X - S;
    },
    'A9M': function(X, S) {
        return X === S;
    },
    'z8u': function(X, S) {
        return X - S;
    },
    'g9b': function(X, S) {
        return X * S;
    },
    'p9p': function(X, S) {
        return X > S;
    },
    'u6f': function(X, S, P) {
        return X - S + P;
    },
    'M7d': function(X, S) {
        return X === S;
    },
    'E6T': function(X, S) {
        return X * S;
    },
    'b02': function(X, S) {
        return X != S;
    },
    'P12': function(X, S) {
        return X / S;
    },
    'X1i': 20,
    'D2D': function(X, S) {
        return X * S;
    },
    'P0d': function(X, S) {
        return X / S;
    },
    'Y8z': function(X, S) {
        return X < S;
    },
    'u5p': function(X, S) {
        return X >= S;
    },
    'o1y': function(X) {
        cc.UNIFORM_SINTIME_S = X;
    },
    'Q7h': function(X, S, P) {
        return X * S * P;
    },
    'k0D': function(X, S) {
        return X != S;
    },
    'K2p': function(X, S) {
        return X < S;
    },
    'I6a': function(X, S) {
        return X * S;
    },
    'H16': function(X, S) {
        return X instanceof S;
    },
    'h4w': function(X, S) {
        return X | S;
    },
    'F45': function(X, S) {
        return X != S;
    },
    'c1T': function(X, S) {
        return X * S;
    },
    'C3d': function(X, S) {
        return X != S;
    },
    'h3a': function(X, S) {
        return X * S;
    },
    'O9f': function(X, S) {
        return X < S;
    },
    'c1B': function(X, S) {
        return X == S;
    },
    'M2f': function(X, S) {
        return X / S;
    },
    'm7u': function(X, S) {
        return X / S;
    },
    'w3d': function(X, S) {
        return X / S;
    },
    'E38': function(X, S) {
        return X < S;
    },
    'f15': function(X, S) {
        return X < S;
    },
    'G2T': function(X, S) {
        return X / S;
    },
    'q5b': function(X, S) {
        return X / S;
    },
    'J8D': function(X, S) {
        return X * S;
    },
    'N6G': function(X, S) {
        return X * S;
    },
    'G3b': function(X, S) {
        return X != S;
    },
    'm9M': function(X, S) {
        return X - S;
    },
    'o2t': function(X, S) {
        return X << S;
    },
    't8y': function(X) {
        cc.DrawNode.TYPE_POLY = X;
    },
    'G8w': function(X, S) {
        return X * S;
    },
    'X6m': function(X, S) {
        return X < S;
    },
    'j8A': function(X, S) {
        return X == S;
    },
    'i4u': function(X, S) {
        return X - S;
    },
    'Y0m': function(X, S) {
        return X * S;
    },
    'Y9y': function(X) {
        cc.VERTEX_ATTRIB_TEX_COORDS = X;
    },
    'r5l': function(X, S) {
        return X * S;
    },
    'Z0T': function(X, S) {
        return X == S;
    },
    'V9v': function(X, S) {
        return X * S;
    },
    'd5m': function(X, S) {
        return X * S;
    },
    'u21': function(X, S, P) {
        return X - S + P;
    },
    'b6q': function(X, S) {
        return X * S;
    },
    'x0m': function(X, S) {
        return X < S;
    },
    'Q7m': function(X, S) {
        return X > S;
    },
    'i6': function(X) {
        cc.Director.EVENT_AFTER_DRAW = X;
    },
    'K42': function(X, S) {
        return X === S;
    },
    't2d': function(X, S) {
        return X != S;
    },
    'W2q': function(X, S) {
        return X * S;
    },
    'v2q': function(X, S) {
        return X * S;
    },
    'L7v': function(X, S) {
        return X <= S;
    },
    'O9s': function(X, S) {
        return X < S;
    },
    'j0A': function(X, S) {
        return X <= S;
    },
    'K4D': function(X, S) {
        return X / S;
    },
    'B6j': function(X, S, P) {
        return X | S | P;
    },
    't3w': function(X, S) {
        return X instanceof S;
    },
    'e7B': function(X, S) {
        return X | S;
    },
    'K3D': function(X, S) {
        return X == S;
    },
    'S1t': function(X, S) {
        return X - S;
    },
    'q98': function(X, S) {
        return X != S;
    },
    'B9y': function(X) {
        cc.VERTEX_ATTRIB_POSITION = X;
    },
    'T1B': function(X, S) {
        return X / S;
    },
    'f5T': function(X, S) {
        return X / S;
    },
    'o46': function(X, S) {
        return X == S;
    },
    'I5u': function(X, S, P) {
        return X * S * P;
    },
    'j3s': function(X, S) {
        return X * S;
    },
    'b1D': function(X, S) {
        return X < S;
    },
    'a2O': function(X, S) {
        return X == S;
    },
    'z5a': function(X, S) {
        return X * S;
    },
    'P02': function(X, S) {
        return X >= S;
    },
    'S7v': function(X, S) {
        return X == S;
    },
    'K8K': "LayerMultiplex",
    'c3L': function(X, S, P) {
        return X * S * P;
    },
    'S8D': function(X, S) {
        return X == S;
    },
    'H6y': function() {
        EIGHT_DIRECTIONS = [[0, 1], [0, -1], [-1, 0], [1, 0], [-1, 1], [1, 1], [((0x13E, 41.40E1) <= (78.9E1, 2.530E2) ? (0x15, "V") : (0x1FF, 0x17B) <= 0x24A ? (44, 1) : (0x1B4, 12.25E2)), -1], [-1, -1]];
    },
    'W8a': function(X, S) {
        return X < S;
    },
    's18': function(X, S) {
        return X != S;
    },
    'd5G': function(X, S) {
        return X > S;
    },
    'u4A': function(X, S) {
        return X != S;
    },
    'P3A': function(X, S) {
        return X == S;
    },
    'w6p': function(X, S) {
        return X | S;
    },
    'q8T': function(X, S) {
        return X * S;
    },
    'Y1l': function(X, S) {
        return X < S;
    },
    'o35': function(X, S) {
        return X - S;
    },
    'b9p': function(X, S) {
        return X < S;
    },
    'B8H': function(X, S) {
        return X / S;
    },
    'O5h': function(X, S, P) {
        return X * S / P;
    },
    'm6s': function(X, S) {
        return X < S;
    },
    'V8h': function(X, S) {
        return X == S;
    },
    'V3u': function(X, S) {
        return X < S;
    },
    'L2q': function(X, S) {
        return X * S;
    },
    'p7a': function(X, S) {
        return X > S;
    },
    'Q0h': function(X, S, P) {
        return X * S * P;
    },
    'g7G': function(X, S) {
        return X === S;
    },
    'h71': function(X, S) {
        return X * S;
    },
    'o8S': "Arial",
    'H3w': function(X, S) {
        return X === S;
    },
    'I7v': function(X, S) {
        return X != S;
    },
    'h6t': function(X, S) {
        return X * S;
    },
    'h5': function(X) {
        cc.DIRECTOR_PROJECTION_CUSTOM = X;
    },
    'P1t': function(X, S) {
        return X - S;
    },
    'M7M': function(X, S, P) {
        return X * S * P;
    },
    'r6v': function(X, S) {
        return X == S;
    },
    'n4u': function(X, S) {
        return X * S;
    },
    'y5b': function(X, S) {
        return X / S;
    },
    'R7K': "stencil",
    'j9t': function(X, S) {
        return X * S;
    },
    'D35': function(X, S) {
        return X !== S;
    },
    'I6z': function(X, S) {
        return X * S;
    },
    'f7E': function(X, S) {
        return X < S;
    },
    'j6l': function(X, S) {
        return X >= S;
    },
    's4N': function(X, S) {
        return X * S;
    },
    'n33': function(X, S) {
        return X != S;
    },
    'A7z': function(X, S) {
        return X === S;
    },
    'B5E': function(X, S) {
        return X * S;
    },
    'E5t': function(X, S) {
        return X * S;
    },
    'V1T': function(X, S) {
        return X / S;
    },
    's0f': function(X, S) {
        return X < S;
    },
    't5M': function(X, S) {
        return X - S;
    },
    'd5b': function(X, S) {
        return X - S;
    },
    'P16': function(X, S) {
        return X < S;
    },
    'y9B': function(X, S) {
        return X <= S;
    },
    'm93': function(X, S) {
        return X | S;
    },
    'A2N': function(X, S) {
        return X * S;
    },
    'P5B': function(X, S) {
        return X * S;
    },
    'V6A': function(X, S) {
        return X < S;
    },
    'C05': function(X, S) {
        return X === S;
    },
    'k0h': function(X, S, P) {
        return X * S * P;
    },
    'z11': function(X, S) {
        return X / S;
    },
    'D7a': function(X, S) {
        return X < S;
    },
    't53': function(X, S) {
        return X !== S;
    },
    'Q6l': function(X, S) {
        return X / S;
    },
    'B3G': function(X, S) {
        return X > S;
    },
    'V9': function(X) {
        cc.FMT_UNKNOWN = X;
    },
    'E5i': "plist",
    'h05': function(X, S) {
        return X < S;
    },
    'q1': function() {
        cc.DEG = ((5.7E1, 0xEB) < 1.0210E3 ? (0x172, 180) : (0xB, 75.9E1)) / cc.PI;
    },
    'S3A': function(X, S) {
        return X == S;
    },
    't3a': function(X, S) {
        return X - S;
    },
    'L5y': function() {
        cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
    },
    'e3l': function(X, S) {
        return X < S;
    },
    'x9L': function(X, S) {
        return X * S;
    },
    'D2v': function(X, S) {
        return X >= S;
    },
    'm6v': function(X, S) {
        return X == S;
    },
    'D3L': function(X, S) {
        return X * S;
    },
    'Z9f': function(X, S) {
        return X | S;
    },
    'L2y': function() {
        lg.languageIndex = -((0xDB, 147.) > (0x131, 3.820E2) ? 'a' : (0x1C0, 3.) < 141 ? (10, 1) : (19.3E1, 0x56));
    },
    'J1y': function(X) {
        cc.UNIFORM_ALPHA_TEST_VALUE_S = X;
    },
    'U1b': function(X, S) {
        return X % S;
    },
    'o7': function() {
        cc.UIInterfaceOrientationLandscapeLeft = -90;
    },
    'r6': function() {
        cc.LabelTTF._textAlign = ["left", "center", "right"];
    },
    'E5S': "director_projection_changed",
    'r2': function(X) {
        cc.POINT_INFRONT_OF_PLANE = X;
    },
    'v8B': function(X, S) {
        return X & S;
    },
    'z8O': function(X, S) {
        return X == S;
    },
    'l5M': function(X, S) {
        return X == S;
    },
    'M8h': function(X, S) {
        return X != S;
    },
    'L5z': function(X, S) {
        return X * S;
    },
    'T58': function(X, S) {
        return X << S;
    },
    'K2H': 5.8,
    'B9s': function(X, S) {
        return X in S;
    },
    'N5m': function(X, S) {
        return X < S;
    },
    'r5w': function(X, S) {
        return X | S;
    },
    'V7t': function(X, S) {
        return X / S;
    },
    'K8P': "shadowOffsetY",
    'Y2D': function(X, S) {
        return X / S;
    },
    'T72': function(X, S) {
        return X == S;
    },
    'w1d': function(X, S) {
        return X * S;
    },
    'c9L': function(X, S) {
        return X * S;
    },
    'k0T': function(X, S) {
        return X * S;
    },
    'm1u': function(X, S) {
        return X < S;
    },
    'i8j': function(X, S) {
        return X - S;
    },
    'p02': function(X, S) {
        return X < S;
    },
    'Z5s': function(X, S) {
        return X / S;
    },
    's8d': function(X, S) {
        return X | S;
    },
    'd71': function(X, S) {
        return X == S;
    },
    'R0h': function(X, S) {
        return X * S;
    },
    'n06': function(X, S) {
        return X == S;
    },
    'I9z': function(X, S) {
        return X * S;
    },
    'm5O': function(X, S) {
        return X == S;
    },
    'w8M': function(X, S) {
        return X === S;
    },
    'L4h': function(X, S) {
        return X == S;
    },
    'r5q': function(X, S) {
        return X * S;
    },
    'S4A': function(X, S) {
        return X == S;
    },
    'r13': function(X, S) {
        return X * S;
    },
    'D9j': function(X, S) {
        return X / S;
    },
    't4B': function(X, S) {
        return X >> S;
    },
    'V5j': function(X, S) {
        return X < S;
    },
    'M1H': function(X, S) {
        return X == S;
    },
    'd0L': function(X, S) {
        return X * S;
    },
    'K85': function(X, S) {
        return X * S;
    },
    'V8O': function(X, S) {
        return X == S;
    },
    'H8b': function(X, S) {
        return X / S;
    },
    'w9H': function(X, S) {
        return X <= S;
    },
    'Q7A': function(X, S) {
        return X <= S;
    },
    'S5E': function(X, S) {
        return X * S;
    },
    's03': function(X, S) {
        return X | S;
    },
    'a8B': function(X, S) {
        return X !== S;
    },
    'c0f': function(X, S) {
        return X * S;
    },
    'd6H': 999,
    'n2l': function(X, S) {
        return X < S;
    },
    'B9u': function(X, S) {
        return X < S;
    },
    'p45': function(X, S) {
        return X * S;
    },
    'R8d': function(X, S) {
        return X == S;
    },
    'f6N': function(X, S) {
        return X * S;
    },
    'c6O': function(X, S) {
        return X == S;
    },
    'v5v': function(X, S) {
        return X != S;
    },
    'c8O': function(X, S) {
        return X - S;
    },
    'n68': function(X, S) {
        return X < S;
    },
    'T6t': function(X, S) {
        return X < S;
    },
    'A5y': function(X) {
        cc.TGA_ERROR_FILE_OPEN = X;
    },
    'z3M': function(X, S) {
        return X * S;
    },
    'Q6s': function(X, S) {
        return X * S;
    },
    'p6m': function(X, S) {
        return X * S;
    },
    'H3q': function(X, S) {
        return X * S;
    },
    'k8B': function(X, S) {
        return X / S;
    },
    'B1G': function(X, S) {
        return X < S;
    },
    'o21': function(X, S) {
        return X * S;
    },
    'j9O': function() {
        Global.gameOver = !(71.10E1 > (78.10E1, 124.0E1) ? (0x14A, 0xCC) : 67. < (7.38E2, 0x86) ? (0x246, 1) : (52., 0x64));
    },
    'Q48': function(X, S) {
        return X < S;
    },
    'i5': function(X) {
        _M[_c.PIXEL_FORMAT_PVRTC4] = X;
    },
    'V4M': function(X, S) {
        return X - S;
    },
    'k9s': function(X, S) {
        return X * S;
    },
    'E3H': "div",
    'h28': function(X, S) {
        return X >>> S;
    },
    'p1T': function(X, S) {
        return X - S;
    },
    'b3T': function(X, S) {
        return X * S;
    },
    'A6D': function(X, S) {
        return X > S;
    },
    'q05': function(X, S) {
        return X != S;
    },
    'H3A': function(X, S) {
        return X != S;
    },
    'O2m': function(X, S, P) {
        return X * S * P;
    },
    'z3z': function(X, S) {
        return X - S;
    },
    'i5s': function(X, S) {
        return X - S;
    },
    'Y72': function(X, S) {
        return X == S;
    },
    'L6H': "CC_MVMatrix",
    'D0u': function(X, S, P) {
        return X / S * P;
    },
    'Y3u': function(X, S) {
        return X | S;
    },
    'w36': function(X, S) {
        return X - S;
    },
    'D6M': function(X, S) {
        return X < S;
    },
    'V3v': function(X, S) {
        return X <= S;
    },
    'E3': function(X) {
        _c.PIXEL_FORMAT_PVRTC4 = X;
    },
    'F5j': function(X, S) {
        return X - S;
    },
    'Q0M': function(X, S, P, O) {
        return X * S * P / O;
    },
    'v4m': function(X, S) {
        return X == S;
    },
    'F9p': function(X, S) {
        return X instanceof S;
    },
    'y0v': function(X, S) {
        return X == S;
    },
    'V3E': function(X, S) {
        return X < S;
    },
    'Z82': function(X, S) {
        return X * S;
    },
    'j4v': function(X, S) {
        return X < S;
    },
    'U8A': function(X, S) {
        return X == S;
    },
    'v4K': "bmp",
    'H0t': function(X, S) {
        return X >= S;
    },
    'O4z': function(X, S) {
        return X * S;
    },
    'y2f': function(X, S) {
        return X !== S;
    },
    'g1s': function(X, S) {
        return X !== S;
    },
    'T03': function(X, S) {
        return X | S;
    },
    'Y45': function(X, S) {
        return X - S;
    },
    'p4i': "director_after_update",
    'L6u': function(X, S, P) {
        return X * S * P;
    },
    'G5u': function(X, S, P) {
        return X * S * P;
    },
    'E98': function(X, S) {
        return X != S;
    },
    'n4A': function(X, S) {
        return X != S;
    },
    'J4m': function(X, S) {
        return X >= S;
    },
    's4p': function(X, S) {
        return X >= S;
    },
    'l98': function(X, S) {
        return X != S;
    },
    'k16': function(X, S) {
        return X == S;
    },
    'r9E': function(X, S) {
        return X !== S;
    },
    'l11': function(X, S) {
        return X !== S;
    },
    'j43': function(X, S) {
        return X * S;
    },
    'H75': function(X, S) {
        return X === S;
    },
    'z6t': function(X, S) {
        return X != S;
    },
    'W0d': function(X, S) {
        return X / S;
    },
    'H12': function(X, S) {
        return X / S;
    },
    'Z23': function(X, S) {
        return X - S;
    },
    'x96': function(X, S) {
        return X < S;
    },
    'P0t': function(X, S) {
        return X < S;
    },
    'r1z': function(X, S) {
        return X - S;
    },
    'm5i': "id",
    'h7m': function(X, S) {
        return X != S;
    },
    'f8m': function(X, S) {
        return X * S;
    },
    'd9M': function(X, S) {
        return X <= S;
    },
    'N8v': function(X, S) {
        return X != S;
    },
    'R7j': function(X, S) {
        return X > S;
    },
    'n8a': function(X, S) {
        return X instanceof S;
    },
    'p6q': function(X, S) {
        return X * S;
    },
    'Z8b': function(X, S) {
        return X != S;
    },
    'M9p': function(X, S) {
        return X === S;
    },
    'r4j': function(X, S) {
        return X < S;
    },
    'o2v': function(X, S) {
        return X == S;
    },
    'V8P': "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ",
    'L4l': function(X, S) {
        return X <= S;
    },
    'S4T': function(X, S, P) {
        return X * S * P;
    },
    'b83': function(X, S) {
        return X * S;
    },
    'w0v': function(X, S) {
        return X / S;
    },
    'c8d': function(X, S) {
        return X == S;
    },
    'K98': function(X, S) {
        return X / S;
    },
    'B9m': function(X, S) {
        return X * S;
    },
    'I55': function(X, S) {
        return X < S;
    },
    'G4h': function(X, S) {
        return X > S;
    },
    's3p': function(X, S) {
        return X >= S;
    },
    'a4q': function(X, S) {
        return X * S;
    },
    'R4M': function(X, S) {
        return X * S;
    },
    'Z7B': function(X, S) {
        return X | S;
    },
    'P0M': function(X, S) {
        return X > S;
    },
    'R1D': function(X, S) {
        return X == S;
    },
    'e8i': 70,
    'S9s': function(X, S) {
        return X / S;
    },
    'U1E': function(X, S) {
        return X !== S;
    },
    'P5s': function(X, S) {
        return X * S;
    },
    'h1': function() {
        cc.$.rotate = cc.$.hd ? function(X) {
            return "rotateZ(" + X + "deg) ";
        } : function(X) {
            return "rotate(" + X + "deg) ";
        };
    },
    'I08': function(X, S) {
        return X | S;
    },
    'Z6z': function(X, S) {
        return X - S;
    },
    'b8s': function(X, S) {
        return X == S;
    },
    'U1N': function(X, S) {
        return X / S;
    },
    'T0H': "CC_Random01",
    't6p': function(X, S) {
        return X < S;
    },
    'I7L': function(X, S) {
        return X * S;
    },
    'A2s': function(X, S) {
        return X == S;
    },
    'd6s': function(X, S) {
        return X <= S;
    },
    'M7l': function(X, S) {
        return X < S;
    },
    'F4L': function(X, S) {
        return X * S;
    },
    'I3M': function(X, S) {
        return X == S;
    },
    'd1q': function(X, S) {
        return X * S;
    },
    'n3A': function(X, S) {
        return X != S;
    },
    'e3S': "script",
    'v3G': function(X, S) {
        return X === S;
    },
    'J8M': function(X, S) {
        return X == S;
    },
    'G0l': function(X, S) {
        return X * S;
    },
    'n31': function(X, S) {
        return X * S;
    },
    'n7L': function(X, S) {
        return X * S;
    },
    'G88': function(X, S) {
        return X / S;
    },
    'l3j': function(X, S) {
        return X - S;
    },
    'i9f': function(X, S) {
        return X >= S;
    },
    's4v': function(X, S) {
        return X * S;
    },
    'N65': function(X, S) {
        return X == S;
    },
    'X7l': function(X, S) {
        return X < S;
    },
    'Q2G': function(X, S) {
        return X == S;
    },
    'g1z': function(X, S) {
        return X * S;
    },
    'c8A': function(X, S) {
        return X != S;
    },
    'E7G': function(X, S) {
        return X < S;
    },
    'y5M': function(X, S) {
        return X < S;
    },
    'y51': function(X, S) {
        return X * S;
    },
    'X1D': function(X, S) {
        return X - S;
    },
    'C0s': function(X, S) {
        return X * S;
    },
    'C3D': function(X, S, P) {
        return X * S * P;
    },
    'X1K': "a_texCoord",
    'F6u': function(X, S) {
        return X < S;
    },
    'F1j': function(X, S) {
        return X < S;
    },
    'w5M': function(X, S) {
        return X - S;
    },
    'R3u': function(X, S) {
        return X | S;
    },
    'E4D': function(X, S) {
        return X * S;
    },
    'C85': function(X, S) {
        return X * S;
    },
    'u2y': function() {
        Global.ShieldBool = !(1.393E3 > (103., 14.20E1) ? (54.7E1, 1) : (85., 32.) > 122.10E1 ? (0x1E6, 96.7E1) : 9.21E2 < (1.229E3, 0x61) ? 660 : (133, 3.02E2));
    },
    'h4a': function(X, S) {
        return X >= S;
    },
    'u2b': function(X, S) {
        return X / S;
    },
    'K3a': function(X, S) {
        return X * S;
    },
    't65': function(X, S) {
        return X - S;
    },
    'C1': function() {
        cc.$.hd = !1;
    },
    'G5T': function(X, S) {
        return X / S;
    },
    'U25': function(X, S) {
        return X < S;
    },
    'h9D': function(X, S) {
        return X < S;
    },
    'I9m': function(X, S) {
        return X == S;
    },
    'r5y': function(X) {
        cc.MENU_STATE_WAITING = X;
    },
    'o9y': function(X) {
        cc.SHADEREX_SWITCHMASK_FRAG = X;
    },
    'G75': function(X, S) {
        return X === S;
    },
    'E2N': function(X, S, P) {
        return X * S * P;
    },
    'c25': function(X, S) {
        return X == S;
    },
    'l3': function(X) {
        _M[_c.PIXEL_FORMAT_I8] = X;
    },
    'e7A': function(X, S) {
        return X >= S;
    },
    'f3G': function(X, S) {
        return X != S;
    },
    'N7q': function(X, S) {
        return X * S;
    },
    'y9a': function(X, S) {
        return X === S;
    },
    'R3p': function(X, S) {
        return X >= S;
    },
    'f68': function(X, S) {
        return X < S;
    },
    'i1b': function(X, S) {
        return X * S;
    },
    'L3G': function(X, S) {
        return X > S;
    },
    'A5': function() {
        cc.SPRITE_INDEX_NOT_INITIALIZED = -1;
    },
    'C8L': function(X, S) {
        return X - S;
    },
    'R5j': function(X, S) {
        return X - S;
    },
    'U3s': function(X, S) {
        return X * S;
    },
    'V0P': 218,
    'u1i': 80,
    'V8l': function(X, S) {
        return X <= S;
    },
    'V1w': function(X, S) {
        return X * S;
    },
    'A9B': function(X, S) {
        return X <= S;
    },
    'x7j': function(X, S) {
        return X < S;
    },
    't4s': function(X, S) {
        return X * S;
    },
    'm8y': function(X) {
        cc.PROGRESS_TEXTURE_COORDS = X;
    },
    'M4p': function(X, S) {
        return X >= S;
    },
    'C7f': function(X, S) {
        return X / S;
    },
    't3': function(X) {
        cc.ALIGN_LEFT = X;
    },
    'q2f': function(X, S) {
        return X !== S;
    },
    'A7u': function(X, S, P) {
        return X / S * P;
    },
    's0A': function(X, S) {
        return X != S;
    },
    'F56': function(X, S) {
        return X / S;
    },
    'A21': function(X, S, P) {
        return X - S + P;
    },
    'f23': function(X, S) {
        return X === S;
    },
    'A3l': function(X, S) {
        return X != S;
    },
    'H0d': function(X, S) {
        return X / S;
    },
    'X1l': function(X, S) {
        return X > S;
    },
    'A1d': function(X, S) {
        return X - S;
    },
    'I5T': function(X, S) {
        return X / S;
    },
    'x7l': function(X, S) {
        return X < S;
    },
    'Y0f': function(X, S) {
        return X | S;
    },
    'C1f': function(X, S) {
        return X / S;
    },
    'X3M': function(X, S) {
        return X * S;
    },
    'P7v': function(X, S) {
        return X != S;
    },
    'c2': function(X) {
        cc.kmPIUnder180 = X;
    },
    'J5y': function() {
        cc.MENU_HANDLER_PRIORITY = -128;
    },
    's3u': function(X, S) {
        return X < S;
    },
    'V02': function(X, S) {
        return X <= S;
    },
    'h6S': 190,
    'v6h': function(X, S) {
        return X === S;
    },
    'd98': function(X, S) {
        return X / S;
    },
    'V2y': function() {
        Global.ZombiePause = !(0xE7 <= (0x4C, 0x14A) ? (0x31, 1) : (0x16B, 1.481E3));
    },
    'n12': function(X, S) {
        return X / S;
    },
    'u8N': function(X, S) {
        return X instanceof S;
    },
    'M9G': function(X, S) {
        return X !== S;
    },
    'Q5m': function(X, S) {
        return X != S;
    },
    't1d': function(X, S) {
        return X * S;
    },
    'e9B': function(X, S) {
        return X * S;
    },
    'E3P': "m4a",
    'U9t': function(X, S) {
        return X != S;
    },
    'S9d': function(X, S) {
        return X - S;
    },
    'M9O': function(X) {
        KOOOO = X;
    },
    'P8E': function(X, S) {
        return X / S;
    },
    'D1B': function(X, S) {
        return X == S;
    },
    'p11': function(X, S) {
        return X / S;
    },
    'M0h': function(X, S) {
        return X * S;
    },
    'm5A': function(X, S) {
        return X != S;
    },
    'U1j': function(X, S) {
        return X > S;
    },
    'h9T': function(X, S) {
        return X * S;
    },
    'w1f': function(X, S) {
        return X | S;
    },
    'D7d': function(X, S) {
        return X / S;
    },
    'l9M': function(X, S) {
        return X / S;
    },
    'o7D': function(X, S) {
        return X * S;
    },
    'V4b': function(X, S) {
        return X * S;
    },
    'a0j': function(X, S) {
        return X === S;
    },
    'H9y': function(X) {
        cc.UNIFORM_MAX = X;
    },
    'q9M': function(X, S) {
        return X / S;
    },
    'Y9t': function(X, S) {
        return X == S;
    },
    'V4v': function(X, S) {
        return X < S;
    },
    'c3': function(X) {
        cc.ALIGN_BOTTOM = X;
    },
    'X9u': function(X, S, P, O) {
        return X * S * P * O;
    },
    'N1u': function(X, S) {
        return X < S;
    },
    'x03': function(X, S) {
        return X | S;
    },
    'V3i': "Cocos2d-html5-v3.0 alpha",
    'v0K': 256,
    'A4j': function(X, S) {
        return X > S;
    },
    'h2d': function(X, S) {
        return X == S;
    },
    'm7O': function(X, S) {
        return X < S;
    },
    'u3A': function(X, S) {
        return X != S;
    },
    'G2O': function(X, S) {
        return X === S;
    },
    'T2f': function(X, S) {
        return X / S;
    },
    'R02': function(X, S) {
        return X < S;
    },
    'o78': function(X, S) {
        return X * S;
    },
    'X63': function(X, S) {
        return X != S;
    },
    'd51': function(X, S) {
        return X * S;
    },
    'M8l': function(X, S) {
        return X > S;
    },
    'x1S': 4294967295,
    'L7N': function(X, S) {
        return X * S;
    },
    'r9y': function(X) {
        cc.VERTEX_ATTRIB_COLOR = X;
    },
    'p7T': function(X, S) {
        return X * S;
    },
    's5S': "childrenCount",
    'T6m': function(X, S) {
        return X * S;
    },
    'R73': function(X, S) {
        return X / S;
    },
    's1w': function(X, S) {
        return X * S;
    },
    's92': function(X, S) {
        return X != S;
    },
    'l2A': function(X, S) {
        return X < S;
    },
    'Q2N': function(X, S) {
        return X * S;
    },
    'B32': function(X, S) {
        return X > S;
    },
    'S2q': function(X, S) {
        return X * S;
    },
    'W0j': function(X, S) {
        return X & S;
    },
    'V9O': function() {
        ZOMBIES1 = [{
            health: 25,
            damage: 25,
            speed: 100,
            interval: 3
        }, {
            health: 25,
            damage: 25,
            speed: 100,
            interval: 3
        }, {
            health: 25,
            damage: 25,
            speed: 100,
            interval: 3
        }, {
            health: 25,
            damage: 50,
            speed: 150,
            interval: 3
        }, {
            health: 25,
            damage: 50,
            speed: 150,
            interval: 2.5
        }, {
            health: 25,
            damage: 75,
            speed: 150,
            interval: 2.5
        }, {
            health: 25,
            damage: 75,
            speed: 150,
            interval: 2.5
        }, {
            health: 25,
            damage: 100,
            speed: 150,
            interval: 2.5
        }, {
            health: 25,
            damage: 100,
            speed: 200,
            interval: 2.5
        }, {
            health: 25,
            damage: 125,
            speed: 200,
            interval: 2.5
        }, {
            health: 25,
            damage: 125,
            speed: 200,
            interval: 2.5
        }, {
            health: 25,
            damage: 150,
            speed: 200,
            interval: 2.5
        }, {
            health: 25,
            damage: 150,
            speed: 250,
            interval: 2.5
        }, {
            health: 25,
            damage: 175,
            speed: 250,
            interval: 2.5
        }, {
            health: 25,
            damage: 175,
            speed: 250,
            interval: 2.5
        }, {
            health: 25,
            damage: 200,
            speed: 250,
            interval: 2.5
        }, {
            health: 25,
            damage: 200,
            speed: 300,
            interval: 2
        }, {
            health: 25,
            damage: 225,
            speed: 300,
            interval: 2
        }, {
            health: 25,
            damage: 225,
            speed: 350,
            interval: 2
        }, {
            health: 25,
            damage: 225,
            speed: 400,
            interval: 2
        }];
    },
    'T9O': function(X) {
        MAX_THINKING_TIME_MS = X;
    },
    'h0H': "disabledImage",
    'o8s': function(X, S) {
        return X == S;
    },
    's2t': function(X, S) {
        return X >= S;
    },
    'S4P': "__cc_touch_all_at_once",
    'l1d': function(X, S) {
        return X == S;
    },
    'r2A': function(X, S) {
        return X != S;
    },
    'C2M': function(X, S) {
        return X - S;
    },
    'i1p': function(X, S) {
        return X === S;
    },
    'F7H': 8,
    'n8f': function(X, S) {
        return X / S;
    },
    'y3t': function(X, S) {
        return X == S;
    },
    'X3p': function(X, S) {
        return X - S;
    },
    'p1N': function(X, S) {
        return X & S;
    },
    'G0T': function(X, S) {
        return X == S;
    },
    'h93': function(X, S) {
        return X / S;
    },
    'E2G': function(X, S) {
        return X >>> S;
    },
    'f2l': function(X, S) {
        return X < S;
    },
    'x21': function(X, S) {
        return X * S;
    },
    'T2B': function(X, S, P) {
        return X * S / P;
    },
    'Z4l': function(X, S, P, O) {
        return X | S | P | O;
    },
    'i41': function(X, S) {
        return X !== S;
    },
    'Q71': function(X, S) {
        return X * S;
    },
    'B1b': function(X, S) {
        return X / S;
    },
    'p5D': function(X, S, P) {
        return X * S * P;
    },
    'W1m': function(X, S) {
        return X >= S;
    },
    'V2D': function(X, S) {
        return X * S;
    },
    'r3': function(X) {
        _c.PIXEL_FORMAT_RGB565 = X;
    },
    'u2E': function(X, S) {
        return X / S;
    },
    'a2B': function(X, S) {
        return X < S;
    },
    'r4w': function(X, S) {
        return X - S;
    },
    'D46': function(X, S) {
        return X == S;
    },
    'a0': function(X) {
        cc.EventTouch.MAX_TOUCHES = X;
    },
    'v9S': "]",
    'F7d': function(X, S) {
        return X / S;
    },
    'm4i': 1.5,
    'p63': function(X, S) {
        return X - S;
    },
    'H6s': function(X, S) {
        return X == S;
    },
    'Q98': function(X, S) {
        return X / S;
    },
    'T6u': function(X, S) {
        return X <= S;
    },
    'q73': function(X, S) {
        return X < S;
    },
    'n7': function(X) {
        cc.Event.TOUCH = X;
    },
    'U0A': function(X, S) {
        return X != S;
    },
    'v7E': function(X, S) {
        return X != S;
    },
    'g5': function(X) {
        _M[_c.PIXEL_FORMAT_RGBA4444] = X;
    },
    'w9B': function(X, S) {
        return X * S;
    },
    'F4s': function(X, S) {
        return X * S;
    },
    'y8S': "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}",
    'N2d': function(X, S) {
        return X > S;
    },
    'B2b': function(X, S) {
        return X / S;
    },
    'N0N': function(X, S) {
        return X * S;
    },
    'o0m': function(X, S) {
        return X * S;
    },
    'b3v': function(X, S) {
        return X instanceof S;
    },
    'X95': function(X, S) {
        return X * S;
    },
    'k1p': function(X, S) {
        return X === S;
    },
    'Z8E': function(X, S) {
        return X == S;
    },
    'n5B': function(X, S) {
        return X / S;
    },
    'G6N': function(X, S) {
        return X > S;
    },
    'W9f': function(X, S) {
        return X < S;
    },
    'C1q': function(X, S) {
        return X * S;
    },
    't4E': function(X, S) {
        return X | S;
    },
    'Y0q': function(X, S) {
        return X * S;
    },
    'k8y': function(X) {
        cc.IMAGE_FORMAT_PNG = X;
    },
    'h5f': function(X, S) {
        return X | S;
    },
    'e6D': function(X, S) {
        return X / S;
    },
    's62': function(X, S) {
        return X == S;
    },
    'v6d': function(X, S) {
        return X < S;
    },
    'P31': function(X, S) {
        return X * S;
    },
    'D5a': function(X, S) {
        return X * S;
    },
    'j0G': function(X, S) {
        return X * S;
    },
    'V35': function(X, S) {
        return X == S;
    },
    'f1L': function(X, S) {
        return X > S;
    },
    's9t': function(X, S) {
        return X >= S;
    },
    'k2q': function(X, S) {
        return X * S;
    },
    'D8s': function(X, S) {
        return X - S;
    },
    'Q4D': function(X, S) {
        return X === S;
    },
    'u4G': function(X, S) {
        return X < S;
    },
    'Y3M': function(X, S) {
        return X < S;
    },
    'W6M': function(X, S) {
        return X * S;
    },
    'n4G': function(X, S) {
        return X < S;
    },
    'm1': function() {
        cc.$.hd = !0;
    },
    'J2y': function() {
        lg = lg || {};
    },
    'd7f': function(X, S) {
        return X == S;
    },
    'd28': function(X, S) {
        return X < S;
    },
    'Q2h': function(X, S) {
        return X == S;
    },
    'U9i': 16,
    'o9t': function(X, S) {
        return X == S;
    },
    'a06': function(X, S) {
        return X == S;
    },
    'Y3z': function(X, S) {
        return X != S;
    },
    'A8L': function(X, S) {
        return X - S;
    },
    'z5h': function(X, S, P) {
        return X * S / P;
    },
    'W1S': 3.141592,
    'w1q': function(X, S) {
        return X * S;
    },
    'F25': function(X, S) {
        return X < S;
    },
    'i7P': "verticalAlign",
    'z7b': function(X, S, P) {
        return X * S * P;
    },
    'j3i': "flippedY",
    'i12': function(X, S) {
        return X / S;
    },
    'l5': function(X) {
        cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = X;
    },
    'p4N': function(X, S) {
        return X * S;
    },
    'c8h': function(X, S) {
        return X === S;
    },
    'K5w': function(X, S) {
        return X === S;
    },
    's6H': 536870912,
    'p1B': function(X, S) {
        return X > S;
    },
    's6b': function(X, S) {
        return X / S;
    },
    'j03': function(X, S) {
        return X | S;
    },
    'R5a': function(X, S) {
        return X * S;
    },
    'U2w': function(X, S) {
        return X === S;
    },
    'y7O': function(X, S) {
        return X == S;
    },
    'h53': function(X, S) {
        return X * S;
    },
    'm4l': function(X, S) {
        return X << S;
    },
    'm6l': function(X, S) {
        return X !== S;
    },
    'c6M': function(X, S) {
        return X < S;
    },
    'f8b': function(X, S, P) {
        return X - S + P;
    },
    'a1L': function(X, S) {
        return X < S;
    },
    'l8t': function(X, S) {
        return X < S;
    },
    'l5m': function(X, S) {
        return X < S;
    },
    'M0f': function(X, S) {
        return X === S;
    },
    'c6q': function(X, S) {
        return X * S;
    },
    'd4i': 1.70158,
    'Q52': function(X, S) {
        return X != S;
    },
    'k9z': function(X, S) {
        return X * S;
    },
    'B9h': function(X, S) {
        return X === S;
    },
    'B06': function(X, S) {
        return X >= S;
    },
    'y9T': function(X, S) {
        return X * S;
    },
    's7D': function(X, S) {
        return X > S;
    },
    'K7O': function(X, S) {
        return X == S;
    },
    'V11': function(X, S) {
        return X != S;
    },
    't3d': function(X, S) {
        return X / S;
    },
    'x5P': 999999,
    'V4p': function(X, S) {
        return X - S;
    },
    'y3y': function() {
        cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS = -1;
    },
    'M83': function(X, S) {
        return X * S;
    },
    'I4O': function(X, S) {
        return X / S;
    },
    'e4a': function(X, S) {
        return X == S;
    },
    'U02': function(X, S) {
        return X - S;
    },
    'e2y': function(X) {
        lg._orientationTip = X;
    },
    'H0l': function(X, S) {
        return X - S;
    },
    'l4l': function(X, S) {
        return X < S;
    },
    'l4w': function(X, S) {
        return X * S;
    },
    'f3M': function(X, S) {
        return X / S;
    },
    'X18': function(X, S) {
        return X != S;
    },
    'H1P': "shadowOffsetX",
    'y3P': "res/a10/a10_logo_3.png",
    'w7O': function(X, S) {
        return X == S;
    },
    'U6b': function(X, S) {
        return X / S;
    },
    'f6G': function(X, S) {
        return X | S;
    },
    'e5O': function(X, S) {
        return X > S;
    },
    'A2A': function(X, S) {
        return X != S;
    },
    'q5u': function(X, S, P) {
        return X * S * P;
    },
    'M0q': function(X, S) {
        return X * S;
    },
    'N2A': function(X, S) {
        return X instanceof S;
    },
    'r8v': function(X, S) {
        return X == S;
    },
    'p0G': function(X, S) {
        return X > S;
    },
    'S8w': function(X, S) {
        return X * S;
    },
    'g9l': function(X, S) {
        return X < S;
    },
    'v7L': function(X, S) {
        return X * S;
    },
    'p3v': function(X, S) {
        return X * S;
    },
    'm1s': function(X, S) {
        return X < S;
    },
    'T2v': function(X, S) {
        return X != S;
    },
    'V25': function(X, S) {
        return X < S;
    },
    'M81': function(X, S) {
        return X !== S;
    },
    'V56': function(X, S) {
        return X / S;
    },
    'g5w': function(X, S) {
        return X === S;
    },
    'n2O': function(X, S) {
        return X === S;
    },
    'N9M': function(X, S) {
        return X - S;
    },
    'C9N': function(X, S, P, O) {
        return X | S | P | O;
    },
    'k3q': function(X, S) {
        return X * S;
    },
    'z1N': function(X, S) {
        return X < S;
    },
    'A3D': function(X, S) {
        return X / S;
    },
    'X01': function(X, S) {
        return X * S;
    },
    'i2m': function(X, S, P) {
        return X * S * P;
    },
    'D03': function(X, S) {
        return X < S;
    },
    'O3A': function(X, S) {
        return X != S;
    },
    'b7T': function(X, S) {
        return X * S;
    },
    'Z5z': function(X, S) {
        return X % S;
    },
    'z3p': function(X, S) {
        return X & S;
    },
    'r1q': function(X, S) {
        return X * S;
    },
    'K7A': function(X, S) {
        return X / S;
    },
    'o8d': function(X, S) {
        return X === S;
    },
    'U8s': function(X, S) {
        return X == S;
    },
    'x1j': function(X, S) {
        return X <= S;
    },
    'g93': function(X, S) {
        return X / S;
    },
    'Q6h': function(X, S) {
        return X / S;
    },
    'P55': function(X, S) {
        return X < S;
    },
    'I9d': function(X, S) {
        return X * S;
    },
    'm4H': function(X, S) {
        return X == S;
    },
    'H4': function(X) {
        cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = X;
    },
    'P4m': function(X, S) {
        return X == S;
    },
    'm6h': function(X, S, P) {
        return X * S / P;
    },
    'F8d': function(X, S) {
        return X | S;
    },
    'Q1P': "ShaderPosition_uColor",
    'A48': function(X, S) {
        return X | S;
    },
    'y1f': function(X, S) {
        return X * S;
    },
    'h2p': function(X, S) {
        return X === S;
    },
    'L4s': function(X, S, P) {
        return X * S * P;
    },
    'v2j': function(X, S) {
        return X - S;
    },
    'r4d': function(X, S) {
        return X | S;
    },
    'z5y': function(X) {
        cc._globalFontName = X;
    },
    'Z7p': function(X, S) {
        return X - S;
    },
    'C6': function(X) {
        cc.LabelTTF.__labelHeightDiv.style.left = X;
    },
    'U1a': function(X, S) {
        return X / S;
    },
    'N53': function(X, S) {
        return X != S;
    },
    'a9m': function(X, S) {
        return X < S;
    },
    'M25': function(X, S) {
        return X < S;
    },
    't4w': function(X, S) {
        return X | S;
    },
    'A13': function(X, S) {
        return X * S;
    },
    'o18': function(X, S) {
        return X === S;
    },
    'e2p': function(X, S) {
        return X === S;
    },
    'L2j': function(X, S) {
        return X === S;
    },
    'u8j': function(X, S) {
        return X << S;
    },
    'I82': function(X, S) {
        return X - S;
    },
    'b1a': function(X, S) {
        return X / S;
    },
    'A3j': function(X, S) {
        return X > S;
    },
    'C9u': function(X, S) {
        return X < S;
    },
    'x83': function(X, S) {
        return X * S;
    },
    'J15': function(X, S) {
        return X * S;
    },
    'd1f': function(X, S) {
        return X == S;
    },
    'd6': function(X) {
        cc.Director.EVENT_AFTER_VISIT = X;
    },
    'X56': function(X, S) {
        return X < S;
    },
    'u3m': function(X, S) {
        return X >= S;
    },
    'z6m': function(X, S) {
        return X !== S;
    },
    'N52': function(X, S) {
        return X != S;
    },
    'q6p': function(X, S) {
        return X < S;
    },
    'I6': function(X) {
        cc.KM_FALSE = X;
    },
    'K7B': function(X, S) {
        return X / S;
    },
    'P9u': function(X, S) {
        return X - S;
    },
    'u0': function(X) {
        cc.NODE_ON_ENTER = X;
    },
    'n2b': function(X, S) {
        return X == S;
    },
    'b3S': "volume",
    'v2b': function(X, S) {
        return X / S;
    },
    'X0z': function(X, S) {
        return X < S;
    },
    'h9': function(X) {
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = X;
    },
    'h9u': function(X, S, P) {
        return X * S * P;
    },
    'L0H': "glServerState",
    'd3w': function(X, S) {
        return X < S;
    },
    'B76': function(X, S) {
        return X != S;
    },
    'D61': function(X, S) {
        return X * S;
    },
    'g7O': function(X, S) {
        return X / S;
    },
    'M73': function(X, S) {
        return X / S;
    },
    'L8S': "anchorY",
    'x4v': function(X, S) {
        return X == S;
    },
    'N9l': function(X, S) {
        return X < S;
    },
    'p1D': function(X, S) {
        return X == S;
    },
    'k8j': function(X, S) {
        return X < S;
    },
    'k5D': function(X, S, P) {
        return X * S * P;
    },
    'X1y': function(X) {
        cc.SHADER_POSITION_TEXTURE = X;
    },
    't7B': function(X, S) {
        return X / S;
    },
    'd9E': function(X, S) {
        return X < S;
    },
    'Y3L': function(X, S) {
        return X == S;
    },
    'F7l': function(X, S) {
        return X * S;
    },
    'Q65': function(X, S) {
        return X != S;
    },
    'K93': function(X, S) {
        return X - S;
    },
    'K1s': function(X, S) {
        return X < S;
    },
    'j9G': function(X, S) {
        return X - S;
    },
    'T9G': function(X, S) {
        return X == S;
    },
    'X3': function(X) {
        cc.ALIGN_TOP_RIGHT = X;
    },
    'h9H': function(X, S) {
        return X - S;
    },
    'B9q': function(X, S) {
        return X * S;
    },
    'K4H': function(X, S) {
        return X == S;
    },
    'd1m': function(X, S, P) {
        return X * S * P;
    },
    'I1p': function(X, S) {
        return X - S;
    },
    'S0T': function(X, S) {
        return X * S;
    },
    'J5z': function(X, S) {
        return X - S;
    },
    'k3b': function(X, S) {
        return X != S;
    },
    'r6w': function(X, S) {
        return X * S;
    },
    'N0p': function(X, S) {
        return X - S;
    },
    'B31': function(X, S) {
        return X * S;
    },
    'R4E': function(X, S) {
        return X / S;
    },
    'r6s': function(X, S) {
        return X * S;
    },
    's8l': function(X, S) {
        return X === S;
    },
    'W9S': "res/music/end.mp3",
    'u41': function(X, S) {
        return X * S;
    },
    'p6A': function(X, S) {
        return X == S;
    },
    'O5i': "Zombie",
    'd0u': function(X, S, P) {
        return X / S * P;
    },
    'B5y': function(X) {
        cc.DISABLE_TAG = X;
    },
    'f7v': function(X, S) {
        return X == S;
    },
    'h36': function(X, S) {
        return X * S;
    },
    'F6': function(X) {
        cc.kmEnum = X;
    },
    'H3O': function(X, S) {
        return X == S;
    },
    'L2O': function(X, S) {
        return X < S;
    },
    'g53': function(X, S) {
        return X !== S;
    },
    'H1v': function(X, S) {
        return X == S;
    },
    'K0': function(X) {
        cc.EventMouse.BUTTON_4 = X;
    },
    'H31': function(X, S) {
        return X * S;
    },
    'F5d': function(X, S) {
        return X < S;
    },
    'F12': function(X, S) {
        return X / S;
    },
    'r7O': function(X, S) {
        return X == S;
    },
    'u3O': function(X, S) {
        return X == S;
    },
    'A6w': function(X, S) {
        return X * S;
    },
    'R7t': function(X, S) {
        return X >= S;
    },
    'Y03': function(X, S) {
        return X | S;
    },
    'Z9A': function(X, S) {
        return X == S;
    },
    'Z88': function(X, S) {
        return X != S;
    },
    'Q2d': function(X, S) {
        return X == S;
    },
    'h6T': function(X, S, P) {
        return X * S * P;
    },
    'a6d': function(X, S) {
        return X === S;
    },
    'd5w': function(X, S) {
        return X | S;
    },
    'A38': function(X, S) {
        return X < S;
    },
    'P33': function(X, S) {
        return X !== S;
    },
    'r48': function(X, S) {
        return X < S;
    },
    'Q4M': function(X, S, P, O) {
        return X * S * P / O;
    },
    's5d': function(X, S) {
        return X == S;
    },
    'q91': function(X, S) {
        return X * S;
    },
    'F03': function(X, S) {
        return X | S;
    },
    'i8i': "bottom",
    'j8l': function(X, S) {
        return X < S;
    },
    'k7v': function(X, S) {
        return X < S;
    },
    'T45': function(X, S) {
        return X == S;
    },
    'z3T': function(X, S) {
        return X * S;
    },
    'q4w': function(X, S) {
        return X * S;
    },
    'z8P': "].",
    'c6B': function(X, S) {
        return X * S;
    },
    'x0f': function(X, S) {
        return X > S;
    },
    'u16': function(X, S) {
        return X * S;
    },
    'I3y': function(X) {
        cc.PARTICLE_TYPE_RELATIVE = X;
    },
    'L8H': function(X, S) {
        return X == S;
    },
    'b96': function(X, S) {
        return X == S;
    },
    'h2a': function(X, S) {
        return X - S;
    },
    'V4t': function(X, S) {
        return X < S;
    },
    'S8B': function(X, S) {
        return X !== S;
    },
    'C5t': function(X, S) {
        return X !== S;
    },
    'O0D': function(X, S) {
        return X < S;
    },
    'f4A': function(X, S) {
        return X == S;
    },
    'P22': function(X, S) {
        return X < S;
    },
    'C5m': function(X, S) {
        return X * S;
    },
    'a6N': function(X, S) {
        return X == S;
    },
    'Q3w': function(X, S) {
        return X * S;
    },
    'T62': function(X, S) {
        return X < S;
    },
    'v2T': function(X, S) {
        return X * S;
    },
    'c1M': function(X, S) {
        return X * S;
    },
    'L8D': function(X, S) {
        return X instanceof S;
    },
    'C2y': function(X) {
        Global.PauseDate = X;
    },
    'X3v': function(X, S) {
        return X < S;
    },
    'O55': function(X, S) {
        return X === S;
    },
    'M11': function(X, S) {
        return X < S;
    },
    'b3E': function(X, S) {
        return X < S;
    },
    'C4d': function(X, S) {
        return X === S;
    },
    'y91': function(X, S) {
        return X * S;
    },
    'e0N': function(X, S) {
        return X * S;
    },
    'Y0M': function(X, S) {
        return X * S;
    },
    'M78': function(X, S) {
        return X & S;
    },
    'C4l': function(X, S) {
        return X === S;
    },
    'T8u': function(X, S) {
        return X - S;
    },
    'Y3p': function(X, S) {
        return X >= S;
    },
    'q4T': function(X, S) {
        return X - S;
    },
    'e8p': function(X, S) {
        return X - S;
    },
    'J26': function(X, S) {
        return X == S;
    },
    'k08': function(X, S) {
        return X == S;
    },
    'x1B': function(X, S) {
        return X != S;
    },
    'O9N': function(X, S) {
        return X * S;
    },
    'C2p': function(X, S) {
        return X - S;
    },
    'U9N': function(X, S) {
        return X == S;
    },
    'O9q': function(X, S) {
        return X * S;
    },
    'x8K': 12288,
    'Z22': function(X, S) {
        return X - S;
    },
    'R1j': function(X, S) {
        return X | S;
    },
    'w6s': function(X, S) {
        return X <= S;
    },
    'S4O': function(X, S) {
        return X == S;
    },
    'R5S': "ShaderPositionTexture",
    'E85': function(X, S) {
        return X * S;
    },
    'X4L': function(X, S) {
        return X > S;
    },
    'l9H': function(X, S) {
        return X < S;
    },
    'U0m': function(X, S) {
        return X < S;
    },
    'b6y': function(X) {
        MAX_IN_TILE = X;
    },
    'O5T': function(X, S) {
        return X > S;
    },
    'H6d': function(X, S) {
        return X >= S;
    },
    'Q3t': function(X, S) {
        return X !== S;
    },
    'p7j': function(X, S) {
        return X * S;
    },
    'd5y': function(X) {
        cc._globalFontSize = X.ITEM_SIZE;
    },
    'e1q': function(X, S) {
        return X * S;
    },
    'Y9i': 30,
    'f75': function(X, S) {
        return X == S;
    },
    'J4q': function(X, S) {
        return X * S;
    },
    's3B': function(X, S) {
        return X * S;
    },
    'P9A': function(X, S) {
        return X != S;
    },
    'f1p': function(X, S) {
        return X >= S;
    },
    'u2j': function(X, S) {
        return X !== S;
    },
    'g5f': function(X, S) {
        return X == S;
    },
    'u4z': function(X, S) {
        return X - S;
    },
    'Y2v': function(X, S) {
        return X != S;
    },
    'A85': function(X, S) {
        return X * S;
    },
    'h5S': "startOpacity",
    'w3l': function(X, S) {
        return X === S;
    },
    'H3b': function(X, S) {
        return X - S;
    },
    'm91': function(X, S) {
        return X - S;
    },
    'c7K': "jpeg",
    'A4D': function(X, S) {
        return X * S;
    },
    'f55': function(X, S) {
        return X != S;
    },
    'Q8y': function(X) {
        cc.ClippingNode._sharedCache = X;
    },
    'U9G': function(X, S) {
        return X instanceof S;
    },
    'd93': function(X, S) {
        return X - S;
    },
    'm0s': function(X, S) {
        return X * S;
    },
    'o3v': function(X, S) {
        return X * S;
    },
    'N9K': "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    'k76': function(X, S) {
        return X == S;
    },
    'i2u': function(X, S) {
        return X & S;
    },
    'z25': function(X, S) {
        return X == S;
    },
    'B0d': function(X, S) {
        return X / S;
    },
    'W3y': function(X) {
        cc.PARTICLE_TEXTURE_MODE = X;
    },
    'H2q': function(X, S) {
        return X * S;
    },
    'U7a': function(X, S) {
        return X * S;
    },
    'O6j': function(X, S) {
        return X >= S;
    },
    'U18': function(X, S) {
        return X === S;
    },
    'z3B': function(X, S) {
        return X < S;
    },
    'F7': function(X) {
        cc.EventMouse.SCROLL = X;
    },
    's8z': function(X, S) {
        return X * S;
    },
    'T95': function(X, S) {
        return X < S;
    },
    'j6b': function(X, S) {
        return X / S;
    },
    'H9s': function(X, S) {
        return X / S;
    },
    'J2O': function(X, S) {
        return X === S;
    },
    'e38': function(X, S) {
        return X << S;
    },
    'V4': function(X) {
        cc.TEXT_ALIGNMENT_CENTER = X;
    },
    'b4t': function(X, S) {
        return X < S;
    },
    'z1': function(X) {
        cc.USE_LA88_LABELS = X;
    },
    'E2A': function(X, S) {
        return X != S;
    },
    'x0A': function(X, S) {
        return X < S;
    },
    'c0b': function(X, S) {
        return X < S;
    },
    'F1a': function(X, S) {
        return X / S;
    },
    'j0H': "CC_alpha_value",
    'x3T': function(X, S) {
        return X * S;
    },
    'G5v': function(X, S) {
        return X in S;
    },
    'S75': function(X, S) {
        return X == S;
    },
    'I4z': function(X, S) {
        return X === S;
    },
    'c6m': function(X, S) {
        return X !== S;
    },
    'p8d': function(X, S) {
        return X == S;
    },
    'P4u': function(X, S) {
        return X | S;
    },
    'p7H': "ExportJson",
    'R5d': function(X, S) {
        return X !== S;
    },
    'v4G': function(X, S) {
        return X < S;
    },
    'Q2y': function() {
        lg = lg || {};
    },
    'S6a': function(X, S) {
        return X - S;
    },
    'J9f': function(X, S) {
        return X | S;
    },
    'Z2q': function(X, S) {
        return X * S;
    },
    'g9a': function(X, S) {
        return X | S;
    },
    'C0B': function(X, S) {
        return X < S;
    },
    'Z2j': function(X, S) {
        return X > S;
    },
    'd6i': "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d",
    'W7N': function(X, S) {
        return X * S;
    },
    'b4b': function(X, S) {
        return X * S;
    },
    'b6H': "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}",
    'E6L': function(X, S) {
        return X > S;
    },
    'b9L': function(X, S) {
        return X * S;
    },
    'P6i': "center",
    'R01': function(X, S) {
        return X / S;
    },
    'g2a': function(X, S) {
        return X * S;
    },
    'm9y': function(X) {
        cc.UNIFORM_PMATRIX = X;
    },
    'q1z': function(X, S) {
        return X * S;
    },
    'm6E': function(X, S) {
        return X * S;
    },
    'H76': function(X, S) {
        return X != S;
    },
    'u08': function(X, S) {
        return X < S;
    },
    'a8D': function(X, S) {
        return X instanceof S;
    },
    'C5l': function(X, S) {
        return X >= S;
    },
    'Q38': function(X, S) {
        return X < S;
    },
    'U3v': function(X, S) {
        return X instanceof S;
    },
    'g7A': function(X, S) {
        return X / S;
    },
    'q5O': function(X, S) {
        return X < S;
    },
    'O5p': function(X, S) {
        return X >= S;
    },
    'K8p': function(X, S) {
        return X - S;
    },
    'U9L': function(X, S) {
        return X * S;
    },
    'N1q': function(X, S) {
        return X * S;
    },
    'B2': function(X) {
        cc.KM_PLANE_FAR = X;
    },
    'S8N': function(X, S) {
        return X | S;
    },
    'e4j': function(X, S) {
        return X < S;
    },
    'L2B': function(X, S) {
        return X != S;
    },
    'n0u': function(X, S) {
        return X * S;
    },
    'p58': function(X, S) {
        return X == S;
    },
    'U5N': function(X, S) {
        return X * S;
    },
    's6O': function(X, S) {
        return X == S;
    },
    'l6t': function(X, S) {
        return X * S;
    },
    'C5A': function(X, S) {
        return X == S;
    },
    'N48': function(X, S) {
        return X | S;
    },
    'N28': function(X, S) {
        return X >= S;
    },
    'B2u': function(X, S) {
        return X != S;
    },
    'w2A': function(X, S) {
        return X == S;
    },
    'i4M': function(X, S, P, O) {
        return X * S * P / O;
    },
    'S08': function(X, S) {
        return X <= S;
    },
    'U4v': function(X, S) {
        return X == S;
    },
    'l6L': function(X, S) {
        return X > S;
    },
    'J6': function(X) {
        cc.LabelTTF._reverseCheckRegEx = X;
    },
    't4j': function(X, S) {
        return X & S;
    },
    'v8w': function(X, S) {
        return X == S;
    },
    'q1u': function(X, S) {
        return X - S;
    },
    'P21': function(X, S, P) {
        return X - S + P;
    },
    'v0l': function(X, S) {
        return X - S;
    },
    'N1s': function(X, S) {
        return X == S;
    },
    'N9T': function(X, S) {
        return X * S;
    },
    'e71': function(X, S) {
        return X === S;
    },
    'z9j': function(X, S) {
        return X / S;
    },
    'r8m': function(X, S) {
        return X - S;
    },
    'W3m': function(X, S) {
        return X * S;
    },
    't1f': function(X, S) {
        return X > S;
    },
    'i9G': function(X, S) {
        return X % S;
    },
    'c3T': function(X, S) {
        return X * S;
    },
    'P6': function(X) {
        cc.Director.sharedDirector = X;
    },
    'y9j': function(X, S) {
        return X < S;
    },
    'J1b': function(X, S, P) {
        return X * S * P;
    },
    'X2D': function(X, S) {
        return X < S;
    },
    'W5B': function(X, S) {
        return X / S;
    },
    'S6N': function(X, S) {
        return X < S;
    },
    'E6s': function(X, S, P) {
        return X - S + P;
    },
    'o6b': function(X, S) {
        return X === S;
    },
    'a9z': function(X, S) {
        return X * S;
    },
    'P88': function(X, S) {
        return X != S;
    },
    'w7q': function(X, S) {
        return X * S;
    },
    'e8M': function(X, S) {
        return X == S;
    },
    'b4P': "vertexZ",
    'B8D': function(X, S) {
        return X * S;
    },
    'I3q': function(X, S) {
        return X * S;
    },
    'Q3l': function(X, S) {
        return X * S;
    },
    'R4N': function(X, S) {
        return X * S;
    },
    'P2O': function(X, S) {
        return X == S;
    },
    'k5L': function(X, S) {
        return X * S;
    },
    'B7s': function(X, S) {
        return X * S;
    },
    'Q4S': "eot",
    'f1t': function(X, S) {
        return X - S;
    },
    'a4l': function(X, S) {
        return X << S;
    },
    'i8N': function(X, S) {
        return X < S;
    },
    't6s': function(X, S) {
        return X <= S;
    },
    'K5l': function(X, S) {
        return X !== S;
    },
    'q2p': function(X, S) {
        return X < S;
    },
    'R3h': function(X, S) {
        return X !== S;
    },
    'V4N': function(X, S) {
        return X * S;
    },
    'h1u': function(X, S) {
        return X - S;
    },
    'y86': function(X, S) {
        return X == S;
    },
    'M2w': function(X, S) {
        return X === S;
    },
    'g1m': function(X, S) {
        return X * S;
    },
    'i55': function(X, S) {
        return X != S;
    },
    'B2O': function(X, S) {
        return X === S;
    },
    'L7E': function(X, S) {
        return X == S;
    },
    'w6D': function(X, S) {
        return X / S;
    },
    'L3f': function(X, S) {
        return X < S;
    },
    'G3q': function(X, S) {
        return X * S;
    },
    'i5p': function(X, S) {
        return X >= S;
    },
    'W0P': ",",
    'v55': function(X, S) {
        return X < S;
    },
    'F81': function(X, S) {
        return X !== S;
    },
    'g86': function(X, S) {
        return X - S;
    },
    'K3d': function(X, S) {
        return X / S;
    },
    'H9f': function(X, S) {
        return X * S;
    },
    'F6T': function(X, S) {
        return X - S;
    },
    'h0v': function(X, S) {
        return X < S;
    },
    'N2h': function(X, S) {
        return X == S;
    },
    'j78': function(X, S) {
        return X * S;
    },
    'U7w': function(X, S) {
        return X % S;
    },
    'H0L': function(X, S, P) {
        return X * S * P;
    },
    'l5l': function(X, S) {
        return X / S;
    },
    'i02': function(X, S) {
        return X < S;
    },
    'Z16': function(X, S) {
        return X * S;
    },
    'K9M': function(X, S) {
        return X - S;
    },
    'A5A': function(X, S) {
        return X == S;
    },
    'D1i': "fnt",
    'E9a': function(X, S) {
        return X * S;
    },
    'F6P': "mainCollider",
    'B4O': function(X, S) {
        return X > S;
    },
    'J4O': function(X, S) {
        return X == S;
    },
    'D1H': function(X, S) {
        return X - S;
    },
    'P0S': 180,
    'M7P': "GRAY",
    'I5w': function(X, S) {
        return X < S;
    },
    'Y9j': function(X, S) {
        return X < S;
    },
    'M4S': 0.017453,
    'G2': function(X) {
        cc.KM_GL_PROJECTION = X;
    },
    'h1y': function(X) {
        cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = X;
    },
    'I6y': function(X) {
        lg.version = X;
    },
    'X7f': function(X, S, P) {
        return X / S * P;
    },
    'd9B': function(X, S) {
        return X * S;
    },
    'Z7E': function(X, S) {
        return X >= S;
    },
    'H0j': function(X, S) {
        return X < S;
    },
    'K1d': function(X, S) {
        return X * S;
    },
    'r3l': function(X, S) {
        return X < S;
    },
    'R9v': function(X, S) {
        return X == S;
    },
    'A2h': function(X, S) {
        return X == S;
    },
    'K5A': function(X, S) {
        return X > S;
    },
    'h5A': function(X, S) {
        return X == S;
    },
    'E2y': function(X) {
        Global.BingMove = X;
    },
    'y3j': function(X, S) {
        return X > S;
    },
    'H5P': 1E4,
    'x5N': function(X, S) {
        return X * S;
    },
    'n9A': function(X, S) {
        return X != S;
    },
    'Z7': function(X) {
        cc.UIInterfaceOrientationPortrait = X;
    },
    'Y2B': function(X, S) {
        return X == S;
    },
    'O22': function(X, S) {
        return X < S;
    },
    'F9N': function(X, S) {
        return X < S;
    },
    'M5N': function(X, S) {
        return X < S;
    },
    'Q9': function(X) {
        cc._gameDiv = X;
    },
    'm5f': function(X, S) {
        return X / S;
    },
    'o3': function(X) {
        _c.PIXEL_FORMAT_RGBA8888 = X;
    },
    'L4z': function(X, S) {
        return X * S;
    },
    'I3l': function(X, S) {
        return X === S;
    },
    'D63': function(X, S) {
        return X != S;
    },
    'w4s': function(X, S, P) {
        return X / S * P;
    },
    'E6v': function(X, S) {
        return X == S;
    },
    'I8y': function() {
        cc.Codec.GZip.bitReverse = [((55, 0x173) <= (115., 4.24E2) ? (119., 0) : (0x70, 0xD1)), 128, ((85.2E1, 109.) <= (52.40E1, 0x23C) ? (116.7E1, 64) : (0x2B, 1.02E3)), 192, (0x7D > (0x3B, 84.) ? (0x249, 32) : (15, 4.)), 160, 96, 224, 16, (6.96E2 > (71.8E1, 0xD) ? (5.47E2, 144) : (0xD1, 40.7E1)), 80, ((118, 20) <= 14.14E2 ? (135., 208) : (0x1C1, 0x245)), 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, ((91, 0x74) <= 11.67E2 ? (142., 232) : (109., 1.2E2) > 12.620E2 ? "F" : (0x199, 137.) < 95 ? (5., 'F') : (39, 0x248)), 24, 152, 88, 216, 56, 184, ((1, 0x96) < 149 ? "ko" : (38, 0x201) < (0x118, 1.26E3) ? (0xE1, 120) : (0x6D, 19.5E1)), 248, 4, 132, 68, 196, (131 >= (128, 100) ? (101., 36) : (54, 5.79E2)), 164, 100, 228, 20, 148, ((5.270E2, 0x189) > 118. ? (21, 84) : (20.3E1, 12.9E1) > (0x238, 0xDE) ? (0x64, 58) : (0x5B, 60.90E1) <= 0x198 ? 91 : (32, 5.43E2)), (0x218 <= (66., 0x180) ? 'j' : 10.28E2 > (6.97E2, 0x125) ? (0x25, 212) : (0x199, 7) > (3.9E2, 56) ? 137 : (34, 0x16F)), 52, 180, 116, 244, (0x241 <= (77, 0x1D2) ? (2.66E2, " x ") : (54., 0x12C) > 1.28E2 ? (29, 12) : 0x15A <= (5.12E2, 144) ? (68., 0x76) : (0x13F, 0x179)), 140, 76, (92. >= (0x107, 59) ? (110, 204) : (0x8E, 2.760E2)), 44, 172, 108, ((0x103, 0xF2) < (90, 0x14F) ? (0x80, 236) : (142., 0xA3)), 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, ((10.69E2, 0x1CE) >= 0x94 ? (38, 226) : (108.9E1, 40)), (0x248 > (11., 68) ? (13.70E1, 18) : (1.640E2, 0x6A)), ((0x19E, 0xF8) < (6.09E2, 146.) ? 'M' : 25 > (134, 24) ? (0x43, 146) : (5.18E2, 88.80E1)), ((0x213, 45) <= 36 ? (2., 7.53E2) : 1.065E3 > (84.30E1, 0x213) ? (37, 82) : (0x21A, 59.40E1)), 210, 50, (92.30E1 <= (2.84E2, 0x188) ? (0x161, 120) : 1.16E2 < (0x1B1, 0x194) ? (0x6C, 178) : (5.01E2, 0xE6)), 114, 242, 10, ((0x79, 1.262E3) > 79 ? (5E0, 138) : (4., 15.)), (0xEF >= (146, 36.) ? (143., 74) : 0x15F > (98., 8.19E2) ? 147. : (64., 53.)), 202, ((0x1DB, 0x6F) <= 0x1D2 ? (0x8C, 42) : 118. > (117, 5.770E2) ? "O" : (5.05E2, 26) > 0x19D ? 98.9E1 : (88., 0x51)), ((12.17E2, 147) <= 108 ? (105, 89.) : (18., 0x1E5) > (148, 1.482E3) ? 'R' : 93. >= (0xB1, 25) ? (80, 170) : (0x19, 53.30E1)), 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, ((141, 64.) >= 44.90E1 ? (136, 96.5E1) : (0xD2, 0x3F) > 14.05E2 ? (57, "A") : 0x24E >= (109, 144.) ? (143, 182) : (0x11D, 94.4E1)), ((125, 112) < (69.2E1, 0xBD) ? (0x160, 118) : (47, 104)), ((87.80E1, 0x10E) >= 140.20E1 ? (36.80E1, 206) : (72, 9.21E2) >= 107. ? (1.3840E3, 246) : (0x62, 31)), 14, 142, 78, 206, 46, ((100., 76) <= 5.53E2 ? (9.700E2, 174) : (0x1BD, 0x14B)), 110, 238, (0x42 <= (27.3E1, 24) ? (7., 111) : (113, 5) <= 0xCE ? (0x1AB, 30) : (115., 0x8E)), 158, 94, 222, 62, 190, 126, 254, 1, 129, ((0x172, 0x50) > (128.3E1, 27.) ? (0xBB, 65) : 110.10E1 <= (1.3880E3, 43) ? "R" : (0x33, 0x87) >= (4.3E2, 0x21B) ? "R" : (13.030E2, 0x7E)), 193, 33, 161, 97, 225, (140. <= (65, 0x1EC) ? (8.1E2, 17) : (0x36, 0x154) < 3.6E1 ? (0xC3, 182) : (137, 1.6E1)), 145, ((53.40E1, 0x46) > 113. ? 'I' : (42, 21.) < (0x90, 2.32E2) ? (53, 81) : 10.32E2 <= (1.311E3, 7.87E2) ? 81 : (92, 143)), 209, 49, 177, (104. <= (1.462E3, 0x14E) ? (54., 113) : (0x1D8, 128.) >= 0x154 ? (0xCC, 85.60E1) : (0x25, 1.258E3) <= 149 ? 35.2E1 : (0x187, 43.)), 241, 9, 137, 73, 201, 41, 169, ((48., 0x211) >= (37, 81.) ? (0x6E, 105) : 5E0 > (98, 58.) ? 66. : (51, 118.)), ((0x41, 0x10B) >= (11.75E2, 7) ? (14.89E2, 233) : (146., 25.5E1)), 25, 153, (13.32E2 <= (7.810E2, 8) ? (125, "i") : (0x4C, 0x24A) > (0xA4, 0x246) ? (0x119, 89) : (0x13F, 136.)), ((74.4E1, 2.) < 0x257 ? (1.118E3, 217) : (0xCE, 0x128)), 57, 185, (16.7E1 <= (119, 116) ? (5.76E2, 116.) : 0x13F <= (27.20E1, 1.018E3) ? (5.9E2, 121) : (98., 0x189)), 249, 5, 133, ((12., 3E0) > (80, 6.4E1) ? 105 : 7.86E2 <= (91, 7.21E2) ? 'f' : (0xA3, 16.2E1) < (1.155E3, 0x188) ? (0x1CD, 69) : (62., 106.30E1)), (5.62E2 > (72, 0x78) ? (115.9E1, 197) : (0x11A, 83)), ((104., 147.9E1) <= 82.30E1 ? (140, 0x59) : (7.96E2, 0x1C9) <= (0x62, 6.86E2) ? (64., 37) : (8.26E2, 26.8E1)), 165, ((133., 0x140) > 0x21B ? 90. : 142.9E1 < (0x1C2, 0x146) ? 0xF2 : (59.6E1, 118.) > (0x21E, 0x1) ? (4.3E2, 101) : (0x179, 0x116)), 229, 21, 149, ((0xC0, 113) > 40. ? (13., 85) : 2.48E2 >= (99., 0x195) ? (9.94E2, 8803) : 105 > (82.4E1, 7.23E2) ? (102, 'l') : (0x17D, 0x4C)), ((0x1BA, 79.) <= (3.0E2, 12.) ? (0x165, 8.51E2) : (126., 0x13F) >= (80., 107) ? (54., 213) : (0x115, 1.168E3)), 53, 181, ((9.78E2, 0x4F) >= 0xA8 ? 8193 : (138., 91.0E1) > (85.9E1, 0x1DD) ? (36.2E1, 117) : (34.4E1, 0xC1) <= (50., 88) ? (1.417E3, 1.048E3) : (6.86E2, 85.9E1)), 245, 13, ((88., 0xBA) <= 0x1F2 ? (0x112, 141) : (1.390E2, 52.40E1)), 77, (89 >= (34, 10.61E2) ? (0x233, 6.13E2) : 10.57E2 < (4.78E2, 97.) ? (51.0E1, "m") : (64, 1.2E2) > (19.6E1, 107.) ? (1.125E3, 205) : (122.4E1, 106)), (4.4E1 <= (66, 0x56) ? (0x110, 45) : (0x238, 0xE9) > (141, 6.640E2) ? (107.5E1, 237) : (60.30E1, 0x125) >= (80., 13.43E2) ? 237 : (30., 0xF7)), (0x24A > (147., 93.) ? (25.20E1, 173) : (21, 0x147) <= 96. ? 0x12F : (44., 73) > 0x16B ? (112.0E1, 'K') : (0x1E6, 0xF6)), 109, 237, 29, 157, 93, ((108., 4.23E2) >= 0x20B ? (0x10, 0xD7) : 122 >= (8.51E2, 30) ? (0x58, 221) : (94.80E1, 38.80E1)), 61, 189, ((21, 0x57) >= 142. ? (122, 12.17E2) : 0x18B < (77., 147.0E1) ? (0x1F, 125) : (0x1EF, 0x1A8)), 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, ((1.58E2, 2.66E2) >= (57, 63) ? (0x213, 83) : (6.29E2, 35.30E1) < (1., 113) ? (91.2E1, ",1)") : (0x14E, 60.) >= (7.42E2, 11.540E2) ? (78., ",1)") : (0xFB, 98.)), 211, ((62., 0x112) >= 27 ? (30., 51) : (27, 0xAE)), ((1.08E3, 33) >= 0x100 ? 34675 : 7.80E1 > (0xD7, 47) ? (24., 179) : (0x255, 8.59E2) >= 1.053E3 ? "Q" : (112., 74.)), ((44, 120) < 37.0E1 ? (0x6D, 115) : 120 >= (0x1A8, 0x155) ? 0x217 : (27., 34.) > (2.6E1, 0x41) ? (0xA5, 43.) : (1.178E3, 24)), 243, 11, 139, 75, 203, ((68.60E1, 127) >= 28 ? (14, 43) : (110, 0x45)), 171, 107, 235, 27, 155, 91, 219, 59, ((0xB3, 107) < (67., 126) ? (0x210, 187) : (125., 34.0E1) < (0x1FB, 0x90) ? (3.820E2, 224) : (0xE0, 46) <= (0x1BF, 4) ? 32 : (0x45, 6.15E2)), 123, 251, 7, 135, 71, 199, ((0x9C, 0x161) > 12.44E2 ? 251 : 0x10C > (1.400E2, 1.171E3) ? (48., 4.24E2) : 0xEE >= (104, 0x76) ? (1.287E3, 39) : (0x94, 0x1A9)), 167, 103, 231, ((106, 12.02E2) <= 6. ? 37.80E1 : (0x16A, 0x16A) >= 89 ? (130., 23) : (14.620E2, 0x153)), 151, 87, 215, 55, 183, 119, 247, ((33.7E1, 78.2E1) >= (120, 5.86E2) ? (117., 15) : (1.95E2, 0x20E)), 143, 79, 207, ((111, 10.71E2) > (0x164, 0x60) ? (72.4E1, 47) : (11.3E2, 29.40E1)), 175, 111, 239, 31, ((145, 79.9E1) > 1.54E2 ? (59.1E1, 159) : (2.75E2, 0x1F) > (68.10E1, 50.) ? (52., 1.32) : (11.42E2, 83.7E1)), 95, 223, 63, 191, 127, 255];
    },
    'L5s': function(X, S) {
        return X - S;
    },
    'k5h': function(X, S) {
        return X != S;
    },
    'a4m': function(X, S) {
        return X == S;
    },
    'c11': function(X, S) {
        return X !== S;
    },
    'w3t': function(X, S) {
        return X != S;
    },
    'B0u': function(X, S) {
        return X > S;
    },
    'g1d': function(X, S) {
        return X * S;
    },
    'Y8q': function(X, S) {
        return X * S;
    },
    'h5O': function(X, S) {
        return X instanceof S;
    },
    'o6B': function(X, S) {
        return X > S;
    },
    'f06': function(X, S) {
        return X == S;
    },
    'J2T': function(X, S) {
        return X > S;
    },
    'q2s': function(X, S) {
        return X <= S;
    },
    'T8z': function(X, S) {
        return X * S;
    },
    'l7f': function(X, S) {
        return X < S;
    },
    'V1y': function(X) {
        cc.VERTEX_ATTRIB_FLAG_POSITION = X;
    },
    'i9d': function(X, S) {
        return X - S;
    },
    'w5l': function(X, S) {
        return X >= S;
    },
    'H5D': function(X, S) {
        return X < S;
    },
    'D8A': function(X, S) {
        return X in S;
    },
    'G4G': function(X, S) {
        return X < S;
    },
    'o9j': function(X, S) {
        return X << S;
    },
    'V3T': function(X, S) {
        return X <= S;
    },
    'i3G': function(X, S) {
        return X > S;
    },
    'H4u': function(X, S) {
        return X * S;
    },
    'O68': function(X, S) {
        return X | S;
    },
    'T7t': function(X, S) {
        return X >= S;
    },
    'E52': function(X, S) {
        return X != S;
    },
    'A7': function(X) {
        cc.Event.KEYBOARD = X;
    },
    'W1G': function(X, S, P) {
        return X % S * P;
    },
    'O9u': function(X, S) {
        return X - S;
    },
    's0m': function(X, S) {
        return X - S;
    },
    'G23': function(X, S) {
        return X < S;
    },
    'm9H': function(X, S) {
        return X > S;
    },
    't06': function(X, S, P) {
        return X - S - P;
    },
    'G8B': function(X, S) {
        return X === S;
    },
    'M4M': function(X, S) {
        return X / S;
    },
    's73': function(X, S, P) {
        return X * S / P;
    },
    'c2L': function(X, S) {
        return X * S;
    },
    'W16': function(X, S) {
        return X != S;
    },
    'y73': function(X, S) {
        return X >= S;
    },
    'O8T': function(X, S) {
        return X / S;
    },
    'T2m': function(X, S) {
        return X * S;
    },
    'B6G': function(X, S, P, O) {
        return X * S * P / O;
    },
    'm36': function(X, S) {
        return X * S;
    },
    'H3y': function(X) {
        cc.PARTICLE_MODE_GRAVITY = X;
    },
    'd1': function(X) {
        cc.RETINA_DISPLAY_FILENAME_SUFFIX = X;
    },
    'V9i': 19,
    'D18': function(X, S) {
        return X != S;
    },
    'G2l': function(X, S) {
        return X | S;
    },
    'I1K': "ended",
    'C3y': function(X) {
        cc.PARTICLE_STAR_SHAPE = X;
    },
    'f82': function(X, S) {
        return X === S;
    },
    'r6L': function(X, S) {
        return X > S;
    },
    'k15': function(X, S) {
        return X * S;
    },
    'k4l': function(X, S) {
        return X > S;
    },
    'Y2L': function(X, S) {
        return X * S;
    },
    's7': function(X) {
        cc.EventMouse.NONE = X;
    },
    'C9B': function(X, S) {
        return X <= S;
    },
    'k7p': function(X, S) {
        return X >= S;
    },
    'P76': function(X, S) {
        return X != S;
    },
    's95': function(X, S) {
        return X === S;
    },
    'Z7M': function(X, S) {
        return X / S;
    },
    'h43': function(X, S) {
        return X * S;
    },
    'o95': function(X, S) {
        return X / S;
    },
    'a2T': function(X, S) {
        return X / S;
    },
    'k4i': 45,
    'z0A': function(X, S) {
        return X > S;
    },
    'g7z': function(X, S) {
        return X >= S;
    },
    'B3S': 120,
    'L1p': function(X, S) {
        return X - S;
    },
    'w7f': function(X, S) {
        return X >= S;
    },
    'n55': function(X, S) {
        return X < S;
    },
    'X3T': function(X, S) {
        return X * S;
    },
    't7q': function(X, S) {
        return X * S;
    },
    'e36': function(X, S) {
        return X <= S;
    },
    'z4N': function(X, S) {
        return X < S;
    },
    'Q8m': function(X, S) {
        return X - S;
    },
    'i4d': function(X, S, P) {
        return X / S * P;
    },
    'N3j': function(X, S) {
        return X === S;
    },
    'v5B': function(X, S) {
        return X / S;
    },
    'P6d': function(X, S) {
        return X instanceof S;
    },
    'r6T': function(X, S) {
        return X / S;
    },
    'e93': function(X, S) {
        return X | S;
    },
    'A1q': function(X, S) {
        return X * S;
    },
    'B7E': function(X, S) {
        return X >= S;
    },
    'p9O': function(X) {
        LINK_WIDTH = X;
    },
    's0h': function(X, S) {
        return X !== S;
    },
    'F2y': function(X) {
        Global.maxHealth = X;
    },
    'Z55': function(X, S) {
        return X < S;
    },
    'k9q': function(X, S) {
        return X * S;
    },
    'c8y': function(X) {
        cc.DrawNode.TYPE_DOT = X;
    },
    'e4E': function(X, S) {
        return X / S;
    },
    'A5f': function(X, S) {
        return X | S;
    },
    'o96': function(X, S) {
        return X != S;
    },
    'l65': function(X, S) {
        return X == S;
    },
    'J8w': function(X, S) {
        return X < S;
    },
    'M61': function(X, S) {
        return X < S;
    },
    'r6H': "startColor",
    'i5z': function(X, S) {
        return X * S;
    },
    'b72': function(X, S) {
        return X == S;
    },
    'U7d': function(X, S) {
        return X / S;
    },
    'z9t': function(X, S) {
        return X != S;
    },
    'T81': function(X, S) {
        return X !== S;
    },
    'W6h': function(X, S) {
        return X === S;
    },
    'N1z': function(X, S) {
        return X - S;
    },
    'F9y': function(X) {
        cc.SHADER_POSITION_TEXTURECOLORALPHATEST = X;
    },
    'L1N': function(X, S) {
        return X == S;
    },
    'a26': function(X, S) {
        return X != S;
    },
    'D1w': function(X, S) {
        return X | S;
    },
    'D5P': "lg.ProgressBar",
    'w7u': function(X, S) {
        return X * S;
    },
    'C7M': function(X, S) {
        return X - S;
    },
    'O2O': function(X, S) {
        return X === S;
    },
    'k4A': function(X, S) {
        return X - S;
    },
    'B7L': function(X, S) {
        return X * S;
    },
    'g7B': function(X, S) {
        return X / S;
    },
    'x5t': function(X, S, P) {
        return X * S * P;
    },
    'E3d': function(X, S) {
        return X != S;
    },
    'A2G': function(X, S) {
        return X === S;
    },
    'R1a': function(X, S) {
        return X / S;
    },
    'N93': function(X, S) {
        return X | S;
    },
    'Q1s': function(X, S) {
        return X << S;
    },
    'e9w': function(X, S) {
        return X / S;
    },
    'y0s': function(X, S) {
        return X * S;
    },
    'Q1A': function(X, S) {
        return X == S;
    },
    'I5v': function(X, S) {
        return X * S;
    },
    'B6z': function(X, S) {
        return X - S;
    },
    'v31': function(X, S) {
        return X * S;
    },
    'n41': function(X, S) {
        return X > S;
    },
    'c4N': function(X, S) {
        return X | S;
    },
    'O1t': function(X, S) {
        return X < S;
    },
    'b3z': function(X, S) {
        return X * S;
    },
    'H0w': function(X, S) {
        return X > S;
    },
    'S3O': function(X, S) {
        return X < S;
    },
    'R0z': function(X, S) {
        return X == S;
    },
    'U6B': function(X, S) {
        return X !== S;
    },
    'c0A': function(X, S) {
        return X / S;
    },
    'B1y': function(X) {
        cc.UNIFORM_COSTIME_S = X;
    },
    'Q91': function(X, S) {
        return X === S;
    },
    'j95': function(X, S) {
        return X == S;
    },
    'Q4d': function(X, S) {
        return X / S;
    },
    'Q51': function(X, S) {
        return X / S;
    },
    'u4O': function(X, S) {
        return X == S;
    },
    'b6u': function(X, S) {
        return X != S;
    },
    's4b': function(X, S) {
        return X < S;
    },
    'A9a': function(X, S) {
        return X * S;
    },
    'Y2w': function(X, S) {
        return X === S;
    },
    'Z0d': function(X, S) {
        return X / S;
    },
    'N5O': function(X, S) {
        return X | S;
    },
    'f76': function(X, S) {
        return X != S;
    },
    'p6u': function(X, S) {
        return X * S;
    },
    'I8B': function(X, S) {
        return X !== S;
    },
    'u7B': function(X, S) {
        return X & S;
    },
    'u5T': function(X, S) {
        return X / S;
    },
    'n0a': function(X, S) {
        return X / S;
    },
    'N7z': function(X, S) {
        return X === S;
    },
    'h4l': function(X, S) {
        return X / S;
    },
    'q6w': function(X, S) {
        return X * S;
    },
    'Q2p': function(X, S) {
        return X > S;
    },
    'j9K': ")",
    'O9h': function(X, S) {
        return X !== S;
    },
    'L9s': function(X, S) {
        return X * S;
    },
    'y2d': function(X, S) {
        return X - S;
    },
    'x3M': function(X, S) {
        return X * S;
    },
    'P5D': function(X, S) {
        return X * S;
    },
    'f5s': function(X, S) {
        return X > S;
    },
    'K9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = X;
    },
    'l36': function(X, S) {
        return X <= S;
    },
    'w05': function(X, S) {
        return X === S;
    },
    'f4B': function(X, S) {
        return X != S;
    },
    'N3a': function(X, S) {
        return X * S;
    },
    'T2D': function(X, S) {
        return X / S;
    },
    'W3f': function(X, S) {
        return X === S;
    },
    'W5z': function(X, S) {
        return X * S;
    },
    'a7': function(X) {
        cc.ResolutionPolicy.FIXED_WIDTH = X;
    },
    'w0i': "y",
    'O3O': function(X, S) {
        return X == S;
    },
    'F78': function(X, S) {
        return X >= S;
    },
    'u2N': function(X, S, P) {
        return X * S * P;
    },
    'L5v': function(X, S) {
        return X instanceof S;
    },
    'w85': function(X, S) {
        return X * S;
    },
    'M3v': function(X, S) {
        return X < S;
    },
    'S6j': function(X, S) {
        return X < S;
    },
    'P5y': function() {
        cc._globalFontNameRelease = !1;
    },
    's11': function(X, S) {
        return X < S;
    },
    'O2S': "RGBA8888",
    'H15': function(X, S) {
        return X - S;
    },
    'I5z': function(X, S) {
        return X * S;
    },
    'p18': function(X, S) {
        return X / S;
    },
    'l5y': function(X) {
        cc.TMX_LAYER_ATTRIB_BASE64 = X;
    },
    'N5t': function(X, S) {
        return X < S;
    },
    'K6p': function(X, S) {
        return X >= S;
    },
    'k5z': function(X, S) {
        return X * S;
    },
    'z4v': function(X, S) {
        return X == S;
    },
    'Z8D': function(X, S) {
        return X * S;
    },
    'Y4M': function(X, S) {
        return X === S;
    },
    'R4v': function(X, S) {
        return X - S;
    },
    'j66': function(X, S) {
        return X < S;
    },
    'b7j': function(X, S, P) {
        return X - S + P;
    },
    'x8d': function(X, S) {
        return X == S;
    },
    'J4z': function(X, S) {
        return X / S;
    },
    'f7u': function(X, S, P) {
        return X / S * P;
    },
    'k9i': "fsh",
    'm5M': function(X, S) {
        return X < S;
    },
    'm0v': function(X, S) {
        return X == S;
    },
    'l6m': function(X, S) {
        return X * S;
    },
    'm2M': function(X, S) {
        return X * S;
    },
    'd85': function(X, S) {
        return X * S;
    },
    'x43': function(X, S) {
        return X * S;
    },
    'F3v': function(X, S) {
        return X * S;
    },
    'R4b': function(X, S) {
        return X * S;
    },
    'E0p': function(X, S) {
        return X - S;
    },
    'P8': function(X) {
        cc.SRC_ALPHA = X;
    },
    'Y6A': function(X, S) {
        return X * S;
    },
    'm2': function(X) {
        cc.km_mat4_stack.INITIAL_SIZE = X;
    },
    'A6T': function(X, S) {
        return X * S;
    },
    'E65': function(X, S) {
        return X == S;
    },
    'b92': function(X, S) {
        return X instanceof S;
    },
    'G6a': function(X, S) {
        return X * S;
    },
    'n8N': function(X, S) {
        return X !== S;
    },
    's1a': function(X, S) {
        return X / S;
    },
    't9H': function(X, S) {
        return X == S;
    },
    'S5p': function(X, S) {
        return X >= S;
    },
    'i0l': function(X, S) {
        return X < S;
    },
    'u9m': function(X, S) {
        return X === S;
    },
    'N4j': function(X, S) {
        return X >> S;
    },
    'B41': function(X, S) {
        return X !== S;
    },
    'h7A': function(X, S) {
        return X == S;
    },
    'C1A': function(X, S) {
        return X == S;
    },
    'a0t': function(X, S) {
        return X == S;
    },
    'a5E': function(X, S) {
        return X < S;
    },
    'j8K': "mainLevel",
    'r51': function(X, S) {
        return X / S;
    },
    'D1l': function(X, S) {
        return X / S;
    },
    'y7q': function(X, S) {
        return X * S;
    },
    'r7A': function(X, S) {
        return X - S;
    },
    'T7w': function(X, S) {
        return X | S;
    },
    'J2q': function(X, S) {
        return X * S;
    },
    'x8l': function(X, S) {
        return X > S;
    },
    'S3b': function(X, S) {
        return X / S;
    },
    'P9d': function(X, S) {
        return X === S;
    },
    'Q8t': function(X, S) {
        return X < S;
    },
    'G1m': function(X, S) {
        return X == S;
    },
    'u0t': function(X, S) {
        return X == S;
    },
    'j1y': function(X) {
        cc.UNIFORM_MVMATRIX_S = X;
    },
    'X78': function(X, S) {
        return X << S;
    },
    'J3m': function(X, S) {
        return X * S;
    },
    'K2N': function(X, S) {
        return X < S;
    },
    'a15': function(X, S) {
        return X * S;
    },
    'g36': function(X, S) {
        return X >= S;
    },
    'X0G': function(X, S) {
        return X * S;
    },
    'C3l': function(X, S) {
        return X | S;
    },
    'L41': function(X, S) {
        return X !== S;
    },
    'y71': function(X, S) {
        return X * S;
    },
    'p35': function(X, S) {
        return X < S;
    },
    'Q42': function(X, S) {
        return X == S;
    },
    'Z3A': function(X, S) {
        return X != S;
    },
    'Y8h': function(X, S) {
        return X == S;
    },
    'p6': function() {
        cc.PI2 = 2 * Math.PI;
    },
    'Y6u': function(X, S) {
        return X / S;
    },
    'S7L': function(X, S) {
        return X * S;
    },
    'u3w': function(X, S) {
        return X / S;
    },
    'o2': function(X) {
        cc.KM_PLANE_NEAR = X;
    },
    'u2u': function(X, S) {
        return X * S;
    },
    'M02': function(X, S) {
        return X < S;
    },
    'v4u': function(X, S) {
        return X * S;
    },
    'W2i': 0.015625,
    'f0d': function(X, S) {
        return X / S;
    },
    'a9f': function(X, S) {
        return X !== S;
    },
    'x72': function(X, S) {
        return X === S;
    },
    'K5m': function(X, S) {
        return X * S;
    },
    'w0E': function(X, S) {
        return X == S;
    },
    'j0': function(X) {
        cc.EventMouse.BUTTON_8 = X;
    },
    'e1A': function(X, S) {
        return X == S;
    },
    'S9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = X;
    },
    'R9L': function(X, S) {
        return X * S;
    },
    'U1w': function(X, S) {
        return X * S;
    },
    'P8b': function(X, S) {
        return X <= S;
    },
    't7G': function(X, S) {
        return X * S;
    },
    'y1y': function(X) {
        cc.GL_ALL = X;
    },
    'K1h': function(X, S) {
        return X * S;
    },
    'k3h': function(X, S) {
        return X < S;
    },
    'H5S': 8192,
    'h6v': function(X, S) {
        return X instanceof S;
    },
    'O4u': function(X, S) {
        return X - S;
    },
    'i76': function(X, S) {
        return X == S;
    },
    'f33': function(X, S) {
        return X !== S;
    },
    'j4S': "down",
    'P5E': function(X, S) {
        return X != S;
    },
    'V1j': function(X, S) {
        return X <= S;
    },
    'u68': function(X, S) {
        return X & S;
    },
    'T9v': function(X, S) {
        return X < S;
    },
    'v7v': function(X, S) {
        return X | S;
    },
    'A4B': function(X, S) {
        return X == S;
    },
    'Z8j': function(X, S) {
        return X - S;
    },
    'G2q': function(X, S) {
        return X * S;
    },
    't9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = X;
    },
    'Z8B': function(X, S) {
        return X === S;
    },
    'G6': function() {
        cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
    },
    'g5b': function(X, S) {
        return X - S;
    },
    'i8B': function(X, S) {
        return X < S;
    },
    'H23': function(X, S) {
        return X * S;
    },
    'O4A': function(X, S) {
        return X < S;
    },
    'k8N': function(X, S) {
        return X < S;
    },
    'A7q': function(X, S) {
        return X * S;
    },
    'I76': function(X, S) {
        return X != S;
    },
    'M9i': "left",
    'v41': function(X, S) {
        return X < S;
    },
    'x8h': function(X, S) {
        return X != S;
    },
    'L6N': function(X, S) {
        return X * S;
    },
    'S9O': function(X) {
        Global.score = X;
    },
    'W5L': function(X, S) {
        return X != S;
    },
    'p6O': function(X, S) {
        return X < S;
    },
    'Z2l': function(X, S) {
        return X <= S;
    },
    'K0j': function(X, S) {
        return X >= S;
    },
    'm9': function(X) {
        cc.FMT_PNG = X;
    },
    'p5d': function(X, S) {
        return X < S;
    },
    'S3G': function(X, S) {
        return X >>> S;
    },
    'j61': function(X, S) {
        return X * S;
    },
    'Y1w': function(X, S) {
        return X | S;
    },
    'N4T': function(X, S) {
        return X - S;
    },
    'L4O': function(X, S) {
        return X < S;
    },
    'O02': function(X, S, P) {
        return X * S / P;
    },
    'n16': function(X, S) {
        return X >= S;
    },
    'm5l': function(X, S) {
        return X === S;
    },
    'Z2O': function(X, S) {
        return X === S;
    },
    'N5G': function(X, S) {
        return X >= S;
    },
    'r2N': function(X, S) {
        return X * S;
    },
    'a1p': function(X, S) {
        return X - S;
    },
    'W6N': function(X, S) {
        return X === S;
    },
    'q4d': function(X, S) {
        return X < S;
    },
    'p5j': function(X, S) {
        return X > S;
    },
    'B3': function(X) {
        _c.PIXEL_FORMAT_RGB888 = X;
    },
    'u6N': function(X, S) {
        return X >= S;
    },
    'i9z': function(X, S) {
        return X * S;
    },
    'V3s': function(X, S) {
        return X === S;
    },
    'y7f': function(X, S) {
        return X / S;
    },
    'W2B': function(X, S, P) {
        return X * S / P;
    },
    'i6y': function(X) {
        cc.TMX_PROPERTY_MAP = X;
    },
    'B88': function(X, S) {
        return X / S;
    },
    'b95': function(X, S) {
        return X * S;
    },
    'a2y': function() {
        lg._soundEnabled = !0;
    },
    'x9v': function(X, S) {
        return X - S;
    },
    'M3B': function(X, S) {
        return X % S;
    },
    'n9O': function(X) {
        ScoreKey = X;
    },
    'C2G': function(X, S) {
        return X / S;
    },
    'l5q': function(X, S) {
        return X * S;
    },
    'r6p': function(X, S) {
        return X === S;
    },
    'N7f': function(X, S) {
        return X === S;
    },
    'W0l': function(X, S) {
        return X % S;
    },
    'U1l': function(X, S) {
        return X < S;
    },
    'S0': function(X) {
        cc.EventMouse.BUTTON_6 = X;
    },
    'u5h': function(X, S) {
        return X / S;
    },
    'v23': function(X, S) {
        return X * S;
    },
    'O0l': function(X, S) {
        return X === S;
    },
    'Y61': function(X, S) {
        return X === S;
    },
    'L3q': function(X, S) {
        return X * S;
    },
    'l6w': function(X, S) {
        return X * S;
    },
    'U9p': function(X, S) {
        return X | S;
    },
    'F3L': function(X, S) {
        return X - S;
    },
    'r1': function(X) {
        cc.ENABLE_STACKABLE_ACTIONS = X;
    },
    'I75': function(X, S) {
        return X != S;
    },
    'h0p': function(X, S) {
        return X - S;
    },
    'W4h': function(X, S) {
        return X < S;
    },
    'g6p': function(X, S) {
        return X * S;
    },
    't8t': function(X, S) {
        return X % S;
    },
    'Q4E': function(X, S, P) {
        return X * S / P;
    },
    'n9z': function(X, S) {
        return X < S;
    },
    'S9m': function(X, S) {
        return X === S;
    },
    'd86': function(X, S) {
        return X != S;
    },
    'x92': function(X, S) {
        return X != S;
    },
    'S26': function(X, S) {
        return X > S;
    },
    'E3t': function(X, S) {
        return X < S;
    },
    'D6S': "I8",
    'Y3v': function(X, S) {
        return X - S;
    },
    'n2T': function(X, S) {
        return X / S;
    },
    'i88': function(X, S) {
        return X / S;
    },
    't0B': function(X, S) {
        return X / S;
    },
    'o4N': function(X, S) {
        return X < S;
    },
    'x46': function(X, S) {
        return X * S;
    },
    'D3v': function(X, S) {
        return X instanceof S;
    },
    'Z5E': function(X, S) {
        return X * S;
    },
    'V8q': function(X, S) {
        return X * S;
    },
    'W6d': function(X, S) {
        return X - S;
    },
    'R7w': function(X, S) {
        return X | S;
    },
    'a3f': function(X, S) {
        return X < S;
    },
    'A4d': function(X, S) {
        return X * S;
    },
    'F6q': function(X, S) {
        return X * S;
    },
    'm5b': function(X, S) {
        return X / S;
    },
    'q6E': function(X, S) {
        return X * S;
    },
    'K2M': function(X, S) {
        return X - S;
    },
    'a5L': function(X, S) {
        return X * S;
    },
    'O9m': function(X, S) {
        return X == S;
    },
    'D6O': function(X, S) {
        return X == S;
    },
    'C0p': function(X, S) {
        return X - S;
    },
    'j0f': function(X, S) {
        return X * S;
    },
    'q6A': function(X, S) {
        return X / S;
    },
    'O6': function(X) {
        cc.Director._fpsImage.src = X;
    },
    'Z7P': 360,
    'j7a': function(X, S) {
        return X * S;
    },
    'Z8w': function(X, S) {
        return X * S;
    },
    'm9w': function(X, S) {
        return X - S;
    },
    'P5z': function(X, S) {
        return X - S;
    },
    'G1y': function(X) {
        cc.ATTRIBUTE_NAME_TEX_COORD = X;
    },
    'S0a': function(X, S) {
        return X * S;
    },
    'T3z': function(X, S) {
        return X % S;
    },
    'r5A': function(X, S) {
        return X != S;
    },
    'F2D': function(X, S) {
        return X < S;
    },
    'P1p': function(X, S) {
        return X === S;
    },
    'f9s': function(X, S) {
        return X / S;
    },
    'j5j': function(X, S) {
        return X < S;
    },
    'U3u': function(X, S) {
        return X < S;
    },
    'X73': function(X, S) {
        return X / S;
    },
    'J12': function(X, S) {
        return X / S;
    },
    'H2u': function(X, S) {
        return X * S;
    },
    'H2l': function(X, S) {
        return X === S;
    },
    'W8f': function(X, S) {
        return X / S;
    },
    't5q': function(X, S) {
        return X * S;
    },
    'i8': function() {
        cc.RECT_PIXELS_TO_POINTS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(X) {
            var S = cc.CONTENT_SCALE_FACTOR();
            return cc.rect(X.x / S, X.y / S, X.width / S, X.height / S);
        } : function(X) {
            return X;
        };
    },
    'V3p': function(X, S) {
        return X >= S;
    },
    'k2u': function(X, S) {
        return X & S;
    },
    'A0N': function(X, S) {
        return X > S;
    },
    'R0M': function(X, S) {
        return X / S;
    },
    'Y58': function(X, S) {
        return X < S;
    },
    'T2E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'R6': function(X) {
        cc.LabelTTF._fontStyleRE = X;
    },
    'Z4A': function(X, S) {
        return X == S;
    },
    'F3P': "\r\n",
    'C0E': function(X, S) {
        return X < S;
    },
    'a7E': function(X, S) {
        return X == S;
    },
    'e0L': function(X, S) {
        return X * S;
    },
    'd3j': function(X, S) {
        return X === S;
    },
    'y2G': function(X, S) {
        return X >>> S;
    },
    'L9m': function(X, S) {
        return X == S;
    },
    'x3B': function(X, S) {
        return X !== S;
    },
    'K8L': function(X, S) {
        return X < S;
    },
    'R8u': function(X, S) {
        return X - S;
    },
    'U2y': function(X) {
        Global.Shield = X;
    },
    'H1': function() {
        cc.RAD = cc.PI / (1.116E3 <= (4.2E2, 0x203) ? 178 : 7.59E2 > (0xAC, 0x47) ? (0x13F, 180) : (3.48E2, 0x20D));
    },
    'F0b': function(X, S) {
        return X === S;
    },
    'v0d': function(X, S) {
        return X / S;
    },
    'x2f': function(X, S) {
        return X instanceof S;
    },
    'S4h': function(X, S) {
        return X != S;
    },
    'Y3h': function(X, S) {
        return X | S;
    },
    'a7s': function(X, S) {
        return X * S;
    },
    'h9a': function(X, S) {
        return X * S;
    },
    'o2w': function(X, S) {
        return X / S;
    },
    'N9D': function(X, S) {
        return X < S;
    },
    'e0v': function(X, S) {
        return X == S;
    },
    'H4G': function(X, S) {
        return X < S;
    },
    'x4N': function(X, S) {
        return X !== S;
    },
    'u2z': function(X, S) {
        return X > S;
    },
    'v5L': function(X, S) {
        return X > S;
    },
    'Z0a': function(X, S) {
        return X < S;
    },
    'j35': function(X, S) {
        return X < S;
    },
    'H7B': function(X, S) {
        return X & S;
    },
    'g06': function(X, S) {
        return X / S;
    },
    'G3f': function(X, S) {
        return X != S;
    },
    'S2l': function(X, S) {
        return X < S;
    },
    'z7w': function(X, S) {
        return X * S;
    },
    'K9a': function(X, S) {
        return X | S;
    },
    'b7D': function(X, S) {
        return X > S;
    },
    'a9P': "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}",
    'm8v': function(X, S) {
        return X < S;
    },
    'a8a': function(X, S) {
        return X / S;
    },
    'V18': function(X, S) {
        return X / S;
    },
    'p4p': function(X, S) {
        return X >= S;
    },
    'z35': function(X, S) {
        return X !== S;
    },
    'U92': function(X, S) {
        return X == S;
    },
    'X3s': function(X, S) {
        return X * S;
    },
    'M96': function(X, S) {
        return X - S;
    },
    'R56': function(X, S) {
        return X * S;
    },
    'h9B': function(X, S) {
        return X >= S;
    },
    'c5a': function(X, S) {
        return X * S;
    },
    'u2i': "text/css",
    'Z9u': function(X, S) {
        return X < S;
    },
    'a5u': function(X, S) {
        return X < S;
    },
    'w9O': function() {
        Global.gamePause = !1;
    },
    'T92': function(X, S) {
        return X === S;
    },
    'h0N': function(X, S, P) {
        return X - S - P;
    },
    'x5a': function(X, S) {
        return X * S;
    },
    'A6p': function(X, S) {
        return X < S;
    },
    'n4m': function(X, S) {
        return X == S;
    },
    'F7P': "endOpacity",
    'r6l': function(X, S) {
        return X % S;
    },
    'd4a': function(X, S) {
        return X == S;
    },
    'E3a': function(X, S) {
        return X * S;
    },
    'Q2A': function(X, S) {
        return X == S;
    },
    'h13': function(X, S) {
        return X * S;
    },
    'B08': function(X, S) {
        return X === S;
    },
    'W5D': function(X, S) {
        return X / S;
    },
    'R83': function(X, S) {
        return X * S;
    },
    'y65': function(X, S) {
        return X instanceof S;
    },
    'j5t': function(X, S) {
        return X | S;
    },
    'B3f': function(X, S) {
        return X != S;
    },
    'I0d': function(X, S) {
        return X === S;
    },
    't2': function(X) {
        cc.KM_PLANE_LEFT = X;
    },
    'W4G': function(X, S) {
        return X < S;
    },
    'd9N': function(X, S) {
        return X < S;
    },
    'q1q': function(X, S) {
        return X * S;
    },
    's4M': function(X, S) {
        return X > S;
    },
    'x0G': function(X, S) {
        return X >= S;
    },
    'Q9b': function(X, S) {
        return X == S;
    },
    'R4s': function(X, S) {
        return X * S;
    },
    'Z9s': function(X, S) {
        return X < S;
    },
    'g2P': "director_after_draw",
    'W8G': function(X, S) {
        return X < S;
    },
    'r0v': function(X, S) {
        return X == S;
    },
    'm1A': function(X, S) {
        return X == S;
    },
    'f9S': "visible",
    'T0z': function(X, S) {
        return X < S;
    },
    't3H': "rotatePerSVar",
    'm2A': function(X, S) {
        return X instanceof S;
    },
    'd7q': function(X, S) {
        return X * S;
    },
    'K5q': function(X, S) {
        return X * S;
    },
    'L9f': function(X, S) {
        return X | S;
    },
    'A4w': function(X, S) {
        return X * S;
    },
    'j0z': function(X, S) {
        return X >= S;
    },
    'x7D': function(X, S) {
        return X * S;
    },
    'R1P': 4208917214,
    'g4B': function(X, S) {
        return X != S;
    },
    'w8t': function(X, S) {
        return X != S;
    },
    'u7': function(X) {
        cc.EventMouse.DOWN = X;
    },
    'r9B': function(X, S) {
        return X * S;
    },
    'z5j': function(X, S) {
        return X > S;
    },
    'c6f': function(X, S) {
        return X / S;
    },
    'M3s': function(X, S) {
        return X === S;
    },
    'Y8y': function(X) {
        cc.PROGRESS_TIMER_TYPE_BAR = X;
    },
    'M62': function(X, S) {
        return X == S;
    },
    'W2u': function(X, S) {
        return X * S;
    },
    'N7A': function(X, S) {
        return X == S;
    },
    'v0j': function(X, S) {
        return X < S;
    },
    'W7v': function(X, S) {
        return X / S;
    },
    'j1a': function(X, S) {
        return X === S;
    },
    's8q': function(X, S) {
        return X * S;
    },
    'G5P': 8802,
    'K8S': "midPoint",
    'Q9D': function(X, S) {
        return X < S;
    },
    'Q1d': function(X, S) {
        return X == S;
    },
    'N5l': function(X, S) {
        return X <= S;
    },
    'p25': function(X, S) {
        return X == S;
    },
    'i16': function(X, S) {
        return X < S;
    },
    'k1P': "endColor",
    'i0T': function(X, S) {
        return X * S;
    },
    'K2G': function(X, S) {
        return X / S;
    },
    'd38': function(X, S) {
        return X == S;
    },
    'T7l': function(X, S) {
        return X % S;
    },
    'N3D': function(X, S) {
        return X == S;
    },
    'O8D': function(X, S) {
        return X * S;
    },
    'f6a': function(X, S) {
        return X * S;
    },
    'A5b': function(X, S) {
        return X != S;
    },
    'I7N': function(X, S) {
        return X < S;
    },
    'Y6O': function(X, S) {
        return X == S;
    },
    'Q5w': function(X, S) {
        return X * S;
    },
    'E4P': "opacity",
    'R6B': function(X, S) {
        return X > S;
    },
    'E9T': function(X, S) {
        return X * S;
    },
    'P5L': function(X, S) {
        return X * S;
    },
    'q4D': function(X, S) {
        return X > S;
    },
    'B2l': function(X, S) {
        return X - S;
    },
    'T8s': function(X, S) {
        return X != S;
    },
    'M2v': function(X, S) {
        return X == S;
    },
    'i8H': function(X, S) {
        return X == S;
    },
    'E1d': function(X, S) {
        return X - S;
    },
    'r9l': function(X, S) {
        return X < S;
    },
    't2i': "gravity",
    'd3l': function(X, S) {
        return X - S;
    },
    'F8s': function(X, S) {
        return X == S;
    },
    'v8H': function(X, S) {
        return X == S;
    },
    'G3': function(X) {
        _c.PIXEL_FORMAT_RGB5A1 = X;
    },
    'k9m': function(X, S) {
        return X instanceof S;
    },
    'D78': function(X, S) {
        return X != S;
    },
    'u6M': function(X, S) {
        return X > S;
    },
    'P9z': function(X, S) {
        return X < S;
    },
    'u0l': function(X, S) {
        return X - S;
    },
    'J41': function(X, S) {
        return X > S;
    },
    'j0q': function(X, S) {
        return X * S;
    },
    'V6b': function(X, S) {
        return X === S;
    },
    'P2u': function(X, S) {
        return X !== S;
    },
    'J0D': function(X, S) {
        return X == S;
    },
    'N2M': function(X, S) {
        return X < S;
    },
    'Y4b': function(X, S) {
        return X > S;
    },
    'W7B': function(X, S) {
        return X & S;
    },
    'U9O': function() {
        Global.DateLevel = [150, 150, 150, (0xE3 < (0x207, 0x1F0) ? (101, 150) : (0x115, 0x224)), 150, ((13.05E2, 93.) < 0xE7 ? (0x1AF, 150) : (0x39, 0x6E)), 150, ((0x190, 0x8) <= 44 ? (13, 150) : (15.5E1, 0x254) <= (82, 0x1DB) ? (2., 8803) : (46., 149.)), 150, (5. <= (0x68, 0x201) ? (51.6E1, 150) : (0xF8, 0x21C)), 150, ((0x246, 14.9E2) <= (2.80E1, 0x1AF) ? (0x2D, "u") : (81, 0x249) >= (75.5E1, 0x78) ? (59, 150) : (107., 110.4E1)), 150, 150, ((104, 1E0) > (1.33E3, 15) ? (13.43E2, 82.60E1) : (124, 3.) <= (0x241, 0x1EC) ? (18., 150) : (110, 0xA2) > (0x1DE, 0x22F) ? (0x32, 'd') : (0x1D1, 2.07E2)), 150, (128 >= (8, 143.) ? 134 : (111., 0x12D) <= (1.7E2, 69.9E1) ? (135., 150) : (13.8E2, 0x16B)), 150, 150, ((0xBB, 0x5B) >= (5.80E1, 80.) ? (95.9E1, 150) : (82., 134.4E1)), 150, ((0x12A, 0x1E0) <= 0x20F ? (0x23C, 150) : (0xF2, 81) >= 13.83E2 ? (22.6E1, 52) : (70., 0x1AB) < (3.86E2, 0x14B) ? 43.90E1 : (0x84, 39.)), 150, 150];
    },
    'C6p': function(X, S) {
        return X - S;
    },
    'W3O': function(X, S) {
        return X !== S;
    },
    'F3i': "onClick",
    'X35': function(X, S) {
        return X & S;
    },
    'q7m': function(X, S) {
        return X / S;
    },
    'J22': function(X, S) {
        return X <= S;
    },
    'N8t': function(X, S) {
        return X == S;
    },
    'f9f': function(X, S) {
        return X * S;
    },
    'S1b': function(X, S) {
        return X * S;
    },
    'D8d': function(X, S) {
        return X == S;
    },
    'g48': function(X, S) {
        return X << S;
    },
    'c63': function(X, S) {
        return X != S;
    },
    'R0O': function(X, S) {
        return X != S;
    },
    'v4L': function(X, S, P) {
        return X * S * P;
    },
    'E5f': function(X, S) {
        return X | S;
    },
    'X0O': function(X, S) {
        return X == S;
    },
    'e0P': "scaleX",
    'J7E': function(X, S) {
        return X > S;
    },
    'n8G': function(X, S) {
        return X != S;
    },
    'j63': function(X, S) {
        return X != S;
    },
    'w8': function(X) {
        cc.ONE_MINUS_SRC_ALPHA = X;
    },
    't9B': function(X, S) {
        return X / S;
    },
    'd8p': function(X, S) {
        return X >= S;
    },
    'A7b': function(X, S) {
        return X * S;
    },
    'a8j': function(X, S) {
        return X === S;
    },
    'O4q': function(X, S) {
        return X * S;
    },
    'R72': function(X, S) {
        return X == S;
    },
    'p2w': function(X, S) {
        return X / S;
    },
    'M3h': function(X, S) {
        return X < S;
    },
    's0b': function(X, S) {
        return X * S;
    },
    'K0N': function(X, S) {
        return X > S;
    },
    'x0z': function(X, S) {
        return X > S;
    },
    'p4b': function(X, S) {
        return X * S;
    },
    'g6S': "loop",
    'l4T': function(X, S) {
        return X - S;
    },
    'H5': function(X) {
        cc.DEVICE_ORIENTATION_PORTRAIT = X;
    },
    'L8a': function(X, S) {
        return X / S;
    },
    't2G': function(X, S) {
        return X / S;
    },
    'Z15': function(X, S) {
        return X * S;
    },
    'W4q': function(X, S) {
        return X * S;
    },
    'q7z': function(X, S) {
        return X < S;
    },
    'v5z': function(X, S, P) {
        return X * S % P;
    },
    'a8T': function(X, S) {
        return X / S;
    },
    'E2h': function(X, S) {
        return X != S;
    },
    'Y6j': function(X, S) {
        return X - S;
    },
    'L3m': function(X, S) {
        return X * S;
    },
    'v08': function(X, S) {
        return X >> S;
    },
    's7l': function(X, S) {
        return X < S;
    },
    'W5s': function(X, S) {
        return X * S;
    },
    'X4y': function() {
        cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, (0x2B >= (101, 40) ? (93., 2) : (0xF0, 14.56E2)), 2, 2, 2, 3, 3, 3, 3, 4, 4, ((0xE7, 0x22B) > (0x9C, 131) ? (73, 4) : 4.2E2 < (12.91E2, 0xE5) ? (10.10E1, 0xB3) : (98, 135)), 4, ((0x154, 0x17A) > 23. ? (50, 5) : (0x256, 136)), 5, 5, 5, ((129, 127.) <= 41. ? 37.7E1 : 0xCD < (17.0E1, 0x1C6) ? (107., 0) : (0xD, 13.700E2)), 99, 99];
    },
    'q3N': function(X, S) {
        return X !== S;
    },
    'J6d': function(X, S) {
        return X < S;
    },
    'V0q': function(X, S) {
        return X * S;
    },
    'F2H': "resize",
    'v3b': function(X, S) {
        return X != S;
    },
    'r4i': "precision lowp float;   \nvarying vec2 v_texCoord;  \nuniform sampler2D CC_Texture0; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}",
    'I8G': function(X, S) {
        return X < S;
    },
    'P75': function(X, S) {
        return X == S;
    },
    'v3f': function(X, S) {
        return X - S;
    },
    'o5a': function(X, S) {
        return X / S;
    },
    't0L': function(X, S) {
        return X * S;
    },
    'P4A': function(X, S) {
        return X * S;
    },
    'b1B': function(X, S) {
        return X / S;
    },
    'p7d': function(X, S) {
        return X === S;
    },
    'z1l': function(X, S) {
        return X < S;
    },
    'c5N': function(X, S) {
        return X > S;
    },
    'c1E': function(X, S) {
        return X * S;
    },
    'O9d': function(X, S) {
        return X < S;
    },
    'z6M': function(X, S, P) {
        return X * S * P;
    },
    'v5': function(X) {
        cc.DIRECTOR_PROJECTION_3D = X;
    },
    'w8S': "ShaderPositionTextureColorAlphaTest",
    'E0B': function(X, S) {
        return X & S;
    },
    'T3s': function(X, S) {
        return X === S;
    },
    'T4M': function(X, S) {
        return X == S;
    },
    'U7h': function(X, S) {
        return X * S;
    },
    'X6M': function(X, S) {
        return X * S;
    },
    'E4w': function(X, S) {
        return X | S;
    },
    'h7f': function(X, S) {
        return X / S;
    },
    'F3D': function(X, S) {
        return X * S;
    },
    'E1h': function(X, S) {
        return X * S;
    },
    'f2u': function(X, S) {
        return X * S;
    },
    'B4u': function(X, S) {
        return X - S;
    },
    'G2j': function(X, S) {
        return X < S;
    },
    'v21': function(X, S) {
        return X * S;
    },
    'b2': function(X) {
        cc.SHADER_POSITION_COLOR_VERT = X;
    },
    'H06': function(X, S) {
        return X <= S;
    },
    'l0z': function(X, S) {
        return X != S;
    },
    'Q3S': "wav",
    'u1': function() {
        cc.INVALID_INDEX = -1;
    },
    'F1B': function(X, S) {
        return X / S;
    },
    'K8y': function() {
        _p.transform = cc._renderType === cc._RENDER_TYPE_WEBGL ? _p._transformForWebGL : _p._transformForCanvas;
    },
    'u32': function(X, S) {
        return X instanceof S;
    },
    'e8t': function(X, S) {
        return X < S;
    },
    't7O': function(X, S) {
        return X == S;
    },
    'g9T': function(X, S) {
        return X * S;
    },
    'p1': function() {
        cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
    },
    'n2u': function(X, S) {
        return X !== S;
    },
    'L7S': "res/music/explosion.mp3",
    'a0d': function(X, S) {
        return X / S;
    },
    'C2h': function(X, S) {
        return X <= S;
    },
    'u4u': function(X, S) {
        return X * S;
    },
    'J8B': function(X, S) {
        return X !== S;
    },
    'T7h': function(X, S) {
        return X * S;
    },
    'h4D': function(X, S) {
        return X > S;
    },
    'P8a': function(X, S) {
        return X / S;
    },
    'L8G': function(X, S) {
        return X == S;
    },
    'J1v': function(X, S) {
        return X == S;
    },
    'I3m': function(X, S) {
        return X == S;
    },
    'W1t': function(X, S) {
        return X != S;
    },
    'e7m': function(X, S) {
        return X === S;
    },
    'j1N': function(X, S) {
        return X * S;
    },
    'D5D': function(X, S, P) {
        return X * S * P;
    },
    'b1j': function(X, S) {
        return X > S;
    },
    'a4z': function(X, S) {
        return X | S;
    },
    'Y25': function(X, S) {
        return X != S;
    },
    'Q9a': function(X, S) {
        return X | S;
    },
    'k3i': "en de es ru fr it tr pt",
    'W8D': function(X, S) {
        return X * S;
    },
    'C3N': function(X, S) {
        return X - S;
    },
    'E6H': "posVar",
    'd9l': function(X, S) {
        return X - S;
    },
    'N2N': function(X, S) {
        return X < S;
    },
    'P1m': function(X, S) {
        return X < S;
    },
    'h9M': function(X, S) {
        return X > S;
    },
    's3y': function(X) {
        cc.PARTICLE_BALL_SHAPE = X;
    },
    'G7p': function(X, S) {
        return X - S;
    },
    'X25': function(X, S) {
        return X == S;
    },
    'w7b': function(X, S) {
        return X / S;
    },
    'Z7s': function(X, S) {
        return X * S;
    },
    'N86': function(X, S) {
        return X == S;
    },
    'P0w': function(X, S) {
        return X % S;
    },
    'f3b': function(X, S) {
        return X != S;
    },
    'I9h': function(X, S) {
        return X * S;
    },
    'e2h': function(X, S) {
        return X == S;
    },
    'E4L': function(X, S, P) {
        return X * S * P;
    },
    'Z6a': function(X, S) {
        return X * S;
    },
    'E8L': function(X, S) {
        return X - S;
    },
    'g8t': function(X, S) {
        return X - S;
    },
    'b5N': function(X, S) {
        return X < S;
    },
    'R8O': function(X, S) {
        return X != S;
    },
    'Z3i': "startColorVar",
    'W4z': function(X, S) {
        return X == S;
    },
    'Z8M': function(X, S) {
        return X === S;
    },
    'z2D': function(X, S) {
        return X / S;
    },
    'a2q': function(X, S) {
        return X * S;
    },
    'w9w': function(X, S) {
        return X / S;
    },
    'G7B': function(X, S) {
        return X / S;
    },
    'P3P': "sprite",
    'K5P': "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d",
    'M7j': function(X, S) {
        return X > S;
    },
    'r1i': "Moz",
    'u6i': "over",
    'o8l': function(X, S) {
        return X <= S;
    },
    'a0u': function(X, S) {
        return X < S;
    },
    'w7M': function(X, S) {
        return X / S;
    },
    'Z3q': function(X, S) {
        return X * S;
    },
    'v5T': function(X, S) {
        return X * S;
    },
    'y4j': function(X, S) {
        return X === S;
    },
    'w2E': function(X, S) {
        return X * S;
    },
    'c6t': function(X, S) {
        return X < S;
    },
    'p2B': function(X, S) {
        return X < S;
    },
    'U45': function(X, S) {
        return X - S;
    },
    'm1f': function(X, S) {
        return X | S;
    },
    'X5j': function(X, S) {
        return X >= S;
    },
    'G7s': function(X, S) {
        return X * S;
    },
    'F8l': function(X, S) {
        return X != S;
    },
    'A6s': function(X, S) {
        return X < S;
    },
    't42': function(X, S) {
        return X < S;
    },
    'j4L': function(X, S) {
        return X * S;
    },
    'M4N': function(X, S) {
        return X * S;
    },
    'q0v': function(X, S) {
        return X != S;
    },
    'p3B': function(X, S) {
        return X / S;
    },
    'v8j': function(X, S) {
        return X === S;
    },
    'Q8S': "CC_MVPMatrix",
    'x6B': function(X, S) {
        return X < S;
    },
    'L9z': function(X, S) {
        return X | S;
    },
    'V7d': function(X, S) {
        return X / S;
    },
    'E2s': function(X, S) {
        return X == S;
    },
    'd7A': function(X, S) {
        return X != S;
    },
    'l6p': function(X, S, P) {
        return X - S - P;
    },
    'j9y': function(X) {
        cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = X;
    },
    'e7O': function(X, S) {
        return X != S;
    },
    'V8d': function(X, S) {
        return X < S;
    },
    'E2d': function(X, S) {
        return X < S;
    },
    'X6O': function(X, S) {
        return X == S;
    },
    'D0h': function(X, S) {
        return X !== S;
    },
    'Z32': function(X, S) {
        return X > S;
    },
    'y6m': function(X, S) {
        return X * S;
    },
    's63': function(X, S) {
        return X === S;
    },
    'X4v': function(X, S) {
        return X == S;
    },
    'x4L': function(X, S) {
        return X * S;
    },
    'p5h': function(X, S, P) {
        return X * S / P;
    },
    'I5h': function(X, S) {
        return X / S;
    },
    'K1f': function(X, S) {
        return X == S;
    },
    'q9S': "batchNode",
    'I3O': function(X, S) {
        return X == S;
    },
    'H7N': function(X, S) {
        return X * S;
    },
    'R3T': function(X, S) {
        return X * S;
    },
    'v4h': function(X, S) {
        return X < S;
    },
    'H6a': function(X, S) {
        return X * S;
    },
    'A5w': function(X, S) {
        return X < S;
    },
    'T5a': function(X, S) {
        return X * S;
    },
    'm7G': function(X, S) {
        return X < S;
    },
    's96': function(X, S) {
        return X != S;
    },
    'q9T': function(X, S) {
        return X * S;
    },
    'y0M': function(X, S) {
        return X * S;
    },
    'H0N': function(X, S) {
        return X < S;
    },
    'l0v': function(X, S) {
        return X < S;
    },
    'h86': function(X, S) {
        return X == S;
    },
    'r9i': 29,
    'm4w': function(X, S) {
        return X * S;
    },
    'c35': function(X, S) {
        return X - S;
    },
    'o2L': function(X, S) {
        return X * S;
    },
    'k7s': function(X, S) {
        return X * S;
    },
    'b0q': function(X, S) {
        return X * S;
    },
    't51': function(X, S) {
        return X * S;
    },
    'p1w': function(X, S) {
        return X * S;
    },
    's1K': "res/music/zombies.mp3",
    'A9O': function(X) {
        LevelKey = X;
    },
    'l0M': function(X, S) {
        return X * S;
    },
    'S02': function(X, S) {
        return X < S;
    },
    'i31': function(X, S) {
        return X < S;
    },
    'o56': function(X, S) {
        return X >= S;
    },
    'P1K': "onMouseMove",
    'K4j': function(X, S) {
        return X !== S;
    },
    't9b': function(X, S) {
        return X | S;
    },
    'W5h': function(X, S) {
        return X / S;
    },
    'f6h': function(X, S) {
        return X * S;
    },
    'E9D': function(X, S) {
        return X < S;
    },
    'N0v': function(X, S) {
        return X == S;
    },
    'r1s': function(X, S) {
        return X < S;
    },
    'I5s': function(X, S) {
        return X < S;
    },
    'J75': function(X, S) {
        return X === S;
    },
    'U7t': function(X, S) {
        return X < S;
    },
    'h4d': function(X, S) {
        return X * S;
    },
    'h8m': function(X, S) {
        return X === S;
    },
    'p2S': "radialAccel",
    'S5u': function(X, S) {
        return X < S;
    },
    'a1v': function(X, S) {
        return X != S;
    },
    'q1h': function(X, S) {
        return X != S;
    },
    's8u': function(X, S) {
        return X - S;
    },
    'l5b': function(X, S) {
        return X == S;
    },
    'I7E': function(X, S) {
        return X < S;
    },
    'Q6T': function(X, S) {
        return X / S;
    },
    'b7w': function(X, S) {
        return X / S;
    },
    'j3u': function(X, S) {
        return X <= S;
    },
    'K6H': "LinkEffect",
    'Y7T': function(X, S) {
        return X * S;
    },
    'R7a': function(X, S) {
        return X / S;
    },
    'L1b': function(X, S) {
        return X !== S;
    },
    'g1f': function(X, S) {
        return X === S;
    },
    'P8f': function(X, S) {
        return X * S;
    },
    'z1D': function(X, S) {
        return X != S;
    },
    'X6B': function(X, S) {
        return X / S;
    },
    'Y8A': function(X, S) {
        return X - S;
    },
    'j2w': function(X, S) {
        return X > S;
    },
    'g6v': function(X, S) {
        return X * S;
    },
    'R1b': function(X, S) {
        return X == S;
    },
    'D5t': function(X, S) {
        return X > S;
    },
    'C2a': function(X, S) {
        return X - S;
    },
    'l4d': function(X, S) {
        return X * S;
    },
    'F63': function(X, S) {
        return X === S;
    },
    's6q': function(X, S) {
        return X * S;
    },
    'L8E': function(X, S) {
        return X / S;
    },
    'A4l': function(X, S) {
        return X | S;
    },
    'V9p': function(X, S) {
        return X | S;
    },
    'S5v': function(X, S) {
        return X != S;
    },
    'u6y': function(X) {
        signals.Signal = X;
    },
    'O8b': function(X, S) {
        return X <= S;
    },
    'x5d': function(X, S) {
        return X < S;
    },
    'N0L': function(X, S, P) {
        return X * S * P;
    },
    'M5a': function(X, S) {
        return X * S;
    },
    'X9N': function(X, S, P) {
        return X | S | P;
    },
    'y7m': function(X, S) {
        return X / S;
    },
    'w7z': function(X, S) {
        return X / S;
    },
    'u1t': function(X, S) {
        return X / S;
    },
    'D8y': function() {
        cc.LABEL_AUTOMATIC_WIDTH = -1;
    },
    't7': function(X) {
        cc.ResolutionPolicy.SHOW_ALL = X;
    },
    'l9B': function(X, S) {
        return X < S;
    },
    'V73': function(X, S) {
        return X * S;
    },
    'L75': function(X, S) {
        return X != S;
    },
    'M46': function(X, S) {
        return X == S;
    },
    'U3h': function(X, S) {
        return X / S;
    },
    'J0j': function(X, S) {
        return X & S;
    },
    'n1v': function(X, S) {
        return X == S;
    },
    'c2H': "WHITE",
    'd05': function(X, S) {
        return X < S;
    },
    'D0A': function(X, S) {
        return X < S;
    },
    'F1H': function(X, S) {
        return X != S;
    },
    't3L': function(X, S, P) {
        return X * S * P;
    },
    'A1s': function(X, S) {
        return X < S;
    },
    't36': function(X, S) {
        return X - S;
    },
    'f5E': function(X, S) {
        return X | S;
    },
    'K2h': function(X, S) {
        return X | S;
    },
    'R7D': function(X, S) {
        return X >> S;
    },
    'M7D': function(X, S) {
        return X % S;
    },
    'r28': function(X, S) {
        return X >= S;
    },
    'x8A': function(X, S) {
        return X == S;
    },
    'b6B': function(X, S) {
        return X === S;
    },
    'B3O': function(X, S) {
        return X === S;
    },
    'j2L': function(X, S) {
        return X * S;
    },
    'X8P': "ShaderPositionTextureColor",
    'P0H': 513,
    'w53': function(X, S) {
        return X !== S;
    },
    'C6m': function(X, S) {
        return X * S;
    },
    'S2j': function(X, S) {
        return X << S;
    },
    'n9d': function(X, S) {
        return X == S;
    },
    'B9N': function(X, S) {
        return X < S;
    },
    't5l': function(X, S) {
        return X in S;
    },
    'A9T': function(X, S) {
        return X * S;
    },
    'g0N': function(X, S) {
        return X * S;
    },
    'T1N': function(X, S) {
        return X & S;
    },
    'M1j': function(X, S) {
        return X < S;
    },
    'e2A': function(X, S) {
        return X == S;
    },
    'S88': function(X, S) {
        return X / S;
    },
    'C93': function(X, S) {
        return X / S;
    },
    'o6O': function(X, S) {
        return X == S;
    },
    'j3T': function(X, S) {
        return X * S;
    },
    'Y1': function(X) {
        cc.ENABLE_GL_STATE_CACHE = X;
    },
    'n8M': function(X, S, P) {
        return X * S / P;
    },
    'u7L': function(X, S) {
        return X * S;
    },
    'U2L': function(X, S) {
        return X * S;
    },
    'I2b': function(X, S) {
        return X / S;
    },
    'H9i': "onUp",
    'X2v': function(X, S) {
        return X == S;
    },
    'I2l': function(X, S) {
        return X === S;
    },
    'H6z': function(X, S) {
        return X / S;
    },
    'L8j': function(X, S) {
        return X | S;
    },
    'h7G': function(X, S) {
        return X * S;
    },
    'F6j': function(X, S) {
        return X & S;
    },
    'F62': function(X, S) {
        return X instanceof S;
    },
    'I16': function(X, S) {
        return X <= S;
    },
    'a9h': function(X, S) {
        return X * S;
    },
    'H33': function(X, S) {
        return X !== S;
    },
    'O0a': function(X, S) {
        return X < S;
    },
    'q5M': function(X, S) {
        return X == S;
    },
    't1s': function(X, S) {
        return X << S;
    },
    'q5G': function(X, S) {
        return X !== S;
    },
    'g0B': function(X, S) {
        return X < S;
    },
    'H9O': function(X) {
        MAX_IDLE_TIME = X;
    },
    'z2v': function(X, S) {
        return X <= S;
    },
    'H3G': function(X, S) {
        return X * S;
    },
    'G32': function(X, S) {
        return X !== S;
    },
    'V4s': function(X, S) {
        return X * S;
    },
    'w1': function(X) {
        cc.SPRITEBATCHNODE_DEBUG_DRAW = X;
    },
    'm2s': function(X, S) {
        return X - S;
    },
    'L1L': function(X, S) {
        return X < S;
    },
    'j4t': function(X, S) {
        return X / S;
    },
    'p9G': function(X, S) {
        return X - S;
    },
    'A5P': "mainMenu",
    'H8a': function(X, S) {
        return X != S;
    },
    'N2z': function(X, S) {
        return X - S;
    },
    'z2m': function(X, S) {
        return X * S;
    },
    'j8h': function(X, S) {
        return X != S;
    },
    'x8s': function(X, S) {
        return X <= S;
    },
    'g4G': function(X, S) {
        return X < S;
    },
    'O7v': function(X, S) {
        return X != S;
    },
    'l28': function(X, S) {
        return X < S;
    },
    'B75': function(X, S) {
        return X == S;
    },
    'n7v': function(X, S) {
        return X === S;
    },
    'g6w': function(X, S) {
        return X * S;
    },
    'Y7l': function(X, S) {
        return X * S;
    },
    'a02': function(X, S) {
        return X != S;
    },
    'z8s': function(X, S) {
        return X == S;
    },
    'U2t': function(X, S) {
        return X - S;
    },
    'S8f': function(X, S) {
        return X * S;
    },
    'G4m': function(X, S) {
        return X == S;
    },
    'u9z': function(X, S) {
        return X * S;
    },
    'I31': function(X, S) {
        return X * S;
    },
    'T8l': function(X, S) {
        return X <= S;
    },
    's5j': function(X, S) {
        return X === S;
    },
    'O4O': function(X, S) {
        return X > S;
    },
    'z2w': function(X, S) {
        return X * S;
    },
    'L9G': function(X, S) {
        return X % S;
    },
    'w1M': function(X, S, P) {
        return X * S * P;
    },
    'l7m': function(X, S) {
        return X | S;
    },
    'w9T': function(X, S) {
        return X == S;
    },
    'n7B': function(X, S) {
        return X | S;
    },
    'B0': function(X) {
        cc.EventListener.TOUCH_ALL_AT_ONCE = X;
    },
    'M6A': function(X, S) {
        return X / S;
    },
    'u06': function(X, S) {
        return X - S;
    },
    'H68': function(X, S) {
        return X * S;
    },
    'B5z': function(X, S) {
        return X < S;
    },
    'S31': function(X, S) {
        return X * S;
    },
    'd2G': function(X, S) {
        return X / S;
    },
    'o4p': function(X, S) {
        return X - S;
    },
    'm21': function(X, S) {
        return X * S;
    },
    'm3w': function(X, S) {
        return X === S;
    },
    'l7q': function(X, S) {
        return X * S;
    },
    'l9T': function(X, S) {
        return X * S;
    },
    'D2w': function(X, S) {
        return X * S;
    },
    'B5L': function(X, S) {
        return X > S;
    },
    'R0q': function(X, S) {
        return X * S;
    },
    'o0z': function(X, S) {
        return X < S;
    },
    'm1d': function(X, S) {
        return X - S;
    },
    'y6D': function(X, S) {
        return X == S;
    },
    'O9z': function(X, S) {
        return X * S;
    },
    'n82': function(X, S) {
        return X * S;
    },
    'J0d': function(X, S) {
        return X / S;
    },
    'E1S': 0.5,
    'D7j': function(X, S) {
        return X >>> S;
    },
    't5A': function(X, S) {
        return X * S;
    },
    'T3p': function(X, S) {
        return X >= S;
    },
    'b3h': function(X, S) {
        return X / S;
    },
    'K06': function(X, S) {
        return X / S;
    },
    'M4b': function(X, S) {
        return X > S;
    },
    'h5b': function(X, S) {
        return X / S;
    },
    'B3b': function(X, S) {
        return X / S;
    },
    'o4t': function(X, S) {
        return X < S;
    },
    't8L': function(X, S) {
        return X < S;
    },
    'x0q': function(X, S) {
        return X * S;
    },
    'e0B': function(X, S) {
        return X / S;
    },
    'G0D': function(X, S) {
        return X == S;
    },
    'I32': function(X, S) {
        return X >= S;
    },
    'k0l': function(X, S) {
        return X % S;
    },
    'c0m': function(X, S) {
        return X * S;
    },
    'c2v': function(X, S) {
        return X > S;
    },
    'L1y': function(X) {
        cc.SHADER_POSITION_TEXTURE_UCOLOR = X;
    },
    'Z1b': function(X, S) {
        return X / S;
    },
    'W4m': function(X, S) {
        return X == S;
    },
    'O9': function(X) {
        cc._canvas = X;
    },
    'N1A': function(X, S) {
        return X == S;
    },
    'y8p': function(X, S) {
        return X >= S;
    },
    't2M': function(X, S) {
        return X < S;
    },
    'j2f': function(X, S) {
        return X == S;
    },
    'h7O': function(X, S) {
        return X == S;
    },
    'm6D': function(X, S) {
        return X * S;
    },
    'E5b': function(X, S) {
        return X === S;
    },
    'u0i': "res/logo1.png",
    'p7': function(X) {
        cc.UIInterfaceOrientationPortraitUpsideDown = X;
    },
    'Y8O': function(X, S) {
        return X == S;
    },
    'z1j': function(X, S) {
        return X - S;
    },
    'y3H': 3233828865,
    'R18': function(X, S) {
        return X === S;
    },
    'm9l': function(X, S) {
        return X > S;
    },
    'k4h': function(X, S) {
        return X < S;
    },
    's7w': function(X, S) {
        return X % S;
    },
    'I4u': function(X, S) {
        return X < S;
    },
    'f3w': function(X, S) {
        return X === S;
    },
    'B68': function(X, S) {
        return X | S;
    },
    'K7i': "vsh",
    'N0s': function(X, S) {
        return X * S;
    },
    'n9s': function(X, S) {
        return X / S;
    },
    'n5T': function(X, S) {
        return X / S;
    },
    'g2M': function(X, S) {
        return X < S;
    },
    'f2O': function(X, S) {
        return X <= S;
    },
    'L2S': "zIndex",
    'l5G': function(X, S) {
        return X >= S;
    },
    'c9v': function(X, S) {
        return X >>> S;
    },
    'b61': function(X, S) {
        return X | S;
    },
    'h7H': 1,
    's01': function(X, S) {
        return X !== S;
    },
    'm4j': function(X, S) {
        return X >> S;
    },
    'O1p': function(X, S) {
        return X === S;
    },
    'D1E': function(X, S) {
        return X | S;
    },
    'S2O': function(X, S) {
        return X === S;
    },
    'p0A': function(X, S) {
        return X != S;
    },
    'n3O': function(X, S) {
        return X == S;
    },
    'J33': function(X, S) {
        return X != S;
    },
    'w5w': function(X, S) {
        return X === S;
    },
    'H6i': "tsx",
    'd6D': function(X, S) {
        return X < S;
    },
    'q7M': function(X, S) {
        return X * S;
    },
    'L3u': function(X, S) {
        return X == S;
    },
    'J0l': function(X, S) {
        return X % S;
    },
    'G08': function(X, S) {
        return X << S;
    },
    'h5m': function(X, S) {
        return X * S;
    },
    'Y8u': function(X, S) {
        return X - S;
    },
    'Z8N': function(X, S) {
        return X != S;
    },
    'q2y': function(X) {
        Global.bombCollidSize = X;
    },
    'h7z': function(X, S) {
        return X !== S;
    },
    'P9f': function(X, S) {
        return X < S;
    },
    'y05': function(X, S) {
        return X == S;
    },
    'l2M': function(X, S) {
        return X / S;
    },
    'l6E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'a8G': function(X, S) {
        return X !== S;
    },
    'W2j': function(X, S) {
        return X < S;
    },
    'P0a': function(X, S) {
        return X * S;
    },
    'Y4v': function(X, S) {
        return X < S;
    },
    'V6E': function(X, S, P) {
        return X * S * P;
    },
    'R95': function(X, S) {
        return X * S;
    },
    'e4f': function(X, S, P) {
        return X / S * P;
    },
    'U5j': function(X, S) {
        return X - S;
    },
    'U4': function(X) {
        cc.VERTICAL_TEXT_ALIGNMENT_CENTER = X;
    },
    'J9A': function(X, S) {
        return X == S;
    },
    'L0l': function(X, S) {
        return X % S;
    },
    'L7L': function(X, S) {
        return X * S;
    },
    'h42': function(X, S) {
        return X != S;
    },
    'M0H': "__cc_acceleration",
    'r0N': function(X, S) {
        return X - S;
    },
    'X2': function(X) {
        cc.KM_TRUE = X;
    },
    'm0B': function(X, S) {
        return X & S;
    },
    'T1j': function(X, S) {
        return X < S;
    },
    'M4v': function(X, S) {
        return X != S;
    },
    'm8m': function(X, S) {
        return X < S;
    },
    'X1E': function(X, S) {
        return X * S;
    },
    'w4M': function(X, S) {
        return X == S;
    },
    'J0u': function(X, S) {
        return X / S;
    },
    'e13': function(X, S) {
        return X * S;
    },
    'x6y': function(X) {
        cc.TMX_TILE_HORIZONTAL_FLAG = X;
    },
    'Z8G': function(X, S) {
        return X < S;
    },
    'f22': function(X, S) {
        return X <= S;
    },
    'i9q': function(X, S) {
        return X * S;
    },
    'D5d': function(X, S) {
        return X != S;
    },
    'D58': function(X, S) {
        return X > S;
    },
    'I7': function(X) {
        cc.EventMouse.BUTTON_LEFT = X;
    },
    'Q7O': function(X, S) {
        return X == S;
    },
    'C1z': function(X, S) {
        return X / S;
    },
    'F0f': function(X, S) {
        return X < S;
    },
    'b0f': function(X, S) {
        return X <= S;
    },
    'u0T': function(X, S) {
        return X * S;
    },
    'A3w': function(X, S) {
        return X != S;
    },
    'x78': function(X, S) {
        return X * S;
    },
    'K6v': function(X, S) {
        return X * S;
    },
    'N3N': function(X, S) {
        return X * S;
    },
    'Q2a': function(X, S) {
        return X * S;
    },
    'O5u': function(X, S) {
        return X == S;
    },
    'K2z': function(X, S) {
        return X * S;
    },
    'U62': function(X, S) {
        return X == S;
    },
    'F4E': function(X, S) {
        return X instanceof S;
    },
    'o4L': function(X, S, P) {
        return X * S * P;
    },
    's9L': function(X, S) {
        return X < S;
    },
    'Z4m': function(X, S) {
        return X <= S;
    },
    'P5': function(X) {
        _B[_c.PIXEL_FORMAT_RGB888] = X;
    },
    'g4j': function(X, S) {
        return X & S;
    },
    'z0O': function(X, S) {
        return X == S;
    },
    'd1K': "Zombie0",
    'T8T': function(X, S) {
        return X * S;
    },
    'p6t': function(X, S) {
        return X > S;
    },
    'w6E': function(X, S) {
        return X < S;
    },
    'H4z': function(X, S) {
        return X - S;
    },
    'U4L': function(X, S) {
        return X * S;
    },
    'g1q': function(X, S) {
        return X * S;
    },
    'y13': function(X, S) {
        return X * S;
    },
    'G5s': function(X, S) {
        return X * S;
    },
    'x18': function(X, S) {
        return X != S;
    },
    'r5O': function(X, S) {
        return X | S;
    },
    'E7m': function(X, S) {
        return X < S;
    },
    'V6j': function(X, S) {
        return X <= S;
    },
    'J0T': function(X, S) {
        return X == S;
    },
    'u8w': function(X, S) {
        return X === S;
    },
    'P4z': function(X, S) {
        return X != S;
    },
    'L7b': function(X, S) {
        return X - S;
    },
    'e5m': function(X, S) {
        return X < S;
    },
    'c2i': "actionManager",
    'Y1N': function(X, S) {
        return X * S;
    },
    'q2d': function(X, S) {
        return X >= S;
    },
    'P8w': function(X, S) {
        return X | S;
    },
    'b2S': 34,
    'x5j': function(X, S) {
        return X < S;
    },
    'S8y': function(X) {
        cc.DrawNode.TYPE_SEGMENT = X;
    },
    'E1s': function(X, S) {
        return X != S;
    },
    'R7h': function(X, S) {
        return X * S;
    },
    'P4O': function(X, S) {
        return X < S;
    },
    'i2j': function(X, S) {
        return X === S;
    },
    'm1i': 77,
    'f2b': function(X, S) {
        return X / S;
    },
    'i9u': function(X, S) {
        return X < S;
    },
    'c2w': function(X, S) {
        return X * S;
    },
    'v2N': function(X, S) {
        return X * S;
    },
    'A7f': function(X, S) {
        return X != S;
    },
    'M8i': "svg",
    'Y8s': function(X, S) {
        return X % S;
    },
    's3h': function(X, S) {
        return X / S;
    },
    'W3b': function(X, S) {
        return X != S;
    },
    'X2l': function(X, S) {
        return X === S;
    },
    'J8E': function(X, S) {
        return X > S;
    },
    'J82': function(X, S) {
        return X !== S;
    },
    'L5h': function(X, S) {
        return X != S;
    },
    'H2E': function(X, S) {
        return X == S;
    },
    'b8h': function(X, S) {
        return X - S;
    },
    'C5H': "played",
    'j7D': function(X, S) {
        return X * S;
    },
    'x9': function(X) {
        cc._renderContext = X;
    },
    'y5O': function(X, S) {
        return X instanceof S;
    },
    'F1D': function(X, S) {
        return X == S;
    },
    'w9l': function(X, S) {
        return X !== S;
    },
    'K4T': function(X, S, P) {
        return X * S * P;
    },
    'B9d': function(X, S) {
        return X < S;
    },
    'l7H': "undefined",
    'W6': function(X) {
        cc.LabelTTF.__labelHeightDiv.style.position = X;
    },
    'u0D': function(X, S) {
        return X == S;
    },
    'v3': function(X) {
        _c.PIXEL_FORMAT_DEFAULT = X.PIXEL_FORMAT_RGBA8888;
    },
    'l6l': function(X, S) {
        return X / S;
    },
    'o3h': function(X, S) {
        return X | S;
    },
    'w4D': function(X, S) {
        return X == S;
    },
    'L4q': function(X, S) {
        return X * S;
    },
    'F5B': function(X, S, P) {
        return X * S / P;
    },
    'J1t': function(X, S) {
        return X < S;
    },
    'E5O': function(X, S) {
        return X === S;
    },
    't3l': function(X, S) {
        return X != S;
    },
    'c3M': function(X, S) {
        return X * S;
    },
    'C4w': function(X, S) {
        return X | S;
    },
    'N0B': function(X, S) {
        return X & S;
    },
    'V83': function(X, S) {
        return X * S;
    },
    'm5u': function(X, S, P) {
        return X * S * P;
    },
    'S9A': function(X, S) {
        return X == S;
    },
    't98': function(X, S) {
        return X != S;
    },
    'C5f': function(X, S) {
        return X | S;
    },
    'Y0O': function(X, S) {
        return X == S;
    },
    'J5P': "tileWidth",
    'o8h': function(X, S) {
        return X == S;
    },
    'E53': function(X, S) {
        return X * S;
    },
    'z0h': function(X, S) {
        return X === S;
    },
    'U11': function(X, S) {
        return X !== S;
    },
    'r6h': function(X, S) {
        return X / S;
    },
    'o5j': function(X, S) {
        return X > S;
    },
    'D4y': function() {
        cc.Codec.GZip.border = [16, 17, 18, (0x32 < (0xB8, 39.5E1) ? (3.80E1, 0) : (0x8D, 106.80E1)), 8, 7, (0x1CC >= (29, 3) ? (86.2E1, 9) : (143, 18) > 1.3E2 ? (0xB6, 0x1DD) : 32 > (25, 139.) ? (10.950E2, 1.09E2) : (1.472E3, 0xB7)), 6, ((0x3E, 21.) < (36, 0x83) ? (1.26E2, 10) : (124., 11.65E2)), 5, 11, ((4.69E2, 76.7E1) > (5.94E2, 0x159) ? (0x13F, 4) : (0x1, 100.) < 43. ? "T" : (4.7E1, 6.16E2) <= (0x1CF, 0x14A) ? (0x208, 0xC9) : (0x100, 69)), ((0x13E, 70.7E1) >= 124. ? (111, 12) : (120, 0xDA) > (0xF3, 14.23E2) ? (0x15B, 33) : (0x101, 1)), 3, (99 <= (17.8E1, 123.) ? (0x3A, 13) : (26.0E1, 0x1F0) < 52 ? (62., 101.7E1) : 0x1EE <= (0x225, 42) ? (0x13E, 'p') : (89., 0x121)), 2, 14, 1, ((23, 0x55) > 0xC6 ? (0x73, 0x1D3) : (0x13D, 0x5C) < (96., 0x147) ? (60.6E1, 15) : (9.55E2, 3.))];
    },
    'L15': function(X, S) {
        return X * S;
    },
    'G76': function(X, S) {
        return X == S;
    },
    'g5S': "BombZombie",
    'A9N': function(X, S) {
        return X * S;
    },
    'q52': function(X, S) {
        return X < S;
    },
    'Y2': function(X) {
        cc.POINT_BEHIND_PLANE = X;
    },
    'q5f': function(X, S) {
        return X === S;
    },
    'g0s': function(X, S) {
        return X * S;
    },
    'F8i': "disabledColor",
    'W75': function(X, S) {
        return X === S;
    },
    'Z6N': function(X, S) {
        return X * S;
    },
    'b5a': function(X, S) {
        return X > S;
    },
    'P8H': function(X, S) {
        return X == S;
    },
    'C9l': function(X, S) {
        return X - S;
    },
    'D92': function(X, S) {
        return X !== S;
    },
    'i33': function(X, S) {
        return X | S;
    },
    'D1T': function(X, S) {
        return X - S;
    },
    'S2E': function(X, S, P, O) {
        return X * S * P * O;
    },
    'u9s': function(X, S) {
        return X / S;
    },
    'f4q': function(X, S) {
        return X * S;
    },
    'I33': function(X, S) {
        return X !== S;
    },
    'k9G': function(X, S) {
        return X * S;
    },
    'y3d': function(X, S) {
        return X - S;
    },
    'P8j': function(X, S) {
        return X < S;
    },
    'P8G': function(X, S) {
        return X < S;
    },
    'h9O': function() {
        Global.PropsLevel = [[[800, ((31.8E1, 6.9E1) >= (99, 5.21E2) ? (0x1CC, 660) : (4.83E2, 15) < (30, 120) ? (8.99E2, 5) : (9., 0x32))], [1E3, 5], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [1E3, 5], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [(83. > (91, 73.8E1) ? "de" : (0x15D, 0x16A) > 23 ? (5.9E1, 1E3) : 70.7E1 <= (0x32, 0x15E) ? (1.17E3, 1.04E3) : (1.258E3, 0xFF)), 5], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [1E3, (80 < (0x1D3, 2.19E2) ? (0x111, 5) : (143.0E1, 108))], [((8.290E2, 0x82) < (67.8E1, 9.1E1) ? (1.69E2, "l") : 60 <= (9.61E2, 3.38E2) ? (2.36E2, 500) : (0xFC, 125)), 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, (0x13B <= (0x23A, 111.) ? 1.94E2 : (0x24F, 73.0E1) > 123. ? (40, 5) : (24.20E1, 0x1FB))], [1E3, 5], [500, (18.2E1 < (0x15, 138) ? (68., "y") : (68.2E1, 0xE) <= (5.97E2, 0x24A) ? (0x141, 5) : (68.8E1, 9))], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [1E3, 5], [500, 5], [5E3, 5], [((12., 0x28) <= (146., 0x215) ? (0x185, 2500) : (0xF4, 22.5E1)), 5], [(0x1F5 <= (76, 124.4E1) ? (6.4E2, 2500) : (0x3E, 11.5E2)), 5]], [[800, ((130., 24.90E1) <= (0x24A, 9.49E2) ? (14.55E2, 5) : (0x238, 121.2E1))], [1E3, 5], [500, 5], [5E3, (9.4E1 < (88, 7.140E2) ? (72, 5) : (0xC2, 75.8E1) < 0x229 ? (2.6E2, "+") : 30. > (54., 10.78E2) ? "+" : (68, 6.91E2))], [((54.80E1, 28) > (46, 142.) ? 0x1C1 : 0x24F > (41., 0x223) ? (5., 2500) : (0x1EF, 17)), 5], [2500, 5]], [[800, 5], [1E3, 5], [500, (8.13E2 > (95, 0xAD) ? (11., 5) : (6.38E2, 51.))], [5E3, 5], [2500, 5], [2500, 5]], [[(86.4E1 < (0x208, 44.) ? 3.260E2 : (0xA0, 0x0) <= 13. ? (28., 800) : (9.61E2, 1.252E3)), 5], [1E3, 5], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[((78, 0x100) < 0x24D ? (97.30E1, 800) : (87.7E1, 48.90E1)), ((0x13E, 0xA8) < (0x24, 1.78E2) ? (0x3, 5) : (0x1FC, 3.71E2) < 88 ? (51.2E1, 16.) : (18., 38))], [1E3, 5], [(0xB6 <= (0x179, 2.550E2) ? (0x245, 500) : (56., 0x112) < (137., 90.) ? 105. : (8., 0x80)), 5], [5E3, 5], [2500, ((126, 0x10D) >= 14.13E2 ? (0xC8, 173) : (32.9E1, 108.) >= (106., 0) ? (95, 5) : (0x4A, 95.10E1))], [2500, ((73.3E1, 122) > (68., 121) ? (2., 5) : (0x40, 60.))]], [[800, 5], [1E3, 5], [((9.32E2, 50.7E1) > 2.02E2 ? (84, 500) : (115.9E1, 74.)), 5], [5E3, 5], [(59 <= (117, 0x234) ? (3.77E2, 2500) : (118., 136) < 52 ? "k" : 16. > (94.5E1, 73) ? 143. : (0., 27.)), 5], [2500, 5]], [[800, 5], [1E3, (0x237 > (6.48E2, 8) ? (140, 5) : (14, 85) > 113 ? 93 : 1.84E2 > (1.68E2, 4.44E2) ? (0x1B2, 227) : (125.9E1, 31.90E1))], [(108. > (0xB2, 4.36E2) ? 54. : 9.68E2 > (0x10, 67) ? (3.570E2, 500) : (1.880E2, 16.3E1) >= (8.57E2, 0x128) ? 71.8E1 : (52.40E1, 11.)), ((75., 146) > 68 ? (39, 5) : 132. < (108., 0x47) ? (71, 209) : (42., 0x233))], [5E3, (44.1E1 <= (107.9E1, 37.) ? 243 : (148, 0x6B) <= 49.7E1 ? (12.6E2, 5) : (0x1A2, 9.78E2) <= 121 ? 0x1D : (5.37E2, 0x48))], [2500, 5], [2500, 5]], [[800, 5], [((0x1DC, 79.5E1) < (0x16D, 1.164E3) ? (0xB8, 1E3) : (147., 41) > (0x5B, 0x11D) ? (0x250, 'g') : (99., 2.)), ((0x131, 8.25E2) > (8.16E2, 0x221) ? (59.6E1, 5) : (138, 46) >= (41., 72.7E1) ? 97 : (1.216E3, 0x24D))], [500, 5], [5E3, 5], [2500, ((0xD0, 0x242) >= 14.46E2 ? 'w' : (130, 118) >= 0x4D ? (14, 5) : (0x126, 12.93E2) < 0x20D ? "w" : (0x6, 0x1EE))], [2500, 5]], [[800, 5], [(0x13B < (0x42, 0xC) ? (138.1E1, 0x9E) : 0x145 < (0x4A, 144) ? 6.45E2 : (27, 13.6E2) >= 0x1DF ? (63., 1E3) : (6.67E2, 4.09E2)), 5], [500, 5], [5E3, 5], [2500, ((1.328E3, 0x16F) > (0x5C, 0xC9) ? (56., 5) : (66., 1.1420E3) < 40.90E1 ? (0xC2, 13.01E2) : (68., 3.08E2))], [2500, 5]], [[800, ((0x8A, 0x24A) > 57 ? (7., 5) : (2.16E2, 0x235) > 1.359E3 ? 4.2E1 : 0x1D3 < (9.16E2, 0x67) ? 0 : (0x132, 70.10E1))], [((0x19B, 7.8E2) > 114. ? (1.245E3, 1E3) : (11.48E2, 0xDB)), (4.810E2 > (0x1AD, 2.5E1) ? (104, 5) : (0xC0, 0x217))], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [1E3, 5], [500, 5], [5E3, (0x254 < (80., 82) ? 0x240 : (0x1FF, 23.70E1) >= 37. ? (36, 5) : 26 >= (100.0E1, 1.067E3) ? 0x10E : (0x8B, 86.))], [2500, 5], [((90, 7.3E2) > (97, 118.) ? (0x246, 2500) : (0x186, 51.6E1)), 5]], [[800, 5], [1E3, 5], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[((1.1E1, 13) < (26.3E1, 36.9E1) ? (0x237, 800) : (113., 5.) >= 67.60E1 ? 2049 : (44., 11) >= 46. ? 2049 : (142., 1.197E3)), 5], [((136.20E1, 0xA5) < 97 ? (0x86, "B") : (1E0, 0x221) < (142., 1.483E3) ? (37, 1E3) : (0x1C9, 0x117) >= (30, 7.270E2) ? 54.30E1 : (0x20E, 1.98E2)), 5], [500, ((144.70E1, 0x18F) > (55, 93.10E1) ? (4.71E2, 9.1E1) : 124. < (0x61, 0x93) ? (6.68E2, 5) : (53.6E1, 111.30E1) < (141.70E1, 82.10E1) ? (3., 10.72E2) : (0x1A6, 0x174))], [(0x235 <= (0xD4, 61.7E1) ? (21, 5E3) : (47.0E1, 0xD6) > (80, 0x206) ? 51 : (57., 49.7E1)), 5], [((0xBC, 85.) <= (0x12, 49.2E1) ? (52., 2500) : (0x132, 83.2E1)), ((0x1B6, 115) > 4.26E2 ? (13.450E2, 1.5) : (51.6E1, 0x173) >= (11.60E1, 0x141) ? (0x209, 5) : 0xE2 > (61, 0xFA) ? 102. : (0x4E, 5.53E2))], [2500, 5]], [[800, 5], [1E3, 5], [500, 5], [5E3, 5], [2500, ((114, 58.30E1) > (0xAA, 0x20F) ? (93, 5) : (0xE6, 143) < 77 ? (79.60E1, 14.06E2) : (28.0E1, 20) >= (31., 0x1F1) ? 247 : (0x10, 131.0E1))], [2500, 5]], [[800, 5], [1E3, (104 < (69., 0x229) ? (117.0E1, 5) : 0x188 <= (25, 122) ? 24577 : (88, 74.5E1))], [(128 < (119, 135.) ? (59., 500) : (8.57E2, 0x1D4) < 4.22E2 ? (3.93E2, 8801) : 0x33 > (44, 0x1DC) ? 45. : (142.6E1, 96.0E1)), 5], [5E3, 5], [2500, 5], [2500, 5]], [[800, 5], [((2.84E2, 0xE0) >= (54.2E1, 0x0) ? (115., 1E3) : (17.6E1, 4.80E1) >= 0x24C ? 0x20B : (60., 108.)), ((0x69, 9.33E2) >= (37., 0xE0) ? (87., 5) : (99.9E1, 1.81E2))], [500, 5], [5E3, 5], [2500, 5], [2500, 5]], [[(112 >= (37., 6.5E1) ? (55.5E1, 800) : (0xEE, 76.2E1)), 5], [1E3, 5], [(1.630E2 > (0x216, 0xDB) ? (72., "g") : (0x1FD, 126.2E1) >= 11.74E2 ? (4.26E2, 500) : 0x91 > (0xA3, 9.86E2) ? 1.306E3 : (95, 69.2E1)), ((0x10A, 0x9E) < 46.1E1 ? (82.80E1, 5) : (1., 42.0E1))], [5E3, 5], [((0x18F, 0xC4) >= 112 ? (1E0, 2500) : (12.790E2, 114) > (7.72E2, 0x1F3) ? 6.05E2 : (6, 46)), 5], [2500, 5]], [[(0x52 >= (0x1B8, 0x43) ? (1.73E2, 800) : (0x233, 0x148) < 103. ? (58., 45.) : (112.0E1, 1.56E2) >= 1.68E2 ? "y" : (27., 13.870E2)), 5], [((0x7B, 28) <= 113. ? (10.4E1, 1E3) : 46. > (124, 0x202) ? "y" : (81.7E1, 122)), 5], [500, 5], [5E3, 5], [2500, (14.17E2 <= (94, 6.68E2) ? 'Q' : (0x194, 75.) < (116., 121) ? (0xDA, 5) : (0x3B, 0x105) <= (32., 141.) ? (17, 1.189E3) : (0x249, 0x16B))], [2500, 5]], [[800, 5], [1E3, ((3.2E1, 70.7E1) > 0x182 ? (0x140, 5) : (23.90E1, 124.2E1) < 89. ? 116 : (7.5E2, 12.59E2) < (5.54E2, 108.) ? (16.2E1, 3.95E2) : (127., 109.80E1))], [500, 5], [5E3, 5], [2500, 5], [2500, ((2, 91.60E1) >= 3.43E2 ? (0xC1, 5) : (0xF, 42.90E1))]]];
    },
    'Y7i': 99,
    'j3': function(X) {
        cc.ALIGN_TOP_LEFT = X;
    },
    'q3': function(X) {
        _M[_c.PIXEL_FORMAT_A8] = X;
    },
    'F4v': function(X, S) {
        return X == S;
    },
    'a12': function(X, S) {
        return X / S;
    },
    'b4v': function(X, S) {
        return X < S;
    },
    'R96': function(X, S) {
        return X != S;
    },
    'F9i': 11,
    'X6q': function(X, S) {
        return X * S;
    },
    'J6a': function(X, S) {
        return X * S;
    },
    'e3N': function(X, S) {
        return X >= S;
    },
    'v9': function(X) {
        cc.ENGINE_VERSION = X;
    },
    'X0m': function(X, S) {
        return X * S;
    },
    'e9a': function(X, S) {
        return X | S;
    },
    'j5d': function(X, S) {
        return X != S;
    },
    'q2P': "no",
    'n8b': function(X, S) {
        return X < S;
    },
    'T8q': function(X, S) {
        return X * S;
    },
    'H7s': function(X, S) {
        return X - S;
    },
    'I0N': function(X, S) {
        return X * S;
    },
    'C9H': function(X, S) {
        return X < S;
    },
    'C9j': function(X, S) {
        return X > S;
    },
    'K1i': "RGB565",
    'p21': function(X, S, P) {
        return X - S + P;
    },
    's2D': function(X, S) {
        return X * S;
    },
    'A6f': function(X, S, P) {
        return X - S + P;
    },
    'r3w': function(X, S) {
        return X < S;
    },
    'U81': function(X, S) {
        return X !== S;
    },
    'z8l': function(X, S) {
        return X <= S;
    },
    'f8i': 49,
    'k3L': function(X, S, P) {
        return X * S * P;
    },
    'R81': function(X, S) {
        return X !== S;
    },
    'J9P': "TransitionScene",
    'n5L': function(X, S) {
        return X == S;
    },
    'l1y': function(X) {
        cc.IMAGE_FORMAT_JPEG = X;
    },
    'k4d': function(X, S) {
        return X | S;
    },
    'e53': function(X, S) {
        return X != S;
    },
    'e5q': function(X, S) {
        return X * S;
    },
    'y2S': 33,
    'k26': function(X, S) {
        return X == S;
    },
    'a5S': "mp4",
    'j72': function(X, S) {
        return X === S;
    },
    't7M': function(X, S) {
        return X < S;
    },
    'h9E': function(X, S) {
        return X / S;
    },
    'Z8f': function(X, S) {
        return X / S;
    },
    'l86': function(X, S) {
        return X == S;
    },
    'D6q': function(X, S) {
        return X * S;
    },
    'R1y': function(X) {
        cc.ATTRIBUTE_NAME_POSITION = X;
    },
    'k8G': function(X, S) {
        return X == S;
    },
    'F0A': function(X, S) {
        return X != S;
    },
    'Q5f': function(X, S) {
        return X == S;
    },
    's0G': function(X, S) {
        return X > S;
    },
    'l73': function(X, S) {
        return X < S;
    },
    'j7l': function(X, S) {
        return X % S;
    },
    'f6M': function(X, S) {
        return X / S;
    },
    'E3j': function(X, S) {
        return X < S;
    },
    'K6T': function(X, S) {
        return X / S;
    },
    'j01': function(X, S) {
        return X * S;
    },
    'X5a': function(X, S) {
        return X * S;
    },
    't86': function(X, S) {
        return X != S;
    },
    'Z3f': function(X, S) {
        return X != S;
    },
    'K9N': function(X, S) {
        return X * S;
    },
    'P2P': "lg.MovieClip",
    'W4u': function(X, S) {
        return X * S;
    },
    'x3E': function(X, S) {
        return X == S;
    },
    'W6a': function(X, S) {
        return X * S;
    },
    'c62': function(X, S) {
        return X - S;
    },
    'y38': function(X, S) {
        return X == S;
    },
    't2s': function(X, S) {
        return X - S;
    },
    'o6A': function(X, S) {
        return X < S;
    },
    'K5O': function(X, S) {
        return X / S;
    },
    'k7i': "horizontal",
    'G31': function(X, S) {
        return X * S;
    },
    'x2y': function() {
        lg._inited = !1;
    },
    'z6O': function(X, S) {
        return X == S;
    },
    'r65': function(X, S) {
        return X < S;
    },
    't9a': function(X, S) {
        return X === S;
    },
    'N3l': function(X, S) {
        return X * S;
    },
    'i8y': function() {
        cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
    },
    'r6M': function(X, S) {
        return X / S;
    },
    'b8d': function(X, S) {
        return X / S;
    },
    'm2p': function(X, S) {
        return X < S;
    },
    'C9D': function(X, S) {
        return X < S;
    },
    'o25': function(X, S) {
        return X !== S;
    },
    'e7u': function(X, S) {
        return X * S;
    },
    'S9i': "CC_Texture0",
    'I9s': function(X, S) {
        return X !== S;
    },
    'W1p': function(X, S) {
        return X === S;
    },
    'e1d': function(X, S) {
        return X == S;
    },
    'j3B': function(X, S) {
        return X === S;
    },
    'n0K': "ShaderPositionTextureA8Color",
    'x9G': function(X, S) {
        return X & S;
    },
    'V1B': function(X, S) {
        return X / S;
    },
    'J1G': function(X, S) {
        return X != S;
    },
    'C2A': function(X, S) {
        return X < S;
    },
    'Y3': function(X) {
        _c.PIXEL_FORMAT_A8 = X;
    },
    'h9j': function(X, S) {
        return X * S;
    },
    'n5H': "lg.TimeLine",
    'i7N': function(X, S) {
        return X * S;
    },
    'i1v': function(X, S) {
        return X == S;
    },
    'x6t': function(X, S) {
        return X > S;
    },
    'v6a': function(X, S) {
        return X * S;
    },
    'V0O': function(X, S) {
        return X != S;
    },
    'a82': function(X, S) {
        return X / S;
    },
    'W8B': function(X, S) {
        return X === S;
    },
    'x3u': function(X, S) {
        return X | S;
    },
    'I4K': 5890,
    'T66': function(X, S) {
        return X - S;
    },
    'v4A': function(X, S) {
        return X != S;
    },
    'W8w': function(X, S) {
        return X > S;
    },
    'M1w': function(X, S) {
        return X / S;
    },
    'H2j': function(X, S) {
        return X > S;
    },
    'F6y': function() {
        DEGREE_TO_RADIAN = Math.PI / 180;
    },
    'X7j': function(X, S) {
        return X > S;
    },
    'f3f': function(X, S) {
        return X instanceof S;
    },
    'v9f': function(X, S) {
        return X * S;
    },
    'a6G': function(X, S) {
        return X * S;
    },
    'I2': function(X) {
        cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = X;
    },
    's6j': function(X, S) {
        return X & S;
    },
    'k31': function(X, S) {
        return X === S;
    },
    'G2b': function(X, S) {
        return X === S;
    },
    'x4p': function(X, S) {
        return X >= S;
    },
    'v8G': function(X, S) {
        return X !== S;
    },
    'G8H': function(X, S) {
        return X - S;
    },
    'L0a': function(X, S) {
        return X * S;
    },
    'w9E': function(X, S) {
        return X !== S;
    },
    'E4l': function(X, S) {
        return X == S;
    },
    'a16': function(X, S) {
        return X == S;
    },
    'q8p': function(X, S) {
        return X - S;
    },
    'C6v': function(X, S) {
        return X == S;
    },
    'p7w': function(X, S) {
        return X | S;
    },
    'G33': function(X, S) {
        return X != S;
    },
    'E1A': function(X, S) {
        return X == S;
    },
    'U7H': 0,
    'I7S': "r",
    'M1P': "type",
    'j8y': function() {
        cc.stencilBits = -1;
    },
    'X5i': "speedVar",
    'x3h': function(X, S) {
        return X < S;
    },
    'l43': function(X, S) {
        return X < S;
    },
    'V0f': function(X, S) {
        return X === S;
    },
    'k8E': function(X, S) {
        return X * S;
    },
    't7u': function(X, S) {
        return X < S;
    },
    'U7D': function(X, S) {
        return X > S;
    },
    'z4L': function(X, S) {
        return X > S;
    },
    'B8E': function(X, S) {
        return X | S;
    },
    'W4A': function(X, S) {
        return X == S;
    },
    'J1p': function(X, S) {
        return X - S;
    },
    'T3M': function(X, S) {
        return X - S;
    },
    'O2T': function(X, S) {
        return X / S;
    },
    'd4D': function(X, S) {
        return X / S;
    },
    'z01': function(X, S) {
        return X * S;
    },
    'E9H': function(X, S) {
        return X * S;
    },
    'O8E': function(X, S) {
        return X / S;
    },
    'F0G': function(X, S) {
        return X >= S;
    },
    'K4K': "RED",
    'G8N': function(X, S) {
        return X instanceof S;
    },
    'i2b': function(X, S) {
        return X == S;
    },
    'y6l': function(X, S) {
        return X / S;
    },
    'P1b': function(X, S) {
        return X === S;
    },
    'q0M': function(X, S) {
        return X * S;
    },
    'I8D': function(X, S) {
        return X / S;
    },
    'm13': function(X, S) {
        return X * S;
    },
    'J32': function(X, S) {
        return X <= S;
    },
    'r8t': function(X, S) {
        return X < S;
    },
    'B12': function(X, S) {
        return X / S;
    },
    'B4A': function(X, S) {
        return X == S;
    },
    'c5j': function(X, S) {
        return X - S;
    },
    'C7G': function(X, S) {
        return X * S;
    },
    'M3z': function(X, S) {
        return X < S;
    },
    'x1T': function(X, S) {
        return X * S;
    },
    'N2a': function(X, S) {
        return X * S;
    },
    'M7t': function(X, S) {
        return X >= S;
    },
    'W76': function(X, S) {
        return X <= S;
    },
    'D7D': function(X, S) {
        return X * S;
    },
    'd5': function(X) {
        _M[_c.PIXEL_FORMAT_PVRTC2] = X;
    },
    'q4l': function(X, S) {
        return X * S;
    },
    'p56': function(X, S) {
        return X - S;
    },
    'T73': function(X, S) {
        return X / S;
    },
    'f7s': function(X, S) {
        return X * S;
    },
    'F8y': function(X) {
        cc.Codec.GZip.NAMEMAX = X;
    },
    'b8z': function(X, S) {
        return X * S;
    },
    'g8p': function(X, S) {
        return X >= S;
    },
    'q0B': function(X, S) {
        return X | S;
    },
    'T1w': function(X, S) {
        return X | S;
    },
    'A28': function(X, S) {
        return X >= S;
    },
    's9S': "mainGame",
    'C7A': function(X, S) {
        return X == S;
    },
    'v8N': function(X, S) {
        return X != S;
    },
    'T7D': function(X, S) {
        return X * S;
    },
    'j3h': function(X, S) {
        return X !== S;
    },
    'k8l': function(X, S, P) {
        return X * S / P;
    },
    'D4t': function(X, S) {
        return X < S;
    },
    'z0m': function(X, S) {
        return X * S;
    },
    'b3p': function(X, S) {
        return X >= S;
    },
    'y9M': function(X, S) {
        return X - S;
    },
    'o0A': function(X, S) {
        return X != S;
    },
    'O4l': function(X, S) {
        return X << S;
    },
    'P2y': function(X) {
        lg.buttonSound = X;
    },
    'P0l': function(X, S) {
        return X < S;
    },
    'n8D': function(X, S) {
        return X * S;
    },
    'N4H': function(X, S) {
        return X == S;
    },
    'd2y': function(X) {
        lg.currentSceneName = X;
    },
    'I8a': function(X, S) {
        return X != S;
    },
    'Z7N': function(X, S) {
        return X * S;
    },
    'f16': function(X, S) {
        return X == S;
    },
    'A7A': function(X, S) {
        return X == S;
    },
    'c61': function(X, S) {
        return X === S;
    },
    'O6a': function(X, S) {
        return X * S;
    },
    'Z4O': function(X, S) {
        return X * S;
    },
    'D7l': function(X, S) {
        return X < S;
    },
    'J2b': function(X, S) {
        return X / S;
    },
    'z0q': function(X, S) {
        return X * S;
    },
    'J4h': function(X, S) {
        return X < S;
    },
    'z72': function(X, S) {
        return X === S;
    },
    'G1t': function(X, S) {
        return X < S;
    },
    'N9O': function(X) {
        MAX_FAULT_TIMES = X;
    },
    'L4m': function(X, S) {
        return X - S;
    },
    'k4q': function(X, S) {
        return X * S;
    },
    'Q0B': function(X, S) {
        return X / S;
    },
    'j3M': function(X, S) {
        return X * S;
    },
    'G9q': function(X, S) {
        return X * S;
    },
    't3j': function(X, S) {
        return X < S;
    },
    'l51': function(X, S) {
        return X == S;
    },
    'g0v': function(X, S) {
        return X != S;
    },
    'c01': function(X, S) {
        return X * S;
    },
    'o3u': function(X, S) {
        return X * S;
    },
    'e4B': function(X, S) {
        return X >> S;
    },
    'v88': function(X, S) {
        return X > S;
    },
    'h0': function() {
        cc.NODE_TAG_INVALID = -1;
    },
    'K6w': function(X, S) {
        return X * S;
    },
    'T6O': function(X, S) {
        return X == S;
    },
    'F92': function(X, S) {
        return X != S;
    },
    'X1w': function(X, S) {
        return X < S;
    },
    't5H': "onPress",
    'g71': function(X, S) {
        return X != S;
    },
    'X8z': function(X, S) {
        return X * S;
    },
    'P0u': function(X, S) {
        return X < S;
    },
    'L2': function(X) {
        cc.kmPI = X;
    },
    'W3G': function(X, S) {
        return X >>> S;
    },
    'Y1a': function(X, S) {
        return X / S;
    },
    'i7v': function(X, S) {
        return X <= S;
    },
    'u9i': 15,
    'w5q': function(X, S) {
        return X * S;
    },
    'r8y': function(X) {
        cc.PROGRESS_TIMER_TYPE_RADIAL = X;
    },
    'f2T': function(X, S) {
        return X * S;
    },
    'k4s': function(X, S) {
        return X == S;
    },
    'T0G': function(X, S) {
        return X === S;
    },
    'g2s': function(X, S) {
        return X == S;
    },
    'y5P': "gif",
    'l0S': 125,
    'm51': function(X, S) {
        return X * S;
    },
    'm9N': function(X, S) {
        return X == S;
    },
    'j6m': function(X, S) {
        return X - S;
    },
    'i9s': function(X, S) {
        return X / S;
    },
    'G9m': function(X, S) {
        return X === S;
    },
    'L5L': function(X, S) {
        return X * S;
    },
    'H55': function(X, S) {
        return X > S;
    },
    'q0z': function(X, S) {
        return X - S;
    },
    'x9S': "pixelsHeight",
    'H1M': function(X, S) {
        return X * S;
    },
    's2': function(X) {
        cc.SHADER_POSITION_UCOLOR_FRAG = X;
    },
    'b62': function(X, S) {
        return X == S;
    },
    'k82': function(X, S) {
        return X / S;
    },
    'L4M': function(X, S) {
        return X * S;
    },
    'f8B': function(X, S) {
        return X !== S;
    },
    'H8B': function(X, S) {
        return X & S;
    },
    'x8u': function(X, S) {
        return X < S;
    },
    'u3y': function() {
        cc.PARTICLE_DURATION_INFINITY = -1;
    },
    'a8b': function(X, S) {
        return X >= S;
    },
    'W0K': "zomibe_attack_player",
    'x0O': function(X, S) {
        return X instanceof S;
    },
    'L7s': function(X, S) {
        return X * S;
    },
    'H5s': function(X, S) {
        return X / S;
    },
    'I4M': function(X, S, P, O) {
        return X * S * P / O;
    },
    'V1D': function(X, S) {
        return X == S;
    },
    'l7j': function(X, S) {
        return X >= S;
    },
    'X5N': function(X, S) {
        return X * S;
    },
    'm0K': 99E3,
    'Q13': function(X, S) {
        return X <= S;
    },
    'n0D': function(X, S) {
        return X < S;
    },
    'u2l': function(X, S) {
        return X === S;
    },
    'm6f': function(X, S) {
        return X * S;
    },
    'y5G': function(X, S) {
        return X * S;
    },
    'U72': function(X, S) {
        return X === S;
    },
    'I0D': function(X, S) {
        return X != S;
    },
    'i0a': function(X, S) {
        return X * S;
    },
    'h0B': function(X, S) {
        return X != S;
    },
    'X62': function(X, S) {
        return X - S;
    },
    'B8w': function(X, S) {
        return X / S;
    },
    'x5': function(X) {
        _B[_c.PIXEL_FORMAT_A8] = X;
    },
    'y8t': function(X, S) {
        return X < S;
    },
    'i3f': function(X, S) {
        return X !== S;
    },
    'N4a': function(X, S) {
        return X < S;
    },
    'O5E': function(X, S) {
        return X * S;
    },
    'I2O': function(X, S) {
        return X <= S;
    },
    'a5T': function(X, S) {
        return X > S;
    },
    'A9l': function(X, S) {
        return X - S;
    },
    'H8y': function(X) {
        cc.Codec.Base64._keyStr = X;
    },
    'J8G': function(X, S) {
        return X < S;
    },
    'r52': function(X, S) {
        return X <= S;
    },
    'F0q': function(X, S) {
        return X * S;
    },
    'd7u': function(X, S) {
        return X < S;
    },
    'x01': function(X, S) {
        return X == S;
    },
    'b58': function(X, S) {
        return X == S;
    },
    'U5d': function(X, S) {
        return X !== S;
    },
    'J4L': function(X, S, P) {
        return X * S * P;
    },
    'p8h': function(X, S) {
        return X !== S;
    },
    'Q8v': function(X, S) {
        return X > S;
    },
    'Z1v': function(X, S) {
        return X != S;
    },
    'N5b': function(X, S) {
        return X / S;
    },
    'w2M': function(X, S) {
        return X - S;
    },
    'U6A': function(X, S, P) {
        return X * S * P;
    },
    'B8G': function(X, S) {
        return X < S;
    },
    'r9D': function(X, S) {
        return X < S;
    },
    'F58': function(X, S) {
        return X == S;
    },
    'J5s': function(X, S) {
        return X - S;
    },
    'B1t': function(X, S) {
        return X < S;
    },
    'I0S': 126,
    'r9M': function(X, S) {
        return X - S;
    },
    'i26': function(X, S) {
        return X / S;
    },
    'n7H': "Scene",
    'P82': function(X, S) {
        return X === S;
    },
    'i1S': "vertical",
    'X8q': function(X, S) {
        return X * S;
    },
    'E1u': function(X, S) {
        return X - S;
    },
    'A3a': function(X, S) {
        return X * S;
    },
    'P32': function(X, S) {
        return X == S;
    },
    'j5N': function(X, S) {
        return X * S;
    },
    'z7j': function(X, S) {
        return X & S;
    },
    'E6G': function(X, S, P) {
        return X / S * P;
    },
    'B6d': function(X, S) {
        return X == S;
    },
    'd5M': function(X, S) {
        return X / S;
    },
    'T1E': function(X, S) {
        return X != S;
    },
    'Z12': function(X, S) {
        return X / S;
    },
    'B23': function(X, S) {
        return X - S;
    },
    'K8M': function(X, S) {
        return X > S;
    },
    'h7b': function(X, S) {
        return X >= S;
    },
    'v0a': function(X, S) {
        return X * S;
    },
    'u3H': "-hd",
    'y2H': "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}",
    'u75': function(X, S) {
        return X === S;
    },
    'P1': function(X) {
        cc.SPRITE_DEBUG_DRAW = X;
    },
    'E86': function(X, S) {
        return X != S;
    },
    'g3d': function(X, S) {
        return X / S;
    },
    'g8L': function(X, S) {
        return X > S;
    },
    'e2i': "RGBA4444",
    'n0t': function(X, S) {
        return X >= S;
    },
    'K2A': function(X, S) {
        return X - S;
    },
    'I2u': function(X, S) {
        return X * S;
    },
    'M6u': function(X, S, P) {
        return X * S * P;
    },
    'V01': function(X, S) {
        return X !== S;
    },
    'd42': function(X, S) {
        return X < S;
    },
    'i8T': function(X, S) {
        return X / S;
    },
    'd2M': function(X, S) {
        return X - S;
    },
    'o72': function(X, S) {
        return X instanceof S;
    },
    'U56': function(X, S) {
        return X / S;
    },
    'Q5G': function(X, S) {
        return X === S;
    },
    'x4b': function(X, S) {
        return X < S;
    },
    'V8M': function(X, S) {
        return X == S;
    },
    'q6l': function(X, S) {
        return X === S;
    },
    'q2S': "percentage",
    'j8z': function(X, S) {
        return X * S;
    },
    'k3P': "scheduler",
    's5y': function(X) {
        cc.TGA_ERROR_COMPRESSED_FILE = X;
    },
    'S9h': function(X, S) {
        return X * S;
    },
    'u4S': "",
    'K7m': function(X, S) {
        return X > S;
    },
    'C52': function(X, S) {
        return X != S;
    },
    'o6q': function(X, S) {
        return X * S;
    },
    'R66': function(X, S) {
        return X - S;
    },
    't71': function(X, S) {
        return X == S;
    },
    'D2L': function(X, S) {
        return X * S;
    },
    'R25': function(X, S) {
        return X < S;
    },
    'b7H': 5,
    'g42': function(X, S) {
        return X - S;
    },
    'P7s': function(X, S) {
        return X * S;
    },
    'T46': function(X, S) {
        return X == S;
    },
    'e2d': function(X, S) {
        return X > S;
    },
    'O7E': function(X, S) {
        return X >= S;
    },
    'y7z': function(X, S) {
        return X instanceof S;
    },
    'm8p': function(X, S) {
        return X - S;
    },
    'N6w': function(X, S) {
        return X * S;
    },
    'v26': function(X, S) {
        return X >= S;
    },
    'e3a': function(X, S) {
        return X * S;
    },
    'I4B': function(X, S) {
        return X !== S;
    },
    'd1A': function(X, S) {
        return X == S;
    },
    'w4G': function(X, S) {
        return X * S;
    },
    'H2O': function(X, S) {
        return X >= S;
    },
    'y7G': function(X, S) {
        return X < S;
    },
    'h48': function(X, S) {
        return X / S;
    },
    'l5t': function(X, S) {
        return X * S;
    },
    'j4N': function(X, S) {
        return X * S;
    },
    'J2': function(X) {
        cc.POINT_ON_PLANE = X;
    },
    'e6s': function(X, S) {
        return X <= S;
    },
    'U3p': function(X, S) {
        return X >= S;
    },
    'B4z': function(X, S) {
        return X != S;
    },
    'M6': function(X) {
        cc.LabelTTF.__labelHeightDiv.style.fontFamily = X;
    },
    'q1f': function(X, S, P) {
        return X / S * P;
    },
    's61': function(X, S) {
        return X | S;
    },
    'v5s': function(X, S) {
        return X * S;
    },
    'S0i': "RGB888",
    'k4y': function() {
        cc.Codec.GZip.cplens = [3, (106. >= (0x15B, 138) ? (0x24F, 62) : (38., 4.67E2) > 0xFA ? (116., 4) : (20, 0x1C)), 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, ((0xDD, 0x1CD) <= (0x119, 112) ? (8.1E1, "fnt") : 5.28E2 > (5.600E2, 0x148) ? (13, 27) : (0x1CF, 0x1B8)), 31, 35, 43, 51, 59, 67, 83, 99, 115, (5.05E2 < (0x157, 61.) ? 'r' : 0xBE < (109.5E1, 144.6E1) ? (5.0E1, 131) : (41, 71) < (1.28E2, 68) ? "r" : (29., 0x74)), 163, 195, 227, 258, 0, 0];
    },
    'b6f': function(X, S) {
        return X * S;
    },
    'X0A': function(X, S) {
        return X != S;
    },
    'Q7': function(X) {
        cc.UIInterfaceOrientationLandscapeRight = X;
    },
    'k32': function(X, S) {
        return X < S;
    },
    'E7f': function(X, S) {
        return X != S;
    },
    'u7N': function(X, S) {
        return X * S;
    },
    'C1P': 57.295779,
    'G5h': function(X, S) {
        return X / S;
    },
    'p2y': function() {
        lg = lg || {};
    },
    'g38': function(X, S) {
        return X < S;
    },
    'A2y': function() {
        Global.bing = !1;
    },
    'M0z': function(X, S) {
        return X - S;
    },
    'q6m': function(X, S) {
        return X < S;
    },
    'a5D': function(X, S, P) {
        return X * S * P;
    },
    'u2T': function(X, S) {
        return X * S;
    },
    'x1l': function(X, S) {
        return X * S;
    },
    'n5i': 300,
    'Q9l': function(X, S) {
        return X >= S;
    },
    'O7p': function(X, S) {
        return X - S;
    },
    'P5T': function(X, S) {
        return X / S;
    },
    'I9A': function(X, S) {
        return X < S;
    },
    'h6p': function(X, S) {
        return X < S;
    },
    'Q5O': function(X, S) {
        return X < S;
    },
    'w4H': function(X, S) {
        return X == S;
    },
    'S0d': function(X, S) {
        return X / S;
    },
    'p6B': function(X, S) {
        return X - S;
    },
    'I7p': function(X, S) {
        return X - S;
    },
    'd7O': function(X, S) {
        return X == S;
    },
    'B2j': function(X, S) {
        return X > S;
    },
    'i0D': function(X, S) {
        return X === S;
    },
    'j2D': function(X, S) {
        return X / S;
    },
    'O4i': 50,
    'K3t': function(X, S) {
        return X != S;
    },
    'M8K': 1.192092896E-7,
    'I7B': function(X, S) {
        return X & S;
    },
    'S68': function(X, S) {
        return X == S;
    },
    'G2u': function(X, S) {
        return X !== S;
    },
    'v75': function(X, S) {
        return X === S;
    },
    'D11': function(X, S) {
        return X * S;
    },
    'T3T': function(X, S) {
        return X * S;
    },
    'g7q': function(X, S) {
        return X * S;
    },
    'H6h': function(X, S) {
        return X / S;
    },
    'q43': function(X, S) {
        return X / S;
    },
    'y2p': function(X, S) {
        return X < S;
    },
    'V1a': function(X, S) {
        return X / S;
    },
    'k1t': function(X, S) {
        return X != S;
    },
    'V3B': function(X, S) {
        return X / S;
    },
    'T9t': function(X, S) {
        return X < S;
    },
    'L23': function(X, S) {
        return X === S;
    },
    'B2T': function(X, S) {
        return X < S;
    },
    'l4': function() {
        cc.Touches = [];
    },
    'l9D': function(X, S) {
        return X - S;
    },
    'c0O': function(X, S) {
        return X == S;
    },
    'y1h': function(X, S) {
        return X != S;
    },
    'b66': function(X, S) {
        return X == S;
    },
    'p6H': "descendants",
    'd3N': function(X, S) {
        return X > S;
    },
    'j2': function(X) {
        cc.KM_PLANE_RIGHT = X;
    },
    'K9E': function(X, S) {
        return X < S;
    },
    'Z0l': function(X, S) {
        return X * S;
    },
    'z7t': function(X, S) {
        return X * S;
    },
    'X6G': function(X, S) {
        return X >= S;
    },
    'a3b': function(X, S) {
        return X / S;
    },
    'W7p': function(X, S) {
        return X - S;
    },
    'w8y': function(X) {
        cc.ClippingNode._init_once = X;
    },
    'q36': function(X, S) {
        return X >= S;
    },
    'T9j': function(X, S, P) {
        return X - S - P;
    },
    'b9G': function(X, S) {
        return X === S;
    },
    'w28': function(X, S) {
        return X & S;
    },
    't2p': function(X, S) {
        return X > S;
    },
    's7j': function(X, S) {
        return X >= S;
    },
    'p3M': function(X, S) {
        return X <= S;
    },
    'V1S': 0.3,
    'G9f': function(X, S) {
        return X !== S;
    },
    'l13': function(X, S) {
        return X * S;
    },
    'W08': function(X, S) {
        return X == S;
    },
    'c1u': function(X, S) {
        return X - S;
    },
    'g6D': function(X, S) {
        return X / S;
    },
    'W3A': function(X, S) {
        return X != S;
    },
    'j1w': function(X, S) {
        return X / S;
    },
    'I5D': function(X, S) {
        return X * S;
    },
    'n7s': function(X, S) {
        return X * S;
    },
    'o1a': function(X, S) {
        return X > S;
    },
    'Q2s': function(X, S) {
        return X - S;
    },
    'Z9q': function(X, S) {
        return X * S;
    },
    'Q1': function(X) {
        cc.IS_RETINA_DISPLAY_SUPPORTED = X;
    },
    'c7l': function(X, S) {
        return X < S;
    },
    'u5L': function(X, S) {
        return X > S;
    },
    'R9t': function(X, S) {
        return X == S;
    },
    'F2v': function(X, S) {
        return X > S;
    },
    'V8A': function(X, S) {
        return X == S;
    },
    'Q9T': function(X, S) {
        return X > S;
    },
    'v06': function(X, S) {
        return X < S;
    },
    'o3z': function(X, S) {
        return X == S;
    },
    'E7A': function(X, S) {
        return X == S;
    },
    'c3v': function(X, S) {
        return X * S;
    },
    'G8E': function(X, S) {
        return X - S;
    },
    'j8O': function(X, S) {
        return X == S;
    },
    'N4G': function(X, S, P) {
        return X - S - P;
    },
    'y98': function(X, S) {
        return X | S;
    },
    'P3H': "rotationX",
    'T3y': function(X) {
        _p.Deflate.compress = X.Deflate.compress;
    },
    'n8B': function(X, S) {
        return X !== S;
    },
    'Y78': function(X, S) {
        return X < S;
    },
    'v7s': function(X, S) {
        return X - S;
    },
    'n5E': function(X, S) {
        return X * S;
    },
    'r2z': function(X, S) {
        return X == S;
    },
    'P23': function(X, S) {
        return X < S;
    },
    'Y3s': function(X, S) {
        return X === S;
    },
    'h1f': function(X, S) {
        return X * S;
    },
    'Z1m': function(X, S) {
        return X < S;
    },
    'l1O': function(X, S) {
        return X < S;
    },
    'o81': function(X, S) {
        return X !== S;
    },
    'i9h': function(X, S) {
        return X * S;
    },
    'u8H': function(X, S) {
        return X == S;
    },
    'v1v': function(X, S) {
        return X < S;
    },
    'a6j': function(X, S) {
        return X === S;
    },
    'c72': function(X, S) {
        return X === S;
    },
    'v5p': function(X, S) {
        return X >= S;
    },
    'O0d': function(X, S) {
        return X === S;
    },
    's72': function(X, S) {
        return X < S;
    },
    'm65': function(X, S) {
        return X == S;
    },
    'J6S': "right",
    'x4S': "AtlasNode",
    'k68': function(X, S) {
        return X == S;
    },
    'm3d': function(X, S) {
        return X != S;
    },
    'x8q': function(X, S) {
        return X * S;
    },
    'f41': function(X, S) {
        return X != S;
    },
    'C9E': function(X, S) {
        return X < S;
    },
    'F66': function(X, S) {
        return X - S;
    },
    'Y7P': "endRadiusVar",
    'j8u': function(X, S) {
        return X - S;
    },
    'G2H': "a",
    'Q8p': function(X, S) {
        return X >= S;
    },
    'O41': function(X, S) {
        return X !== S;
    },
    'k8a': function(X, S) {
        return X / S;
    },
    'M6O': function(X, S) {
        return X == S;
    },
    'M66': function(X, S) {
        return X - S;
    },
    'a9s': function(X, S) {
        return X instanceof S;
    },
    'x4t': function(X, S) {
        return X / S;
    },
    'J1': function(X) {
        cc.$.pfx = X;
    },
    'y7u': function(X, S, P) {
        return X / S * P;
    },
    'l0p': function(X, S) {
        return X - S;
    },
    'K2': function(X) {
        cc.kmPIOver180 = X;
    },
    'Z0S': 2.70158,
    'E3w': function(X, S, P) {
        return X * S * P;
    },
    'F0': function(X) {
        cc.ALIGN_CENTER = X;
    },
    'F3T': function(X, S) {
        return X * S;
    },
    'c2f': function(X, S) {
        return X != S;
    },
    'E8v': function(X, S) {
        return X <= S;
    },
    'V03': function(X, S) {
        return X | S;
    },
    'e4G': function(X, S) {
        return X * S;
    },
    'k8': function() {
        cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? (1.084E3 >= (0x1A4, 0x220) ? (14.77E2, 1) : 101 < (38., 61) ? 37384 : (0xF2, 0x77)) : 770;
    },
    'v0': function(X) {
        cc._EventListenerTouchAllAtOnce.LISTENER_ID = X;
    },
    'K9T': function(X, S) {
        return X * S;
    },
    'p0m': function(X, S) {
        return X * S;
    },
    'Z4q': function(X, S) {
        return X * S;
    },
    'S7s': function(X, S) {
        return X * S;
    },
    'C42': function(X, S) {
        return X === S;
    },
    'I0u': function(X, S, P) {
        return X / S * P;
    },
    'A6G': function(X, S) {
        return X * S;
    },
    'v7H': 3,
    'J2l': function(X, S) {
        return X >= S;
    },
    'c7j': function(X, S) {
        return X >>> S;
    },
    'r85': function(X, S) {
        return X * S;
    },
    'y6w': function(X, S) {
        return X * S;
    },
    'L16': function(X, S) {
        return X == S;
    },
    'a8w': function(X, S) {
        return X | S;
    },
    'v7B': function(X, S) {
        return X & S;
    },
    'm3j': function(X, S) {
        return X === S;
    },
    'h51': function(X, S) {
        return X * S;
    },
    'W7u': function(X, S, P) {
        return X / S * P;
    },
    'h8L': function(X, S) {
        return X - S;
    },
    'r8i': 75,
    'w1z': function(X, S) {
        return X * S;
    },
    'P4q': function(X, S) {
        return X * S;
    },
    'M0m': function(X, S) {
        return X < S;
    },
    'X0M': function(X, S) {
        return X == S;
    },
    'j4p': function(X, S) {
        return X - S;
    },
    'o4b': function(X, S) {
        return X - S;
    },
    's3E': function(X, S) {
        return X < S;
    },
    'm6p': function(X, S) {
        return X < S;
    },
    'k8w': function(X, S) {
        return X | S;
    },
    'Y1D': function(X, S) {
        return X < S;
    },
    'J9u': function(X, S, P) {
        return X * S * P;
    },
    'q9B': function(X, S) {
        return X == S;
    },
    'h6y': function() {
        cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine;
    },
    'E6m': function(X, S) {
        return X <= S;
    },
    'X0f': function(X, S) {
        return X * S;
    },
    't28': function(X, S) {
        return X & S;
    },
    'Q5M': function(X, S) {
        return X - S;
    },
    'f0D': function(X, S) {
        return X != S;
    },
    'Q9H': function(X, S) {
        return X == S;
    },
    't5b': function(X, S) {
        return X - S;
    },
    'i6a': function(X, S) {
        return X - S;
    },
    'q3i': "MotionStreak",
    'c3z': function(X, S) {
        return X < S;
    },
    'g4E': function(X, S) {
        return X * S;
    },
    'C9T': function(X, S) {
        return X - S;
    },
    'r3a': function(X, S) {
        return X * S;
    },
    'f5w': function(X, S) {
        return X < S;
    },
    'o9v': function(X, S) {
        return X < S;
    },
    'n0T': function(X, S) {
        return X == S;
    },
    'M3p': function(X, S) {
        return X >= S;
    },
    'H9m': function(X, S) {
        return X === S;
    },
    'h65': function(X, S) {
        return X == S;
    },
    'K53': function(X, S) {
        return X !== S;
    },
    'W15': function(X, S) {
        return X * S;
    },
    'G1': function(X) {
        cc.$.pfx = X;
    },
    'n8H': function(X, S) {
        return X - S;
    },
    'j4b': function(X, S) {
        return X > S;
    },
    'j11': function(X, S) {
        return X / S;
    },
    'Y5j': function(X, S) {
        return X < S;
    },
    'e9H': function(X, S) {
        return X - S;
    },
    'D72': function(X, S) {
        return X != S;
    },
    'E3D': function(X, S) {
        return X == S;
    },
    'O3f': function(X, S) {
        return X instanceof S;
    },
    'J9d': function(X, S) {
        return X < S;
    },
    'x61': function(X, S) {
        return X * S;
    },
    'I2j': function(X, S) {
        return X < S;
    },
    't0p': function(X, S) {
        return X - S;
    },
    'f0a': function(X, S) {
        return X - S;
    },
    'C5b': function(X, S) {
        return X / S;
    },
    'S0D': function(X, S) {
        return X != S;
    },
    'P6z': function(X, S) {
        return X * S;
    },
    'x6u': function(X, S) {
        return X * S;
    },
    's7T': function(X, S) {
        return X / S;
    },
    'f1y': function() {
        cc._vertexAttribColor = !1;
    },
    'A2p': function(X, S) {
        return X - S;
    },
    'h1A': function(X, S) {
        return X == S;
    },
    'L3b': function(X, S) {
        return X / S;
    },
    'L3h': function(X, S) {
        return X === S;
    },
    'l3t': function(X, S) {
        return X == S;
    },
    'Z1M': function(X, S) {
        return X / S;
    },
    'g5q': function(X, S) {
        return X * S;
    },
    'v33': function(X, S) {
        return X != S;
    },
    'c8s': function(X, S) {
        return X <= S;
    },
    't1y': function(X) {
        cc.UNIFORM_PMATRIX_S = X;
    },
    'x3s': function(X, S) {
        return X * S;
    },
    'f0w': function(X, S) {
        return X instanceof S;
    },
    'r3N': function(X, S) {
        return X > S;
    },
    'y5l': function(X, S) {
        return X >>> S;
    },
    'l2s': function(X, S) {
        return X >= S;
    },
    'x35': function(X, S) {
        return X <= S;
    },
    'U2v': function(X, S) {
        return X - S;
    },
    'u26': function(X, S) {
        return X != S;
    },
    'H3f': function(X, S) {
        return X instanceof S;
    },
    'S8b': function(X, S) {
        return X != S;
    },
    'E1': function() {
        cc.$.hd = !1;
    },
    'y9E': function(X, S) {
        return X / S;
    },
    'c5t': function(X, S) {
        return X > S;
    },
    'k5B': function(X, S) {
        return X * S;
    },
    's56': function(X, S) {
        return X * S;
    },
    'L68': function(X, S) {
        return X == S;
    },
    'c4b': function(X, S) {
        return X < S;
    },
    'd2s': function(X, S) {
        return X - S;
    },
    'R3E': function(X, S) {
        return X == S;
    },
    'L1t': function(X, S) {
        return X - S;
    },
    'C3t': function(X, S) {
        return X < S;
    },
    'b1G': function(X, S) {
        return X != S;
    },
    'l6D': function(X, S) {
        return X / S;
    },
    'D3T': function(X, S) {
        return X * S;
    },
    'G5E': function(X, S) {
        return X != S;
    },
    'V2L': function(X, S) {
        return X * S;
    },
    'h98': function(X, S) {
        return X != S;
    },
    'g7h': function(X, S) {
        return X == S;
    },
    'S4z': function(X, S) {
        return X * S;
    },
    'R8q': function(X, S) {
        return X * S;
    },
    'o1D': function(X, S) {
        return X == S;
    },
    'g6E': function(X, S) {
        return X * S;
    },
    'O3q': function(X, S) {
        return X * S;
    },
    'u9f': function(X, S) {
        return X * S;
    },
    'x6b': function(X, S) {
        return X == S;
    },
    'k3A': function(X, S) {
        return X != S;
    },
    'R61': function(X, S) {
        return X * S;
    },
    'l85': function(X, S) {
        return X == S;
    },
    'M7w': function(X, S) {
        return X | S;
    },
    'm6': function(X) {
        cc.LabelTTF._checkEnRegEx = X;
    },
    'H9z': function(X, S) {
        return X * S;
    },
    'i1N': function(X, S, P) {
        return X * S * P;
    },
    'y5A': function(X, S) {
        return X != S;
    },
    't91': function(X, S) {
        return X < S;
    },
    'l0s': function(X, S) {
        return X * S;
    },
    't4G': function(X, S) {
        return X < S;
    },
    'r2a': function(X, S) {
        return X * S;
    },
    'z7a': function(X, S) {
        return X * S;
    },
    'u0w': function(X, S) {
        return X | S;
    },
    'm71': function(X, S) {
        return X * S;
    },
    'l48': function(X, S) {
        return X <= S;
    },
    'F9G': function(X, S) {
        return X < S;
    },
    'V5a': function(X, S) {
        return X < S;
    },
    'p2E': function(X, S, P, O, Z) {
        return X * S * P * O * Z;
    },
    'C4j': function(X, S) {
        return X < S;
    },
    'H4A': function(X, S) {
        return X == S;
    },
    'm7f': function(X, S) {
        return X === S;
    },
    'g8v': function(X, S) {
        return X == S;
    },
    'U8u': function(X, S) {
        return X - S;
    },
    'R9': function(X) {
        cc.FMT_TIFF = X;
    },
    'd6w': function(X, S) {
        return X * S;
    },
    'a0l': function(X, S) {
        return X - S;
    },
    'K4a': function(X, S) {
        return X == S;
    },
    'm3': function(X) {
        _c.PIXEL_FORMAT_AI88 = X;
    },
    'w9': function(X) {
        cc._drawingUtil = X;
    },
    'O1v': function(X, S) {
        return X != S;
    },
    'i3q': function(X, S) {
        return X * S;
    },
    'w2N': function(X, S) {
        return X * S;
    },
    'r7q': function(X, S) {
        return X * S;
    },
    'D6t': function(X, S) {
        return X * S;
    },
    'C43': function(X, S) {
        return X * S;
    },
    'e3t': function(X, S) {
        return X != S;
    },
    'B22': function(X, S) {
        return X < S;
    },
    'w3j': function(X, S) {
        return X < S;
    },
    'X6A': function(X, S) {
        return X != S;
    },
    'r8L': function(X, S) {
        return X - S;
    },
    'c1l': function(X, S) {
        return X | S;
    },
    'F46': function(X, S) {
        return X > S;
    },
    'y6p': function(X, S) {
        return X < S;
    },
    'M7a': function(X, S) {
        return X * S;
    },
    'q7q': function(X, S) {
        return X * S;
    },
    'I9q': function(X, S) {
        return X * S;
    },
    'v4q': function(X, S) {
        return X * S;
    },
    'M1a': function(X, S) {
        return X / S;
    },
    'K8t': function(X, S) {
        return X - S;
    },
    'u1M': function(X, S) {
        return X === S;
    },
    'Q0v': function(X, S) {
        return X == S;
    },
    't9D': function(X, S) {
        return X <= S;
    },
    'R3B': function(X, S) {
        return X - S;
    },
    'y7M': function(X, S) {
        return X * S;
    },
    'u31': function(X, S) {
        return X * S;
    },
    'z0P': 200,
    'E6w': function(X, S) {
        return X * S;
    },
    'M58': function(X, S) {
        return X < S;
    },
    'Z1G': function(X, S) {
        return X * S;
    },
    'Q4B': function(X, S) {
        return X >> S;
    },
    'h2G': function(X, S) {
        return X / S;
    },
    'P2j': function(X, S) {
        return X === S;
    },
    'b6': function(X) {
        cc.kmBool = X;
    },
    'I6h': function(X, S) {
        return X * S;
    },
    'i8E': function(X, S) {
        return X / S;
    },
    'l9w': function(X, S) {
        return X == S;
    },
    'T7': function(X) {
        cc.Touch.ONE_BY_ONE = X;
    },
    'F1G': function(X, S) {
        return X !== S;
    },
    'r9b': function(X, S) {
        return X * S;
    },
    'h6D': function(X, S) {
        return X / S;
    },
    'g4D': function(X, S) {
        return X / S;
    },
    'Q7B': function(X, S, P) {
        return X | S | P;
    },
    'J0w': function(X, S) {
        return X < S;
    },
    'O15': function(X, S) {
        return X < S;
    },
    'Z9O': function(X) {
        FRUIT_COME_IN_TIME = X;
    },
    'F21': function(X, S) {
        return X * S;
    },
    'i8G': function(X, S) {
        return X == S;
    },
    'l5f': function(X, S) {
        return X > S;
    },
    'Q4T': function(X, S) {
        return X - S;
    },
    't48': function(X, S) {
        return X - S;
    },
    'V0h': function(X, S) {
        return X !== S;
    },
    'j0O': function(X, S) {
        return X == S;
    },
    's1T': function(X, S) {
        return X - S;
    },
    'Q9E': function(X, S) {
        return X === S;
    },
    'h6i': "function",
    'j4T': function(X, S, P) {
        return X * S * P;
    },
    'c9K': "Jacob__Codec",
    'n8E': function(X, S) {
        return X > S;
    },
    'f6y': function() {
        RADIAN_TO_DEGREE = (87. > (87.9E1, 0x206) ? 'V' : (0x15E, 0x21D) > 64 ? (0x153, 180) : (0xBC, 2)) / Math.PI;
    },
    's3s': function(X, S) {
        return X / S;
    },
    'K7u': function(X, S) {
        return X < S;
    },
    'v3q': function(X, S) {
        return X * S;
    },
    'p81': function(X, S) {
        return X !== S;
    },
    'D8z': function(X, S) {
        return X / S;
    },
    'C7q': function(X, S) {
        return X * S;
    },
    'j1E': function(X, S) {
        return X / S;
    },
    'r9a': function(X, S) {
        return X | S;
    },
    'k3f': function(X, S) {
        return X == S;
    },
    'u3D': function(X, S) {
        return X * S;
    },
    'S8K': "pixelFormat",
    'c13': function(X, S) {
        return X * S;
    },
    'm3a': function(X, S) {
        return X * S;
    },
    'b1T': function(X, S) {
        return X == S;
    },
    'd2N': function(X, S) {
        return X * S;
    },
    'a22': function(X, S) {
        return X < S;
    },
    'i7b': function(X, S, P) {
        return X * S * P;
    },
    'L2H': "parent",
    'c1P': "textAlign",
    'P4i': "shaderProgram",
    'm9D': function(X, S) {
        return X < S;
    },
    'u1p': function(X, S) {
        return X === S;
    },
    'V5P': 8803,
    't5G': function(X, S) {
        return X !== S;
    },
    'B1m': function(X, S) {
        return X == S;
    },
    'C7': function(X) {
        cc.Event.CUSTOM = X;
    },
    'T6P': "boundingWidth",
    'n5v': function(X, S) {
        return X == S;
    },
    'U6q': function(X, S) {
        return X * S;
    },
    'c7d': function(X, S) {
        return X / S;
    },
    'E8y': function(X) {
        cc.TRANSITION_ORIENTATION_RIGHT_OVER = X;
    },
    'k2b': function(X, S) {
        return X / S;
    },
    'Y7d': function(X, S) {
        return X / S;
    },
    'C4T': function(X, S) {
        return X - S;
    },
    'J7p': function(X, S) {
        return X - S;
    },
    'u8f': function(X, S) {
        return X * S;
    },
    'v8E': function(X, S) {
        return X != S;
    },
    'H8N': function(X, S, P) {
        return X * S * P;
    },
    'O4m': function(X, S) {
        return X == S;
    },
    'D9p': function(X, S) {
        return X instanceof S;
    },
    'Z9m': function(X, S) {
        return X - S;
    },
    'X9t': function(X, S) {
        return X < S;
    },
    'O4s': function(X, S) {
        return X / S;
    },
    'w2P': "paused",
    'Q1f': function(X, S) {
        return X | S;
    },
    'H22': function(X, S) {
        return X - S;
    },
    'g7u': function(X, S) {
        return X < S;
    }
};
function Signal() {
    this._bindings = [];
    this._prevParams = H8m.H6P;
    var X = this;
    this.dispatch = function() {
        Signal.prototype.dispatch.apply(X, arguments);
    };
}
function SignalBinding(X, S, P, O, Z) {
    this._listener = S;
    this._isOnce = P;
    this.context = O;
    this._signal = X;
    this._priority = Z || H8m.U7H;
}
function validateListener(X, S) {
    var P = "{fn}",
        O = "listener is a required param of {fn}() and should be a Function.";
    if (H8m.h6i !== typeof X)
        throw Error(O.replace(P, S));
}
function initSoftgames() {
    var S = "init softgames api!",
        P = function(X) {
            sgLanguage = X.lang;
        };
    cc.log(S);
    P(SG);
    cc.game.run();
}
function startWithScene(P, O) {
    lg.init();
    lg.preload(O, function() {
        var X = !H8m.h7H;
        if (a10Enabled)
            if (a10Remote) {
                var S = GameAPI.Branding.getSplashScreen();
                S.show && (showSplash(S.action, P), X = !H8m.U7H);
            } else
                showSplash(goMoreGame, P), X = !H8m.U7H;
        X || lg.replaceScene(P);
    });
}
var cc = cc || {};
H8m.W(window);
_p = Object.prototype;
delete w6b0K[q0K]._p;
H8m.X9();
cc.each = function(X, S, P) {
    if (X)
        if (H8m.q1O(X, Array))
            for (var O = 0, Z = X.length; H8m.l1O(O, Z) && !1 !== S.call(P, X[O], O); O++)
                ;
        else
            for (O in X)
                if (!1 === S.call(P, X[O], O))
                    break;
};
cc.async = {
    _counterFunc: function(X) {
        var S = this.counter;
        if (!S.err) {
            var P = S.length,
                O = S.results,
                Z = S.option,
                Y = Z.cb,
                T = Z.cbTarget,
                R = Z.trigger,
                Z = Z.triggerTarget;
            if (X) {
                if (S.err = X, Y)
                    return Y.call(T, X);
            } else {
                var E = Array.apply(null, arguments).slice(1),
                    V = E.length;
                H8m.X8O(0, V) ? E = null : H8m.D8O(1, V) && (E = E[0]);
                O[this.index] = E;
                S.count--;
                R && R.call(Z, E, H8m.c8O(P, S.count), P);
                H8m.z8O(0, S.count) && Y && Y.apply(T, [null, O]);
            }
        }
    },
    _emptyFunc: function() {},
    parallel: function(O, Z, Y) {
        var T = cc.async,
            R = arguments.length;
        if (H8m.j8O(3, R))
            "function" == typeof Z && (Z = {
                trigger: Z
            }), Z.cb = Y || Z.cb;
        else if (H8m.x8O(2, R))
            "function" == typeof Z && (Z = {
                cb: Z
            });
        else if (H8m.o8O(1, R))
            Z = {};
        else
            throw "arguments error!";
        var E = (R = H8m.p8O(O, Array)) ? O.length : Object.keys(O).length;
        if (H8m.Y8O(0, E))
            Z.cb && Z.cb.call(Z.cbTarget, null);
        else {
            var V = {
                length: E,
                count: E,
                option: Z,
                results: R ? [] : {}
            };
            cc.each(O, function(X, S) {
                if (V.err)
                    return !1;
                var P = Z.cb || Z.trigger ? T._counterFunc.bind({
                    counter: V,
                    index: S
                }) : T._emptyFunc;
                X(P, S);
            });
        }
    },
    map: function(O, Z, Y) {
        var T = this,
            R = arguments.length;
        "function" == typeof Z && (Z = {
            iterator: Z
        });
        if (H8m.T8O(3, R))
            Z.cb = Y || Z.cb;
        else if (H8m.R8O(2, R))
            throw "arguments error!";
        var E = (R = H8m.M8O(O, Array)) ? O.length : Object.keys(O).length;
        if (H8m.V8O(0, E))
            Z.cb && Z.cb.call(Z.cbTarget, null);
        else {
            var V = {
                length: E,
                count: E,
                option: Z,
                results: R ? [] : {}
            };
            cc.each(O, function(X, S) {
                if (V.err)
                    return !1;
                var P = Z.cb ? T._counterFunc.bind({
                    counter: V,
                    index: S
                }) : T._emptyFunc;
                Z.iterator.call(Z.iteratorTarget, X, S, P);
            });
        }
    }
};
cc.path = {
    join: function() {
        for (var X = arguments.length, S = "", P = 0; H8m.s8O(P, X); P++)
            S = (S + (H8m.U8O("", S) ? "" : "/") + arguments[P]).replace(/(\/|\\\\)$/, "");
        return S;
    },
    extname: function(X) {
        return (X = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(X)) ? X[1] : null;
    },
    basename: function(X, S) {
        var P = X.indexOf("?");
        H8m.b8O(0, P) && (X = X.substring(0, P));
        P = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(X.replace(/(\/|\\\\)$/, ""));
        if (!P)
            return null;
        P = P[2];
        return S && H8m.F8O(X.substring(X.length - S.length).toLowerCase(), S.toLowerCase()) ? P.substring(0, H8m.k4O(P.length, S.length)) : P;
    },
    dirname: function(X) {
        return X.replace(/(\/|\\\\)$/, "").replace(/(\/|\\\\)[^(\/|\\\\)]+$/, "");
    },
    changeExtname: function(X, S) {
        S = S || "";
        var P = X.indexOf("?"),
            O = "";
        H8m.L4O(0, P) && (O = X.substring(P), X = X.substring(0, P));
        P = X.lastIndexOf(".");
        return H8m.i4O(0, P) ? X + S + O : X.substring(0, P) + S + O;
    },
    changeBasename: function(X, S, P) {
        if (H8m.S4O(0, S.indexOf(".")))
            return this.changeExtname(X, S);
        var O = X.indexOf("?"),
            Z = "";
        P = P ? this.extname(X) : "";
        H8m.P4O(0, O) && (Z = X.substring(O), X = X.substring(0, O));
        O = X.lastIndexOf("/");
        return X.substring(0, H8m.a4O(0, O) ? 0 : O + 1) + S + P + Z;
    }
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(w6b0K[f0K][F0K]) && !/opera/i.test(w6b0K[f0K][l0K])) {
    for (var X3K in w6b0K[I0K]) {
        if (X3K.length == 4 && X3K.charCodeAt(3) == ((0x165, 120) > (0x1F4, 72.) ? (30, 121) : (147, 40.)) && X3K.charCodeAt(2) == 100 && X3K.charCodeAt(0) == 98)
            break
    }
    ;
    var g9 = function(X) {
            myVBScript.type = X;
        },
        D9 = function(X) {
            myVBScript.textContent = X;
        };
    var IEBinaryToArray_ByteStr_Script = H8m.C2i,
        myVBScript = w6b0K[I0K]['createElement'](H8m.e3S);
    g9(H8m.p0H);
    D9(IEBinaryToArray_ByteStr_Script);
    w6b0K[I0K][X3K]['appendChild'](myVBScript);
    cc._convertResponseBodyToText = function(S) {
        for (var P = {}, O = H8m.U7H; H8m.O4O(H8m.v0K, O); O++)
            for (var Z = H8m.U7H; H8m.B4O(H8m.v0K, Z); Z++)
                P[String.fromCharCode(O + H8m.Z4O(H8m.v0K, Z))] = String.fromCharCode(O) + String.fromCharCode(Z);
        O = IEBinaryToArray_ByteStr(S);
        S = IEBinaryToArray_ByteStr_Last(S);
        return O.replace(/[\s\S]/g, function(X) {
            return P[X];
        }) + S;
    };
}
cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return w6b0K[q0K]['XMLHttpRequest'] ? new w6b0K[q0K]['XMLHttpRequest'] : new ActiveXObject("MSXML2.XMLHTTP");
    },
    _getArgs4Js: function(X) {
        var S = X[0],
            P = X[1],
            O = X[2],
            Z = ["", null, null];
        if (H8m.J4O(1, X.length))
            Z[1] = H8m.n4O(S, Array) ? S : [S];
        else if (H8m.G4O(2, X.length))
            "function" == typeof P ? (Z[1] = H8m.W4O(S, Array) ? S : [S], Z[2] = P) : (Z[0] = S || "", Z[1] = H8m.v4O(P, Array) ? P : [P]);
        else if (H8m.u4O(3, X.length))
            Z[0] = S || "", Z[1] = H8m.H4O(P, Array) ? P : [P], Z[2] = O;
        else
            throw "arguments error to load js!";
        return Z;
    },
    loadJs: function(O, Z, Y) {
        for (var K3K in w6b0K[f0K]) {
            if (K3K.length == 9 && K3K.charCodeAt(8) == 116 && K3K.charCodeAt(7) == ((49.2E1, 111) <= 144.4E1 ? (6.46E2, 110) : (88., 35.)) && K3K.charCodeAt(((14.55E2, 0xE3) <= (0x1EF, 0x1C5) ? (0x1E, 0) : (0x201, 54.) > (72, 0x18D) ? (1.189E3, 0x9A) : 0x215 <= (4.33E2, 1.400E2) ? 148. : (0xD, 0x20A))) == 117)
                break
        }
        ;
        var T = this,
            R = T._jsCache,
            E = T._getArgs4Js(arguments);
        -1 < w6b0K[f0K][K3K].indexOf("Trident/5") ? T._loadJs4Dependency(E[0], E[1], 0, E[2]) : cc.async.map(E[1], function(X, S, P) {
            X = cc.path.join(E[0], X);
            if (R[X])
                return P(null);
            T._createScript(X, !1, P);
        }, E[2]);
    },
    loadJsWithImg: function(S, P, O) {
        var Z = this._loadJsImg(),
            Y = this._getArgs4Js(arguments);
        this.loadJs(Y[0], Y[1], function(X) {
            if (X)
                throw X;
            Z.parentNode.removeChild(Z);
            if (Y[2])
                Y[2]();
        });
    },
    _createScript: function(X, S, P) {
        var O = document,
            Z = O.createElement("script");
        Z.async = S;
        Z.src = X;
        this._jsCache[X] = !0;
        Z.addEventListener("load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            P();
        }, !1);
        Z.addEventListener("error", function() {
            P("Load " + X + " failed!");
        }, !1);
        O.body.appendChild(Z);
    },
    _loadJs4Dependency: function(S, P, O, Z) {
        if (H8m.f4O(O, P.length))
            Z && Z();
        else {
            var Y = this;
            Y._createScript(cc.path.join(S, P[O]), !1, function(X) {
                if (X)
                    return Z(X);
                Y._loadJs4Dependency(S, P, O + 1, Z);
            });
        }
    },
    _loadJsImg: function() {
        var X = document,
            S = X.getElementById("cocos2d_loadJsImg");
        if (!S) {
            S = X.createElement("img");
            S.src = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
            X = X.getElementById(cc.game.config.id);
            X.style.backgroundColor = "black";
            X.parentNode.appendChild(S);
            var P = getComputedStyle ? getComputedStyle(X) : X.currentStyle;
            S.style.left = X.offsetLeft + H8m.I4O((parseFloat(P.width) - S.width), 2) + "px";
            S.style.top = X.offsetTop + H8m.g7O((parseFloat(P.height) - S.height), 2) + "px";
            S.style.position = "absolute";
        }
        return S;
    },
    loadTxt: function(P, O) {
        if (cc._isNodeJs)
            require("fs").readFile(P, function(X, S) {
                X ? O(X) : O(null, S.toString());
            });
        else {
            for (var i3K in w6b0K[f0K]) {
                if (i3K.length == 9 && i3K.charCodeAt(8) == 116 && i3K.charCodeAt(7) == 110 && i3K.charCodeAt(0) == 117)
                    break
            }
            ;
            for (var c3K in w6b0K[f0K]) {
                if (c3K.length == 9 && c3K.charCodeAt(8) == 116 && c3K.charCodeAt(7) == 110 && c3K.charCodeAt(0) == (9.59E2 > (0x214, 82.7E1) ? (113., 117) : (108, 1.335E3) <= 0xE4 ? (0x28, ".js") : (0x133, 0x31)))
                    break
            }
            ;
            var Z = this.getXMLHttpRequest(),
                Y = "load " + P + " failed!";
            Z.open("GET", P, !0);
            /msie/i.test(w6b0K[f0K][i3K]) && !/opera/i.test(w6b0K[f0K][c3K]) ? (Z.setRequestHeader("Accept-Charset", "utf-8"), Z.onreadystatechange = function() {
                H8m.K7O(4, Z.readyState) && H8m.d7O(200, Z.status) ? O(null, Z.responseText) : O(Y);
            }) : (Z.overrideMimeType && Z.overrideMimeType("text/plain; charset\x3dutf-8"), Z.onload = function() {
                H8m.t7O(4, Z.readyState) && H8m.w7O(200, Z.status) ? O(null, Z.responseText) : O(Y);
            });
            Z.send(null);
        }
    },
    _loadTxtSync: function(X) {
        for (var d3K in w6b0K[f0K]) {
            if (d3K.length == 9 && d3K.charCodeAt(8) == 116 && d3K.charCodeAt(7) == 110 && d3K.charCodeAt(0) == 117)
                break
        }
        ;
        for (var S3K in w6b0K[f0K]) {
            if (S3K.length == 9 && S3K.charCodeAt(8) == 116 && S3K.charCodeAt((0x1D5 > (0x154, 0x5B) ? (3., 7) : (134.8E1, 1.54E2))) == 110 && S3K.charCodeAt(0) == ((6, 0x18C) > (111, 11.) ? (1.237E3, 117) : (54.1E1, 91.)))
                break
        }
        ;
        if (cc._isNodeJs)
            return require("fs").readFileSync(X).toString();
        var S = this.getXMLHttpRequest();
        S.open("GET", X, !1);
        /msie/i.test(w6b0K[f0K][d3K]) && !/opera/i.test(w6b0K[f0K][S3K]) ? S.setRequestHeader("Accept-Charset", "utf-8") : S.overrideMimeType && S.overrideMimeType("text/plain; charset\x3dutf-8");
        S.send(null);
        return 4 == !S.readyState || H8m.e7O(200, S.status) ? null : S.responseText;
    },
    loadJson: function(O, Z) {
        this.loadTxt(O, function(S, P) {
            try {
                S ? Z(S) : Z(null, JSON.parse(P));
            } catch (X) {
                throw X;
            }
        });
    },
    loadImg: function(X, S, P) {
        var O = arguments.length,
            Z = !0;
        H8m.Q7O(3, O) ? Z = H8m.r7O(null, S.isCrossOrigin) ? Z : S.isCrossOrigin : H8m.N7O(2, O) && (P = S);
        var Y = new Image;
        Z && (Y.crossOrigin = "Anonymous");
        Y.addEventListener("load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
            P && P(null, Y);
        });
        Y.addEventListener("error", function() {
            this.removeEventListener("error", arguments.callee, !1);
            P && P("load image failed");
        });
        Y.src = X;
        return Y;
    },
    _str2Uint8Array: function(X) {
        if (!X)
            return null;
        for (var S = new Uint8Array(X.length), P = 0; H8m.m7O(P, X.length); P++)
            S[P] = H8m.A7O(X.charCodeAt(P), 255);
        return S;
    },
    loadBinary: function(S, P) {
        for (var z3K in w6b0K[f0K]) {
            if (z3K.length == 9 && z3K.charCodeAt(8) == 116 && z3K.charCodeAt(7) == 110 && z3K.charCodeAt(0) == 117)
                break
        }
        ;
        for (var t3K in w6b0K[f0K]) {
            if (t3K.length == 9 && t3K.charCodeAt(8) == 116 && t3K.charCodeAt(7) == 110 && t3K.charCodeAt(0) == 117)
                break
        }
        ;
        var O = this,
            Z = this.getXMLHttpRequest(),
            Y = "load " + S + " failed!";
        Z.open("GET", S, !0);
        /msie/i.test(w6b0K[f0K][z3K]) && !/opera/i.test(w6b0K[f0K][t3K]) ? (Z.setRequestHeader("Accept-Charset", "x-user-defined"), Z.onreadystatechange = function() {
            if (H8m.E7O(4, Z.readyState) && H8m.C7O(200, Z.status)) {
                var X = cc._convertResponseBodyToText(Z.responseBody);
                P(null, O._str2Uint8Array(X));
            } else
                P(Y);
        }) : (Z.overrideMimeType && Z.overrideMimeType("text/plain; charset\x3dx-user-defined"), Z.onload = function() {
            H8m.h7O(4, Z.readyState) && H8m.y7O(200, Z.status) ? P(null, O._str2Uint8Array(Z.responseText)) : P(Y);
        });
        Z.send(null);
    },
    loadBinarySync: function(X) {
        for (var P3K in w6b0K[f0K]) {
            if (P3K.length == 9 && P3K.charCodeAt(8) == 116 && P3K.charCodeAt(7) == 110 && P3K.charCodeAt(0) == 117)
                break
        }
        ;
        for (var j3K in w6b0K[f0K]) {
            if (j3K.length == 9 && j3K.charCodeAt(8) == 116 && j3K.charCodeAt(7) == 110 && j3K.charCodeAt(0) == ((0x1E, 109) <= 11 ? 120 : (85., 0x94) <= 0x100 ? (8., 117) : (14.19E2, 108.)))
                break
        }
        ;
        var S = this.getXMLHttpRequest(),
            P = "load " + X + " failed!";
        S.open("GET", X, !1);
        X = null;
        if (/msie/i.test(w6b0K[f0K][P3K]) && !/opera/i.test(w6b0K[f0K][j3K])) {
            S.setRequestHeader("Accept-Charset", "x-user-defined");
            S.send(null);
            if (H8m.q7O(200, S.status))
                return cc.log(P), null;
            (S = cc._convertResponseBodyToText(S.responseBody)) && (X = this._str2Uint8Array(S));
        } else {
            S.overrideMimeType && S.overrideMimeType("text/plain; charset\x3dx-user-defined");
            S.send(null);
            if (H8m.l7O(200, S.status))
                return cc.log(P), null;
            X = this._str2Uint8Array(S.responseText);
        }
        return X;
    },
    _loadResIterator: function(P, O, Z) {
        var Y = this,
            T = null,
            R = P.type;
        R ? (R = "." + R.toLowerCase(), T = P.name + R) : (T = P, R = cc.path.extname(T));
        if (O = Y.cache[T])
            return Z(null, O);
        O = Y._register[R.toLowerCase()];
        if (!O)
            return Z("loader for [" + R + "] not exists!");
        R = O.getBasePath ? O.getBasePath() : Y.resPath;
        R = Y.getUrl(R, T);
        O.load(R, T, P, function(X, S) {
            X ? (cc.log(X), Y.cache[T] = null, Z()) : (Y.cache[T] = S, Z(null, S));
        });
    },
    getUrl: function(X, S) {
        var P = this._langPathCache,
            O = cc.path;
        if (H8m.X0O(1, arguments.length)) {
            S = X;
            var Z = O.extname(S),
                Z = Z ? Z.toLowerCase() : "";
            X = (Z = this._register[Z]) ? Z.getBasePath ? Z.getBasePath() : this.resPath : this.resPath;
        }
        S = cc.path.join(X || "", S);
        if (S.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (P[S])
                return P[S];
            O = O.extname(S) || "";
            S = P[S] = S.substring(0, H8m.D0O(S.length, O.length)) + "_" + cc.sys.language + O;
        }
        return S;
    },
    load: function(P, O, Z) {
        var Y = arguments.length;
        if (H8m.c0O(3, Y))
            "function" == typeof O && (O = {
                trigger: O
            });
        else if (H8m.z0O(2, Y))
            "function" == typeof O && (Z = O, O = {});
        else if (H8m.j0O(1, Y))
            O = {};
        else
            throw "arguments error!";
        O.cb = function(X, S) {
            X && cc.log(X);
            Z && Z(S);
        };
        H8m.x0O(P, Array) || (P = [P]);
        O.iterator = this._loadResIterator;
        O.iteratorTarget = this;
        cc.async.map(P, O);
    },
    _handleAliases: function(X, S) {
        var P = this._aliases,
            O = [],
            Z;
        for (Z in X) {
            var Y = X[Z];
            P[Z] = Y;
            O.push(Y);
        }
        this.load(O, S);
    },
    loadAliases: function(S, P) {
        var O = this,
            Z = O.getRes(S);
        Z ? O._handleAliases(Z.filenames, P) : O.load(S, function(X) {
            O._handleAliases(X[0].filenames, P);
        });
    },
    register: function(X, S) {
        if (X && S) {
            if ("string" == typeof X)
                return this._register[X.trim().toLowerCase()] = S;
            for (var P = 0, O = X.length; H8m.o0O(P, O); P++)
                this._register["." + X[P].trim().toLowerCase()] = S;
        }
    },
    getRes: function(X) {
        return this.cache[X] || this.cache[this._aliases[X]];
    },
    release: function(X) {
        var S = this.cache,
            P = this._aliases;
        delete S[X];
        delete S[P[X]];
        delete P[X];
    },
    releaseAll: function() {
        var X = this.cache,
            S = this._aliases,
            P;
        for (P in X)
            delete X[P];
        for (P in S)
            delete S[P];
    }
};
(function() {
    var X = "focus",
        S = "blur",
        P = "webkitvisibilitychange",
        O = "webkitHidden",
        Z = "msvisibilitychange",
        Y = "msHidden",
        T = "mozvisibilitychange",
        R = "mozHidden",
        E = "visibilitychange",
        V = window,
        U,
        k9;
    H8m.l7H !== typeof w6b0K[I0K]['hidden'] ? (U = H8m.f5H, k9 = E) : H8m.l7H !== typeof w6b0K[I0K].mozHidden ? (U = R, k9 = T) : H8m.l7H !== typeof w6b0K[I0K].msHidden ? (U = Y, k9 = Z) : H8m.l7H !== typeof w6b0K[I0K].webkitHidden && (U = O, k9 = P);
    var L9 = function() {
            cc.eventManager && cc.eventManager.dispatchEvent(cc.game._eventHide);
        },
        K9 = function() {
            cc.eventManager && cc.eventManager.dispatchEvent(cc.game._eventShow);
        };
    H8m.l7H !== typeof w6b0K[I0K]['addEventListener'] && U ? w6b0K[I0K]['addEventListener'](k9, function() {
        w6b0K[I0K][U] ? L9() : K9();
    }, !H8m.h7H) : (V.addEventListener(S, L9, !H8m.h7H), V.addEventListener(X, K9, !H8m.h7H));
    k9 = V = H8m.H6P;
})();
cc._logToWebPage = function(X) {
    var S = "none",
        P = "1px solid #cccccc",
        O = "transparent",
        Z = "30",
        Y = "cols",
        T = "20",
        R = "rows",
        E = "textarea",
        V = "99999",
        U = "200",
        k9 = "logInfoDiv",
        L9 = "Div";
    if (cc._canvas) {
        var K9 = cc._logList,
            c9 = document;
        if (!K9) {
            var t9 = c9.createElement(L9),
                K9 = t9.style;
            t9.setAttribute(H8m.m5i, k9);
            cc._canvas.parentNode.appendChild(t9);
            t9.setAttribute(H8m.D3H, U);
            t9.setAttribute("height", cc._canvas.height);
            K9.zIndex = V;
            K9.position = H8m.w2i;
            K9.top = H8m.S5P;
            K9.left = H8m.S5P;
            K9 = cc._logList = c9.createElement(E);
            c9 = K9.style;
            K9.setAttribute(R, T);
            K9.setAttribute(Y, Z);
            K9.setAttribute(H8m.A7S, !H8m.U7H);
            t9.appendChild(K9);
            c9.backgroundColor = O;
            c9.borderBottom = P;
            c9.borderRightWidth = H8m.E2P;
            c9.borderLeftWidth = H8m.E2P;
            c9.borderTopWidth = H8m.E2P;
            c9.borderTopStyle = S;
            c9.borderRightStyle = S;
            c9.borderLeftStyle = S;
            c9.padding = H8m.E2P;
            c9.margin = H8m.U7H;
        }
        X = H8m.u6P == typeof X ? X : JSON.stringify(X);
        K9.value = K9.value + X + H8m.F3P;
        K9.scrollTop = K9.scrollHeight;
    }
};
console.log ? (cc.log = console.log.bind(console), cc.warn = console.warn.bind(console), cc.error = console.error.bind(console), cc.assert = console.assert.bind(console)) : cc.log = cc.warn = cc.error = cc.assert = function() {};
cc._initDebugSetting = function(P) {
    var O = cc.game;
    H8m.p0O(P, O.DEBUG_MODE_INFO) && console.log || (cc.log = H8m.Y0O(P, O.DEBUG_MODE_INFO) && !console.log || H8m.T0O(P, O.DEBUG_MODE_INFO_FOR_WEB_PAGE) ? cc._logToWebPage.bind(cc) : function() {});
    P && H8m.R0O(P, O.DEBUG_MODE_NONE) && H8m.M0O(P, O.DEBUG_MODE_ERROR) && H8m.V0O(P, O.DEBUG_MODE_ERROR_FOR_WEB_PAGE) ? H8m.s0O(P, O.DEBUG_MODE_INFO_FOR_WEB_PAGE) && H8m.U0O(P, O.DEBUG_MODE_WARN_FOR_WEB_PAGE) && console.warn || (cc.warn = cc._logToWebPage.bind(cc)) : cc.warn = function() {};
    P && H8m.b0O(P, O.DEBUG_MODE_NONE) ? H8m.F0O(P, O.DEBUG_MODE_INFO_FOR_WEB_PAGE) && H8m.k3O(P, O.DEBUG_MODE_WARN_FOR_WEB_PAGE) && H8m.L3O(P, O.DEBUG_MODE_ERROR_FOR_WEB_PAGE) && console.error || (cc.error = cc._logToWebPage.bind(cc), cc.assert = function(X, S) {
        !X && S && cc._logToWebPage(S);
    }) : (cc.error = function() {}, cc.assert = function() {});
};
cc.create3DContext = function(S, P) {
    for (var O = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], Z = null, Y = 0; H8m.i3O(Y, O.length); ++Y) {
        try {
            Z = S.getContext(O[Y], P);
        } catch (X) {}
        if (Z)
            break;
    }
    return Z;
};
cc._initSys = function(T, R) {
    for (var e3K in w6b0K[I0K]) {
        if (e3K.length == 15 && e3K.charCodeAt((17 > (42.90E1, 0x20) ? (62.1E1, "top") : (0x23, 0x68) < (39, 69.9E1) ? (1.274E3, 14) : (122., 0x215))) == 116 && e3K.charCodeAt(13) == 110 && e3K.charCodeAt(0) == 100)
            break
    }
    ;
    var E = "X11",
        V = "Mac",
        U = "Win",
        k9 = "storage",
        L9 = "Canvas",
        K9 = "android",
        c9 = "mobile",
        t9 = "unknown",
        S9 = "chrome",
        j9 = "safari",
        a9 = "firefox",
        o9 = "miuibrowser",
        T9 = "opera",
        A9 = "maxthon",
        F9 = "baidubrowser",
        M9 = "baiduboxapp",
        s9 = "360browser",
        C9 = "ucbrowser",
        n9 = "mqqbrowser",
        t1 = "qqbrowser",
        o1 = "ie",
        a1 = "androidbrowser",
        j1 = "wechat",
        T1 = "Unknown",
        e8 = "Android",
        y1 = "Linux",
        s8 = "UNIX",
        I8 = "OS X",
        L4 = "iOS",
        g4 = "Windows",
        X4 = "pl",
        k4 = "ar",
        c4 = "pt",
        i4 = "hu",
        K4 = "ja",
        D4 = "ko",
        d4 = "ru",
        B9 = "es",
        l1 = "de",
        O8 = "it",
        o8 = "fr",
        u9 = "zh";
    cc._RENDER_TYPE_CANVAS = H8m.U7H;
    cc._RENDER_TYPE_WEBGL = H8m.h7H;
    var e9 = cc.sys = {};
    e9.LANGUAGE_ENGLISH = H8m.e2H;
    e9.LANGUAGE_CHINESE = u9;
    e9.LANGUAGE_FRENCH = o8;
    e9.LANGUAGE_ITALIAN = O8;
    e9.LANGUAGE_GERMAN = l1;
    e9.LANGUAGE_SPANISH = B9;
    e9.LANGUAGE_RUSSIAN = d4;
    e9.LANGUAGE_KOREAN = D4;
    e9.LANGUAGE_JAPANESE = K4;
    e9.LANGUAGE_HUNGARIAN = i4;
    e9.LANGUAGE_PORTUGUESE = c4;
    e9.LANGUAGE_ARABIC = k4;
    e9.LANGUAGE_NORWEGIAN = H8m.q2P;
    e9.LANGUAGE_POLISH = X4;
    e9.OS_WINDOWS = g4;
    e9.OS_IOS = L4;
    e9.OS_OSX = I8;
    e9.OS_UNIX = s8;
    e9.OS_LINUX = y1;
    e9.OS_ANDROID = e8;
    e9.OS_UNKNOWN = T1;
    e9.BROWSER_TYPE_WECHAT = j1;
    e9.BROWSER_TYPE_ANDROID = a1;
    e9.BROWSER_TYPE_IE = o1;
    e9.BROWSER_TYPE_QQ = t1;
    e9.BROWSER_TYPE_MOBILE_QQ = n9;
    e9.BROWSER_TYPE_UC = C9;
    e9.BROWSER_TYPE_360 = s9;
    e9.BROWSER_TYPE_BAIDU_APP = M9;
    e9.BROWSER_TYPE_BAIDU = F9;
    e9.BROWSER_TYPE_MAXTHON = A9;
    e9.BROWSER_TYPE_OPERA = T9;
    e9.BROWSER_TYPE_MIUI = o9;
    e9.BROWSER_TYPE_FIREFOX = a9;
    e9.BROWSER_TYPE_SAFARI = j9;
    e9.BROWSER_TYPE_CHROME = S9;
    e9.BROWSER_TYPE_UNKNOWN = t9;
    e9.isNative = !H8m.h7H;
    var R1 = [e9.BROWSER_TYPE_BAIDU, e9.BROWSER_TYPE_OPERA, e9.BROWSER_TYPE_FIREFOX, e9.BROWSER_TYPE_CHROME, e9.BROWSER_TYPE_SAFARI],
        m8 = [e9.BROWSER_TYPE_BAIDU, e9.BROWSER_TYPE_OPERA, e9.BROWSER_TYPE_FIREFOX, e9.BROWSER_TYPE_CHROME, e9.BROWSER_TYPE_SAFARI, e9.BROWSER_TYPE_UC, e9.BROWSER_TYPE_QQ, e9.BROWSER_TYPE_MOBILE_QQ, e9.BROWSER_TYPE_IE],
        g8 = window,
        t8 = g8.navigator,
        B1 = w6b0K[I0K][e3K],
        a8 = t8.userAgent.toLowerCase();
    e9.isMobile = -H8m.h7H != a8.indexOf(c9) || -H8m.h7H != a8.indexOf(K9);
    var K1 = t8.language,
        K1 = (K1 = K1 ? K1 : t8.browserLanguage) ? K1.split(H8m.S3P)[H8m.U7H] : e9.LANGUAGE_ENGLISH;
    e9.language = K1;
    var K1 = e9.BROWSER_TYPE_UNKNOWN,
        L1 = a8.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|opera|miuibrowser|firefox/i) || a8.match(/chrome|safari/i);
    L1 && H8m.S3O(0, L1.length) && (K1 = L1[0].toLowerCase(), H8m.P3O("micromessenger", K1) ? K1 = e9.BROWSER_TYPE_WECHAT : H8m.a3O("safari", K1) && a8.match(/android.*applewebkit/) ? K1 = e9.BROWSER_TYPE_ANDROID : H8m.O3O("trident", K1) && (K1 = e9.BROWSER_TYPE_IE));
    e9.browserType = K1;
    e9._supportMultipleAudio = -H8m.h7H < m8.indexOf(e9.browserType);
    m8 = parseInt(T[R.renderMode]);
    K1 = cc._RENDER_TYPE_WEBGL;
    L1 = w6b0K[I0K]['createElement'](L9);
    cc._supportRender = !H8m.U7H;
    R1 = -H8m.h7H == R1.indexOf(e9.browserType);
    if (H8m.B3O(H8m.h7H, m8) || H8m.Z3O(H8m.U7H, m8) && (e9.isMobile || R1))
        K1 = cc._RENDER_TYPE_CANVAS;
    H8m.J3O(K1, cc._RENDER_TYPE_WEBGL) || g8.WebGLRenderingContext && cc.create3DContext(L1, {
        stencil: !H8m.U7H,
        preserveDrawingBuffer: !H8m.U7H
    }) || (H8m.n3O(H8m.U7H, m8) ? K1 = cc._RENDER_TYPE_CANVAS : cc._supportRender = !H8m.h7H);
    if (H8m.G3O(K1, cc._RENDER_TYPE_CANVAS))
        try {
            L1.getContext(H8m.C9K);
        } catch (X) {
            cc._supportRender = !H8m.h7H;
        }
    cc._renderType = K1;
    try {
        e9._supportWebAudio = !!new (g8.AudioContext || g8.webkitAudioContext || g8.mozAudioContext);
    } catch (X) {
        e9._supportWebAudio = !H8m.h7H;
    }
    try {
        var M1 = e9.localStorage = g8.localStorage;
        M1.setItem(k9, H8m.u4S);
        M1.removeItem(k9);
        M1 = H8m.H6P;
    } catch (X) {
        var I9 = "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
            Z1 = "QuotaExceededError",
            j8 = "SECURITY_ERR";
        H8m.W3O(j8, X.name) && H8m.v3O(Z1, X.name) || cc.warn(I9), e9.localStorage = function() {};
    }
    M1 = e9.capabilities = {
        canvas: !0
    };
    H8m.u3O(cc._renderType, cc._RENDER_TYPE_WEBGL) && (M1.opengl = !H8m.U7H);
    void H8m.U7H !== B1.ontouchstart || t8.msPointerEnabled ? M1.touches = !H8m.U7H : void H8m.U7H !== B1.onmouseup && (M1.mouse = !H8m.U7H);
    void H8m.U7H !== B1.onkeyup && (M1.keyboard = !H8m.U7H);
    if (g8.DeviceMotionEvent || g8.DeviceOrientationEvent)
        M1.accelerometer = !H8m.U7H;
    g8 = a8.match(/(iPad|iPhone|iPod)/i) ? !H8m.U7H : !H8m.h7H;
    a8 = a8.match(/android/i) || t8.platform.match(/android/i) ? !H8m.U7H : !H8m.h7H;
    B1 = e9.OS_UNKNOWN;
    -H8m.h7H != t8.appVersion.indexOf(U) ? B1 = e9.OS_WINDOWS : g8 ? B1 = e9.OS_IOS : -H8m.h7H != t8.appVersion.indexOf(V) ? B1 = e9.OS_OSX : -H8m.h7H != t8.appVersion.indexOf(E) ? B1 = e9.OS_UNIX : -H8m.h7H != t8.appVersion.indexOf(y1) ? B1 = e9.OS_LINUX : a8 && (B1 = e9.OS_ANDROID);
    e9.os = B1;
    e9.garbageCollect = function() {};
    e9.dumpRoot = function() {};
    e9.restartVM = function() {};
    e9.dump = function() {
        var X = "os : ",
            S = "capabilities : ",
            P = "browserType : ",
            O = "language : ",
            Z = "isMobile : ",
            Y;
        Y = H8m.u4S + (Z + this.isMobile + H8m.F3P);
        Y += O + this.language + H8m.F3P;
        Y += P + this.browserType + H8m.F3P;
        Y += S + JSON.stringify(this.capabilities) + H8m.F3P;
        Y += X + this.os + H8m.F3P;
        cc.log(Y);
    };
};
H8m.i9(H8m.U7H);
H8m.d9(H8m.h7H);
H8m.z9(H8m.s7H);
H8m.P9(H8m.v7H);
H8m.w9(H8m.H6P);
H8m.x9(H8m.H6P);
H8m.O9(H8m.H6P);
H8m.Q9(H8m.H6P);
H8m.p9();
cc._setup = function(X, S, P) {
    for (var Q3K in w6b0K[I0K]) {
        if (Q3K.length == 4 && Q3K.charCodeAt(3) == ((0x30, 0x214) <= (12.21E2, 0x229) ? (58, 121) : (1.78E2, 138.5E1)) && Q3K.charCodeAt(2) == 100 && Q3K.charCodeAt(((0x1, 78.5E1) < 7.94E2 ? (122.60E1, 0) : 44.80E1 < (0x233, 4.08E2) ? 94. : (11.25E2, 0x41))) == 98)
            break
    }
    ;
    var O = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}",
        Z = "100%",
        Y = "relative",
        T = "0 auto",
        R = 480,
        E = window;
    E.requestAnimFrame = E.requestAnimationFrame || E.webkitRequestAnimationFrame || E.mozRequestAnimationFrame || E.oRequestAnimationFrame || E.msRequestAnimationFrame;
    var V = cc.$(X) || cc.$(H8m.R6P + X),
        U;
    H8m.H3O("CANVAS", V.tagName) ? (S = S || V.width, P = P || V.height, U = cc.container = cc.$new("DIV"), X = cc._canvas = V, X.parentNode.insertBefore(U, X), X.appendTo(U), U.setAttribute("id", "Cocos2dGameContainer")) : (H8m.f3O("DIV", V.tagName) && cc.log("Warning: target element is not a DIV or CANVAS"), S = S || V.clientWidth, P = P || V.clientHeight, U = cc.container = V, X = cc._canvas = cc.$new("CANVAS"), V.appendChild(X));
    X.addClass(H8m.h1P);
    X.setAttribute(H8m.D3H, S || R);
    X.setAttribute(H8m.m5S, P || H8m.l3i);
    V = U.style;
    V.width = (S || 480) + "px";
    V.height = (P || 320) + "px";
    V.margin = T;
    V.position = Y;
    V.overflow = H8m.f5H;
    U.top = Z;
    H8m.I3O(cc._renderType, cc._RENDER_TYPE_WEBGL) && (cc._renderContext = cc.webglContext = cc.create3DContext(X, {
        stencil: !H8m.U7H,
        preserveDrawingBuffer: !H8m.U7H,
        antialias: !cc.sys.isMobile,
        alpha: !H8m.h7H
    }));
    cc._renderContext ? (E.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = X.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, X.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
    cc._gameDiv = U;
    cc.log(cc.ENGINE_VERSION);
    cc._setContextMenuEnable(!H8m.h7H);
    cc.sys.isMobile && (S = w6b0K[I0K]['createElement'](H8m.r6i), S.type = H8m.u2i, w6b0K[I0K][Q3K]['appendChild'](S), S.textContent = O);
    cc.view = cc.EGLView._getInstance();
    cc.inputManager.registerSystemEvent(cc._canvas);
    cc.director = cc.Director._getInstance();
    cc.director.setOpenGLView(cc.view);
    cc.winSize = cc.director.getWinSize();
    cc.saxParser = new cc.SAXParser;
    cc.plistParser = new cc.PlistParser;
};
H8m.r9();
cc._setContextMenuEnable = function(X) {
    cc._isContextMenuEnable = X;
    cc._canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable)
            return !H8m.h7H;
    };
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(X) {
        this.config[this.CONFIG_KEY.frameRate] = X;
        this._intervalId && clearInterval(this._intervalId);
        this._paused = !0;
        this._runMainLoop();
    },
    _runMainLoop: function() {
        var X = this,
            S,
            P = X.config,
            O = X.CONFIG_KEY,
            Z = window,
            Y = P[O.frameRate],
            T = cc.director;
        T.setDisplayStats(P[O.showFPS]);
        Z.requestAnimFrame && H8m.g5O(60, Y) ? (S = function() {
            X._paused || (T.mainLoop(), Z.requestAnimFrame(S));
        }, Z.requestAnimFrame(S)) : (S = function() {
            T.mainLoop();
        }, X._intervalId = setInterval(S, H8m.K5O(1E3, Y)));
        X._paused = !1;
    },
    run: function() {
        var X = this;
        X._prepareCalled ? cc._supportRender && (X._checkPrepare = setInterval(function() {
            X._prepared && (cc._setup(X.config[X.CONFIG_KEY.id]), X._runMainLoop(), X._eventHide = X._eventHide || new cc.EventCustom(X.EVENT_HIDE), X._eventHide.setUserData(X), X._eventShow = X._eventShow || new cc.EventCustom(X.EVENT_SHOW), X._eventShow.setUserData(X), X.onStart(), clearInterval(X._checkPrepare));
        }, 10)) : X.prepare(function() {
            cc._supportRender && (cc._setup(X.config[X.CONFIG_KEY.id]), X._runMainLoop(), X._eventHide = X._eventHide || new cc.EventCustom(X.EVENT_HIDE), X._eventHide.setUserData(X), X._eventShow = X._eventShow || new cc.EventCustom(X.EVENT_SHOW), X._eventShow.setUserData(X), X.onStart());
        });
    },
    _initConfig: function() {
        var S = this.CONFIG_KEY,
            P = function(X) {
                X[S.engineDir] = X[S.engineDir] || "libs/cocos2d-html5";
                X[S.debugMode] = X[S.debugMode] || 0;
                X[S.frameRate] = X[S.frameRate] || 60;
                X[S.renderMode] = X[S.renderMode] || 0;
                return X;
            };
        if (w6b0K[I0K].ccConfig)
            this.config = P(w6b0K[I0K].ccConfig);
        else
            try {
                var O = cc.loader._loadTxtSync("project.json"),
                    Z = JSON.parse(O);
                this.config = P(Z || {});
            } catch (X) {
                this.config = P({});
            }
        cc._initDebugSetting(this.config[S.debugMode]);
        cc._initSys(this.config, S);
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(X, S, P) {
        var O = this._jsAddedCache;
        if (O[S])
            return null;
        P = P || "";
        var Z = [],
            Y = X[S];
        if (!Y)
            throw "can not find module [" + S + "]";
        S = cc.path;
        for (var T = 0, R = Y.length; H8m.d5O(T, R); T++) {
            var E = Y[T];
            if (!O[E]) {
                var V = S.extname(E);
                V ? H8m.t5O(".js", V.toLowerCase()) && Z.push(S.join(P, E)) : (V = this._getJsListOfModule(X, E, P)) && (Z = Z.concat(V));
                O[E] = 1;
            }
        }
        return Z;
    },
    prepare: function(V) {
        var U = this,
            k9 = U.config,
            L9 = U.CONFIG_KEY,
            K9 = k9[L9.engineDir],
            c9 = cc.loader;
        if (cc._supportRender) {
            U._prepareCalled = !0;
            var t9 = k9[L9.jsList] || [];
            cc.Class ? c9.loadJsWithImg("", t9, function(X) {
                if (X)
                    throw X;
                U._prepared = !0;
                V && V();
            }) : (L9 = cc.path.join(K9, "moduleConfig.json"), c9.loadJson(L9, function(S, P) {
                if (S)
                    throw S;
                var O = k9.modules || [],
                    Z = P.module,
                    Y = [];
                H8m.w5O(cc._renderType, cc._RENDER_TYPE_WEBGL) ? O.splice(0, 0, "shaders") : H8m.e5O(0, O.indexOf("core")) && O.splice(0, 0, "core");
                for (var T = 0, R = O.length; H8m.Q5O(T, R); T++) {
                    var E = U._getJsListOfModule(Z, O[T], K9);
                    E && (Y = Y.concat(E));
                }
                Y = Y.concat(t9);
                cc.loader.loadJsWithImg(Y, function(X) {
                    if (X)
                        throw X;
                    U._prepared = !0;
                    V && V();
                });
            }));
         didLoadCompleted();

        } else
            cc.error("Can not support render!");
    }
};
cc.game._initConfig();
var cc = cc || {},
    ClassManager = {
        id: H8m.r5O(H8m.U7H, H8m.i6H * Math.random()),
        instanceId: H8m.N5O(H8m.U7H, H8m.i6H * Math.random()),
        compileSuper: function(P, O, Z) {
            var Y = "this._super",
                T = "}",
                R = "{",
                E = ((0x20C, 88.) >= 0x21D ? (112., "r") : (76, 29.70E1) > (109., 24.1E1) ? (98., "(") : (53., 1.088E3));
            P = P.toString();
            var V = P.indexOf(E),
                U = P.indexOf(H8m.j9K),
                V = P.substring(V + H8m.h7H, U),
                V = V.trim(),
                U = P.indexOf(R),
                k9 = P.lastIndexOf(T);
            for (P = P.substring(U + H8m.h7H, k9); -H8m.h7H != P.indexOf(Y);) {
                var L9 = function() {
                    var X = ".call(this",
                        S = "ClassManager[";
                    P = P.substring(H8m.U7H, U) + S + Z + H8m.z8P + O + X + K9 + P.substring(k9 + H8m.h7H);
                };
                var U = P.indexOf(Y),
                    k9 = P.indexOf(E, U),
                    K9 = P.indexOf(H8m.j9K, k9),
                    K9 = P.substring(k9 + H8m.h7H, K9),
                    K9 = (K9 = K9.trim()) ? H8m.W0P : H8m.u4S;
                L9();
            }
            return Function(V, P);
        },
        getNewID: function() {
            return this.id++;
        },
        getNewInstanceId: function() {
            return this.instanceId++;
        }
    };
H8m.Y9(ClassManager);
(function() {
    var o9 = "release Mode",
        T9 = /\b_super\b/,
        A9 = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    A9 && console.log(o9);
    cc.Class = function() {};
    cc.Class.extend = function(Z) {
        var Y = "constructor",
            T = "__pid";
        function R() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments);
        }
        var E = this.prototype,
            V = Object.create(E),
            U = ClassManager.getNewID();
        ClassManager[U] = E;
        var k9 = {
            writable: !H8m.U7H,
            enumerable: !H8m.h7H,
            configurable: !H8m.U7H
        };
        V.__instanceId = H8m.H6P;
        R.id = U;
        k9.value = U;
        Object.defineProperty(V, T, k9);
        R.prototype = V;
        k9.value = R;
        Object.defineProperty(R.prototype, Y, k9);
        this.__getters__ && (R.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (R.__setters__ = cc.clone(this.__setters__));
        for (var L9 in Z) {
            var K9 = H8m.h6i === typeof Z[L9],
                c9 = H8m.h6i === typeof E[L9],
                t9 = T9.test(Z[L9]);
            A9 && K9 && c9 && t9 ? (k9.value = ClassManager.compileSuper(Z[L9], L9, U), Object.defineProperty(V, L9, k9)) : K9 && c9 && t9 ? (k9.value = function(P, O) {
                return function() {
                    var X = this._super;
                    this._super = E[P];
                    var S = O.apply(this, arguments);
                    this._super = X;
                    return S;
                };
            }(L9, Z[L9]), Object.defineProperty(V, L9, k9)) : K9 ? (k9.value = Z[L9], Object.defineProperty(V, L9, k9)) : V[L9] = Z[L9];
            if (K9) {
                var S9,
                    j9;
                if (this.__getters__ && this.__getters__[L9]) {
                    var K9 = this.__getters__[L9],
                        a9;
                    for (a9 in this.__setters__)
                        if (H8m.m5O(this.__setters__[a9], K9)) {
                            j9 = a9;
                            break;
                        }
                    cc.defineGetterSetter(V, K9, Z[L9], Z[j9] ? Z[j9] : V[j9], L9, j9);
                }
                if (this.__setters__ && this.__setters__[L9]) {
                    K9 = this.__setters__[L9];
                    for (a9 in this.__getters__)
                        if (H8m.A5O(this.__getters__[a9], K9)) {
                            S9 = a9;
                            break;
                        }
                    cc.defineGetterSetter(V, K9, Z[S9] ? Z[S9] : V[S9], Z[L9], S9, L9);
                }
            }
        }
        R.extend = cc.Class.extend;
        R.implement = function(X) {
            for (var S in X)
                V[S] = X[S];
        };
        return R;
    };
    Function.prototype.bind = Function.prototype.bind || function(S) {
        var P = this;
        return function() {
            var X = Array.prototype.slice.call(arguments);
            return P.apply(S || H8m.H6P, X);
        };
    };
})();
cc.inherits = function(X, S) {
    function P() {}
    P.prototype = S.prototype;
    X.superClass_ = S.prototype;
    X.prototype = new P;
    X.prototype.constructor = X;
};
cc.base = function(X, S, P) {
    var O = "cc.base called from a method of one name to a method of a different name",
        Z = arguments.callee.caller;
    if (Z.superClass_)
        return ret = Z.superClass_.constructor.apply(X, Array.prototype.slice.call(arguments, H8m.h7H));
    for (var Y = Array.prototype.slice.call(arguments, H8m.s7H), T = !H8m.h7H, R = X.constructor; R; R = R.superClass_ && R.superClass_.constructor)
        if (H8m.E5O(R.prototype[S], Z))
            T = !H8m.U7H;
        else if (T)
            return R.prototype[S].apply(X, Y);
    if (H8m.C5O(X[S], Z))
        return X.constructor.prototype[S].apply(X, Y);
    throw Error(O);
};
cc.concatObjectProperties = function(X, S) {
    X || (X = {});
    for (var P in S)
        X[P] = S[P];
    return X;
};
cc.clone = function(X) {
    var S = X.constructor ? new X.constructor : {},
        P;
    for (P in X) {
        var O = X[P];
        S[P] = H8m.u9P != typeof O || !O || H8m.h5O(O, cc.Node) || H8m.y5O(O, HTMLElement) ? O : cc.clone(O);
    }
    return S;
};
cc.associateWithNative = function(X, S) {};
cc.KEY = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    ",": 186,
    equal: 187,
    "\x3d": 187,
    ";": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    "]": 221,
    closebracket: 221,
    backslash: 220,
    quote: 222,
    space: 32
};
H8m.J9(H8m.U7H);
H8m.m9(H8m.h7H);
H8m.R9(H8m.s7H);
H8m.G9(H8m.v7H);
H8m.E9(H8m.q7H);
H8m.V9(H8m.b7H);
cc.getImageFormatByData = function(X) {
    return H8m.q5O(8, X.length) && H8m.l5O(137, X[0]) && H8m.X6O(80, X[1]) && H8m.D6O(78, X[2]) && H8m.c6O(71, X[3]) && H8m.z6O(13, X[4]) && H8m.j6O(10, X[5]) && H8m.x6O(26, X[6]) && H8m.o6O(10, X[7]) ? cc.FMT_PNG : H8m.p6O(2, X.length) && (H8m.Y6O(73, X[0]) && H8m.T6O(73, X[1]) || H8m.R6O(77, X[0]) && H8m.M6O(77, X[1]) || H8m.V6O(255, X[0]) && H8m.s6O(216, X[1])) ? cc.FMT_TIFF : cc.FMT_UNKNOWN;
};
cc.defineGetterSetter = function(X, S, P, O, Z, Y) {
    if (X.__defineGetter__)
        P && X.__defineGetter__(S, P), O && X.__defineSetter__(S, O);
    else if (Object.defineProperty) {
        var T = {
            enumerable: !1,
            configurable: !0
        };
        P && (T.get = P);
        O && (T.set = O);
        Object.defineProperty(X, S, T);
    } else
        throw Error("browser does not support getters");
    if (!Z && !Y)
        for (var T = H8m.U6O(null, P), R = void 0 != O, E = Object.getOwnPropertyNames(X), V = 0; H8m.b6O(V, E.length); V++) {
            var U = E[V];
            if (!X.__lookupGetter__(U) && "function" === typeof X[U]) {
                var k9 = X[U];
                if (T && H8m.F6O(k9, P) && (Z = U, !R || Y))
                    break;
                if (R && H8m.k2O(k9, O) && (Y = U, !T || Z))
                    break;
            }
        }
    X = X.constructor;
    Z && (X.__getters__ || (X.__getters__ = {}), X.__getters__[Z] = S);
    Y && (X.__setters__ || (X.__setters__ = {}), X.__setters__[Y] = S);
};
cc.copyArray = function(X) {
    var S,
        P = X.length,
        O = Array(P);
    for (S = 0; H8m.L2O(S, P); S += 1)
        O[S] = X[S];
    return O;
};
cc.Point = function(X, S) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
};
cc.p = function(X, S) {
    return void H8m.U7H == X ? {
        x: H8m.U7H,
        y: H8m.U7H
    } : void H8m.U7H == S ? {
        x: X.x,
        y: X.y
    } : {
        x: X,
        y: S
    };
};
cc.pointEqualToPoint = function(X, S) {
    return X && S ? H8m.i2O(X.x, S.x) && H8m.S2O(X.y, S.y) : !H8m.h7H;
};
cc.Size = function(X, S) {
    this.width = X || 0;
    this.height = S || 0;
};
cc.size = function(X, S) {
    return void 0 === X ? {
        width: 0,
        height: 0
    } : void 0 === S ? {
        width: X.width,
        height: X.height
    } : {
        width: X,
        height: S
    };
};
cc.sizeEqualToSize = function(X, S) {
    return X && S ? H8m.P2O(X.width, S.width) && H8m.a2O(X.height, S.height) : !1;
};
cc.Rect = function(X, S, P, O) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.width = P || 0;
    this.height = O || 0;
};
cc.rect = function(X, S, P, O) {
    return void 0 === X ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === S ? {
        x: X.x,
        y: X.y,
        width: X.width,
        height: X.height
    } : {
        x: X,
        y: S,
        width: P,
        height: O
    };
};
cc.rectEqualToRect = function(X, S) {
    return X && S ? H8m.O2O(X.x, S.x) && H8m.B2O(X.y, S.y) && H8m.Z2O(X.width, S.width) && H8m.J2O(X.height, S.height) : !1;
};
cc._rectEqualToZero = function(X) {
    return X ? H8m.n2O(0, X.x) && H8m.G2O(0, X.y) && H8m.W2O(0, X.width) && H8m.v2O(0, X.height) : !1;
};
cc.rectContainsRect = function(X, S) {
    return X && S ? !(H8m.u2O(X.x, S.x) || H8m.H2O(X.y, S.y) || H8m.f2O(X.x + X.width, S.x + S.width) || H8m.I2O(X.y + X.height, S.y + S.height)) : !1;
};
cc.rectGetMaxX = function(X) {
    return X.x + X.width;
};
cc.rectGetMidX = function(X) {
    return X.x + H8m.g9D(X.width, 2);
};
cc.rectGetMinX = function(X) {
    return X.x;
};
cc.rectGetMaxY = function(X) {
    return X.y + X.height;
};
cc.rectGetMidY = function(X) {
    return X.y + H8m.K9D(X.height, 2);
};
cc.rectGetMinY = function(X) {
    return X.y;
};
cc.rectContainsPoint = function(X, S) {
    return H8m.d9D(S.x, cc.rectGetMinX(X)) && H8m.t9D(S.x, cc.rectGetMaxX(X)) && H8m.w9D(S.y, cc.rectGetMinY(X)) && H8m.e9D(S.y, cc.rectGetMaxY(X));
};
cc.rectIntersectsRect = function(X, S) {
    return !(H8m.Q9D(cc.rectGetMaxX(X), cc.rectGetMinX(S)) || H8m.r9D(cc.rectGetMaxX(S), cc.rectGetMinX(X)) || H8m.N9D(cc.rectGetMaxY(X), cc.rectGetMinY(S)) || H8m.m9D(cc.rectGetMaxY(S), cc.rectGetMinY(X)));
};
cc.rectOverlapsRect = function(X, S) {
    return !(H8m.A9D(X.x + X.width, S.x) || H8m.E9D(S.x + S.width, X.x) || H8m.C9D(X.y + X.height, S.y) || H8m.h9D(S.y + S.height, X.y));
};
cc.rectUnion = function(X, S) {
    var P = cc.rect(0, 0, 0, 0);
    P.x = Math.min(X.x, S.x);
    P.y = Math.min(X.y, S.y);
    P.width = H8m.y9D(Math.max(X.x + X.width, S.x + S.width), P.x);
    P.height = H8m.q9D(Math.max(X.y + X.height, S.y + S.height), P.y);
    return P;
};
cc.rectIntersection = function(X, S) {
    var P = cc.rect(Math.max(cc.rectGetMinX(X), cc.rectGetMinX(S)), Math.max(cc.rectGetMinY(X), cc.rectGetMinY(S)), 0, 0);
    P.width = H8m.l9D(Math.min(cc.rectGetMaxX(X), cc.rectGetMaxX(S)), cc.rectGetMinX(P));
    P.height = H8m.X1D(Math.min(cc.rectGetMaxY(X), cc.rectGetMaxY(S)), cc.rectGetMinY(P));
    return P;
};
cc.SAXParser = cc.Class.extend({
    _parser: H8m.H6P,
    _isSupportDOMParser: H8m.H6P,
    ctor: function() {
        w6b0K[q0K]['DOMParser'] ? (this._isSupportDOMParser = !H8m.U7H, this._parser = new DOMParser) : this._isSupportDOMParser = !H8m.h7H;
    },
    parse: function(X) {
        return this._parseXML(X);
    },
    _parseXML: function(X) {
        var S = "Microsoft.XMLDOM",
            P = "text/xml",
            O;
        this._isSupportDOMParser ? O = this._parser.parseFromString(X, P) : (O = new ActiveXObject(S), O.async = H8m.B0i, O.loadXML(X));
        return O;
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function(X) {
        X = this._parseXML(X).documentElement;
        if (H8m.D1D("plist", X.tagName))
            throw "Not a plist file!";
        for (var S = null, P = 0, O = X.childNodes.length; H8m.c1D(P, O) && (S = X.childNodes[P], H8m.z1D(1, S.nodeType)); P++)
            ;
        return this._parseNode(S);
    },
    _parseNode: function(X) {
        var S = null,
            P = X.tagName;
        if (H8m.j1D("dict", P))
            S = this._parseDict(X);
        else if (H8m.x1D("array", P))
            S = this._parseArray(X);
        else if (H8m.o1D("string", P))
            if (H8m.p1D(1, X.childNodes.length))
                S = X.firstChild.nodeValue;
            else
                for (S = "", P = 0; H8m.Y1D(P, X.childNodes.length); P++)
                    S += X.childNodes[P].nodeValue;
        else
            H8m.T1D("false", P) ? S = !1 : H8m.R1D("true", P) ? S = !0 : H8m.M1D("real", P) ? S = parseFloat(X.firstChild.nodeValue) : H8m.V1D("integer", P) && (S = parseInt(X.firstChild.nodeValue, 10));
        return S;
    },
    _parseArray: function(X) {
        for (var S = [], P = 0, O = X.childNodes.length; H8m.s1D(P, O); P++) {
            var Z = X.childNodes[P];
            H8m.U1D(1, Z.nodeType) && S.push(this._parseNode(Z));
        }
        return S;
    },
    _parseDict: function(X) {
        for (var S = {}, P = null, O = 0, Z = X.childNodes.length; H8m.b1D(O, Z); O++) {
            var Y = X.childNodes[O];
            H8m.F1D(1, Y.nodeType) && (H8m.k8D("key", Y.tagName) ? P = Y.firstChild.nodeValue : S[P] = this._parseNode(Y));
        }
        return S;
    }
});
cc._txtLoader = {
    load: function(X, S, P, O) {
        cc.loader.loadTxt(X, O);
    }
};
cc.loader.register([H8m.D3i, H8m.I1P, H8m.K7i, H8m.k9i], cc._txtLoader);
cc._jsonLoader = {
    load: function(X, S, P, O) {
        cc.loader.loadJson(X, O);
    }
};
cc.loader.register([H8m.s7K, H8m.p7H], cc._jsonLoader);
cc._imgLoader = {
    load: function(P, O, Z, Y) {
        P = cc.loader.loadImg(P, function(X, S) {
            if (X)
                return Y(X);
            cc.textureCache.handleLoadedTexture(O);
            Y(null, S);
        });
        cc.loader.cache[O] = P;
    }
};
cc.loader.register([H8m.Q6P, H8m.N1S, H8m.v4K, H8m.c7K, H8m.y5P], cc._imgLoader);
cc._plistLoader = {
    load: function(P, O, Z, Y) {
        cc.loader.loadTxt(P, function(X, S) {
            if (X)
                return Y(X);
            Y(null, cc.plistParser.parse(S));
        });
    }
};
cc.loader.register([H8m.E5i], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        eot: "embedded-opentype",
        ttf: "truetype",
        woff: "woff",
        svg: "svg"
    },
    _loadFont: function(X, S, P) {
        var O = document,
            Z = cc.path,
            Y = this.TYPE,
            T = O.createElement("style");
        T.type = "text/css";
        O.body.appendChild(T);
        var R = "@font-face { font-family:" + X + "; src:";
        if (H8m.L8D(S, Array))
            for (var E = 0, V = S.length; H8m.i8D(E, V); E++)
                P = Z.extname(S[E]), R += "url('" + S[E] + "') format('" + Y[P] + "')", R += H8m.S8D(E, V - 1) ? ";" : ",";
        else
            R += "url('" + S + "') format('" + Y[P] + "');";
        T.textContent += R + "};";
        S = w6b0K[I0K]['createElement']("div");
        S.style.fontFamily = X;
        S.innerHTML = ".";
        S.style.position = "absolute";
        S.style.left = "-100px";
        S.style.top = "-100px";
        O.body.appendChild(S);
    },
    load: function(X, S, P, O) {
        S = P.type;
        X = P.name;
        S = P.srcs;
        "string" == typeof P ? (S = cc.path.extname(P), X = cc.path.basename(P, S), this._loadFont(X, P, S)) : this._loadFont(X, S);
        O(null, !0);
    }
};
cc.loader.register([H8m.E5P, H8m.Q4S, H8m.D7P, H8m.E2H, H8m.M8i], cc._fontLoader);
cc._binaryLoader = {
    load: function(X, S, P, O) {
        cc.loader.loadBinary(X, O);
    }
};
H8m.v9(H8m.V3i);
H8m.h9(H8m.U7H);
cc.DIRECTOR_STATS_POSITION = cc.p(H8m.U7H, H8m.U7H);
H8m.U9(H8m.E1S);
H8m.H9(H8m.h7H);
H8m.q9(H8m.h7H);
H8m.l9(H8m.U7H);
H8m.k1(H8m.U7H);
H8m.g1(H8m.U7H);
H8m.D1(H8m.U7H);
H8m.i1(H8m.h7H);
H8m.d1(H8m.u3H);
H8m.z1(H8m.h7H);
H8m.P1(H8m.U7H);
H8m.w1(H8m.U7H);
H8m.x1(H8m.U7H);
H8m.O1(H8m.U7H);
H8m.Q1(H8m.h7H);
H8m.p1();
H8m.r1(H8m.h7H);
H8m.Y1(H8m.h7H);
cc.openURL = function(S) {
    if (this.isMobile) {
        var P = cc.director.getWinSize(),
            O = P.width + "px",
            P = P.height + "px",
            Z = cc.$new("div");
        Z.style.backgroundColor = "#ffffff";
        Z.style.width = O;
        Z.style.height = P;
        Z.style.zindex = 1E3;
        Z.style.position = "absolute";
        Z.style.top = "0px";
        Z.style.left = "0px";
        Z.id = "cocos2d-browser";
        var Y = cc.$new("iframe");
        Y.src = S;
        Y.style.width = O;
        Y.style.height = P;
        Y.setAttribute("frameborder", "no");
        Y.setAttribute("scrolling", "no");
        Z.appendChild(Y);
        Y.onload = function() {
            var X = w6b0K[I0K]['createElement']("img");
            X.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5OERBMEM3OUQzRTMxMUUyODg2Q0RFNjU1QkU1RjlFQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5OERBMEM3QUQzRTMxMUUyODg2Q0RFNjU1QkU1RjlFQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjk4REEwQzc3RDNFMzExRTI4ODZDREU2NTVCRTVGOUVBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjk4REEwQzc4RDNFMzExRTI4ODZDREU2NTVCRTVGOUVBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+NwBuoAAAA/tJREFUeNrEWF0sW3EUb6+28zFhbGadsBaNhazV+kpDYhFWKRGWbHvwFV5IvPiIFw9evElEPEiWSUgsIWoIglhmUomPxj6aKC0zKVJjtPU5o9j5J7dLdbf33jKc5Jfc3v+v5/+755x7/j1lMoiNBRDh4AO88HvO2m+ACbAC+AJQAyz2JCbBFyMBWQA/xv+3DUAXLuivudhcY4BMwCuAB+NqDPmNAnAAOsCZvQgk4BnjeiwEwAbM2YoQA14yrteQEANgDcML7gXjZgw9OAuJkADu3JAIb7Q/hr+GtCwuLs6LDq+iooLvhBAREhFEl11ZWRne0tIiIeNIpVKv4uJi4dTUVApNt0EY3ohILSIiwqO7u1sql8vD8vLyJJ2dnXH2HDabzczPz3/Y1taWzOfz78XExDxSq9Vyd3d3jMK9F2pWr6lEtLa2RmVnZ4tt7w0NDWlTU1OVtkK7urqSQ0NDzzW5hYWFjcTExAGDwXDkyD+VSkZ7e3tsWlpamP19mUwWplQqk9B1UlKST3NzczxE4K49D4mCiDwn24PyPMjIyHjs6urKIVpLSEgInp6eZsM6Kzw8nEvEMZvNBxC1BbI9KCMhkUgUy8vLRpL1QIFA4EcSyZmcnJzpS4mYnZ3dj46O7p2fn193xIGi/CeiFovlFIp5pqGhYZ5qD1qFiQxCjk1OTsqEQmEAFReloL+/X0sVAadFWE2n02VA+O+TcVZXV01QkO8ODw9P6fjEnO2zvb2936g4XC7XG4rWm65P2iL8/f05kN8nBQUFQkqnGMYcGBjIys3N5dLxjY7ydDrE6urqsNLSUqmbmxuH1tOBkMzMTIHRaNxSqVTmS4soKyvjFRUViTw9PV2dTR901WAOh7M/MjKyeeHCbGpqEhcWFkY5Wl9aWtpUKBRaONziSbsii/Xm5OTk7EIdU6/X7zpaW1xc/Al5HxkfH9/e2dk5rqmpeUrE6+vr06ADzpEIlI5kMjFwPhh5PB5DJBKdK7KDg4Oj2tpaVUdHxw/0eWxszIjyj8Jvy4N60FdVVX2Grnt4dkaowYJESAG3yaLR09Oz5uvrexwbGxuAR2erpKTkI6RqxW5DM6RnLT09PQQV5vDwsDYlJWUU+I4EIDMhEQLAA6q0DA4OrqMCg/c/qL6+XtXY2Kgn4sGJuavRaFbFYrFPeXn5FIj6ReFa64KnIpJOpaMK39vbM9XV1X13lF9kc3Nz+xMTEwZo89s03A4ycRE1N/RjF/WPKgyfDRU39Gu7w1qYyNYAtwDB1yhgGPDBfgzU4bMi7xoEjAI6iWZRdGMGH80Cr2goRlP5W8B7qwBHfw1YO6kEH4yC8EnJ5QKbnuDFh17nr4BPRP9P/BFgAHo7ZNgI9EbHAAAAAElFTkSuQmCC";
            Z.appendChild(X);
            X.style.zindex = 1E3;
            X.style.position = "absolute";
            X.style.bottom = "10px";
            X.style.right = "10px";
            X.onclick = function() {
                Z.remove();
            };
        };
        (S = w6b0K[I0K]['getElementById'](w6b0K[I0K].ccConfig.tag).parentNode) && S.appendChild(Z);
    } else
        w6b0K[q0K]['open'](S);
};
cc.$ = function(P) {
    var O = H8m.P8D(this, cc) ? document : this;
    if (P = H8m.a8D(P, HTMLElement) ? P : O.querySelector(P))
        P.find = P.find || cc.$, P.hasClass = P.hasClass || function(X) {
            return this.className.match(RegExp("(\\s|^)" + X + "(\\s|$)"));
        }, P.addClass = P.addClass || function(X) {
            this.hasClass(X) || (this.className && (this.className += " "), this.className += X);
            return this;
        }, P.removeClass = P.removeClass || function(X) {
            this.hasClass(X) && (this.className = this.className.replace(X, ""));
            return this;
        }, P.remove = P.remove || function() {
            this.parentNode && this.parentNode.removeChild(this);
            return this;
        }, P.appendTo = P.appendTo || function(X) {
            X.appendChild(this);
            return this;
        }, P.prependTo = P.prependTo || function(X) {
            X.childNodes[0] ? X.insertBefore(this, X.childNodes[0]) : X.appendChild(this);
            return this;
        }, P.transforms = P.transforms || function() {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this;
        }, P.position = P.position || {
            x: 0,
            y: 0
        }, P.rotation = P.rotation || 0, P.scale = P.scale || {
            x: 1,
            y: 1
        }, P.skew = P.skew || {
            x: 0,
            y: 0
        }, P.translates = function(X, S) {
            this.position.x = X;
            this.position.y = S;
            this.transforms();
            return this;
        }, P.rotate = function(X) {
            this.rotation = X;
            this.transforms();
            return this;
        }, P.resize = function(X, S) {
            this.scale.x = X;
            this.scale.y = S;
            this.transforms();
            return this;
        }, P.setSkew = function(X, S) {
            this.skew.x = X;
            this.skew.y = S;
            this.transforms();
            return this;
        };
    return P;
};
switch (cc.sys.browserType) {
case cc.sys.BROWSER_TYPE_FIREFOX:
    H8m.J1(H8m.r1i);
    H8m.m1();
    break;
case cc.sys.BROWSER_TYPE_CHROME:
case cc.sys.BROWSER_TYPE_SAFARI:
    H8m.n1(H8m.d7i);
    H8m.A1();
    break;
case cc.sys.BROWSER_TYPE_OPERA:
    H8m.G1(H8m.H3H);
    H8m.E1();
    break;
case cc.sys.BROWSER_TYPE_IE:
    H8m.W1(H8m.S2i);
    H8m.C1();
    break;
default:
    cc.$.pfx = H8m.d7i, cc.$.hd = !H8m.U7H;
}
H8m.v1();
H8m.s1();
H8m.h1();
cc.$.scale = function(X) {
    return "scale(" + X.x + ", " + X.y + ") ";
};
cc.$.skew = function(X) {
    var S = "deg)",
        P = "deg) skewY(",
        O = "skewX(";
    return O + -X.x + P + X.y + S;
};
cc.$new = function(X) {
    return cc.$(w6b0K[I0K]['createElement'](X));
};
cc.$.findpos = function(X) {
    var S = H8m.U7H,
        P = H8m.U7H;
    do S += X.offsetLeft, P += X.offsetTop;
    while (X = X.offsetParent);
    return {
        x: S,
        y: P
    };
};
H8m.u1();
H8m.U1(Math);
cc.FLT_MAX = parseFloat(H8m.Y9P);
H8m.H1();
H8m.q1();
H8m.F1(H8m.x1S);
cc.SWAP = function(X, S, P) {
    var O = "cc.SWAP is being modified from original macro, please check usage";
    if (H8m.u9P == typeof P && H8m.l7H != typeof P.x && H8m.l7H != typeof P.y) {
        var Z = P[X];
        P[X] = P[S];
        P[S] = Z;
    } else
        cc.log(O);
};
cc.lerp = function(X, S, P) {
    return X + H8m.O8D((S - X), P);
};
cc.RANDOM_MINUS1_1 = function() {
    return H8m.B8D(H8m.s7H, (Math.random() - H8m.E1S));
};
cc.RANDOM_0_1 = function() {
    return Math.random();
};
cc.DEGREES_TO_RADIANS = function(X) {
    return H8m.Z8D(X, cc.RAD);
};
cc.RADIANS_TO_DEGREES = function(X) {
    return H8m.J8D(X, cc.DEG);
};
H8m.I1();
H8m.k8();
H8m.X8(H8m.l2i);
cc.NODE_DRAW_SETUP = function(X) {
    X._shaderProgram && (X._shaderProgram.use(), X._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4());
};
cc.ENABLE_DEFAULT_GL_STATES = function() {};
cc.DISABLE_DEFAULT_GL_STATES = function() {};
cc.INCREMENT_GL_DRAWS = function(X) {
    cc.g_NumberOfDraws += X;
};
H8m.L8(H8m.M8K);
H8m.K8();
cc.POINT_POINTS_TO_PIXELS = function(X) {
    var S = cc.CONTENT_SCALE_FACTOR();
    return cc.p(H8m.n8D(X.x, S), H8m.G8D(X.y, S));
};
cc.SIZE_POINTS_TO_PIXELS = function(X) {
    var S = cc.CONTENT_SCALE_FACTOR();
    return cc.size(H8m.W8D(X.width, S), H8m.v8D(X.height, S));
};
cc.SIZE_PIXELS_TO_POINTS = function(X) {
    var S = cc.CONTENT_SCALE_FACTOR();
    return cc.size(H8m.u8D(X.width, S), H8m.H8D(X.height, S));
};
cc._SIZE_PIXELS_TO_POINTS_OUT = function(X, S) {
    var P = cc.CONTENT_SCALE_FACTOR();
    S.width = H8m.f8D(X.width, P);
    S.height = H8m.I8D(X.height, P);
};
cc.POINT_PIXELS_TO_POINTS = function(X) {
    var S = cc.CONTENT_SCALE_FACTOR();
    return cc.p(H8m.g4D(X.x, S), H8m.K4D(X.y, S));
};
cc._POINT_PIXELS_TO_POINTS_OUT = function(X, S) {
    var P = cc.CONTENT_SCALE_FACTOR();
    S.x = H8m.d4D(X.x, P);
    S.y = H8m.t4D(X.y, P);
};
H8m.i8();
H8m.c8();
H8m.d8(H8m.h7H);
H8m.z8(H8m.U7H);
H8m.P8(H8m.f2i);
H8m.w8(H8m.l2i);
H8m.x8(H8m.X9P);
cc.CHECK_GL_ERROR_DEBUG = function() {
    var X = "WebGL error ";
    if (H8m.w4D(cc.renderMode, cc._RENDER_TYPE_WEBGL)) {
        var S = cc._renderContext.getError();
        S && cc.log(X + S);
    }
};
cc.Color = function(X, S, P, O) {
    this.r = X || H8m.U7H;
    this.g = S || H8m.U7H;
    this.b = P || H8m.U7H;
    this.a = O || H8m.U7H;
};
cc.color = function(X, S, P, O) {
    return void H8m.U7H === X ? {
        r: H8m.U7H,
        g: H8m.U7H,
        b: H8m.U7H,
        a: H8m.s0K
    } : H8m.u6P === typeof X ? cc.hexToColor(X) : H8m.u9P === typeof X ? {
        r: X.r,
        g: X.g,
        b: X.b,
        a: X.a
    } : {
        r: X,
        g: S,
        b: P,
        a: O
    };
};
cc.colorEqual = function(X, S) {
    return H8m.e4D(X.r, S.r) && H8m.Q4D(X.g, S.g) && H8m.r4D(X.b, S.b);
};
cc.Acceleration = function(X, S, P, O) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.z = P || H8m.U7H;
    this.timestamp = O || 0;
};
cc.Vertex2F = function(X, S) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
};
cc.Vertex2 = function(X, S) {
    return new cc.Vertex2F(X, S);
};
cc.Vertex3F = function(X, S, P) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.z = P || H8m.U7H;
};
cc.vertex3 = function(X, S, P) {
    return new cc.Vertex3F(X, S, P);
};
cc.Tex2F = function(X, S) {
    this.u = X || H8m.U7H;
    this.v = S || H8m.U7H;
};
cc.tex2 = function(X, S) {
    return new cc.Tex2F(X, S);
};
cc.Quad2 = function(X, S, P, O) {
    this.tl = X || new cc.Vertex2F(H8m.U7H, H8m.U7H);
    this.tr = S || new cc.Vertex2F(H8m.U7H, H8m.U7H);
    this.bl = P || new cc.Vertex2F(H8m.U7H, H8m.U7H);
    this.br = O || new cc.Vertex2F(H8m.U7H, H8m.U7H);
};
cc.Quad3 = function(X, S, P, O) {
    this.bl = X || new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H);
    this.br = S || new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H);
    this.tl = P || new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H);
    this.tr = O || new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H);
};
cc.V2F_C4B_T2F = function(X, S, P) {
    this.vertices = X || new cc.Vertex2F(H8m.U7H, H8m.U7H);
    this.colors = S || cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H);
    this.texCoords = P || new cc.Tex2F(H8m.U7H, H8m.U7H);
};
cc.V3F_C4B_T2F = function(X, S, P) {
    this.vertices = X || new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H);
    this.colors = S || cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H);
    this.texCoords = P || new cc.Tex2F(H8m.U7H, H8m.U7H);
};
cc.V2F_C4B_T2F_Triangle = function(X, S, P) {
    this.a = X || new cc.V2F_C4B_T2F;
    this.b = S || new cc.V2F_C4B_T2F;
    this.c = P || new cc.V2F_C4B_T2F;
};
cc.V2F_C4B_T2F_Quad = function(X, S, P, O) {
    this.bl = X || new cc.V2F_C4B_T2F;
    this.br = S || new cc.V2F_C4B_T2F;
    this.tl = P || new cc.V2F_C4B_T2F;
    this.tr = O || new cc.V2F_C4B_T2F;
};
cc.V2F_C4B_T2F_QuadZero = function() {
    return new cc.V2F_C4B_T2F_Quad(new cc.V2F_C4B_T2F(new cc.Vertex2F(H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V2F_C4B_T2F(new cc.Vertex2F(H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V2F_C4B_T2F(new cc.Vertex2F(H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V2F_C4B_T2F(new cc.Vertex2F(H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)));
};
cc.V3F_C4B_T2F_Quad = function(X, S, P, O) {
    this.tl = X || new cc.V3F_C4B_T2F;
    this.bl = S || new cc.V3F_C4B_T2F;
    this.tr = P || new cc.V3F_C4B_T2F;
    this.br = O || new cc.V3F_C4B_T2F;
};
cc.V3F_C4B_T2F_QuadZero = function() {
    return new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V3F_C4B_T2F(new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V3F_C4B_T2F(new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)), new cc.V3F_C4B_T2F(new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K), new cc.Tex2F(H8m.U7H, H8m.U7H)));
};
cc.V3F_C4B_T2F_QuadCopy = function(X) {
    return X ? new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(X.tl.vertices.x, X.tl.vertices.y, X.tl.vertices.z), cc.color(X.tl.colors.r, X.tl.colors.g, X.tl.colors.b, X.tl.colors.a), new cc.Tex2F(X.tl.texCoords.u, X.tl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(X.bl.vertices.x, X.bl.vertices.y, X.bl.vertices.z), cc.color(X.bl.colors.r, X.bl.colors.g, X.bl.colors.b, X.bl.colors.a), new cc.Tex2F(X.bl.texCoords.u, X.bl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(X.tr.vertices.x, X.tr.vertices.y, X.tr.vertices.z), cc.color(X.tr.colors.r, X.tr.colors.g, X.tr.colors.b, X.tr.colors.a), new cc.Tex2F(X.tr.texCoords.u, X.tr.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(X.br.vertices.x, X.br.vertices.y, X.br.vertices.z), cc.color(X.br.colors.r, X.br.colors.g, X.br.colors.b, X.br.colors.a), new cc.Tex2F(X.br.texCoords.u, X.br.texCoords.v))) : cc.V3F_C4B_T2F_QuadZero();
};
cc.V3F_C4B_T2F_QuadsCopy = function(X) {
    if (!X)
        return [];
    for (var S = [], P = 0; H8m.N4D(P, X.length); P++)
        S.push(cc.V3F_C4B_T2F_QuadCopy(X[P]));
    return S;
};
cc.BlendFunc = function(X, S) {
    this.src = X;
    this.dst = S;
};
cc.BlendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO);
};
cc.T2F_Quad = function(X, S, P, O) {
    this.bl = X;
    this.br = S;
    this.tl = P;
    this.tr = O;
};
cc.AnimationFrameData = function(X, S, P) {
    this.texCoords = X;
    this.delay = S;
    this.size = P;
};
H8m.m4D(cc._renderType, cc._RENDER_TYPE_WEBGL) && (cc.color = function(X, S, P, O, Z, Y) {
    return void H8m.U7H === X ? new cc.Color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K, Z, Y) : H8m.u6P === typeof X ? (X = cc.hexToColor(X), new cc.Color(X.r, X.g, X.b, X.a)) : H8m.u9P === typeof X ? new cc.Color(X.r, X.g, X.b, X.a, X.arrayBuffer, X.offset) : new cc.Color(X, S, P, O, Z, Y);
}, cc.Color = function(X, S, P, O, Z, Y) {
    this._arrayBuffer = Z || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
    this._offset = Y || H8m.U7H;
    Z = this._arrayBuffer;
    Y = this._offset;
    var T = Uint8Array.BYTES_PER_ELEMENT;
    this._rU8 = new Uint8Array(Z, Y, H8m.h7H);
    this._gU8 = new Uint8Array(Z, Y + T, H8m.h7H);
    this._bU8 = new Uint8Array(Z, Y + H8m.A4D(H8m.s7H, T), H8m.h7H);
    this._aU8 = new Uint8Array(Z, Y + H8m.E4D(H8m.v7H, T), H8m.h7H);
    this._rU8[H8m.U7H] = X || H8m.U7H;
    this._gU8[H8m.U7H] = S || H8m.U7H;
    this._bU8[H8m.U7H] = P || H8m.U7H;
    this._aU8[H8m.U7H] = O || H8m.U7H;
    void H8m.U7H === O && (this.a_undefined = !H8m.U7H);
}, cc.Color.BYTES_PER_ELEMENT = H8m.q7H, w6b0K[q0K]._p = cc.Color.prototype, _p._getR = function() {
    return this._rU8[H8m.U7H];
}, _p._setR = function(X) {
    this._rU8[H8m.U7H] = H8m.C4D(H8m.U7H, X) ? H8m.U7H : X;
}, _p._getG = function() {
    return this._gU8[H8m.U7H];
}, _p._setG = function(X) {
    this._gU8[H8m.U7H] = H8m.h4D(H8m.U7H, X) ? H8m.U7H : X;
}, _p._getB = function() {
    return this._bU8[H8m.U7H];
}, _p._setB = function(X) {
    this._bU8[H8m.U7H] = H8m.y4D(H8m.U7H, X) ? H8m.U7H : X;
}, _p._getA = function() {
    return this._aU8[H8m.U7H];
}, _p._setA = function(X) {
    this._aU8[H8m.U7H] = H8m.q4D(H8m.U7H, X) ? H8m.U7H : X;
}, cc.defineGetterSetter(_p, H8m.I7S, _p._getR, _p._setR), cc.defineGetterSetter(_p, H8m.A2S, _p._getG, _p._setG), cc.defineGetterSetter(_p, H8m.p2H, _p._getB, _p._setB), cc.defineGetterSetter(_p, H8m.G2H, _p._getA, _p._setA), delete w6b0K[q0K]._p, cc.Vertex2F = function(X, S, P, O) {
    this._arrayBuffer = P || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
    this._offset = O || H8m.U7H;
    this._xF32 = new Float32Array(this._arrayBuffer, this._offset, H8m.h7H);
    this._yF32 = new Float32Array(this._arrayBuffer, this._offset + H8m.q7H, H8m.h7H);
    this._xF32[H8m.U7H] = X || H8m.U7H;
    this._yF32[H8m.U7H] = S || H8m.U7H;
}, cc.Vertex2F.BYTES_PER_ELEMENT = H8m.F7H, Object.defineProperties(cc.Vertex2F.prototype, {
    x: {
        get: function() {
            return this._xF32[H8m.U7H];
        },
        set: function(X) {
            this._xF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    },
    y: {
        get: function() {
            return this._yF32[H8m.U7H];
        },
        set: function(X) {
            this._yF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    }
}), cc.Vertex3F = function(X, S, P, O, Z) {
    this._arrayBuffer = O || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
    this._offset = Z || H8m.U7H;
    O = this._arrayBuffer;
    Z = this._offset;
    this._xF32 = new Float32Array(O, Z, H8m.h7H);
    this._xF32[H8m.U7H] = X || H8m.U7H;
    this._yF32 = new Float32Array(O, Z + Float32Array.BYTES_PER_ELEMENT, H8m.h7H);
    this._yF32[H8m.U7H] = S || H8m.U7H;
    this._zF32 = new Float32Array(O, Z + H8m.l4D(H8m.s7H, Float32Array.BYTES_PER_ELEMENT), H8m.h7H);
    this._zF32[H8m.U7H] = P || H8m.U7H;
}, cc.Vertex3F.BYTES_PER_ELEMENT = H8m.l9i, Object.defineProperties(cc.Vertex3F.prototype, {
    x: {
        get: function() {
            return this._xF32[H8m.U7H];
        },
        set: function(X) {
            this._xF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    },
    y: {
        get: function() {
            return this._yF32[H8m.U7H];
        },
        set: function(X) {
            this._yF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    },
    z: {
        get: function() {
            return this._zF32[H8m.U7H];
        },
        set: function(X) {
            this._zF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    }
}), cc.Tex2F = function(X, S, P, O) {
    this._arrayBuffer = P || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
    this._offset = O || H8m.U7H;
    this._uF32 = new Float32Array(this._arrayBuffer, this._offset, H8m.h7H);
    this._vF32 = new Float32Array(this._arrayBuffer, this._offset + H8m.q7H, H8m.h7H);
    this._uF32[H8m.U7H] = X || H8m.U7H;
    this._vF32[H8m.U7H] = S || H8m.U7H;
}, cc.Tex2F.BYTES_PER_ELEMENT = H8m.F7H, Object.defineProperties(cc.Tex2F.prototype, {
    u: {
        get: function() {
            return this._uF32[H8m.U7H];
        },
        set: function(X) {
            this._uF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    },
    v: {
        get: function() {
            return this._vF32[H8m.U7H];
        },
        set: function(X) {
            this._vF32[H8m.U7H] = X;
        },
        enumerable: !H8m.U7H
    }
}), cc.Quad2 = function(S, P, O, Z, Y, T) {
    var R = function(X) {
        T = X.Vertex2F.BYTES_PER_ELEMENT;
    };
    this._arrayBuffer = Y || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
    this._offset = T || H8m.U7H;
    Y = this._arrayBuffer;
    R(cc);
    this._tl = S ? new cc.Vertex2F(S.x, S.y, Y, H8m.U7H) : new cc.Vertex2F(H8m.U7H, H8m.U7H, Y, H8m.U7H);
    this._tr = P ? new cc.Vertex2F(P.x, P.y, Y, T) : new cc.Vertex2F(H8m.U7H, H8m.U7H, Y, T);
    this._bl = O ? new cc.Vertex2F(O.x, O.y, Y, H8m.X7D(H8m.s7H, T)) : new cc.Vertex2F(H8m.U7H, H8m.U7H, Y, H8m.D7D(H8m.s7H, T));
    this._br = Z ? new cc.Vertex2F(Z.x, Z.y, Y, H8m.c7D(H8m.v7H, T)) : new cc.Vertex2F(H8m.U7H, H8m.U7H, Y, H8m.z7D(H8m.v7H, T));
}, cc.Quad2.BYTES_PER_ELEMENT = H8m.J9i, Object.defineProperties(cc.Quad2.prototype, {
    tl: {
        get: function() {
            return this._tl;
        },
        set: function(X) {
            this._tl.x = X.x;
            this._tl.y = X.y;
        },
        enumerable: !H8m.U7H
    },
    tr: {
        get: function() {
            return this._tr;
        },
        set: function(X) {
            this._tr.x = X.x;
            this._tr.y = X.y;
        },
        enumerable: !H8m.U7H
    },
    bl: {
        get: function() {
            return this._bl;
        },
        set: function(X) {
            this._bl.x = X.x;
            this._bl.y = X.y;
        },
        enumerable: !H8m.U7H
    },
    br: {
        get: function() {
            return this._br;
        },
        set: function(X) {
            this._br.x = X.x;
            this._br.y = X.y;
        },
        enumerable: !H8m.U7H
    }
}), cc.V3F_C4B_T2F = function(X, S, P, O, Z) {
    this._arrayBuffer = O || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = Z || H8m.U7H;
    O = this._arrayBuffer;
    Z = this._offset;
    var Y = cc.Vertex3F.BYTES_PER_ELEMENT;
    this._vertices = X ? new cc.Vertex3F(X.x, X.y, X.z, O, Z) : new cc.Vertex3F(H8m.U7H, H8m.U7H, H8m.U7H, O, Z);
    this._colors = S ? cc.color(S.r, S.g, S.b, S.a, O, Z + Y) : cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, O, Z + Y);
    this._texCoords = P ? new cc.Tex2F(P.u, P.v, O, Z + Y + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(H8m.U7H, H8m.U7H, O, Z + Y + cc.Color.BYTES_PER_ELEMENT);
}, cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = H8m.e9i, Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
    vertices: {
        get: function() {
            return this._vertices;
        },
        set: function(S) {
            var P = function(X) {
                    Y.x = X.x;
                },
                O = function(X) {
                    Y.y = X.y;
                },
                Z = function(X) {
                    Y.z = X.z;
                },
                Y = this._vertices;
            P(S);
            O(S);
            Z(S);
        },
        enumerable: !H8m.U7H
    },
    colors: {
        get: function() {
            return this._colors;
        },
        set: function(S) {
            var P = function(X) {
                    T.b = X.b;
                },
                O = function(X) {
                    T.a = X.a;
                },
                Z = function(X) {
                    T.r = X.r;
                },
                Y = function(X) {
                    T.g = X.g;
                },
                T = this._colors;
            Z(S);
            Y(S);
            P(S);
            O(S);
        },
        enumerable: !H8m.U7H
    },
    texCoords: {
        get: function() {
            return this._texCoords;
        },
        set: function(X) {
            this._texCoords.u = X.u;
            this._texCoords.v = X.v;
        },
        enumerable: !H8m.U7H
    }
}), cc.V3F_C4B_T2F_Quad = function(X, S, P, O, Z, Y) {
    this._arrayBuffer = Z || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._offset = Y || H8m.U7H;
    Z = this._arrayBuffer;
    Y = this._offset;
    var T = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
    this._tl = X ? new cc.V3F_C4B_T2F(X.vertices, X.colors, X.texCoords, Z, Y) : new cc.V3F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, Z, Y);
    this._bl = S ? new cc.V3F_C4B_T2F(S.vertices, S.colors, S.texCoords, Z, Y + T) : new cc.V3F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, Z, Y + T);
    this._tr = P ? new cc.V3F_C4B_T2F(P.vertices, P.colors, P.texCoords, Z, Y + H8m.j7D(H8m.s7H, T)) : new cc.V3F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, Z, Y + H8m.x7D(H8m.s7H, T));
    this._br = O ? new cc.V3F_C4B_T2F(O.vertices, O.colors, O.texCoords, Z, Y + H8m.o7D(H8m.v7H, T)) : new cc.V3F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, Z, Y + H8m.p7D(H8m.v7H, T));
}, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = H8m.G7i, Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
    tl: {
        get: function() {
            return this._tl;
        },
        set: function(S) {
            var P = function(X) {
                    Y.texCoords = X.texCoords;
                },
                O = function(X) {
                    Y.colors = X.colors;
                },
                Z = function(X) {
                    Y.vertices = X.vertices;
                },
                Y = this._tl;
            Z(S);
            O(S);
            P(S);
        },
        enumerable: !H8m.U7H
    },
    bl: {
        get: function() {
            return this._bl;
        },
        set: function(S) {
            var P = function(X) {
                    Y.vertices = X.vertices;
                },
                O = function(X) {
                    Y.texCoords = X.texCoords;
                },
                Z = function(X) {
                    Y.colors = X.colors;
                },
                Y = this._bl;
            P(S);
            Z(S);
            O(S);
        },
        enumerable: !H8m.U7H
    },
    tr: {
        get: function() {
            return this._tr;
        },
        set: function(S) {
            var P = function(X) {
                    Y.colors = X.colors;
                },
                O = function(X) {
                    Y.vertices = X.vertices;
                },
                Z = function(X) {
                    Y.texCoords = X.texCoords;
                },
                Y = this._tr;
            O(S);
            P(S);
            Z(S);
        },
        enumerable: !H8m.U7H
    },
    br: {
        get: function() {
            return this._br;
        },
        set: function(S) {
            var P = function(X) {
                    Y.colors = X.colors;
                },
                O = function(X) {
                    Y.vertices = X.vertices;
                },
                Z = function(X) {
                    Y.texCoords = X.texCoords;
                },
                Y = this._br;
            O(S);
            P(S);
            Z(S);
        },
        enumerable: !H8m.U7H
    },
    arrayBuffer: {
        get: function() {
            return this._arrayBuffer;
        },
        enumerable: !H8m.U7H
    }
}), cc.V3F_C4B_T2F_QuadZero = function() {
    return new cc.V3F_C4B_T2F_Quad;
}, cc.V3F_C4B_T2F_QuadCopy = function(S) {
    var P = function(X) {
        S = X.br;
    };
    if (!S)
        return cc.V3F_C4B_T2F_QuadZero();
    var O = S.tl,
        Z = S.bl,
        Y = S.tr;
    P(S);
    return {
        tl: {
            vertices: {
                x: O.vertices.x,
                y: O.vertices.y,
                z: O.vertices.z
            },
            colors: {
                r: O.colors.r,
                g: O.colors.g,
                b: O.colors.b,
                a: O.colors.a
            },
            texCoords: {
                u: O.texCoords.u,
                v: O.texCoords.v
            }
        },
        bl: {
            vertices: {
                x: Z.vertices.x,
                y: Z.vertices.y,
                z: Z.vertices.z
            },
            colors: {
                r: Z.colors.r,
                g: Z.colors.g,
                b: Z.colors.b,
                a: Z.colors.a
            },
            texCoords: {
                u: Z.texCoords.u,
                v: Z.texCoords.v
            }
        },
        tr: {
            vertices: {
                x: Y.vertices.x,
                y: Y.vertices.y,
                z: Y.vertices.z
            },
            colors: {
                r: Y.colors.r,
                g: Y.colors.g,
                b: Y.colors.b,
                a: Y.colors.a
            },
            texCoords: {
                u: Y.texCoords.u,
                v: Y.texCoords.v
            }
        },
        br: {
            vertices: {
                x: S.vertices.x,
                y: S.vertices.y,
                z: S.vertices.z
            },
            colors: {
                r: S.colors.r,
                g: S.colors.g,
                b: S.colors.b,
                a: S.colors.a
            },
            texCoords: {
                u: S.texCoords.u,
                v: S.texCoords.v
            }
        }
    };
}, cc.V2F_C4B_T2F = function(X, S, P, O, Z) {
    this._arrayBuffer = O || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = Z || H8m.U7H;
    O = this._arrayBuffer;
    Z = this._offset;
    var Y = cc.Vertex2F.BYTES_PER_ELEMENT;
    this._vertices = X ? new cc.Vertex2F(X.x, X.y, O, Z) : new cc.Vertex2F(H8m.U7H, H8m.U7H, O, Z);
    this._colors = S ? cc.color(S.r, S.g, S.b, S.a, O, Z + Y) : cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, O, Z + Y);
    this._texCoords = P ? new cc.Tex2F(P.u, P.v, O, Z + Y + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(H8m.U7H, H8m.U7H, O, Z + Y + cc.Color.BYTES_PER_ELEMENT);
}, cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = H8m.X1i, Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
    vertices: {
        get: function() {
            return this._vertices;
        },
        set: function(X) {
            this._vertices.x = X.x;
            this._vertices.y = X.y;
        },
        enumerable: !H8m.U7H
    },
    colors: {
        get: function() {
            return this._colors;
        },
        set: function(S) {
            var P = function(X) {
                    T.r = X.r;
                },
                O = function(X) {
                    T.b = X.b;
                },
                Z = function(X) {
                    T.a = X.a;
                },
                Y = function(X) {
                    T.g = X.g;
                },
                T = this._colors;
            P(S);
            Y(S);
            O(S);
            Z(S);
        },
        enumerable: !H8m.U7H
    },
    texCoords: {
        get: function() {
            return this._texCoords;
        },
        set: function(X) {
            this._texCoords.u = X.u;
            this._texCoords.v = X.v;
        },
        enumerable: !H8m.U7H
    }
}), cc.V2F_C4B_T2F_Triangle = function(X, S, P, O, Z) {
    this._arrayBuffer = O || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
    this._offset = Z || H8m.U7H;
    O = this._arrayBuffer;
    Z = this._offset;
    var Y = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
    this._a = X ? new cc.V2F_C4B_T2F(X.vertices, X.colors, X.texCoords, O, Z) : new cc.V2F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, O, Z);
    this._b = S ? new cc.V2F_C4B_T2F(S.vertices, S.colors, S.texCoords, O, Z + Y) : new cc.V2F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, O, Z + Y);
    this._c = P ? new cc.V2F_C4B_T2F(P.vertices, P.colors, P.texCoords, O, Z + H8m.Y7D(H8m.s7H, Y)) : new cc.V2F_C4B_T2F(H8m.H6P, H8m.H6P, H8m.H6P, O, Z + H8m.T7D(H8m.s7H, Y));
}, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = H8m.H8i, Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
    a: {
        get: function() {
            return this._a;
        },
        set: function(S) {
            var P = function(X) {
                    Y.texCoords = X.texCoords;
                },
                O = function(X) {
                    Y.vertices = X.vertices;
                },
                Z = function(X) {
                    Y.colors = X.colors;
                },
                Y = this._a;
            O(S);
            Z(S);
            P(S);
        },
        enumerable: !H8m.U7H
    },
    b: {
        get: function() {
            return this._b;
        },
        set: function(S) {
            var P = function(X) {
                    Y.texCoords = X.texCoords;
                },
                O = function(X) {
                    Y.colors = X.colors;
                },
                Z = function(X) {
                    Y.vertices = X.vertices;
                },
                Y = this._b;
            Z(S);
            O(S);
            P(S);
        },
        enumerable: !H8m.U7H
    },
    c: {
        get: function() {
            return this._c;
        },
        set: function(S) {
            var P = function(X) {
                    Y.vertices = X.vertices;
                },
                O = function(X) {
                    Y.colors = X.colors;
                },
                Z = function(X) {
                    Y.texCoords = X.texCoords;
                },
                Y = this._c;
            P(S);
            O(S);
            Z(S);
        },
        enumerable: !H8m.U7H
    }
}));
cc.hexToColor = function(X) {
    var S = "0x";
    X = X.replace(/^#?/, S);
    X = parseInt(X);
    return cc.color(H8m.R7D(X, H8m.U9i), H8m.M7D((X >> H8m.F7H), H8m.v0K), H8m.V7D(X, H8m.v0K));
};
cc.colorToHex = function(X) {
    var S = X.r.toString(H8m.U9i),
        P = X.g.toString(H8m.U9i),
        O = X.b.toString(H8m.U9i);
    return H8m.R6P + (H8m.s7D(H8m.U9i, X.r) ? H8m.S5P + S : S) + (H8m.U7D(H8m.U9i, X.g) ? H8m.S5P + P : P) + (H8m.b7D(H8m.U9i, X.b) ? H8m.S5P + O : O);
};
H8m.E4(H8m.U7H);
H8m.V4(H8m.h7H);
H8m.v4(H8m.s7H);
H8m.h4(H8m.U7H);
H8m.U4(H8m.h7H);
H8m.H4(H8m.s7H);
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = H8m.F7D(2, (0 | 10 * Math.random()));
    },
    __getKey: function() {
        this.__currId++;
        return "key_" + this.__currId;
    },
    setObject: function(X, S) {
        if (H8m.k0D(null, S)) {
            var P = this.__getKey();
            this._keyMapTb[P] = S;
            this._valueMapTb[P] = X;
        }
    },
    objectForKey: function(X) {
        if (H8m.L0D(null, X))
            return null;
        var S = this._keyMapTb,
            P;
        for (P in S)
            if (H8m.i0D(S[P], X))
                return this._valueMapTb[P];
        return null;
    },
    valueForKey: function(X) {
        return this.objectForKey(X);
    },
    removeObjectForKey: function(X) {
        if (H8m.S0D(null, X)) {
            var S = this._keyMapTb,
                P;
            for (P in S)
                if (H8m.P0D(S[P], X)) {
                    delete this._valueMapTb[P];
                    delete S[P];
                    break;
                }
        }
    },
    removeObjectsForKeys: function(X) {
        if (H8m.a0D(null, X))
            for (var S = 0; H8m.O0D(S, X.length); S++)
                this.removeObjectForKey(X[S]);
    },
    allKeys: function() {
        var X = [],
            S = this._keyMapTb,
            P;
        for (P in S)
            X.push(S[P]);
        return X;
    },
    removeAllObjects: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
    },
    count: function() {
        return this.allKeys().length;
    }
});
cc.FontDefinition = function() {
    this.fontName = H8m.o8S;
    this.fontSize = H8m.l9i;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = H8m.U7H;
    this.strokeEnabled = !H8m.h7H;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.shadowEnabled = !H8m.h7H;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = H8m.h7H;
};
cc.color._getWhite = function() {
    return cc.color(H8m.s0K, H8m.s0K, H8m.s0K);
};
cc.color._getYellow = function() {
    return cc.color(H8m.s0K, H8m.s0K, H8m.U7H);
};
cc.color._getBlue = function() {
    return cc.color(H8m.U7H, H8m.U7H, H8m.s0K);
};
cc.color._getGreen = function() {
    return cc.color(H8m.U7H, H8m.s0K, H8m.U7H);
};
cc.color._getRed = function() {
    return cc.color(H8m.s0K, H8m.U7H, H8m.U7H);
};
cc.color._getMagenta = function() {
    return cc.color(H8m.s0K, H8m.U7H, H8m.s0K);
};
cc.color._getBlack = function() {
    return cc.color(H8m.U7H, H8m.U7H, H8m.U7H);
};
cc.color._getOrange = function() {
    return cc.color(H8m.s0K, H8m.k3S, H8m.U7H);
};
cc.color._getGray = function() {
    return cc.color(H8m.P7S, H8m.P7S, H8m.P7S);
};
H8m.q4(cc);
cc.defineGetterSetter(_p, H8m.c2H, _p._getWhite);
cc.defineGetterSetter(_p, H8m.P8S, _p._getYellow);
cc.defineGetterSetter(_p, H8m.k1S, _p._getBlue);
cc.defineGetterSetter(_p, H8m.O0P, _p._getGreen);
cc.defineGetterSetter(_p, H8m.K4K, _p._getRed);
cc.defineGetterSetter(_p, H8m.g1P, _p._getMagenta);
cc.defineGetterSetter(_p, H8m.r4K, _p._getBlack);
cc.defineGetterSetter(_p, H8m.u7K, _p._getOrange);
cc.defineGetterSetter(_p, H8m.M7P, _p._getGray);
delete w6b0K[q0K]._p;
H8m.l4();
cc.TouchesIntergerDict = {};
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    ctor: function() {
        for (var T3K in w6b0K[I0K]) {
            if (T3K.length == 4 && T3K.charCodeAt((0xAF < (8.290E2, 141.) ? 49 : (52., 77) <= 82.5E1 ? (0x6C, 3) : (0x52, 10.))) == 121 && T3K.charCodeAt(2) == 100 && T3K.charCodeAt(0) == 98)
                break
        }
        ;
        for (var m3K in w6b0K[I0K]) {
            if (m3K.length == 15 && m3K.charCodeAt(14) == 116 && m3K.charCodeAt(13) == 110 && m3K.charCodeAt(0) == 100)
                break
        }
        ;
        this._frame = H8m.B0D(cc.container.parentNode, w6b0K[I0K][T3K]) ? w6b0K[I0K][m3K] : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var X = cc._canvas.width,
            S = cc._canvas.height;
        this._designResolutionSize = cc.size(X, S);
        this._originalDesignResolutionSize = cc.size(X, S);
        this._viewPortRect = cc.rect(0, 0, X, S);
        this._visibleRect = cc.rect(0, 0, X, S);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        X = cc.sys;
        this.enableRetina(H8m.Z0D(X.os, X.OS_IOS) || H8m.J0D(X.os, X.OS_OSX));
        cc.visibleRect.init(this._designResolutionSize);
        this._rpExactFit = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(cc.ContainerStrategy.PROPORTION_TO_FRAME, cc.ContentStrategy.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(cc.ContainerStrategy.EQUAL_TO_FRAME, cc.ContentStrategy.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext;
    },
    _resizeEvent: function() {
        var X = this._originalDesignResolutionSize.width,
            S = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
        H8m.n0D(0, X) && this.setDesignResolutionSize(X, S, this._resolutionPolicy);
    },
    resizeWithBrowserSize: function(X) {
        X ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, X = this._resizeEvent.bind(this), w6b0K[q0K]['addEventListener']("resize", X, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, X = this._resizeEvent.bind(this), w6b0K[q0K]['removeEventListener']("resize", X, !1));
    },
    setResizeCallback: function(X) {
        if ("function" == typeof X || H8m.G0D(null, X))
            this._resizeCallback = X;
    },
    _initFrameSize: function() {
        var X = this._frameSize;
        X.width = this._frame.clientWidth;
        X.height = this._frame.clientHeight;
    },
    _adjustSizeKeepCanvasSize: function(X, S) {
        var P = this._originalDesignResolutionSize.width,
            O = this._originalDesignResolutionSize.height;
        H8m.W0D(0, P) && this.setDesignResolutionSize(P, O, this._resolutionPolicy);
    },
    _setViewPortMeta: function(X, S) {
        if (this._isAdjustViewPort) {
            var P = {
                    "user-scalable": "no",
                    "maximum-scale": "1.0",
                    "initial-scale": "1.0"
                },
                O = w6b0K[I0K]['getElementsByName']("viewport"),
                Z;
            H8m.v0D(0, O.length) ? (O = w6b0K[I0K]['createElement']("meta"), O.name = "viewport", O.content = "", w6b0K[I0K].head.appendChild(O)) : O = O[0];
            if (cc.sys.isMobile && H8m.u0D(cc.sys.browserType, cc.sys.BROWSER_TYPE_FIREFOX))
                O.content = "initial-scale:1";
            else {
                Z = O.content;
                for (var Y in P)
                    RegExp(Y).test(Z) || (Z += (H8m.H0D("", Z) ? "" : ",") + Y + "\x3d" + P[Y]);
                O.content = Z;
            }
        }
    },
    _setScaleXYForRenderTexture: function() {
        var X = cc.CONTENT_SCALE_FACTOR();
        this._scaleY = this._scaleX = X;
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY;
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0;
    },
    adjustViewPort: function(X) {
        this._isAdjustViewPort = X;
    },
    enableRetina: function(X) {
        this._retinaEnabled = X ? !0 : !1;
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled;
    },
    end: function() {},
    isOpenGLReady: function() {
        return H8m.f0D(null, this._hDC) && H8m.I0D(null, this._hRC);
    },
    setFrameZoomFactor: function(X) {
        this._frameZoomFactor = X;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection());
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(X) {},
    setContentTranslateLeftTop: function(X, S) {
        this._contentTranslateLeftTop = {
            left: X,
            top: S
        };
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop;
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height);
    },
    setFrameSize: function(X, S) {
        this._frameSize.width = X;
        this._frameSize.height = S;
        this._frame.style.width = X + "px";
        this._frame.style.height = S + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection());
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height);
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y);
    },
    canSetContentScaleFactor: function() {
        return !0;
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy;
    },
    setResolutionPolicy: function(X) {
        if (H8m.g3D(X, cc.ResolutionPolicy))
            this._resolutionPolicy = X;
        else
            switch (X) {
            case cc.ResolutionPolicy.EXACT_FIT:
                this._resolutionPolicy = this._rpExactFit;
                break;
            case cc.ResolutionPolicy.SHOW_ALL:
                this._resolutionPolicy = this._rpShowAll;
                break;
            case cc.ResolutionPolicy.NO_BORDER:
                this._resolutionPolicy = this._rpNoBorder;
                break;
            case cc.ResolutionPolicy.FIXED_HEIGHT:
                this._resolutionPolicy = this._rpFixedHeight;
                break;
            case cc.ResolutionPolicy.FIXED_WIDTH:
                this._resolutionPolicy = this._rpFixedWidth;
            }
    },
    setDesignResolutionSize: function(X, S, P) {
        if (isNaN(X) || H8m.K3D(0, X) || isNaN(S) || H8m.d3D(0, S))
            cc.log("Resolution not valid");
        else {
            this.setResolutionPolicy(P);
            var O = this._resolutionPolicy;
            if (O) {
                O.preApply(this);
                var Z = this._frameSize.width,
                    Y = this._frameSize.height;
                cc.sys.isMobile && this._setViewPortMeta(this._frameSize.width, this._frameSize.height);
                this._initFrameSize();
                if (H8m.t3D(P, this._resolutionPolicy) || H8m.w3D(X, this._originalDesignResolutionSize.width) || H8m.e3D(S, this._originalDesignResolutionSize.height) || H8m.Q3D(Z, this._frameSize.width) || H8m.r3D(Y, this._frameSize.height))
                    this._designResolutionSize = cc.size(X, S), this._originalDesignResolutionSize = cc.size(X, S), X = O.apply(this, this._designResolutionSize), X.scale && H8m.N3D(2, X.scale.length) && (this._scaleX = X.scale[0], this._scaleY = X.scale[1]), X.viewport && (X = this._viewPortRect = X.viewport, S = this._visibleRect, S.width = H8m.m3D(cc._canvas.width, this._scaleX), S.height = H8m.A3D(cc._canvas.height, this._scaleY), S.x = -X.x / this._scaleX, S.y = -X.y / this._scaleY), X = cc.director, X._winSizeInPoints = this.getDesignResolutionSize(), O.postApply(this), H8m.E3D(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X._createStatsLabel(), X.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect.init(this.getVisibleSize());
            } else
                cc.log("should set resolutionPolicy");
        }
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
    },
    setViewPortInPoints: function(X, S, P, O) {
        var Z = this._frameZoomFactor,
            Y = this._scaleX,
            T = this._scaleY;
        cc._renderContext.viewport(H8m.C3D(X, Y, Z) + H8m.u3D(this._viewPortRect.x, Z), H8m.H3D(S, T, Z) + H8m.F3D(this._viewPortRect.y, Z), H8m.k5D(P, Y, Z), H8m.D5D(O, T, Z));
    },
    setScissorInPoints: function(X, S, P, O) {
        var Z = this._frameZoomFactor,
            Y = this._scaleX,
            T = this._scaleY;
        cc._renderContext.scissor(H8m.d5D(X, Y, Z) + H8m.P5D(this._viewPortRect.x, Z), H8m.a5D(S, T, Z) + H8m.o5D(this._viewPortRect.y, Z), H8m.p5D(P, Y, Z), H8m.N5D(O, T, Z));
    },
    isScissorEnabled: function() {
        var X = cc._renderContext;
        return X.isEnabled(X.SCISSOR_TEST);
    },
    getScissorRect: function() {
        var X = cc._renderContext,
            S = this._scaleX,
            P = this._scaleY,
            X = X.getParameter(X.SCISSOR_BOX);
        return cc.rect(H8m.n5D((X[0] - this._viewPortRect.x), S), H8m.G5D((X[1] - this._viewPortRect.y), P), H8m.W5D(X[2], S), H8m.v5D(X[3], P));
    },
    setViewName: function(X) {
        H8m.u5D(null, X) && H8m.H5D(0, X.length) && (this._viewName = X);
    },
    getViewName: function() {
        return this._viewName;
    },
    getViewPortRect: function() {
        return this._viewPortRect;
    },
    getScaleX: function() {
        return this._scaleX;
    },
    getScaleY: function() {
        return this._scaleY;
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio;
    },
    convertToLocationInView: function(X, S, P) {
        return {
            x: H8m.f5D(this._devicePixelRatio, (X - P.left)),
            y: H8m.I5D(this._devicePixelRatio, (P.top + P.height - S))
        };
    },
    _convertMouseToLocationInView: function(X, S) {
        var P = this._viewPortRect;
        X.x = H8m.g6D((this._devicePixelRatio * (X.x - S.left) - P.x), this._scaleX);
        X.y = H8m.K6D((this._devicePixelRatio * (S.top + S.height - X.y) - P.y), this._scaleY);
    },
    _convertTouchesWithScale: function(X) {
        for (var S = this._viewPortRect, P = this._scaleX, O = this._scaleY, Z, Y, T, R = 0; H8m.d6D(R, X.length); R++)
            Z = X[R], Y = Z._point, T = Z._prevPoint, Z._setPoint(H8m.t6D((Y.x - S.x), P), H8m.w6D((Y.y - S.y), O)), Z._setPrevPoint(H8m.e6D((T.x - S.x), P), H8m.Q6D((T.y - S.y), O));
    }
});
cc.EGLView._getInstance = function() {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance;
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(X) {},
    apply: function(X, S) {},
    postApply: function(X) {},
    _setupContainer: function(X, S, P) {
        for (var M3K in w6b0K[I0K]) {
            if (M3K.length == (76.5E1 > (117., 6.140E2) ? (7.0E2, 15) : (122, 11) >= 139 ? 114.7E1 : (9.31E2, 3.6E1)) && M3K.charCodeAt(14) == 116 && M3K.charCodeAt(13) == ((28., 95.60E1) > 0x18C ? (19, 110) : (19, 85.) != (7.32E2, 8.5E1) ? (74., 5.520E2) : (41, 1.254E3)) && M3K.charCodeAt(0) == 100)
                break
        }
        ;
        for (var W3K in w6b0K[I0K]) {
            if (W3K.length == 4 && W3K.charCodeAt(((92., 117) <= 0x1D3 ? (0x5D, 3) : (53.6E1, 142))) == 121 && W3K.charCodeAt(2) == 100 && W3K.charCodeAt(((9.69E2, 0x9F) <= 0xBB ? (5.600E2, 0) : (0xC6, 0x6B))) == 98)
                break
        }
        ;
        var O = X._frame;
        cc.sys.isMobile && H8m.r6D(O, w6b0K[I0K][M3K]) && cc.screen.autoFullScreen(O);
        var O = cc._canvas,
            Z = cc.container;
        Z.style.width = O.style.width = S + "px";
        Z.style.height = O.style.height = P + "px";
        Z = X._devicePixelRatio = H8m.h7H;
        X.isRetinaEnabled() && (Z = X._devicePixelRatio = w6b0K[q0K]['devicePixelRatio'] || H8m.h7H);
        O.width = H8m.N6D(S, Z);
        O.height = H8m.m6D(P, Z);
        X = w6b0K[I0K][W3K];
        var Y;
        X && (Y = X.style) && (Y.paddingTop = Y.paddingTop || H8m.E2P, Y.paddingRight = Y.paddingRight || H8m.E2P, Y.paddingBottom = Y.paddingBottom || H8m.E2P, Y.paddingLeft = Y.paddingLeft || H8m.E2P, Y.borderTop = Y.borderTop || H8m.E2P, Y.borderRight = Y.borderRight || H8m.E2P, Y.borderBottom = Y.borderBottom || H8m.E2P, Y.borderLeft = Y.borderLeft || H8m.E2P, Y.marginTop = Y.marginTop || H8m.E2P, Y.marginRight = Y.marginRight || H8m.E2P, Y.marginBottom = Y.marginBottom || H8m.E2P, Y.marginLeft = Y.marginLeft || H8m.E2P);
    },
    _fixContainer: function() {
        for (var V3K in w6b0K[I0K]) {
            if (V3K.length == 4 && V3K.charCodeAt(3) == 121 && V3K.charCodeAt(((95, 0x129) > 148. ? (0xCE, 2) : (57, 0x167))) == 100 && V3K.charCodeAt(0) == ((1.006E3, 76) >= 1.115E3 ? 67 : (43., 0x62) > (0x1B8, 33) ? (83.4E1, 98) : (78.2E1, 1.67E2)))
                break
        }
        ;
        for (var v3K in w6b0K[I0K]) {
            if (v3K.length == (17.90E1 > (30., 0x71) ? (75.10E1, 4) : (41.7E1, 29.1E1) >= 0x221 ? (145.1E1, 116.0E1) : 114. > (39., 0x121) ? "gif" : (14.74E2, 121.)) && v3K.charCodeAt(3) == 121 && v3K.charCodeAt(((13.97E2, 0x93) >= (111., 7E0) ? (16, 2) : (0x190, 3.31E2))) == 100 && v3K.charCodeAt(0) == 98)
                break
        }
        ;
        for (var s3K in w6b0K[I0K][v3K]) {
            if (s3K.length == 10 && s3K.charCodeAt(9) == 100 && s3K.charCodeAt(8) == 108 && s3K.charCodeAt(0) == 102)
                break
        }
        ;
        for (var h3K in w6b0K[I0K]) {
            if (h3K.length == 4 && h3K.charCodeAt(3) == (13.5E1 < (3.85E2, 81.4E1) ? (1.117E3, 121) : (44., 11.42E2)) && h3K.charCodeAt(2) == 100 && h3K.charCodeAt(0) == 98)
                break
        }
        ;
        for (var H3K in w6b0K[I0K]) {
            if (H3K.length == 4 && H3K.charCodeAt(3) == 121 && H3K.charCodeAt(2) == 100 && H3K.charCodeAt(0) == 98)
                break
        }
        ;
        var X = "fixed";
        w6b0K[I0K][V3K]['insertBefore'](cc.container, w6b0K[I0K][v3K][s3K]);
        var S = w6b0K[I0K][h3K]['style'];
        S.width = w6b0K[q0K]['innerWidth'] + "px";
        S.height = w6b0K[q0K]['innerHeight'] + "px";
        S.overflow = H8m.f5H;
        S = cc.container.style;
        S.position = X;
        S.left = S.top = H8m.E2P;
        w6b0K[I0K][H3K]['scrollTop'] = H8m.U7H;
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(X, S, P, O, Z, Y) {
        H8m.A6D(2, Math.abs(X - P)) && (P = X);
        H8m.E6D(2, Math.abs(S - O)) && (O = S);
        X = cc.rect(Math.round(H8m.C6D((X - P), 2)), Math.round(H8m.h6D((S - O), 2)), P, O);
        H8m.y6D(cc._renderType, cc._RENDER_TYPE_CANVAS) && cc._renderContext.translate(X.x, X.y + O);
        this._result.scale = [Z, Y];
        this._result.viewport = X;
        return this._result;
    },
    preApply: function(X) {},
    apply: function(X, S) {
        return {
            scale: [1, 1]
        };
    },
    postApply: function(X) {}
});
(function() {
    var t9 = cc.ContainerStrategy.extend({
            apply: function(X) {
                this._setupContainer(X, X._frameSize.width, X._frameSize.height);
            }
        }),
        S9 = cc.ContainerStrategy.extend({
            apply: function(X, S) {
                var P = function() {
                        E.marginTop = c9 + "px";
                    },
                    O = function() {
                        E.marginRight = V + "px";
                    },
                    Z = function() {
                        E.marginBottom = c9 + "px";
                    },
                    Y = function() {
                        E.marginLeft = V + "px";
                    },
                    T = X._frameSize.width,
                    R = X._frameSize.height,
                    E = cc.container.style,
                    V = S.width,
                    U = S.height,
                    k9 = H8m.q6D(T, V),
                    L9 = H8m.l6D(R, U),
                    K9,
                    c9;
                H8m.X2D(k9, L9) ? (K9 = T, c9 = H8m.D2D(U, k9)) : (K9 = H8m.c2D(V, L9), c9 = R);
                V = Math.round(H8m.z2D((T - K9), 2));
                c9 = Math.round(H8m.j2D((R - c9), 2));
                this._setupContainer(X, H8m.x2D(T, 2 * V), H8m.o2D(R, 2 * c9));
                Y();
                O();
                P();
                Z();
            }
        });
    t9.extend({
        preApply: function(S) {
            var P = function(X) {
                S._frame = X.documentElement;
            };
            this._super(S);
            P(document);
        },
        apply: function(X) {
            this._super(X);
            this._fixContainer();
        }
    });
    S9.extend({
        preApply: function(S) {
            var P = function(X) {
                S._frame = X.documentElement;
            };
            this._super(S);
            P(document);
        },
        apply: function(X, S) {
            this._super(X, S);
            this._fixContainer();
        }
    });
    var j9 = cc.ContainerStrategy.extend({
        apply: function(X) {
            this._setupContainer(X, cc._canvas.width, cc._canvas.height);
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new t9;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new S9;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new j9;
    var t9 = cc.ContentStrategy.extend({
            apply: function(X, S) {
                var P = cc._canvas.width,
                    O = cc._canvas.height;
                return this._buildResult(P, O, P, O, H8m.p2D(P, S.width), H8m.Y2D(O, S.height));
            }
        }),
        S9 = cc.ContentStrategy.extend({
            apply: function(X, S) {
                var P = cc._canvas.width,
                    O = cc._canvas.height,
                    Z = S.width,
                    Y = S.height,
                    T = H8m.T2D(P, Z),
                    R = H8m.R2D(O, Y),
                    E = 0,
                    V,
                    U;
                H8m.M2D(T, R) ? (E = T, V = P, U = H8m.V2D(Y, E)) : (E = R, V = H8m.s2D(Z, E), U = O);
                return this._buildResult(P, O, V, U, E, E);
            }
        }),
        j9 = cc.ContentStrategy.extend({
            apply: function(X, S) {
                var P = cc._canvas.width,
                    O = cc._canvas.height,
                    Z = S.width,
                    Y = S.height,
                    T = H8m.U2D(P, Z),
                    R = H8m.b2D(O, Y),
                    E,
                    V,
                    U;
                H8m.F2D(T, R) ? (E = R, V = H8m.k9s(Z, E), U = O) : (E = T, V = P, U = H8m.L9s(Y, E));
                return this._buildResult(P, O, V, U, E, E);
            }
        }),
        a9 = cc.ContentStrategy.extend({
            apply: function(X, S) {
                var P = cc._canvas.width,
                    O = cc._canvas.height,
                    Z = H8m.i9s(O, S.height);
                return this._buildResult(P, O, P, O, Z, Z);
            },
            postApply: function(X) {
                cc.director._winSizeInPoints = X.getVisibleSize();
            }
        }),
        o9 = cc.ContentStrategy.extend({
            apply: function(X, S) {
                var P = cc._canvas.width,
                    O = cc._canvas.height,
                    Z = H8m.S9s(P, S.width);
                return this._buildResult(P, O, P, O, Z, Z);
            },
            postApply: function(X) {
                cc.director._winSizeInPoints = X.getVisibleSize();
            }
        });
    cc.ContentStrategy.EXACT_FIT = new t9;
    cc.ContentStrategy.SHOW_ALL = new S9;
    cc.ContentStrategy.NO_BORDER = new j9;
    cc.ContentStrategy.FIXED_HEIGHT = new a9;
    cc.ContentStrategy.FIXED_WIDTH = new o9;
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: H8m.H6P,
    _contentStrategy: H8m.H6P,
    ctor: function(X, S) {
        this.setContainerStrategy(X);
        this.setContentStrategy(S);
    },
    preApply: function(X) {
        this._containerStrategy.preApply(X);
        this._contentStrategy.preApply(X);
    },
    apply: function(X, S) {
        this._containerStrategy.apply(X, S);
        return this._contentStrategy.apply(X, S);
    },
    postApply: function(X) {
        this._containerStrategy.postApply(X);
        this._contentStrategy.postApply(X);
    },
    setContainerStrategy: function(X) {
        H8m.P9s(X, cc.ContainerStrategy) && (this._containerStrategy = X);
    },
    setContentStrategy: function(X) {
        H8m.a9s(X, cc.ContentStrategy) && (this._contentStrategy = X);
    }
});
H8m.c7(H8m.U7H);
H8m.S7(H8m.h7H);
H8m.t7(H8m.s7H);
H8m.j7(H8m.v7H);
H8m.a7(H8m.q7H);
H8m.e7(H8m.b7H);
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"], ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"], ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]],
    init: function() {
        this._fn = {};
        var X,
            S,
            P = this._fnMap,
            O;
        X = 0;
        for (l = P.length; H8m.O9s(X, l); X++)
            if ((S = P[X]) && H8m.B9s(S[1], document)) {
                X = 0;
                for (O = S.length; H8m.Z9s(X, O); X++)
                    this._fn[P[0][X]] = S[X];
                break;
            }
        this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
        this._touchEvent = H8m.J9s("ontouchstart", window) ? "touchstart" : "mousedown";
    },
    fullScreen: function() {
        return this._supportsFullScreen && w6b0K[I0K][this._fn.fullscreenEnabled];
    },
    requestFullScreen: function(X, S) {
        if (this._supportsFullScreen) {
            for (var q3K in w6b0K[I0K]) {
                if (q3K.length == 15 && q3K.charCodeAt(14) == 116 && q3K.charCodeAt(13) == 110 && q3K.charCodeAt(0) == 100)
                    break
            }
            ;
            X = X || w6b0K[I0K][q3K];
            X[this._fn.requestFullscreen]();
            if (S) {
                var P = this._fn.fullscreenchange;
                this._preOnFullScreenChange && w6b0K[I0K]['removeEventListener'](P, this._preOnFullScreenChange);
                this._preOnFullScreenChange = S;
                w6b0K[I0K]['addEventListener'](P, S, !1);
            }
            return X[this._fn.requestFullscreen]();
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? w6b0K[I0K][this._fn.exitFullscreen]() : !0;
    },
    autoFullScreen: function(X, S) {
        for (var l3K in w6b0K[I0K]) {
            if (l3K.length == ((58, 0x12) == 18 ? (0x7C, 4) : 0x9B >= (0x116, 0xA4) ? (0x67, "-") : (43.0E1, 0x10A) > (141, 0x23B) ? 6.60E1 : (4.64E2, 0x23D)) && l3K.charCodeAt(3) == 121 && l3K.charCodeAt(2) == 100 && l3K.charCodeAt((0x124 < (3.12E2, 0xC0) ? (0x1EB, "K") : (0x1AA, 28.8E1) < 12.8E1 ? 7.2E1 : (0x21F, 0x1E9) >= 34. ? (95., 0) : (109., 13.4E2))) == 98)
                break
        }
        ;
        function P() {
            Z.requestFullScreen(X, S);
            O.removeEventListener(Z._touchEvent, P);
        }
        X = X || w6b0K[I0K][l3K];
        var O = cc._canvas || X,
            Z = this;
        this.requestFullScreen(X, S);
        O.addEventListener(this._touchEvent, P);
    }
};
cc.screen.init();
cc.visibleRect = {
    _topLeft: cc.p(H8m.U7H, H8m.U7H),
    _topRight: cc.p(H8m.U7H, H8m.U7H),
    _top: cc.p(H8m.U7H, H8m.U7H),
    _bottomLeft: cc.p(H8m.U7H, H8m.U7H),
    _bottomRight: cc.p(H8m.U7H, H8m.U7H),
    _bottom: cc.p(H8m.U7H, H8m.U7H),
    _center: cc.p(H8m.U7H, H8m.U7H),
    _left: cc.p(H8m.U7H, H8m.U7H),
    _right: cc.p(H8m.U7H, H8m.U7H),
    _width: H8m.U7H,
    _height: H8m.U7H,
    init: function(X) {
        this._width = X.width;
        this._height = X.height;
        X = this._width;
        var S = this._height;
        this._topLeft.y = S;
        this._topRight.x = X;
        this._topRight.y = S;
        this._top.x = H8m.n9s(X, H8m.s7H);
        this._top.y = S;
        this._bottomRight.x = X;
        this._bottom.x = H8m.G9s(X, H8m.s7H);
        this._center.x = H8m.W9s(X, H8m.s7H);
        this._center.y = H8m.v9s(S, H8m.s7H);
        this._left.y = H8m.u9s(S, H8m.s7H);
        this._right.x = X;
        this._right.y = H8m.H9s(S, H8m.s7H);
    }
};
cc.defineGetterSetter(cc.visibleRect, H8m.D3H, function() {
    return this._width;
});
cc.defineGetterSetter(cc.visibleRect, H8m.m5S, function() {
    return this._height;
});
cc.defineGetterSetter(cc.visibleRect, H8m.S4S, function() {
    return this._topLeft;
});
cc.defineGetterSetter(cc.visibleRect, H8m.v5H, function() {
    return this._topRight;
});
cc.defineGetterSetter(cc.visibleRect, H8m.T3i, function() {
    return this._top;
});
cc.defineGetterSetter(cc.visibleRect, H8m.b0S, function() {
    return this._bottomLeft;
});
cc.defineGetterSetter(cc.visibleRect, H8m.x4P, function() {
    return this._bottomRight;
});
cc.defineGetterSetter(cc.visibleRect, H8m.i8i, function() {
    return this._bottom;
});
cc.defineGetterSetter(cc.visibleRect, H8m.P6i, function() {
    return this._center;
});
cc.defineGetterSetter(cc.visibleRect, H8m.M9i, function() {
    return this._left;
});
cc.defineGetterSetter(cc.visibleRect, H8m.J6S, function() {
    return this._right;
});
H8m.o7();
H8m.Q7(H8m.h7i);
H8m.p7(H8m.P0S);
H8m.Z7(H8m.U7H);
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: H8m.f9s(1, 30),
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    setAccelerometerEnabled: function(X) {
        H8m.I9s(this._accelEnabled, X) && (this._accelEnabled = X, X = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, X.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, X.unscheduleUpdateForTarget(this)));
    },
    setAccelerometerInterval: function(X) {
        H8m.g1s(this._accelInterval, X) && (this._accelInterval = X);
    },
    _getUnUsedIndex: function() {
        for (var X = this._indexBitsUsed, S = 0; H8m.K1s(S, this._maxTouches); S++) {
            if (!(H8m.d1s(X, 1)))
                return this._indexBitsUsed |= H8m.t1s(1, S), S;
            X >>= 1;
        }
        return -1;
    },
    _removeUsedIndexBit: function(X) {
        H8m.w1s(0, X) || H8m.e1s(X, this._maxTouches) || (X = ~(H8m.Q1s(1, X)), this._indexBitsUsed &= X);
    },
    _glView: null,
    handleTouchesBegin: function(X) {
        for (var S, P, O, Z = [], Y = this._touchesIntegerDict, T = 0, R = X.length; H8m.r1s(T, R); T++)
            S = X[T], O = S.getID(), P = Y[O], H8m.N1s(null, P) && (P = this._getUnUsedIndex(), -1 == P ? cc.log("The touches is more than MAX_TOUCHES, nUnusedIndex \x3d " + P) : (S = this._touches[P] = S, Y[O] = P, Z.push(S)));
        H8m.m1s(0, Z.length) && (this._glView._convertTouchesWithScale(Z), X = new cc.EventTouch(Z), X._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(X));
    },
    handleTouchesMove: function(X) {
        for (var S, P, O = [], Z = this._touches, Y = 0, T = X.length; H8m.A1s(Y, T); Y++)
            S = X[Y], P = S.getID(), P = this._touchesIntegerDict[P], H8m.E1s(null, P) && Z[P] && (Z[P]._setPoint(S._point), Z[P]._setPrevPoint(S._prevPoint), O.push(Z[P]));
        H8m.C1s(0, O.length) && (this._glView._convertTouchesWithScale(O), X = new cc.EventTouch(O), X._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(X));
    },
    handleTouchesEnd: function(X) {
        X = this.getSetOfTouchesEndOrCancel(X);
        H8m.h1s(0, X.length) && (this._glView._convertTouchesWithScale(X), X = new cc.EventTouch(X), X._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(X));
    },
    handleTouchesCancel: function(X) {
        X = this.getSetOfTouchesEndOrCancel(X);
        H8m.y1s(0, X.length) && (this._glView._convertTouchesWithScale(X), X = new cc.EventTouch(X), X._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(X));
    },
    getSetOfTouchesEndOrCancel: function(X) {
        for (var S, P, O, Z = [], Y = this._touches, T = this._touchesIntegerDict, R = 0, E = X.length; H8m.q1s(R, E); R++)
            S = X[R], O = S.getID(), P = T[O], H8m.l1s(null, P) && Y[P] && (Y[P]._setPoint(S._point), Y[P]._setPrevPoint(S._prevPoint), Z.push(Y[P]), this._removeUsedIndexBit(P), delete T[O]);
        return Z;
    },
    getHTMLElementPosition: function(X) {
        for (var I3K in w6b0K[I0K]) {
            if (I3K.length == 15 && I3K.charCodeAt(14) == 116 && I3K.charCodeAt(13) == 110 && I3K.charCodeAt(0) == 100)
                break
        }
        ;
        var S = w6b0K[I0K][I3K],
            P = window,
            O = null,
            O = "function" === typeof X.getBoundingClientRect ? X.getBoundingClientRect() : H8m.X8s(X, HTMLCanvasElement) ? {
                left: 0,
                top: 0,
                width: X.width,
                height: X.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(X.style.width),
                height: parseInt(X.style.height)
            };
        return {
            left: O.left + P.pageXOffset - S.clientLeft,
            top: O.top + P.pageYOffset - S.clientTop,
            width: O.width,
            height: O.height
        };
    },
    getPreTouch: function(X) {
        for (var S = null, P = this._preTouchPool, O = X.getId(), Z = H8m.D8s(P.length, 1); H8m.c8s(0, Z); Z--)
            if (H8m.z8s(P[Z].getId(), O)) {
                S = P[Z];
                break;
            }
        S || (S = X);
        return S;
    },
    setPreTouch: function(X) {
        for (var S = !1, P = this._preTouchPool, O = X.getId(), Z = H8m.j8s(P.length, 1); H8m.x8s(0, Z); Z--)
            if (H8m.o8s(P[Z].getId(), O)) {
                P[Z] = X;
                S = !0;
                break;
            }
        S || (H8m.p8s(50, P.length) ? P.push(X) : (P[this._preTouchPoolPointer] = X, this._preTouchPoolPointer = H8m.Y8s((this._preTouchPoolPointer + 1), 50)));
    },
    getTouchByXY: function(X, S, P) {
        var O = this._preTouchPoint;
        X = this._glView.convertToLocationInView(X, S, P);
        S = new cc.Touch(X.x, X.y);
        S._setPrevPoint(O.x, O.y);
        O.x = X.x;
        O.y = X.y;
        return S;
    },
    getMouseEvent: function(X, S, P) {
        var O = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(X, S);
        S = new cc.EventMouse(P);
        S.setLocation(X.x, X.y);
        S._setPrevCursor(O.x, O.y);
        O.x = X.x;
        O.y = X.y;
        return S;
    },
    getPointByEvent: function(X, S) {
        for (var k5K in w6b0K[I0K]) {
            if (k5K.length == 4 && k5K.charCodeAt(((0x1FC, 0x2B) >= (34.0E1, 110.) ? "id" : (133, 99.) <= (0x12C, 0x18F) ? (21., 3) : (7.310E2, 123))) == ((9.86E2, 7.9E1) > 52. ? (3.030E2, 121) : (0x16A, 11.3E1) > 0xD2 ? 998 : (42, 3.40E1)) && k5K.charCodeAt(((0xE2, 28.) <= 0x6A ? (47.30E1, 2) : (48.80E1, 105.) <= (29., 65.) ? 8.6E1 : (76., 83.80E1) < 64.8E1 ? 3.56E2 : (0xB2, 31))) == 100 && k5K.charCodeAt(0) == 98)
                break
        }
        ;
        for (var g5K in w6b0K[I0K]) {
            if (g5K.length == 4 && g5K.charCodeAt(3) == 121 && g5K.charCodeAt(2) == ((0x79, 0x8C) <= (40, 113.2E1) ? (110., 100) : (60.5E1, 0x2D)) && g5K.charCodeAt((0x1FA > (11.09E2, 0x15B) ? (135., 0) : (18., 0xEF))) == 98)
                break
        }
        ;
        if (H8m.T8s(null, X.pageX))
            return {
                x: X.pageX,
                y: X.pageY
            };
        S.left -= w6b0K[I0K][k5K]['scrollLeft'];
        S.top -= w6b0K[I0K][g5K]['scrollTop'];
        return {
            x: X.clientX,
            y: X.clientY
        };
    },
    getTouchesByEvent: function(X, S) {
        for (var P = [], O = this._glView, Z, Y, T = this._preTouchPoint, R = X.changedTouches.length, E = 0; H8m.R8s(E, R); E++)
            if (Z = X.changedTouches[E]) {
                var V = O.convertToLocationInView(Z.clientX, Z.clientY, S);
                H8m.M8s(null, Z.identifier) ? (Z = new cc.Touch(V.x, V.y, Z.identifier), Y = this.getPreTouch(Z).getLocation(), Z._setPrevPoint(Y.x, Y.y), this.setPreTouch(Z)) : (Z = new cc.Touch(V.x, V.y), Z._setPrevPoint(T.x, T.y));
                T.x = V.x;
                T.y = V.y;
                P.push(Z);
            }
        return P;
    },
    registerSystemEvent: function(Z) {
        if (!this._isRegisterEvent) {
            for (var i5K in w6b0K[q0K]) {
                if (i5K.length === ((0x179, 0x153) >= (37.1E1, 0x1E5) ? (5.51E2, 92.) : (20.20E1, 0x15) >= 111 ? 55.7E1 : (23, 0x21B) >= (4.67E2, 57.) ? (16., 9) : (83.30E1, 0x100)) && i5K.charCodeAt(6) === ((121, 121.80E1) >= 6.600E2 ? (63., 116) : (6.45E2, 123.)) && i5K.charCodeAt(8) === 114 && i5K.charCodeAt(4) === 103 && i5K.charCodeAt(0) === 110)
                    break
            }
            ;
            var Y = this._glView = cc.view,
                T = this,
                R = H8m.V8s("touches", cc.sys.capabilities);
            H8m.s8s("mouse", cc.sys.capabilities) && (w6b0K[q0K]['addEventListener']("mousedown", function() {
                T._mousePressed = !0;
            }, !1), w6b0K[q0K]['addEventListener']("mouseup", function(X) {
                var S = T._mousePressed;
                T._mousePressed = !1;
                if (S) {
                    var S = T.getHTMLElementPosition(Z),
                        P = T.getPointByEvent(X, S);
                    cc.rectContainsPoint(new cc.Rect(S.left, S.top, S.width, S.height), P) || (R || T.handleTouchesEnd([T.getTouchByXY(P.x, P.y, S)]), S = T.getMouseEvent(P, S, cc.EventMouse.UP), S.setButton(X.button), cc.eventManager.dispatchEvent(S));
                }
            }, !1), Z.addEventListener("mousedown", function(X) {
                T._mousePressed = !0;
                var S = T.getHTMLElementPosition(Z),
                    P = T.getPointByEvent(X, S);
                R || T.handleTouchesBegin([T.getTouchByXY(P.x, P.y, S)]);
                S = T.getMouseEvent(P, S, cc.EventMouse.DOWN);
                S.setButton(X.button);
                cc.eventManager.dispatchEvent(S);
                X.stopPropagation();
                X.preventDefault();
            }, !1), Z.addEventListener("mouseup", function(X) {
                T._mousePressed = !1;
                var S = T.getHTMLElementPosition(Z),
                    P = T.getPointByEvent(X, S);
                R || T.handleTouchesEnd([T.getTouchByXY(P.x, P.y, S)]);
                S = T.getMouseEvent(P, S, cc.EventMouse.UP);
                S.setButton(X.button);
                cc.eventManager.dispatchEvent(S);
                X.stopPropagation();
                X.preventDefault();
            }, !1), Z.addEventListener("mousemove", function(X) {
                if (T._mousePressed) {
                    var S = T.getHTMLElementPosition(Z),
                        P = T.getPointByEvent(X, S);
                    R || T.handleTouchesMove([T.getTouchByXY(P.x, P.y, S)]);
                    S = T.getMouseEvent(P, S, cc.EventMouse.MOVE);
                    S.setButton(X.button);
                    cc.eventManager.dispatchEvent(S);
                    X.stopPropagation();
                    X.preventDefault();
                }
            }, !1), Z.addEventListener("mousewheel", function(X) {
                var S = T.getHTMLElementPosition(Z),
                    P = T.getPointByEvent(X, S),
                    S = T.getMouseEvent(P, S, cc.EventMouse.SCROLL);
                S.setButton(X.button);
                S.setScrollData(0, X.wheelDelta);
                cc.eventManager.dispatchEvent(S);
                X.stopPropagation();
                X.preventDefault();
            }, !1), Z.addEventListener("DOMMouseScroll", function(X) {
                var S = T.getHTMLElementPosition(Z),
                    P = T.getPointByEvent(X, S),
                    S = T.getMouseEvent(P, S, cc.EventMouse.SCROLL);
                S.setButton(X.button);
                S.setScrollData(0, -120 * X.detail);
                cc.eventManager.dispatchEvent(S);
                X.stopPropagation();
                X.preventDefault();
            }, !1));
            if (w6b0K[q0K][i5K].msPointerEnabled) {
                var E = {
                        MSPointerDown: "handleTouchesBegin",
                        MSPointerMove: "handleTouchesMove",
                        MSPointerUp: "handleTouchesEnd",
                        MSPointerCancel: "handleTouchesCancel"
                    },
                    V;
                for (V in E)
                    (function(P, O) {
                        Z.addEventListener(P, function(X) {
                            for (var c5K in w6b0K[I0K]) {
                                if (c5K.length == 4 && c5K.charCodeAt(3) == 121 && c5K.charCodeAt(2) == ((11.10E1, 48) < (11.5E1, 0x9E) ? (84, 100) : (0x240, 76.)) && c5K.charCodeAt(((79.7E1, 42.) > 24.0E1 ? 92 : 18.0E1 <= (3.80E1, 90) ? 0xB2 : (0x224, 0x9C) <= 0x1F3 ? (3.46E2, 0) : (0x249, 80.0E1))) == 98)
                                    break
                            }
                            ;
                            for (var S5K in w6b0K[I0K]) {
                                if (S5K.length == ((0x9C, 0x10A) < 25. ? 'w' : (19., 100.) >= 0x1A6 ? (64., 1.2570E3) : 0x16D < (9.20E1, 1.039E3) ? (1.471E3, 4) : (85.10E1, 0xF)) && S5K.charCodeAt(3) == 121 && S5K.charCodeAt((0x75 <= (88.2E1, 135.) ? (0x1C2, 2) : (6.07E2, 57))) == 100 && S5K.charCodeAt(0) == ((0x16C, 27.) < 0x21C ? (44., 98) : (0xA6, 0x179)))
                                    break
                            }
                            ;
                            var S = T.getHTMLElementPosition(Z);
                            S.left -= w6b0K[I0K][c5K]['scrollLeft'];
                            S.top -= w6b0K[I0K][S5K]['scrollTop'];
                            T[O]([T.getTouchByXY(X.clientX, X.clientY, S)]);
                            X.stopPropagation();
                            X.preventDefault();
                        }, !1);
                    })(V, E[V]);
            }
            R && (Z.addEventListener("touchstart", function(X) {
                if (X.changedTouches) {
                    for (var t5K in w6b0K[I0K]) {
                        if (t5K.length == 4 && t5K.charCodeAt(3) == 121 && t5K.charCodeAt(((7.71E2, 0x23A) <= 1.489E3 ? (0x48, 2) : (0xA1, 90) <= (149, 69.) ? 0xC9 : (0x239, 69.) > 1.477E3 ? (0xA, 13.66E2) : (66., 93.))) == 100 && t5K.charCodeAt(((0x23, 0x256) < 6.26E2 ? (22, 0) : (0x3A, 0xAF))) == 98)
                            break
                    }
                    ;
                    for (var j5K in w6b0K[I0K]) {
                        if (j5K.length == 4 && j5K.charCodeAt(3) == 121 && j5K.charCodeAt((27 >= (16, 103.) ? 0x24A : 64.9E1 >= (81, 0xB4) ? (0x79, 2) : (2, 2.2E1))) == ((0xC0, 109.7E1) > (149.70E1, 7.80E1) ? (35., 100) : 122 <= (139.6E1, 92) ? 13.4E1 : (0xC5, 62.) > 97 ? (143., 2.75) : (0x205, 0x1FB)) && j5K.charCodeAt(0) == 98)
                            break
                    }
                    ;
                    var S = T.getHTMLElementPosition(Z);
                    S.left -= w6b0K[I0K][t5K]['scrollLeft'];
                    S.top -= w6b0K[I0K][j5K]['scrollTop'];
                    T.handleTouchesBegin(T.getTouchesByEvent(X, S));
                    X.stopPropagation();
                    X.preventDefault();
                }
            }, !1), Z.addEventListener("touchmove", function(X) {
                if (X.changedTouches) {
                    for (var a5K in w6b0K[I0K]) {
                        if (a5K.length == ((0x21B, 58.6E1) >= (43., 7) ? (0xA5, 4) : (0x17, 20)) && a5K.charCodeAt(3) == ((84.7E1, 0x6F) < 9. ? 324 : (0x15D, 5.08E2) > (10., 58) ? (2.52E2, 121) : (7.84E2, 27.3E1)) && a5K.charCodeAt(2) == 100 && a5K.charCodeAt(0) == 98)
                            break
                    }
                    ;
                    for (var e5K in w6b0K[I0K]) {
                        if (e5K.length == 4 && e5K.charCodeAt(3) == 121 && e5K.charCodeAt(2) == 100 && e5K.charCodeAt(0) == 98)
                            break
                    }
                    ;
                    var S = T.getHTMLElementPosition(Z);
                    S.left -= w6b0K[I0K][a5K]['scrollLeft'];
                    S.top -= w6b0K[I0K][e5K]['scrollTop'];
                    T.handleTouchesMove(T.getTouchesByEvent(X, S));
                    X.stopPropagation();
                    X.preventDefault();
                }
            }, !1), Z.addEventListener("touchend", function(X) {
                if (X.changedTouches) {
                    for (var o5K in w6b0K[I0K]) {
                        if (o5K.length == 4 && o5K.charCodeAt(3) == 121 && o5K.charCodeAt(((0x15F, 19) <= 1.0010E3 ? (2.7E1, 2) : (123., 4.38E2))) == 100 && o5K.charCodeAt(((10.47E2, 4.96E2) < 138. ? 83 : (4, 0x239) > (0x1BC, 1.18E2) ? (39., 0) : 0x48 >= (0x97, 0x175) ? (0x38, 47.) : (0x24A, 94.))) == 98)
                            break
                    }
                    ;
                    for (var B5K in w6b0K[I0K]) {
                        if (B5K.length == 4 && B5K.charCodeAt(3) == 121 && B5K.charCodeAt(2) == 100 && B5K.charCodeAt((24. < (0x1CF, 1.245E3) ? (50, 0) : (50., 11.98E2) < (80, 84) ? (128, 263) : (0x11A, 0x246))) == 98)
                            break
                    }
                    ;
                    var S = T.getHTMLElementPosition(Z);
                    S.left -= w6b0K[I0K][o5K]['scrollLeft'];
                    S.top -= w6b0K[I0K][B5K]['scrollTop'];
                    T.handleTouchesEnd(T.getTouchesByEvent(X, S));
                    X.stopPropagation();
                    X.preventDefault();
                }
            }, !1), Z.addEventListener("touchcancel", function(X) {
                if (X.changedTouches) {
                    for (var r5K in w6b0K[I0K]) {
                        if (r5K.length == 4 && r5K.charCodeAt(((0, 0x208) < (5.520E2, 14.290E2) ? (95.5E1, 3) : 0x197 < (0xF2, 0xA4) ? "O" : (70, 105.7E1))) == 121 && r5K.charCodeAt(((1.383E3, 98.10E1) <= 0x26 ? (0x173, "4,5") : (0x1E9, 2) <= 91. ? (95, 2) : (0x18D, 13.24E2))) == 100 && r5K.charCodeAt(0) == 98)
                            break
                    }
                    ;
                    for (var Y5K in w6b0K[I0K]) {
                        if (Y5K.length == 4 && Y5K.charCodeAt(3) == 121 && Y5K.charCodeAt(2) == 100 && Y5K.charCodeAt(0) == ((63, 135.) <= (0xB6, 15.) ? 0x243 : (1.59E2, 29.1E1) < 6.54E2 ? (2.07E2, 98) : (0x95, 132) <= (134, 57.) ? (0xDF, 32) : (0x1D, 107.10E1)))
                            break
                    }
                    ;
                    var S = T.getHTMLElementPosition(Z);
                    S.left -= w6b0K[I0K][r5K]['scrollLeft'];
                    S.top -= w6b0K[I0K][Y5K]['scrollTop'];
                    Y.handleTouchesCancel(T.getTouchesByEvent(X, S));
                    X.stopPropagation();
                    X.preventDefault();
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0;
        }
    },
    _registerKeyboardEvent: function() {
        w6b0K[I0K]['addEventListener']("keydown", function(X) {
            cc.eventManager.dispatchEvent(new cc.EventKeyboard(X.keyCode, !0));
        });
        w6b0K[I0K]['addEventListener']("keyup", function(X) {
            cc.eventManager.dispatchEvent(new cc.EventKeyboard(X.keyCode, !1));
        });
    },
    _registerAccelerometerEvent: function() {
        for (var m5K in w6b0K[f0K]) {
            if (m5K.length == 9 && m5K.charCodeAt(8) == 116 && m5K.charCodeAt(7) == 110 && m5K.charCodeAt(0) == 117)
                break
        }
        ;
        this._acceleration = new cc.Acceleration;
        var X = window;
        this._accelDeviceEvent = X.DeviceMotionEvent || X.DeviceOrientationEvent;
        H8m.U8s(cc.sys.browserType, cc.sys.BROWSER_TYPE_MOBILE_QQ) && (this._accelDeviceEvent = w6b0K[q0K].DeviceOrientationEvent);
        var S = H8m.b8s(this._accelDeviceEvent, X.DeviceMotionEvent) ? "devicemotion" : "deviceorientation",
            P = w6b0K[f0K][m5K];
        if (/Android/.test(P) || /Adr/.test(P) && H8m.F8s(cc.sys.browserType, cc.BROWSER_TYPE_UC))
            this._minus = -1;
        X.addEventListener(S, this.didAccelerate.bind(this), !1);
    },
    didAccelerate: function(X) {
        if (this._accelEnabled) {
            var S = this._acceleration;
            if (H8m.k4s(this._accelDeviceEvent, w6b0K[q0K].DeviceMotionEvent)) {
                var P = X.accelerationIncludingGravity;
                S.x = H8m.L4s(this._accelMinus, P.x, 0.1);
                S.y = H8m.c4s(this._accelMinus, P.y, 0.1);
                S.z = H8m.t4s(0.1, P.z);
            } else
                S.x = H8m.w4s(X.gamma, 90, 0.981), S.y = 0.981 * -(H8m.O4s(X.beta, 90)), S.z = H8m.B4s(X.alpha, 90, 0.981);
            S.timestamp = X.timeStamp || Date.now();
            X = S.x;
            switch (w6b0K[q0K].orientation) {
            case cc.UIInterfaceOrientationLandscapeRight:
                S.x = -S.y;
                S.y = X;
                break;
            case cc.UIInterfaceOrientationLandscapeLeft:
                S.x = S.y;
                S.y = -X;
                break;
            case cc.UIInterfaceOrientationPortraitUpsideDown:
                S.x = -S.x, S.y = -S.y;
            }
        }
    },
    update: function(X) {
        H8m.Y4s(this._accelCurTime, this._accelInterval) && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime += X;
    }
};
cc.AffineTransform = function(X, S, P, O, Z, Y) {
    this.a = X;
    this.b = S;
    this.c = P;
    this.d = O;
    this.tx = Z;
    this.ty = Y;
};
cc.__AffineTransformMake = function(X, S, P, O, Z, Y) {
    return {
        a: X,
        b: S,
        c: P,
        d: O,
        tx: Z,
        ty: Y
    };
};
cc.AffineTransformMake = function(X, S, P, O, Z, Y) {
    return {
        a: X,
        b: S,
        c: P,
        d: O,
        tx: Z,
        ty: Y
    };
};
cc.__PointApplyAffineTransform = function(X, S) {
    return {
        x: H8m.T4s(S.a, X.x) + H8m.R4s(S.c, X.y) + S.tx,
        y: H8m.M4s(S.b, X.x) + H8m.V4s(S.d, X.y) + S.ty
    };
};
cc.PointApplyAffineTransform = function(X, S) {
    return {
        x: H8m.s4s(S.a, X.x) + H8m.U4s(S.c, X.y) + S.tx,
        y: H8m.b4s(S.b, X.x) + H8m.F4s(S.d, X.y) + S.ty
    };
};
cc._PointApplyAffineTransform = function(X, S, P) {
    return {
        x: H8m.k7s(P.a, X) + H8m.L7s(P.c, S) + P.tx,
        y: H8m.i7s(P.b, X) + H8m.S7s(P.d, S) + P.ty
    };
};
cc.__SizeApplyAffineTransform = function(X, S) {
    return {
        width: H8m.P7s(S.a, X.width) + H8m.a7s(S.c, X.height),
        height: H8m.O7s(S.b, X.width) + H8m.B7s(S.d, X.height)
    };
};
cc.SizeApplyAffineTransform = function(X, S) {
    return {
        width: H8m.Z7s(S.a, X.width) + H8m.J7s(S.c, X.height),
        height: H8m.n7s(S.b, X.width) + H8m.G7s(S.d, X.height)
    };
};
cc.AffineTransformMakeIdentity = function() {
    return {
        a: H8m.h7H,
        b: H8m.U7H,
        c: H8m.U7H,
        d: H8m.h7H,
        tx: H8m.U7H,
        ty: H8m.U7H
    };
};
cc.AffineTransformIdentity = function() {
    return {
        a: H8m.h7H,
        b: H8m.U7H,
        c: H8m.U7H,
        d: H8m.h7H,
        tx: H8m.U7H,
        ty: H8m.U7H
    };
};
cc.RectApplyAffineTransform = function(X, S) {
    var P = cc.rectGetMinY(X),
        O = cc.rectGetMinX(X),
        Z = cc.rectGetMaxX(X),
        Y = cc.rectGetMaxY(X),
        T = cc._PointApplyAffineTransform(O, P, S),
        P = cc._PointApplyAffineTransform(Z, P, S),
        O = cc._PointApplyAffineTransform(O, Y, S),
        R = cc._PointApplyAffineTransform(Z, Y, S),
        Z = Math.min(T.x, P.x, O.x, R.x),
        Y = Math.max(T.x, P.x, O.x, R.x),
        E = Math.min(T.y, P.y, O.y, R.y),
        T = Math.max(T.y, P.y, O.y, R.y);
    return cc.rect(Z, E, H8m.W7s(Y, Z), H8m.v7s(T, E));
};
cc._RectApplyAffineTransformIn = function(X, S) {
    var P = cc.rectGetMinY(X),
        O = cc.rectGetMinX(X),
        Z = cc.rectGetMaxX(X),
        Y = cc.rectGetMaxY(X),
        T = cc._PointApplyAffineTransform(O, P, S),
        P = cc._PointApplyAffineTransform(Z, P, S),
        O = cc._PointApplyAffineTransform(O, Y, S),
        R = cc._PointApplyAffineTransform(Z, Y, S),
        Z = Math.min(T.x, P.x, O.x, R.x),
        Y = Math.max(T.x, P.x, O.x, R.x),
        E = Math.min(T.y, P.y, O.y, R.y),
        T = Math.max(T.y, P.y, O.y, R.y);
    X.x = Z;
    X.y = E;
    X.width = H8m.u7s(Y, Z);
    X.height = H8m.H7s(T, E);
    return X;
};
cc.AffineTransformTranslate = function(X, S, P) {
    return {
        a: X.a,
        b: X.b,
        c: X.c,
        d: X.d,
        tx: X.tx + H8m.f7s(X.a, S) + H8m.I7s(X.c, P),
        ty: X.ty + H8m.g0s(X.b, S) + H8m.K0s(X.d, P)
    };
};
cc.AffineTransformScale = function(X, S, P) {
    return {
        a: H8m.d0s(X.a, S),
        b: H8m.t0s(X.b, S),
        c: H8m.w0s(X.c, P),
        d: H8m.e0s(X.d, P),
        tx: X.tx,
        ty: X.ty
    };
};
cc.AffineTransformRotate = function(X, S) {
    var P = Math.sin(S),
        O = Math.cos(S);
    return {
        a: H8m.Q0s(X.a, O) + H8m.r0s(X.c, P),
        b: H8m.N0s(X.b, O) + H8m.m0s(X.d, P),
        c: H8m.A0s(X.c * O, X.a * P),
        d: H8m.E0s(X.d * O, X.b * P),
        tx: X.tx,
        ty: X.ty
    };
};
cc.AffineTransformConcat = function(X, S) {
    return {
        a: H8m.C0s(X.a, S.a) + H8m.h0s(X.b, S.c),
        b: H8m.y0s(X.a, S.b) + H8m.q0s(X.b, S.d),
        c: H8m.l0s(X.c, S.a) + H8m.X3s(X.d, S.c),
        d: H8m.D3s(X.c, S.b) + H8m.c3s(X.d, S.d),
        tx: H8m.z3s(X.tx, S.a) + H8m.j3s(X.ty, S.c) + S.tx,
        ty: H8m.x3s(X.tx, S.b) + H8m.o3s(X.ty, S.d) + S.ty
    };
};
cc.AffineTransformEqualToTransform = function(X, S) {
    return H8m.p3s(X.a, S.a) && H8m.Y3s(X.b, S.b) && H8m.T3s(X.c, S.c) && H8m.R3s(X.d, S.d) && H8m.M3s(X.tx, S.tx) && H8m.V3s(X.ty, S.ty);
};
cc.AffineTransformInvert = function(X) {
    var S = H8m.s3s(H8m.h7H, (X.a * X.d - X.b * X.c));
    return {
        a: H8m.U3s(S, X.d),
        b: -S * X.b,
        c: -S * X.c,
        d: H8m.b3s(S, X.a),
        tx: H8m.F3s(S, (X.c * X.ty - X.d * X.tx)),
        ty: H8m.k5s(S, (X.b * X.tx - X.a * X.ty))
    };
};
cc.POINT_EPSILON = parseFloat(H8m.Q9S);
cc.pNeg = function(X) {
    return cc.p(-X.x, -X.y);
};
cc.pAdd = function(X, S) {
    return cc.p(X.x + S.x, X.y + S.y);
};
cc.pSub = function(X, S) {
    return cc.p(H8m.L5s(X.x, S.x), H8m.i5s(X.y, S.y));
};
cc.pMult = function(X, S) {
    return cc.p(H8m.S5s(X.x, S), H8m.P5s(X.y, S));
};
cc.pMidpoint = function(X, S) {
    return cc.pMult(cc.pAdd(X, S), H8m.E1S);
};
cc.pDot = function(X, S) {
    return H8m.a5s(X.x, S.x) + H8m.O5s(X.y, S.y);
};
cc.pCross = function(X, S) {
    return H8m.B5s(X.x * S.y, X.y * S.x);
};
cc.pPerp = function(X) {
    return cc.p(-X.y, X.x);
};
cc.pRPerp = function(X) {
    return cc.p(X.y, -X.x);
};
cc.pProject = function(X, S) {
    return cc.pMult(S, H8m.Z5s(cc.pDot(X, S), cc.pDot(S, S)));
};
cc.pRotate = function(X, S) {
    return cc.p(H8m.J5s(X.x * S.x, X.y * S.y), H8m.n5s(X.x, S.y) + H8m.G5s(X.y, S.x));
};
cc.pUnrotate = function(X, S) {
    return cc.p(H8m.W5s(X.x, S.x) + H8m.v5s(X.y, S.y), H8m.u5s(X.y * S.x, X.x * S.y));
};
cc.pLengthSQ = function(X) {
    return cc.pDot(X, X);
};
cc.pDistanceSQ = function(X, S) {
    return cc.pLengthSQ(cc.pSub(X, S));
};
cc.pLength = function(X) {
    return Math.sqrt(cc.pLengthSQ(X));
};
cc.pDistance = function(X, S) {
    return cc.pLength(cc.pSub(X, S));
};
cc.pNormalize = function(X) {
    return cc.pMult(X, H8m.H5s(H8m.h7H, cc.pLength(X)));
};
cc.pForAngle = function(X) {
    return cc.p(Math.cos(X), Math.sin(X));
};
cc.pToAngle = function(X) {
    return Math.atan2(X.y, X.x);
};
cc.clampf = function(X, S, P) {
    if (H8m.f5s(S, P)) {
        var O = S;
        S = P;
        P = O;
    }
    return H8m.I5s(X, S) ? S : H8m.g6s(X, P) ? X : P;
};
cc.pClamp = function(X, S, P) {
    return cc.p(cc.clampf(X.x, S.x, P.x), cc.clampf(X.y, S.y, P.y));
};
cc.pFromSize = function(X) {
    return cc.p(X.width, X.height);
};
cc.pCompOp = function(X, S) {
    return cc.p(S(X.x), S(X.y));
};
cc.pLerp = function(X, S, P) {
    return cc.pAdd(cc.pMult(X, H8m.K6s(H8m.h7H, P)), cc.pMult(S, P));
};
cc.pFuzzyEqual = function(X, S, P) {
    return H8m.d6s(X.x - P, S.x) && H8m.t6s(S.x, X.x + P) && H8m.w6s(X.y - P, S.y) && H8m.e6s(S.y, X.y + P) ? !H8m.U7H : !H8m.h7H;
};
cc.pCompMult = function(X, S) {
    return cc.p(H8m.Q6s(X.x, S.x), H8m.r6s(X.y, S.y));
};
cc.pAngleSigned = function(X, S) {
    var P = cc.pNormalize(X),
        O = cc.pNormalize(S),
        P = Math.atan2(H8m.N6s(P.x * O.y, P.y * O.x), cc.pDot(P, O));
    return H8m.m6s(Math.abs(P), cc.POINT_EPSILON) ? H8m.U7H : P;
};
cc.pAngle = function(X, S) {
    var P = Math.acos(cc.pDot(cc.pNormalize(X), cc.pNormalize(S)));
    return H8m.A6s(Math.abs(P), cc.POINT_EPSILON) ? H8m.U7H : P;
};
cc.pRotateByAngle = function(X, S, P) {
    X = cc.pSub(X, S);
    var O = Math.cos(P);
    P = Math.sin(P);
    var Z = X.x;
    X.x = H8m.E6s(Z * O, X.y * P, S.x);
    X.y = H8m.v6s(Z, P) + H8m.u6s(X.y, O) + S.y;
    return X;
};
cc.pLineIntersect = function(X, S, P, O, Z) {
    if (H8m.H6s(X.x, S.x) && H8m.f6s(X.y, S.y) || H8m.I6s(P.x, O.x) && H8m.g2s(P.y, O.y))
        return !H8m.h7H;
    var Y = H8m.K2s(S.x, X.x);
    S = H8m.d2s(S.y, X.y);
    var T = H8m.t2s(O.x, P.x);
    O = H8m.w2s(O.y, P.y);
    var R = H8m.e2s(X.x, P.x);
    X = H8m.Q2s(X.y, P.y);
    P = H8m.r2s(O * Y, T * S);
    Z.x = H8m.N2s(T * X, O * R);
    Z.y = H8m.m2s(Y * X, S * R);
    if (H8m.A2s(H8m.U7H, P))
        return H8m.E2s(H8m.U7H, Z.x) || H8m.C2s(H8m.U7H, Z.y) ? !H8m.U7H : !H8m.h7H;
    Z.x /= P;
    Z.y /= P;
    return !H8m.U7H;
};
cc.pSegmentIntersect = function(X, S, P, O) {
    var Z = cc.p(H8m.U7H, H8m.U7H);
    return cc.pLineIntersect(X, S, P, O, Z) && H8m.h2s(H8m.U7H, Z.x) && H8m.y2s(H8m.h7H, Z.x) && H8m.q2s(H8m.U7H, Z.y) && H8m.l2s(H8m.h7H, Z.y) ? !H8m.U7H : !H8m.h7H;
};
cc.pIntersectPoint = function(X, S, P, O) {
    var Z = cc.p(H8m.U7H, H8m.U7H);
    return cc.pLineIntersect(X, S, P, O, Z) ? (P = cc.p(H8m.U7H, H8m.U7H), P.x = X.x + H8m.X95(Z.x, (S.x - X.x)), P.y = X.y + H8m.D95(Z.x, (S.y - X.y)), P) : cc.p(H8m.U7H, H8m.U7H);
};
cc.pSameAs = function(X, S) {
    return H8m.c95(H8m.H6P, X) && H8m.z95(H8m.H6P, S) ? H8m.j95(X.x, S.x) && H8m.x95(X.y, S.y) : !H8m.h7H;
};
cc.pZeroIn = function(X) {
    X.x = H8m.U7H;
    X.y = H8m.U7H;
};
cc.pIn = function(X, S) {
    X.x = S.x;
    X.y = S.y;
};
cc.pMultIn = function(X, S) {
    X.x *= S;
    X.y *= S;
};
cc.pSubIn = function(X, S) {
    X.x -= S.x;
    X.y -= S.y;
};
cc.pAddIn = function(X, S) {
    X.x += S.x;
    X.y += S.y;
};
cc.pNormalizeIn = function(X) {
    cc.pMultIn(X, H8m.o95(H8m.h7H, Math.sqrt(X.x * X.x + X.y * X.y)));
};
cc.vertexLineToPolygon = function(X, S, P, O, Z) {
    Z += O;
    if (!(H8m.p95(H8m.h7H, Z))) {
        S *= H8m.E1S;
        for (var Y, T = H8m.Y95(Z, H8m.h7H), R = O; H8m.T95(R, Z); R++) {
            Y = H8m.R95(H8m.s7H, R);
            var E = cc.p(X[H8m.M95(H8m.s7H, R)], X[H8m.V95(H8m.s7H, R) + H8m.h7H]),
                V;
            if (H8m.s95(H8m.U7H, R))
                V = cc.pPerp(cc.pNormalize(cc.pSub(E, cc.p(X[H8m.U95(H8m.s7H, (R + H8m.h7H))], X[H8m.b95(H8m.s7H, (R + H8m.h7H)) + H8m.h7H]))));
            else if (H8m.F95(R, T))
                V = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(X[H8m.k15(H8m.s7H, (R - H8m.h7H))], X[H8m.L15(H8m.s7H, (R - H8m.h7H)) + H8m.h7H]), E)));
            else {
                V = cc.p(X[H8m.i15(H8m.s7H, (R - H8m.h7H))], X[H8m.S15(H8m.s7H, (R - H8m.h7H)) + H8m.h7H]);
                var U = cc.p(X[H8m.P15(H8m.s7H, (R + H8m.h7H))], X[H8m.a15(H8m.s7H, (R + H8m.h7H)) + H8m.h7H]),
                    k9 = cc.pNormalize(cc.pSub(U, E)),
                    L9 = cc.pNormalize(cc.pSub(V, E)),
                    K9 = Math.acos(cc.pDot(k9, L9));
                V = H8m.O15(K9, cc.DEGREES_TO_RADIANS(H8m.e8i)) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(k9, L9))) : H8m.B15(K9, cc.DEGREES_TO_RADIANS(H8m.u7S)) ? cc.pNormalize(cc.pMidpoint(k9, L9)) : cc.pPerp(cc.pNormalize(cc.pSub(U, V)));
            }
            V = cc.pMult(V, S);
            P[H8m.Z15(H8m.s7H, Y)] = E.x + V.x;
            P[H8m.J15(H8m.s7H, Y) + H8m.h7H] = E.y + V.y;
            P[H8m.n15(H8m.s7H, (Y + H8m.h7H))] = H8m.G15(E.x, V.x);
            P[H8m.W15(H8m.s7H, (Y + H8m.h7H)) + H8m.h7H] = H8m.v15(E.y, V.y);
        }
        for (R = H8m.u15(H8m.U7H, O) ? H8m.U7H : H8m.H15(O, H8m.h7H); H8m.f15(R, T); R++)
            Y = H8m.I15(H8m.s7H, R), X = Y + H8m.s7H, S = cc.Vertex2(P[H8m.g85(H8m.s7H, Y)], P[H8m.K85(H8m.s7H, Y) + H8m.h7H]), Z = cc.Vertex2(P[H8m.d85(H8m.s7H, (Y + H8m.h7H))], P[H8m.t85(H8m.s7H, (Y + H8m.h7H)) + H8m.h7H]), Y = cc.Vertex2(P[H8m.w85(H8m.s7H, X)], P[H8m.e85(H8m.s7H, X)]), O = cc.Vertex2(P[H8m.Q85(H8m.s7H, (X + H8m.h7H))], P[H8m.r85(H8m.s7H, (X + H8m.h7H)) + H8m.h7H]), S = !cc.vertexLineIntersect(S.x, S.y, O.x, O.y, Z.x, Z.y, Y.x, Y.y), !S.isSuccess && (H8m.N85(H8m.U7H, S.value) || H8m.m85(H8m.h7H, S.value)) && (S.isSuccess = !H8m.U7H), S.isSuccess && (P[H8m.A85(H8m.s7H, X)] = O.x, P[H8m.E85(H8m.s7H, X) + H8m.h7H] = O.y, P[H8m.C85(H8m.s7H, (X + H8m.h7H))] = Y.x, P[H8m.h85(H8m.s7H, (X + H8m.h7H)) + H8m.h7H] = Y.y);
    }
};
cc.vertexLineIntersect = function(X, S, P, O, Z, Y, T, R) {
    if (H8m.y85(X, P) && H8m.q85(S, O) || H8m.l85(Z, T) && H8m.X45(Y, R))
        return {
            isSuccess: !H8m.h7H,
            value: H8m.U7H
        };
    P -= X;
    O -= S;
    Z -= X;
    Y -= S;
    T -= X;
    R -= S;
    X = Math.sqrt(H8m.D45(P, P) + H8m.c45(O, O));
    P /= X;
    O /= X;
    S = H8m.z45(Z, P) + H8m.j45(Y, O);
    Y = H8m.x45(Y * P, Z * O);
    Z = S;
    S = H8m.o45(T, P) + H8m.p45(R, O);
    R = H8m.Y45(R * P, T * O);
    T = S;
    return H8m.T45(Y, R) ? {
        isSuccess: !H8m.h7H,
        value: H8m.U7H
    } : {
        isSuccess: !H8m.U7H,
        value: H8m.R45((T + (Z - T) * R / (R - Y)), X)
    };
};
cc.CGAffineToGL = function(X, S) {
    S[H8m.s7H] = S[H8m.v7H] = S[H8m.H7H] = S[H8m.y7H] = S[H8m.F7H] = S[H8m.f7H] = S[H8m.F9i] = S[H8m.f9i] = H8m.U7H;
    S[H8m.e1i] = S[H8m.u9i] = H8m.h7H;
    S[H8m.U7H] = X.a;
    S[H8m.q7H] = X.c;
    S[H8m.l9i] = X.tx;
    S[H8m.h7H] = X.b;
    S[H8m.b7H] = X.d;
    S[H8m.b9i] = X.ty;
};
cc.GLToCGAffine = function(X, S) {
    S.a = X[H8m.U7H];
    S.c = X[H8m.q7H];
    S.tx = X[H8m.l9i];
    S.b = X[H8m.h7H];
    S.d = X[H8m.b7H];
    S.ty = X[H8m.b9i];
};
cc.Touch = cc.Class.extend({
    _point: H8m.H6P,
    _prevPoint: H8m.H6P,
    _id: H8m.U7H,
    _startPointCaptured: !H8m.h7H,
    _startPoint: H8m.H6P,
    ctor: function(X, S, P) {
        this._point = cc.p(X || H8m.U7H, S || H8m.U7H);
        this._id = P || H8m.U7H;
    },
    getLocation: function() {
        return this._point;
    },
    getLocationX: function() {
        return this._point.x;
    },
    getLocationY: function() {
        return this._point.y;
    },
    getPreviousLocation: function() {
        return this._prevPoint;
    },
    getStartLocation: function() {
        return this._startPoint;
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint);
    },
    getLocationInView: function() {
        return this._point;
    },
    getPreviousLocationInView: function() {
        return this._prevPoint;
    },
    getStartLocationInView: function() {
        return this._startPoint;
    },
    getID: function() {
        return this._id;
    },
    getId: function() {
        return this._id;
    },
    setTouchInfo: function(X, S, P) {
        this._prevPoint = this._point;
        this._point = cc.p(S || H8m.U7H, P || H8m.U7H);
        this._id = X;
        this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !H8m.U7H);
    },
    _setPoint: function(X, S) {
        void H8m.U7H === S ? (this._point.x = X.x, this._point.y = X.y) : (this._point.x = X, this._point.y = S);
    },
    _setPrevPoint: function(X, S) {
        this._prevPoint = void H8m.U7H === S ? cc.p(X.x, X.y) : cc.p(X || H8m.U7H, S || H8m.U7H);
    }
});
H8m.N7(H8m.U7H);
H8m.T7(H8m.h7H);
cc.Event = cc.Class.extend({
    _type: H8m.U7H,
    _isStopped: !H8m.h7H,
    _currentTarget: H8m.H6P,
    _setCurrentTarget: function(X) {
        this._currentTarget = X;
    },
    ctor: function(X) {
        this._type = X;
    },
    getType: function() {
        return this._type;
    },
    stopPropagation: function() {
        this._isStopped = !H8m.U7H;
    },
    isStopped: function() {
        return this._isStopped;
    },
    getCurrentTarget: function() {
        return this._currentTarget;
    }
});
H8m.n7(H8m.U7H);
H8m.A7(H8m.h7H);
H8m.M7(H8m.s7H);
H8m.W7(H8m.v7H);
H8m.C7(H8m.q7H);
cc.EventAcceleration = cc.Event.extend({
    _acc: H8m.H6P,
    ctor: function(X) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = X;
    }
});
cc.EventCustom = cc.Event.extend({
    _eventName: H8m.H6P,
    _userData: H8m.H6P,
    ctor: function(X) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = X;
    },
    setUserData: function(X) {
        this._userData = X;
    },
    getUserData: function() {
        return this._userData;
    },
    getEventName: function() {
        return this._eventName;
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: H8m.U7H,
    _isPressed: !H8m.h7H,
    ctor: function(X, S) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = X;
        this._isPressed = S;
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(X) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = X;
    },
    setScrollData: function(X, S) {
        this._scrollX = X;
        this._scrollY = S;
    },
    getScrollX: function() {
        return this._scrollX;
    },
    getScrollY: function() {
        return this._scrollY;
    },
    setLocation: function(X, S) {
        this._x = X;
        this._y = S;
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        };
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: H8m.M45(cc.view._designResolutionSize.height, this._y)
        };
    },
    _setPrevCursor: function(X, S) {
        this._prevX = X;
        this._prevY = S;
    },
    getDelta: function() {
        return {
            x: H8m.V45(this._x, this._prevX),
            y: H8m.s45(this._y, this._prevY)
        };
    },
    getDeltaX: function() {
        return H8m.U45(this._x, this._prevX);
    },
    getDeltaY: function() {
        return H8m.b45(this._y, this._prevY);
    },
    setButton: function(X) {
        this._button = X;
    },
    getButton: function() {
        return this._button;
    },
    getLocationX: function() {
        return this._x;
    },
    getLocationY: function() {
        return this._y;
    }
});
H8m.s7(H8m.U7H);
H8m.u7(H8m.h7H);
H8m.y7(H8m.s7H);
H8m.b7(H8m.v7H);
H8m.F7(H8m.q7H);
H8m.I7(H8m.U7H);
H8m.X0(H8m.s7H);
H8m.L0(H8m.h7H);
H8m.K0(H8m.v7H);
H8m.c0(H8m.q7H);
H8m.S0(H8m.b7H);
H8m.t0(H8m.H7H);
H8m.j0(H8m.y7H);
cc.EventTouch = cc.Event.extend({
    _eventCode: H8m.U7H,
    _touches: H8m.H6P,
    ctor: function(X) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = X || [];
    },
    getEventCode: function() {
        return this._eventCode;
    },
    getTouches: function() {
        return this._touches;
    },
    _setEventCode: function(X) {
        this._eventCode = X;
    },
    _setTouches: function(X) {
        this._touches = X;
    }
});
H8m.a0(H8m.b7H);
cc.EventTouch.EventCode = {
    BEGAN: H8m.U7H,
    MOVED: H8m.h7H,
    ENDED: H8m.s7H,
    CANCELLED: H8m.v7H
};
cc.EventListener = cc.Class.extend({
    _onEvent: H8m.H6P,
    _type: H8m.U7H,
    _listenerID: H8m.H6P,
    _registered: !H8m.h7H,
    _fixedPriority: H8m.U7H,
    _node: H8m.H6P,
    _paused: !H8m.h7H,
    ctor: function(X, S, P) {
        this._onEvent = P;
        this._type = X || H8m.U7H;
        this._listenerID = S || H8m.u4S;
    },
    _setPaused: function(X) {
        this._paused = X;
    },
    _isPaused: function() {
        return this._paused;
    },
    _setRegistered: function(X) {
        this._registered = X;
    },
    _isRegistered: function() {
        return this._registered;
    },
    _getType: function() {
        return this._type;
    },
    _getListenerID: function() {
        return this._listenerID;
    },
    _setFixedPriority: function(X) {
        this._fixedPriority = X;
    },
    _getFixedPriority: function() {
        return this._fixedPriority;
    },
    _setSceneGraphPriority: function(X) {
        this._node = X;
    },
    _getSceneGraphPriority: function() {
        return this._node;
    },
    checkAvailable: function() {
        return H8m.F45(H8m.H6P, this._onEvent);
    },
    clone: function() {
        return H8m.H6P;
    },
    retain: function() {},
    release: function() {}
});
H8m.e0(H8m.U7H);
H8m.o0(H8m.h7H);
H8m.B0(H8m.s7H);
H8m.r0(H8m.v7H);
H8m.Y0(H8m.q7H);
H8m.J0(H8m.b7H);
H8m.m0(H8m.H7H);
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: H8m.H6P,
    ctor: function(S, P) {
        this._onCustomEvent = P;
        var O = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, S, function(X) {
            H8m.k75(H8m.H6P, O._onCustomEvent) && O._onCustomEvent(X);
        });
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && H8m.L75(H8m.H6P, this._onCustomEvent);
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
    }
});
cc._EventListenerCustom.create = function(X, S) {
    return new cc._EventListenerCustom(X, S);
};
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: H8m.H6P,
    ctor: function(S) {
        this._onAccelerationEvent = S;
        var P = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(X) {
            P._onAccelerationEvent(X._acc, X);
        });
    },
    checkAvailable: function() {
        var X = "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil";
        if (!this._onAccelerationEvent)
            throw X;
        return !H8m.U7H;
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent);
    }
});
H8m.R0(H8m.M0H);
cc._EventListenerAcceleration.create = function(X) {
    return new cc._EventListenerAcceleration(X);
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: H8m.H6P,
    onKeyReleased: H8m.H6P,
    ctor: function() {
        var S = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(X) {
            if (X._isPressed) {
                if (S.onKeyPressed)
                    S.onKeyPressed(X._keyCode, X);
            } else if (S.onKeyReleased)
                S.onKeyReleased(X._keyCode, X);
        });
    },
    clone: function() {
        var X = new cc._EventListenerKeyboard;
        X.onKeyPressed = this.onKeyPressed;
        X.onKeyReleased = this.onKeyReleased;
        return X;
    },
    checkAvailable: function() {
        var X = "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!";
        return H8m.i75(H8m.H6P, this.onKeyPressed) && H8m.S75(H8m.H6P, this.onKeyReleased) ? (cc.log(X), !H8m.h7H) : !H8m.U7H;
    }
});
H8m.G0(H8m.w6H);
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard;
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: H8m.H6P,
    onMouseUp: H8m.H6P,
    onMouseMove: H8m.H6P,
    onMouseScroll: H8m.H6P,
    ctor: function() {
        var P = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(X) {
            var S = cc.EventMouse;
            switch (X._eventType) {
            case S.DOWN:
                if (P.onMouseDown)
                    P.onMouseDown(X);
                break;
            case S.UP:
                if (P.onMouseUp)
                    P.onMouseUp(X);
                break;
            case S.MOVE:
                if (P.onMouseMove)
                    P.onMouseMove(X);
                break;
            case S.SCROLL:
                if (P.onMouseScroll)
                    P.onMouseScroll(X);
            }
        });
    },
    clone: function() {
        var X = new cc._EventListenerMouse;
        X.onMouseDown = this.onMouseDown;
        X.onMouseUp = this.onMouseUp;
        X.onMouseMove = this.onMouseMove;
        X.onMouseScroll = this.onMouseScroll;
        return X;
    },
    checkAvailable: function() {
        return !H8m.U7H;
    }
});
H8m.E0(H8m.C8S);
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse;
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: H8m.H6P,
    swallowTouches: !H8m.h7H,
    onTouchBegan: H8m.H6P,
    onTouchMoved: H8m.H6P,
    onTouchEnded: H8m.H6P,
    onTouchCancelled: H8m.H6P,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, H8m.H6P);
        this._claimedTouches = [];
    },
    setSwallowTouches: function(X) {
        this.swallowTouches = X;
    },
    clone: function() {
        var X = new cc._EventListenerTouchOneByOne;
        X.onTouchBegan = this.onTouchBegan;
        X.onTouchMoved = this.onTouchMoved;
        X.onTouchEnded = this.onTouchEnded;
        X.onTouchCancelled = this.onTouchCancelled;
        X.swallowTouches = this.swallowTouches;
        return X;
    },
    checkAvailable: function() {
        var X = "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!";
        return this.onTouchBegan ? !H8m.U7H : (cc.log(X), !H8m.h7H);
    }
});
H8m.V0(H8m.H0P);
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne;
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: H8m.H6P,
    onTouchesMoved: H8m.H6P,
    onTouchesEnded: H8m.H6P,
    onTouchesCancelled: H8m.H6P,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, H8m.H6P);
    },
    clone: function() {
        var X = new cc._EventListenerTouchAllAtOnce;
        X.onTouchesBegan = this.onTouchesBegan;
        X.onTouchesMoved = this.onTouchesMoved;
        X.onTouchesEnded = this.onTouchesEnded;
        X.onTouchesCancelled = this.onTouchesCancelled;
        return X;
    },
    checkAvailable: function() {
        var X = "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!";
        return H8m.P75(H8m.H6P, this.onTouchesBegan) && H8m.a75(H8m.H6P, this.onTouchesMoved) && H8m.O75(H8m.H6P, this.onTouchesEnded) && H8m.B75(H8m.H6P, this.onTouchesCancelled) ? (cc.log(X), !H8m.h7H) : !H8m.U7H;
    }
});
H8m.v0(H8m.S4P);
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce;
};
cc.EventListener.create = function(X) {
    var S = "Invalid parameter.";
    if (!X || !X.event)
        throw S;
    var P = X.event;
    delete X.event;
    var O = H8m.H6P;
    H8m.Z75(P, cc.EventListener.TOUCH_ONE_BY_ONE) ? O = new cc._EventListenerTouchOneByOne : H8m.J75(P, cc.EventListener.TOUCH_ALL_AT_ONCE) ? O = new cc._EventListenerTouchAllAtOnce : H8m.n75(P, cc.EventListener.MOUSE) ? O = new cc._EventListenerMouse : H8m.G75(P, cc.EventListener.CUSTOM) ? (O = new cc._EventListenerCustom(X.eventName, X.callback), delete X.eventName, delete X.callback) : H8m.W75(P, cc.EventListener.KEYBOARD) ? O = new cc._EventListenerKeyboard : H8m.v75(P, cc.EventListener.ACCELERATION) && (O = new cc._EventListenerAcceleration(X.callback), delete X.callback);
    for (var Z in X)
        O[Z] = X[Z];
    return O;
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = [];
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
    },
    empty: function() {
        return H8m.u75(0, this._fixedListeners.length) && H8m.H75(0, this._sceneGraphListeners.length);
    },
    push: function(X) {
        H8m.f75(0, X._getFixedPriority()) ? this._sceneGraphListeners.push(X) : this._fixedListeners.push(X);
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0;
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0;
    },
    clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners;
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners;
    }
});
cc.__getListenerID = function(X) {
    var S = "Invalid event type!",
        P = "Don't call this method if the event is for touch.",
        O = cc.Event;
    switch (X.getType()) {
    case O.ACCELERATION:
        return cc._EventListenerAcceleration.LISTENER_ID;
    case O.CUSTOM:
        return X.getEventName();
    case O.KEYBOARD:
        return cc._EventListenerKeyboard.LISTENER_ID;
    case O.MOUSE:
        return cc._EventListenerMouse.LISTENER_ID;
    case O.TOUCH:
        return cc.log(P), H8m.u4S;
    default:
        return cc.log(S), H8m.u4S;
    }
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !0,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(X) {
        H8m.I75(null, this._nodeListenersMap[X.__instanceId]) && this._dirtyNodes.push(X);
    },
    pauseTarget: function(X, S) {
        var P = this._nodeListenersMap[X.__instanceId],
            O,
            Z;
        if (P)
            for (O = 0, Z = P.length; H8m.g05(O, Z); O++)
                P[O]._setPaused(!0);
        if (!0 === S)
            for (P = X.getChildren(), O = 0, Z = P.length; H8m.K05(O, Z); O++)
                this.pauseTarget(P[O], !0);
    },
    resumeTarget: function(X, S) {
        var P = this._nodeListenersMap[X.__instanceId],
            O,
            Z;
        if (P)
            for (O = 0, Z = P.length; H8m.d05(O, Z); O++)
                P[O]._setPaused(!1);
        this._setDirtyForNode(X);
        if (!0 === S)
            for (P = X.getChildren(), O = 0, Z = P.length; H8m.t05(O, Z); O++)
                this.resumeTarget(P[O], !0);
    },
    _addListener: function(X) {
        H8m.w05(0, this._inDispatch) ? this._forceAddEventListener(X) : this._toAddedListeners.push(X);
    },
    _forceAddEventListener: function(X) {
        var S = X._getListenerID(),
            P = this._listenersMap[S];
        P || (P = new cc._EventListenerVector, this._listenersMap[S] = P);
        P.push(X);
        H8m.e05(0, X._getFixedPriority()) ? (this._setDirty(S, this.DIRTY_SCENE_GRAPH_PRIORITY), S = X._getSceneGraphPriority(), H8m.Q05(null, S) && cc.log("Invalid scene graph priority!"), this._associateNodeAndEventListener(S, X), S.isRunning() && this.resumeTarget(S)) : this._setDirty(S, this.DIRTY_FIXED_PRIORITY);
    },
    _getListeners: function(X) {
        return this._listenersMap[X];
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (H8m.r05(0, this._dirtyNodes.length)) {
            for (var X = this._dirtyNodes, S, P, O = this._nodeListenersMap, Z = 0, Y = X.length; H8m.N05(Z, Y); Z++)
                if (S = O[X[Z].__instanceId])
                    for (var T = 0, R = S.length; H8m.m05(T, R); T++)
                        (P = S[T]) && this._setDirty(P._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0;
        }
    },
    _removeAllListenersInVector: function(X) {
        if (X)
            for (var S, P = 0; H8m.A05(P, X.length);)
                S = X[P], S._setRegistered(!1), H8m.E05(null, S._getSceneGraphPriority()) && this._dissociateNodeAndEventListener(S._getSceneGraphPriority(), S), H8m.C05(0, this._inDispatch) ? cc.arrayRemoveObject(X, S) : ++P;
    },
    _removeListenersForListenerID: function(X) {
        var S = this._listenersMap[X];
        if (S) {
            var P = S.getFixedPriorityListeners(),
                O = S.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(O);
            this._removeAllListenersInVector(P);
            delete this._priorityDirtyFlagMap[X];
            this._inDispatch || (S.clear(), delete this._listenersMap[X]);
        }
        P = this._toAddedListeners;
        for (S = 0; H8m.h05(S, P.length);)
            (O = P[S]) && H8m.y05(O._getListenerID(), X) ? cc.arrayRemoveObject(P, O) : ++S;
    },
    _sortEventListeners: function(X) {
        var S = this.DIRTY_NONE;
        this._priorityDirtyFlagMap[X] && (S = this._priorityDirtyFlagMap[X]);
        H8m.q05(S, this.DIRTY_NONE) && (H8m.l05(S, this.DIRTY_FIXED_PRIORITY) && this._sortListenersOfFixedPriority(X), H8m.X35(S, this.DIRTY_SCENE_GRAPH_PRIORITY) && this._sortListenersOfSceneGraphPriority(X), this._priorityDirtyFlagMap[X] = this.DIRTY_NONE);
    },
    _sortListenersOfSceneGraphPriority: function(X) {
        if (X = this._getListeners(X)) {
            var S = X.getSceneGraphPriorityListeners();
            S && H8m.D35(0, S.length) && (S = cc.director.getRunningScene(), this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(S, !0), X.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes));
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(X, S) {
        var P = cc.eventManager._nodePriorityMap;
        return H8m.c35(P[S._getSceneGraphPriority().__instanceId], P[X._getSceneGraphPriority().__instanceId]);
    },
    _sortListenersOfFixedPriority: function(X) {
        if (X = this._listenersMap[X]) {
            var S = X.getFixedPriorityListeners();
            if (S && H8m.z35(0, S.length)) {
                S.sort(this._sortListenersOfFixedPriorityAsc);
                for (var P = 0, O = S.length; H8m.j35(P, O) && !(H8m.x35(0, S[P]._getFixedPriority()));)
                    ++P;
                X.gt0Index = P;
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(X, S) {
        return H8m.o35(X._getFixedPriority(), S._getFixedPriority());
    },
    _onUpdateListeners: function(X) {
        if (X = this._listenersMap[X]) {
            var S = X.getFixedPriorityListeners(),
                P = X.getSceneGraphPriorityListeners(),
                O,
                Z;
            if (P)
                for (O = 0; H8m.p35(O, P.length);)
                    Z = P[O], Z._isRegistered() ? ++O : cc.arrayRemoveObject(P, Z);
            if (S)
                for (O = 0; H8m.Y35(O, S.length);)
                    Z = S[O], Z._isRegistered() ? ++O : cc.arrayRemoveObject(S, Z);
            P && H8m.T35(0, P.length) && X.clearSceneGraphListeners();
            S && H8m.R35(0, S.length) && X.clearFixedListeners();
        }
    },
    _updateListeners: function(X) {
        var S = this._inDispatch;
        cc.assert(H8m.M35(0, S), "If program goes here, there should be event in dispatch.");
        H8m.V35(X.getType(), cc.Event.TOUCH) ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(X));
        if (!(H8m.s35(1, S))) {
            cc.assert(H8m.U35(1, S), "_inDispatch should be 1 here.");
            X = this._listenersMap;
            var S = this._priorityDirtyFlagMap,
                P;
            for (P in X)
                X[P].empty() && (delete S[P], delete X[P]);
            P = this._toAddedListeners;
            if (H8m.b35(0, P.length)) {
                X = 0;
                for (S = P.length; H8m.F35(X, S); X++)
                    this._forceAddEventListener(P[X]);
                this._toAddedListeners.length = 0;
            }
        }
    },
    _onTouchEventCallback: function(X, S) {
        if (!X._isRegistered)
            return !1;
        var P = S.event,
            O = S.selTouch;
        P._setCurrentTarget(X._node);
        var Z = !1,
            Y,
            T = P.getEventCode(),
            R = cc.EventTouch.EventCode;
        if (H8m.k55(T, R.BEGAN))
            X.onTouchBegan && (Z = X.onTouchBegan(O, P)) && X._registered && X._claimedTouches.push(O);
        else if (H8m.L55(0, X._claimedTouches.length) && -1 != (Y = X._claimedTouches.indexOf(O)))
            switch (Z = !0, T) {
            case R.MOVED:
                if (X.onTouchMoved)
                    X.onTouchMoved(O, P);
                break;
            case R.ENDED:
                if (X.onTouchEnded)
                    X.onTouchEnded(O, P);
                X._registered && X._claimedTouches.splice(Y, 1);
                break;
            case R.CANCELLED:
                if (X.onTouchCancelled)
                    X.onTouchCancelled(O, P);
                X._registered && X._claimedTouches.splice(Y, 1);
                break;
            default:
                cc.log("The event code is invalid.");
            }
        return P.isStopped() ? (cc.eventManager._updateListeners(P), !0) : Z && X._registered && X.swallowTouches ? (S.needsMutableSet && S.touches.splice(O, 1), !0) : !1;
    },
    _dispatchTouchEvent: function(X) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var S = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            P = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (H8m.i55(null, S) || H8m.S55(null, P)) {
            var O = X.getTouches(),
                Z = cc.copyArray(O),
                Y = {
                    event: X,
                    needsMutableSet: S && P,
                    touches: Z,
                    selTouch: null
                };
            if (S)
                for (var T = 0; H8m.P55(T, O.length); T++)
                    if (Y.selTouch = O[T], this._dispatchEventToListeners(S, this._onTouchEventCallback, Y), X.isStopped())
                        return;
            if (P && H8m.a55(0, Z.length) && (this._dispatchEventToListeners(P, this._onTouchesEventCallback, {
                event: X,
                touches: Z
            }), X.isStopped()))
                return;
            this._updateListeners(X);
        }
    },
    _onTouchesEventCallback: function(X, S) {
        if (!X._registered)
            return !1;
        var P = cc.EventTouch.EventCode,
            O = S.event,
            Z = S.touches;
        O._setCurrentTarget(X._node);
        switch (O.getEventCode()) {
        case P.BEGAN:
            if (X.onTouchesBegan)
                X.onTouchesBegan(Z, O);
            break;
        case P.MOVED:
            if (X.onTouchesMoved)
                X.onTouchesMoved(Z, O);
            break;
        case P.ENDED:
            if (X.onTouchesEnded)
                X.onTouchesEnded(Z, O);
            break;
        case P.CANCELLED:
            if (X.onTouchesCancelled)
                X.onTouchesCancelled(Z, O);
            break;
        default:
            cc.log("The event code is invalid.");
        }
        return O.isStopped() ? (cc.eventManager._updateListeners(O), !0) : !1;
    },
    _associateNodeAndEventListener: function(X, S) {
        var P = this._nodeListenersMap[X.__instanceId];
        P || (P = [], this._nodeListenersMap[X.__instanceId] = P);
        P.push(S);
    },
    _dissociateNodeAndEventListener: function(X, S) {
        var P = this._nodeListenersMap[X.__instanceId];
        P && (cc.arrayRemoveObject(P, S), H8m.O55(0, P.length) && delete this._nodeListenersMap[X.__instanceId]);
    },
    _dispatchEventToListeners: function(X, S, P) {
        var O = !1,
            Z = X.getFixedPriorityListeners(),
            Y = X.getSceneGraphPriorityListeners(),
            T = 0,
            R;
        if (Z && H8m.B55(0, Z.length))
            for (; H8m.Z55(T, X.gt0Index); ++T)
                if (R = Z[T], !R._isPaused() && R._isRegistered() && S(R, P)) {
                    O = !0;
                    break;
                }
        if (Y && !O)
            for (X = 0; H8m.J55(X, Y.length); X++)
                if (R = Y[X], !R._isPaused() && R._isRegistered() && S(R, P)) {
                    O = !0;
                    break;
                }
        if (Z && !O)
            for (; H8m.n55(T, Z.length) && (R = Z[T], R._isPaused() || !R._isRegistered() || !S(R, P)); ++T)
                ;
    },
    _setDirty: function(X, S) {
        var P = this._priorityDirtyFlagMap;
        P[X] = H8m.G55(null, P[X]) ? S : H8m.W55(S, P[X]);
    },
    _visitTarget: function(X, S) {
        var P = 0,
            O = X.getChildren(),
            Z = O.length,
            Y = this._globalZOrderNodeMap,
            T = this._nodeListenersMap;
        if (H8m.v55(0, Z)) {
            for (var R; H8m.u55(P, Z); P++)
                if ((R = O[P]) && H8m.H55(0, R.getLocalZOrder()))
                    this._visitTarget(R, !1);
                else
                    break;
            H8m.f55(null, T[X.__instanceId]) && (Y[X.getGlobalZOrder()] || (Y[X.getGlobalZOrder()] = []), Y[X.getGlobalZOrder()].push(X.__instanceId));
            for (; H8m.I55(P, Z); P++)
                (R = O[P]) && this._visitTarget(R, !1);
        } else
            H8m.g65(null, T[X.__instanceId]) && (Y[X.getGlobalZOrder()] || (Y[X.getGlobalZOrder()] = []), Y[X.getGlobalZOrder()].push(X.__instanceId));
        if (S) {
            var O = [],
                E;
            for (E in Y)
                O.push(E);
            O.sort(this._sortNumberAsc);
            E = O.length;
            R = this._nodePriorityMap;
            for (P = 0; H8m.K65(P, E); P++)
                for (Z = Y[O[P]], T = 0; H8m.d65(T, Z.length); T++)
                    R[Z[T]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {};
        }
    },
    _sortNumberAsc: function(X, S) {
        return H8m.t65(X, S);
    },
    addListener: function(X, S) {
        if (!X || !S)
            throw "Invalid parameters.";
        if (!(H8m.w65(X, cc.EventListener))) {
            if ("number" === typeof S)
                throw "listener must be a cc.EventListener object when adding a fixed priority listener";
            X = cc.EventListener.create(X);
        } else if (X._isRegistered())
            throw "The listener has been registered.";
        X.checkAvailable() && ("number" == typeof S ? H8m.e65(0, S) ? cc.log("0 priority is forbidden for fixed priority since it's used for scene graph based priority.") : (X._setSceneGraphPriority(null), X._setFixedPriority(S), X._setRegistered(!0), X._setPaused(!1), this._addListener(X)) : (X._setSceneGraphPriority(S), X._setFixedPriority(0), X._setRegistered(!0), this._addListener(X)));
    },
    addCustomListener: function(X, S) {
        var P = cc._EventListenerCustom.create(X, S);
        this.addListener(P, 1);
        return P;
    },
    removeListener: function(X) {
        if (H8m.Q65(null, X)) {
            var S,
                P = this._listenersMap,
                O;
            for (O in P) {
                var Z = P[O],
                    Y = Z.getFixedPriorityListeners();
                S = Z.getSceneGraphPriorityListeners();
                (S = this._removeListenerInVector(S, X)) ? this._setDirty(X._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (S = this._removeListenerInVector(Y, X)) && this._setDirty(X._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                Z.empty() && (delete this._priorityDirtyFlagMap[X._getListenerID()], delete P[O]);
                if (S)
                    break;
            }
            if (!S)
                for (P = this._toAddedListeners, O = 0, Z = P.length; H8m.r65(O, Z); O++)
                    if (Y = P[O], H8m.N65(Y, X)) {
                        cc.arrayRemoveObject(P, Y);
                        break;
                    }
        }
    },
    _removeListenerInVector: function(X, S) {
        if (H8m.m65(null, X))
            return !1;
        for (var P = 0, O = X.length; H8m.A65(P, O); P++) {
            var Z = X[P];
            if (H8m.E65(Z, S))
                return Z._setRegistered(!1), H8m.C65(null, Z._getSceneGraphPriority()) && this._dissociateNodeAndEventListener(Z._getSceneGraphPriority(), Z), H8m.h65(0, this._inDispatch) && cc.arrayRemoveObject(X, Z), !0;
        }
        return !1;
    },
    removeListeners: function(X, S) {
        if (H8m.y65(X, cc.Node)) {
            var P = this._nodeListenersMap[X.__instanceId];
            if (P) {
                for (var P = cc.copyArray(P), O = 0; H8m.q65(O, P.length); O++)
                    this.removeListener(P[O]);
                P.length = 0;
            }
        } else
            H8m.l65(X, cc.EventListener.TOUCH_ONE_BY_ONE) ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : H8m.X25(X, cc.EventListener.TOUCH_ALL_AT_ONCE) ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : H8m.D25(X, cc.EventListener.MOUSE) ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : H8m.c25(X, cc.EventListener.ACCELERATION) ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : H8m.z25(X, cc.EventListener.KEYBOARD) ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log("Invalid listener type!");
    },
    removeCustomListeners: function(X) {
        this._removeListenersForListenerID(X);
    },
    removeAllListeners: function() {
        var X = this._listenersMap,
            S = this._internalCustomListenerIDs,
            P;
        for (P in X)
            -1 === S.indexOf(P) && this._removeListenersForListenerID(P);
    },
    setPriority: function(X, S) {
        if (H8m.j25(null, X)) {
            var P = this._listenersMap,
                O;
            for (O in P) {
                var Z = P[O].getFixedPriorityListeners();
                if (Z && -1 != Z.indexOf(X)) {
                    H8m.x25(null, X._getSceneGraphPriority()) && cc.log("Can't set fixed priority with scene graph based listener.");
                    H8m.o25(X._getFixedPriority(), S) && (X._setFixedPriority(S), this._setDirty(X._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break;
                }
            }
        }
    },
    setEnabled: function(X) {
        this._isEnabled = X;
    },
    isEnabled: function() {
        return this._isEnabled;
    },
    dispatchEvent: function(X) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (H8m.p25(X.getType(), cc.Event.TOUCH))
                this._dispatchTouchEvent(X);
            else {
                var S = cc.__getListenerID(X);
                this._sortEventListeners(S);
                S = this._listenersMap[S];
                H8m.Y25(null, S) && this._dispatchEventToListeners(S, this._onListenerCallback, X);
                this._updateListeners(X);
            }
            this._inDispatch--;
        }
    },
    _onListenerCallback: function(X, S) {
        S._setCurrentTarget(X._getSceneGraphPriority());
        X._onEvent(S);
        return S.isStopped();
    },
    dispatchCustomEvent: function(X, S) {
        var P = new cc.EventCustom(X);
        P.setUserData(S);
        this.dispatchEvent(P);
    }
};
H8m.h0();
H8m.u0(H8m.H6P);
H8m.y0(H8m.H6P);
H8m.q0(H8m.h7H);
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !0,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._children = [];
        this._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var X = cc.director;
        this._actionManager = X.getActionManager();
        this._scheduler = X.getScheduler();
        this._initializedNode = !0;
        this._additionalTransform = cc.AffineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
    },
    init: function() {
        !1 === this._initializedNode && this._initNode();
        return !0;
    },
    _arrayMakeObjectsPerformSelector: function(X, S) {
        if (X && H8m.T25(0, X.length)) {
            var P,
                O = X.length,
                Z;
            P = cc.Node.StateCallbackType;
            switch (S) {
            case P.onEnter:
                for (P = 0; H8m.R25(P, O); P++)
                    if (Z = X[P])
                        Z.onEnter();
                break;
            case P.onExit:
                for (P = 0; H8m.M25(P, O); P++)
                    if (Z = X[P])
                        Z.onExit();
                break;
            case P.onEnterTransitionDidFinish:
                for (P = 0; H8m.V25(P, O); P++)
                    if (Z = X[P])
                        Z.onEnterTransitionDidFinish();
                break;
            case P.cleanup:
                for (P = 0; H8m.s25(P, O); P++)
                    (Z = X[P]) && Z.cleanup();
                break;
            case P.updateTransform:
                for (P = 0; H8m.U25(P, O); P++)
                    (Z = X[P]) && Z.updateTransform();
                break;
            case P.onExitTransitionDidStart:
                for (P = 0; H8m.b25(P, O); P++)
                    if (Z = X[P])
                        Z.onExitTransitionDidStart();
                break;
            case P.sortAllChildren:
                for (P = 0; H8m.F25(P, O); P++)
                    (Z = X[P]) && Z.sortAllChildren();
                break;
            default:
                throw "Unknown callback function";
            }
        }
    },
    setNodeDirty: null,
    _setNodeDirtyForCanvas: function() {
        this._setNodeDirtyForCache();
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0);
    },
    _setNodeDirtyForWebGL: function() {
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0);
    },
    attr: function(X) {
        for (var S in X)
            this[S] = X[S];
    },
    getSkewX: function() {
        return this._skewX;
    },
    setSkewX: function(X) {
        this._skewX = X;
        this.setNodeDirty();
    },
    getSkewY: function() {
        return this._skewY;
    },
    setSkewY: function(X) {
        this._skewY = X;
        this.setNodeDirty();
    },
    setLocalZOrder: function(X) {
        this._localZOrder = X;
        this._parent && this._parent.reorderChild(this, X);
        cc.eventManager._setDirtyForNode(this);
    },
    _setLocalZOrder: function(X) {
        this._localZOrder = X;
    },
    getLocalZOrder: function() {
        return this._localZOrder;
    },
    getZOrder: function() {
        cc.log("getZOrder is deprecated. Please use getLocalZOrder instead.");
        return this.getLocalZOrder();
    },
    setZOrder: function(X) {
        cc.log("setZOrder is deprecated. Please use setLocalZOrder instead.");
        this.setLocalZOrder(X);
    },
    setGlobalZOrder: function(X) {
        H8m.k9h(this._globalZOrder, X) && (this._globalZOrder = X, cc.eventManager._setDirtyForNode(this));
    },
    getGlobalZOrder: function() {
        return this._globalZOrder;
    },
    getVertexZ: function() {
        return this._vertexZ;
    },
    setVertexZ: function(X) {
        this._vertexZ = X;
    },
    getRotation: function() {
        H8m.L9h(this._rotationX, this._rotationY) && cc.log("cc.Node.rotation(): RotationX !\x3d RotationY. Don't know which one to return");
        return this._rotationX;
    },
    setRotation: function(X) {
        this._rotationX = this._rotationY = X;
        this._rotationRadiansX = H8m.i9h(0.017453292519943295, this._rotationX);
        this._rotationRadiansY = H8m.S9h(0.017453292519943295, this._rotationY);
        this.setNodeDirty();
    },
    getRotationX: function() {
        return this._rotationX;
    },
    setRotationX: function(X) {
        this._rotationX = X;
        this._rotationRadiansX = H8m.P9h(0.017453292519943295, this._rotationX);
        this.setNodeDirty();
    },
    getRotationY: function() {
        return this._rotationY;
    },
    setRotationY: function(X) {
        this._rotationY = X;
        this._rotationRadiansY = H8m.a9h(0.017453292519943295, this._rotationY);
        this.setNodeDirty();
    },
    getScale: function() {
        H8m.O9h(this._scaleX, this._scaleY) && cc.log("cc.Node.getScale(): ScaleX !\x3d ScaleY. Don't know which one to return");
        return this._scaleX;
    },
    setScale: function(X, S) {
        this._scaleX = X;
        this._scaleY = S || H8m.B9h(0, S) ? S : X;
        this.setNodeDirty();
    },
    getScaleX: function() {
        return this._scaleX;
    },
    setScaleX: function(X) {
        this._scaleX = X;
        this.setNodeDirty();
    },
    getScaleY: function() {
        return this._scaleY;
    },
    setScaleY: function(X) {
        this._scaleY = X;
        this.setNodeDirty();
    },
    setPosition: function(X, S) {
        var P = this._position;
        void 0 === S ? (P.x = X.x, P.y = X.y) : (P.x = X, P.y = S);
        this.setNodeDirty();
    },
    getPosition: function() {
        return this._position;
    },
    getPositionX: function() {
        return this._position.x;
    },
    setPositionX: function(X) {
        this._position.x = X;
        this.setNodeDirty();
    },
    getPositionY: function() {
        return this._position.y;
    },
    setPositionY: function(X) {
        this._position.y = X;
        this.setNodeDirty();
    },
    getChildrenCount: function() {
        return this._children.length;
    },
    getChildren: function() {
        return this._children;
    },
    isVisible: function() {
        return this._visible;
    },
    setVisible: function(X) {
        this._visible = X;
        this.setNodeDirty();
    },
    getAnchorPoint: function() {
        return this._anchorPoint;
    },
    setAnchorPoint: function(X, S) {
        var P = this._anchorPoint;
        if (void 0 === S) {
            if (H8m.Z9h(X.x, P.x) && H8m.J9h(X.y, P.y))
                return;
            P.x = X.x;
            P.y = X.y;
        } else {
            if (H8m.n9h(X, P.x) && H8m.G9h(S, P.y))
                return;
            P.x = X;
            P.y = S;
        }
        var O = this._anchorPointInPoints,
            Z = this._contentSize;
        O.x = H8m.W9h(Z.width, P.x);
        O.y = H8m.v9h(Z.height, P.y);
        this.setNodeDirty();
    },
    _getAnchor: function() {
        return this._anchorPoint;
    },
    _setAnchor: function(X) {
        var S = X.x;
        X = X.y;
        H8m.u9h(this._anchorPoint.x, S) && (this._anchorPoint.x = S, this._anchorPointInPoints.x = H8m.H9h(this._contentSize.width, S));
        H8m.f9h(this._anchorPoint.y, X) && (this._anchorPoint.y = X, this._anchorPointInPoints.y = H8m.I9h(this._contentSize.height, X));
        this.setNodeDirty();
    },
    _getAnchorX: function() {
        return this._anchorPoint.x;
    },
    _setAnchorX: function(X) {
        H8m.g1h(this._anchorPoint.x, X) && (this._anchorPoint.x = X, this._anchorPointInPoints.x = H8m.K1h(this._contentSize.width, X), this.setNodeDirty());
    },
    _getAnchorY: function() {
        return this._anchorPoint.y;
    },
    _setAnchorY: function(X) {
        H8m.d1h(this._anchorPoint.y, X) && (this._anchorPoint.y = X, this._anchorPointInPoints.y = H8m.t1h(this._contentSize.height, X), this.setNodeDirty());
    },
    getAnchorPointInPoints: function() {
        return this._anchorPointInPoints;
    },
    _getWidth: function() {
        return this._contentSize.width;
    },
    _setWidth: function(X) {
        this._contentSize.width = X;
        this._anchorPointInPoints.x = H8m.w1h(X, this._anchorPoint.x);
        this.setNodeDirty();
    },
    _getHeight: function() {
        return this._contentSize.height;
    },
    _setHeight: function(X) {
        this._contentSize.height = X;
        this._anchorPointInPoints.y = H8m.e1h(X, this._anchorPoint.y);
        this.setNodeDirty();
    },
    getContentSize: function() {
        return this._contentSize;
    },
    setContentSize: function(X, S) {
        var P = this._contentSize;
        if (void 0 === S) {
            if (H8m.Q1h(X.width, P.width) && H8m.r1h(X.height, P.height))
                return;
            P.width = X.width;
            P.height = X.height;
        } else {
            if (H8m.N1h(X, P.width) && H8m.m1h(S, P.height))
                return;
            P.width = X;
            P.height = S;
        }
        var O = this._anchorPointInPoints,
            Z = this._anchorPoint;
        O.x = H8m.A1h(P.width, Z.x);
        O.y = H8m.E1h(P.height, Z.y);
        this.setNodeDirty();
    },
    isRunning: function() {
        return this._running;
    },
    getParent: function() {
        return this._parent;
    },
    setParent: function(X) {
        this._parent = X;
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition;
    },
    ignoreAnchorPointForPosition: function(X) {
        H8m.C1h(X, this._ignoreAnchorPointForPosition) && (this._ignoreAnchorPointForPosition = X, this.setNodeDirty());
    },
    getTag: function() {
        return this.tag;
    },
    setTag: function(X) {
        this.tag = X;
    },
    getUserData: function() {
        return this.userData;
    },
    setUserData: function(X) {
        this.userData = X;
    },
    getUserObject: function() {
        return this.userObject;
    },
    setUserObject: function(X) {
        H8m.h1h(this.userObject, X) && (this.userObject = X);
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder;
    },
    setOrderOfArrival: function(X) {
        this.arrivalOrder = X;
    },
    getActionManager: function() {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager;
    },
    setActionManager: function(X) {
        H8m.y1h(this._actionManager, X) && (this.stopAllActions(), this._actionManager = X);
    },
    getScheduler: function() {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler;
    },
    setScheduler: function(X) {
        H8m.q1h(this._scheduler, X) && (this.unscheduleAllCallbacks(), this._scheduler = X);
    },
    getBoundingBox: function() {
        var X = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._RectApplyAffineTransformIn(X, this.nodeToParentTransform());
    },
    cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup);
    },
    getChildByTag: function(X) {
        var S = this._children;
        if (H8m.l1h(null, S))
            for (var P = 0; H8m.X8h(P, S.length); P++) {
                var O = S[P];
                if (O && H8m.D8h(O.tag, X))
                    return O;
            }
        return null;
    },
    addChild: function(X, S, P) {
        if (!X)
            throw "cc.Node.addChild(): child must be non-null";
        if (H8m.c8h(X, this))
            cc.log("cc.Node.addChild(): An Node can't be added as a child of itself.");
        else if (H8m.z8h(null, X._parent))
            cc.log("cc.Node.addChild(): child already added. It can't be added again");
        else if (S = H8m.j8h(null, S) ? S : X._localZOrder, X.tag = H8m.x8h(null, P) ? P : X.tag, this._insertChild(X, S), X._parent = this, this._cachedParent && (X._cachedParent = this._cachedParent), this._running && (X.onEnter(), this._isTransitionFinished))
            X.onEnterTransitionDidFinish();
    },
    removeFromParent: function(X) {
        this._parent && (H8m.o8h(null, X) && (X = !0), this._parent.removeChild(this, X));
    },
    removeFromParentAndCleanup: function(X) {
        cc.log("removeFromParentAndCleanup is deprecated. Use removeFromParent instead");
        this.removeFromParent(X);
    },
    removeChild: function(X, S) {
        H8m.p8h(0, this._children.length) && (H8m.Y8h(null, S) && (S = !0), -1 < this._children.indexOf(X) && this._detachChild(X, S), this.setNodeDirty());
    },
    removeChildByTag: function(X, S) {
        H8m.T8h(X, cc.NODE_TAG_INVALID) && cc.log("cc.Node.removeChildByTag(): argument tag is an invalid tag");
        var P = this.getChildByTag(X);
        H8m.R8h(null, P) ? cc.log("cocos2d: removeChildByTag(tag \x3d " + X + "): child not found!") : this.removeChild(P, S);
    },
    removeAllChildrenWithCleanup: function(X) {
        cc.log("removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead");
        this.removeAllChildren(X);
    },
    removeAllChildren: function(X) {
        var S = this._children;
        if (H8m.M8h(null, S)) {
            H8m.V8h(null, X) && (X = !0);
            for (var P = 0; H8m.s8h(P, S.length); P++) {
                var O = S[P];
                O && (this._running && (O.onExitTransitionDidStart(), O.onExit()), X && O.cleanup(), O.parent = null);
            }
            this._children.length = 0;
        }
    },
    _detachChild: function(X, S) {
        this._running && (X.onExitTransitionDidStart(), X.onExit());
        S && X.cleanup();
        X.parent = null;
        cc.arrayRemoveObject(this._children, X);
    },
    _insertChild: function(X, S) {
        this._reorderChildDirty = !0;
        this._children.push(X);
        X._setLocalZOrder(S);
    },
    reorderChild: function(X, S) {
        if (!X)
            throw "cc.Node.reorderChild(): child must be non-null";
        this._reorderChildDirty = !0;
        X.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        X._setLocalZOrder(S);
        this.setNodeDirty();
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var X = this._children,
                S,
                P,
                O = X.length,
                Z;
            for (S = 0; H8m.U8h(S, O); S++) {
                var Y = X[S];
                P = H8m.b8h(S, 1);
                for (Z = X[P]; H8m.F8h(0, P) && (H8m.k4h(Y._localZOrder, Z._localZOrder) || H8m.L4h(Y._localZOrder, Z._localZOrder) && H8m.i4h(Y.arrivalOrder, Z.arrivalOrder));)
                    X[P + 1] = Z, P -= 1, Z = X[P];
                X[P + 1] = Y;
            }
            this._reorderChildDirty = !1;
        }
    },
    draw: function(X) {},
    transformAncestors: function() {
        H8m.S4h(null, this._parent) && (this._parent.transformAncestors(), this._parent.transform());
    },
    onEnter: function() {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resume();
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish);
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart);
    },
    onExit: function() {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit);
        this._componentContainer && this._componentContainer.removeAll();
    },
    runAction: function(X) {
        if (!X)
            throw "cc.Node.runAction(): action must be non-null";
        this.actionManager.addAction(X, this, !this._running);
        return X;
    },
    stopAllActions: function() {
        this.actionManager.removeAllActionsFromTarget(this);
    },
    stopAction: function(X) {
        this.actionManager.removeAction(X);
    },
    stopActionByTag: function(X) {
        H8m.P4h(X, cc.ACTION_TAG_INVALID) ? cc.log("cc.Node.stopActionBy(): argument tag an invalid tag") : this.actionManager.removeActionByTag(X, this);
    },
    getActionByTag: function(X) {
        return H8m.a4h(X, cc.ACTION_TAG_INVALID) ? (cc.log("cc.Node.getActionByTag(): argument tag is an invalid tag"), null) : this.actionManager.getActionByTag(X, this);
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this);
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0);
    },
    scheduleUpdateWithPriority: function(X) {
        this.scheduler.scheduleUpdateForTarget(this, X, !this._running);
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this);
    },
    schedule: function(X, S, P, O) {
        S = S || 0;
        if (!X)
            throw "cc.Node.schedule(): callback function must be non-null";
        if (H8m.O4h(0, S))
            throw "cc.Node.schedule(): interval must be positive";
        P = H8m.B4h(null, P) ? cc.REPEAT_FOREVER : P;
        this.scheduler.scheduleCallbackForTarget(this, X, S, P, O || 0, !this._running);
    },
    scheduleOnce: function(X, S) {
        this.schedule(X, 0, 0, S);
    },
    unschedule: function(X) {
        X && this.scheduler.unscheduleCallbackForTarget(this, X);
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this);
    },
    resumeSchedulerAndActions: function() {
        cc.log("resumeSchedulerAndActions is deprecated, please use resume instead.");
        this.resume();
    },
    resume: function() {
        this.scheduler.resumeTarget(this);
        this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this);
    },
    pauseSchedulerAndActions: function() {
        cc.log("pauseSchedulerAndActions is deprecated, please use pause instead.");
        this.pause();
    },
    pause: function() {
        this.scheduler.pauseTarget(this);
        this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this);
    },
    setAdditionalTransform: function(X) {
        this._additionalTransform = X;
        this._additionalTransformDirty = this._transformDirty = !0;
    },
    parentToNodeTransform: function() {
        this._inverseDirty && (this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform()), this._inverseDirty = !1);
        return this._inverse;
    },
    nodeToWorldTransform: function() {
        for (var X = this.nodeToParentTransform(), S = this._parent; H8m.Z4h(null, S); S = S.parent)
            X = cc.AffineTransformConcat(X, S.nodeToParentTransform());
        return X;
    },
    worldToNodeTransform: function() {
        return cc.AffineTransformInvert(this.nodeToWorldTransform());
    },
    convertToNodeSpace: function(X) {
        return cc.PointApplyAffineTransform(X, this.worldToNodeTransform());
    },
    convertToWorldSpace: function(X) {
        return cc.PointApplyAffineTransform(X, this.nodeToWorldTransform());
    },
    convertToNodeSpaceAR: function(X) {
        return cc.pSub(this.convertToNodeSpace(X), this._anchorPointInPoints);
    },
    convertToWorldSpaceAR: function(X) {
        X = cc.pAdd(X, this._anchorPointInPoints);
        return this.convertToWorldSpace(X);
    },
    _convertToWindowSpace: function(X) {
        X = this.convertToWorldSpace(X);
        return cc.director.convertToUI(X);
    },
    convertTouchToNodeSpace: function(X) {
        X = X.getLocation();
        return this.convertToNodeSpace(X);
    },
    convertTouchToNodeSpaceAR: function(X) {
        X = X.getLocation();
        X = cc.director.convertToGL(X);
        return this.convertToNodeSpaceAR(X);
    },
    update: function(X) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(X);
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
    },
    retain: function() {},
    release: function() {},
    getComponent: function(X) {
        return this._componentContainer.getComponent(X);
    },
    addComponent: function(X) {
        this._componentContainer.add(X);
    },
    removeComponent: function(X) {
        return this._componentContainer.remove(X);
    },
    removeAllComponents: function() {
        this._componentContainer.removeAll();
    },
    _transform4x4: null,
    _stackMatrix: null,
    _glServerState: null,
    _camera: null,
    grid: null,
    ctor: null,
    _ctorForCanvas: function() {
        this._initNode();
    },
    _ctorForWebGL: function() {
        this._initNode();
        var X = new cc.kmMat4;
        X.mat[2] = X.mat[3] = X.mat[6] = X.mat[7] = X.mat[8] = X.mat[9] = X.mat[11] = X.mat[14] = 0;
        X.mat[10] = X.mat[15] = 1;
        this._transform4x4 = X;
        this._glServerState = 0;
        this._stackMatrix = new cc.kmMat4;
    },
    visit: null,
    _visitForCanvas: function(X) {
        if (this._visible) {
            X = X || cc._renderContext;
            var S,
                P = this._children,
                O;
            X.save();
            this.transform(X);
            var Z = P.length;
            if (H8m.J4h(0, Z)) {
                this.sortAllChildren();
                for (S = 0; H8m.n4h(S, Z); S++)
                    if (O = P[S], H8m.G4h(0, O._localZOrder))
                        O.visit(X);
                    else
                        break;
                for (this.draw(X); H8m.W4h(S, Z); S++)
                    P[S].visit(X);
            } else
                this.draw(X);
            this.arrivalOrder = 0;
            X.restore();
        }
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var X = cc._renderContext,
                S,
                P = cc.current_stack;
            P.stack.push(P.top);
            cc.kmMat4Assign(this._stackMatrix, P.top);
            P.top = this._stackMatrix;
            var O = this.grid;
            O && O._active && O.beforeDraw();
            this.transform();
            var Z = this._children;
            if (Z && H8m.v4h(0, Z.length)) {
                var Y = Z.length;
                this.sortAllChildren();
                for (S = 0; H8m.u4h(S, Y); S++)
                    if (Z[S] && H8m.H4h(0, Z[S]._localZOrder))
                        Z[S].visit();
                    else
                        break;
                for (this.draw(X); H8m.f4h(S, Y); S++)
                    Z[S] && Z[S].visit();
            } else
                this.draw(X);
            this.arrivalOrder = 0;
            O && O._active && O.afterDraw(this);
            P.top = P.stack.pop();
        }
    },
    transform: null,
    _transformForCanvas: function(X) {
        X = X || cc._renderContext;
        var S = cc.view,
            P = this.nodeToParentTransform();
        X.transform(P.a, P.c, P.b, P.d, H8m.I4h(P.tx, S.getScaleX()), -P.ty * S.getScaleY());
    },
    _transformForWebGL: function() {
        var X = this._transform4x4,
            S = cc.current_stack.top,
            P = this.nodeToParentTransform(),
            O = X.mat;
        O[0] = P.a;
        O[4] = P.c;
        O[12] = P.tx;
        O[1] = P.b;
        O[5] = P.d;
        O[13] = P.ty;
        O[14] = this._vertexZ;
        cc.kmMat4Multiply(S, S, X);
        H8m.g7h(null, this._camera) || H8m.K7h(null, this.grid) && this.grid.isActive() || (X = this._anchorPointInPoints.x, S = this._anchorPointInPoints.y, H8m.d7h(0, X) || H8m.t7h(0, S) ? (cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(X), cc.RENDER_IN_SUBPIXEL(S), 0), this._camera.locate(), cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(-X), cc.RENDER_IN_SUBPIXEL(-S), 0)) : this._camera.locate());
    },
    nodeToParentTransform: null,
    _nodeToParentTransformForCanvas: function() {
        if (this._transformDirty) {
            var X = this._transform;
            X.tx = this._position.x;
            X.ty = this._position.y;
            var S = 1,
                P = 0;
            this._rotationX && (S = Math.cos(this._rotationRadiansX), P = Math.sin(this._rotationRadiansX));
            X.a = X.d = S;
            X.b = -P;
            X.c = P;
            var O = this._scaleX,
                Z = this._scaleY,
                Y = this._anchorPointInPoints.x,
                T = this._anchorPointInPoints.y,
                R = H8m.w7h(1E-6, O) && -1E-6 < O ? 1E-6 : O,
                E = H8m.e7h(1E-6, Z) && -1E-6 < Z ? 1E-6 : Z;
            if (this._skewX || this._skewY) {
                var V = Math.tan(-this._skewX * Math.PI / 180),
                    U = Math.tan(-this._skewY * Math.PI / 180),
                    k9 = H8m.Q7h(T, V, R),
                    L9 = H8m.Z7h(Y, U, E);
                X.a = S + -P * U;
                X.b = H8m.T7h(S, V) + -P;
                X.c = P + H8m.R7h(S, U);
                X.d = H8m.M7h(P, V) + S;
                X.tx += H8m.V7h(S, k9) + -P * L9;
                X.ty += H8m.s7h(P, k9) + H8m.U7h(S, L9);
            }
            if (H8m.b7h(1, O) || H8m.F7h(1, Z))
                X.a *= R, X.c *= R, X.b *= E, X.d *= E;
            X.tx += S * -Y * R + -P * T * E;
            X.ty -= P * -Y * R + H8m.k0h(S, T, E);
            this._ignoreAnchorPointForPosition && (X.tx += Y, X.ty += T);
            this._additionalTransformDirty && (this._transform = cc.AffineTransformConcat(X, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transformDirty = !1;
        }
        return this._transform;
    },
    _nodeToParentTransformForWebGL: function() {
        if (this._transformDirty) {
            var X = this._position.x,
                S = this._position.y,
                P = this._anchorPointInPoints.x,
                O = -P,
                Z = this._anchorPointInPoints.y,
                Y = -Z,
                T = this._scaleX,
                R = this._scaleY;
            this._ignoreAnchorPointForPosition && (X += P, S += Z);
            var E = 1,
                V = 0,
                U = 1,
                k9 = 0;
            if (H8m.D0h(0, this._rotationX) || H8m.c0h(0, this._rotationY))
                E = Math.cos(-this._rotationRadiansX), V = Math.sin(-this._rotationRadiansX), U = Math.cos(-this._rotationRadiansY), k9 = Math.sin(-this._rotationRadiansY);
            var L9 = this._skewX || this._skewY;
            L9 || H8m.z0h(0, P) && H8m.j0h(0, Z) || (X += H8m.x0h(U, O, T) + -V * Y * R, S += H8m.Q0h(k9, O, T) + H8m.Z0h(E, Y, R));
            var K9 = this._transform;
            K9.a = H8m.T0h(U, T);
            K9.b = H8m.R0h(k9, T);
            K9.c = -V * R;
            K9.d = H8m.M0h(E, R);
            K9.tx = X;
            K9.ty = S;
            L9 && (K9 = cc.AffineTransformConcat({
                a: 1,
                b: Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)),
                c: Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, K9), H8m.V0h(0, P) || H8m.s0h(0, Z)) && (K9 = cc.AffineTransformTranslate(K9, O, Y));
            this._additionalTransformDirty && (K9 = cc.AffineTransformConcat(K9, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transform = K9;
            this._transformDirty = !1;
        }
        return this._transform;
    },
    _setNodeDirtyForCache: function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var X = this._cachedParent;
            X && H8m.U0h(X, this) && X._setNodeDirtyForCache();
        }
    },
    getCamera: function() {
        this._camera || (this._camera = new cc.Camera);
        return this._camera;
    },
    getGrid: function() {
        return this.grid;
    },
    setGrid: function(X) {
        this.grid = X;
    },
    getShaderProgram: function() {
        return this._shaderProgram;
    },
    setShaderProgram: function(X) {
        this._shaderProgram = X;
    },
    getGLServerState: function() {
        return this._glServerState;
    },
    setGLServerState: function(X) {
        this._glServerState = X;
    },
    getBoundingBoxToWorld: function() {
        var X = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            S = this.nodeToWorldTransform(),
            X = cc.RectApplyAffineTransform(X, this.nodeToWorldTransform());
        if (!this._children)
            return X;
        for (var P = this._children, O = 0; H8m.b0h(O, P.length); O++) {
            var Z = P[O];
            Z && Z._visible && (Z = Z._getBoundingBoxToCurrentNode(S)) && (X = cc.rectUnion(X, Z));
        }
        return X;
    },
    _getBoundingBoxToCurrentNode: function(X) {
        var S = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        X = H8m.F0h(null, X) ? this.nodeToParentTransform() : cc.AffineTransformConcat(this.nodeToParentTransform(), X);
        S = cc.RectApplyAffineTransform(S, X);
        if (!this._children)
            return S;
        for (var P = this._children, O = 0; H8m.k3h(O, P.length); O++) {
            var Z = P[O];
            Z && Z._visible && (Z = Z._getBoundingBoxToCurrentNode(X)) && (S = cc.rectUnion(S, Z));
        }
        return S;
    }
});
w6b0K[q0K]._p = cc.Node.prototype;
H8m.L3h(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.ctor = _p._ctorForWebGL, _p.setNodeDirty = _p._setNodeDirtyForWebGL, _p.visit = _p._visitForWebGL, _p.transform = _p._transformForWebGL, _p.nodeToParentTransform = _p._nodeToParentTransformForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setNodeDirty = _p._setNodeDirtyForCanvas, _p.visit = _p._visitForCanvas, _p.transform = _p._transformForCanvas, _p.nodeToParentTransform = _p._nodeToParentTransformForCanvas);
cc.defineGetterSetter(_p, H8m.R0i, _p.getPositionX, _p.setPositionX);
cc.defineGetterSetter(_p, H8m.w0i, _p.getPositionY, _p.setPositionY);
cc.defineGetterSetter(_p, H8m.D3H, _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, H8m.m5S, _p._getHeight, _p._setHeight);
cc.defineGetterSetter(_p, H8m.K4S, _p._getAnchorX, _p._setAnchorX);
cc.defineGetterSetter(_p, H8m.L8S, _p._getAnchorY, _p._setAnchorY);
cc.defineGetterSetter(_p, H8m.c6i, _p.getSkewX, _p.setSkewX);
cc.defineGetterSetter(_p, H8m.R4K, _p.getSkewY, _p.setSkewY);
cc.defineGetterSetter(_p, H8m.L2S, _p.getLocalZOrder, _p.setLocalZOrder);
cc.defineGetterSetter(_p, H8m.b4P, _p.getVertexZ, _p.setVertexZ);
cc.defineGetterSetter(_p, H8m.L1K, _p.getRotation, _p.setRotation);
cc.defineGetterSetter(_p, H8m.P3H, _p.getRotationX, _p.setRotationX);
cc.defineGetterSetter(_p, H8m.D0H, _p.getRotationY, _p.setRotationY);
cc.defineGetterSetter(_p, H8m.a2H, _p.getScale, _p.setScale);
cc.defineGetterSetter(_p, H8m.e0P, _p.getScaleX, _p.setScaleX);
cc.defineGetterSetter(_p, H8m.U0P, _p.getScaleY, _p.setScaleY);
cc.defineGetterSetter(_p, H8m.E4K, _p.getChildren);
cc.defineGetterSetter(_p, H8m.s5S, _p.getChildrenCount);
cc.defineGetterSetter(_p, H8m.L2H, _p.getParent, _p.setParent);
cc.defineGetterSetter(_p, H8m.f9S, _p.isVisible, _p.setVisible);
cc.defineGetterSetter(_p, H8m.H9P, _p.isRunning);
cc.defineGetterSetter(_p, H8m.u5S, _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
cc.defineGetterSetter(_p, H8m.c2i, _p.getActionManager, _p.setActionManager);
cc.defineGetterSetter(_p, H8m.k3P, _p.getScheduler, _p.setScheduler);
cc.defineGetterSetter(_p, H8m.P4i, _p.getShaderProgram, _p.setShaderProgram);
cc.defineGetterSetter(_p, H8m.L0H, _p.getGLServerState, _p.setGLServerState);
delete w6b0K[q0K]._p;
cc.Node.create = function() {
    return new cc.Node;
};
cc.Node.StateCallbackType = {
    onEnter: H8m.h7H,
    onExit: H8m.s7H,
    cleanup: H8m.v7H,
    onEnterTransitionDidFinish: H8m.q7H,
    updateTransform: H8m.b7H,
    onExitTransitionDidStart: H8m.H7H,
    sortAllChildren: H8m.y7H
};
cc.NodeRGBA = cc.Node.extend({
    RGBAProtocol: !0,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._realOpacity = this._displayedOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
    },
    getOpacity: function() {
        return this._realOpacity;
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity;
    },
    setOpacity: function(X) {
        this._displayedOpacity = this._realOpacity = X;
        var S = 255,
            P = this._parent;
        P && P.RGBAProtocol && P.cascadeOpacity && (S = P.getDisplayedOpacity());
        this.updateDisplayedOpacity(S);
        this._displayedColor.a = this._realColor.a = X;
    },
    updateDisplayedOpacity: function(X) {
        this._displayedOpacity = H8m.i3h(this._realOpacity, X, 255);
        if (this._cascadeOpacityEnabled) {
            X = this._children;
            for (var S = 0; H8m.z3h(S, X.length); S++) {
                var P = X[S];
                P && P.RGBAProtocol && P.updateDisplayedOpacity(this._displayedOpacity);
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled;
    },
    setCascadeOpacityEnabled: function(X) {
        H8m.j3h(this._cascadeOpacityEnabled, X) && ((this._cascadeOpacityEnabled = X) ? this._enableCascadeOpacity() : this._disableCascadeOpacity());
    },
    _enableCascadeOpacity: function() {
        var X = 255,
            S = this._parent;
        S && S.RGBAProtocol && S.cascadeOpacity && (X = S.getDisplayedOpacity());
        this.updateDisplayedOpacity(X);
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        for (var X = this._children, S = 0; H8m.x3h(S, X.length); S++) {
            var P = X[S];
            P && P.RGBAProtocol && P.updateDisplayedOpacity(255);
        }
    },
    getColor: function() {
        var X = this._realColor;
        return cc.color(X.r, X.g, X.b, X.a);
    },
    getDisplayedColor: function() {
        return this._displayedColor;
    },
    setColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        S.r = P.r = X.r;
        S.g = P.g = X.g;
        S.b = P.b = X.b;
        S = (S = this._parent) && S.RGBAProtocol && S.cascadeColor ? S.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(S);
        void 0 === X.a || X.a_undefined || this.setOpacity(X.a);
    },
    updateDisplayedColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        S.r = H8m.o3h(0, P.r * X.r / 255);
        S.g = H8m.p3h(0, P.g * X.g / 255);
        S.b = H8m.Y3h(0, P.b * X.b / 255);
        if (this._cascadeColorEnabled)
            for (X = this._children, P = 0; H8m.T3h(P, X.length); P++) {
                var O = X[P];
                O && O.RGBAProtocol && O.updateDisplayedColor(S);
            }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled;
    },
    setCascadeColorEnabled: function(X) {
        H8m.R3h(this._cascadeColorEnabled, X) && ((this._cascadeColorEnabled = X) ? this._enableCascadeColor() : this._disableCascadeColor());
    },
    _enableCascadeColor: function() {
        var X;
        X = (X = this._parent) && X.RGBAProtocol && X.cascadeColor ? X.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(X);
    },
    _disableCascadeColor: function() {
        var X = this._displayedColor,
            S = this._realColor;
        X.r = S.r;
        X.g = S.g;
        X.b = S.b;
        for (var X = this._children, S = cc.color.WHITE, P = 0; H8m.M3h(P, X.length); P++) {
            var O = X[P];
            O && O.RGBAProtocol && O.updateDisplayedColor(S);
        }
    },
    addChild: function(X, S, P) {
        cc.Node.prototype.addChild.call(this, X, S, P);
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity();
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !1;
    }
});
cc.NodeRGBA.create = function() {
    var X = new cc.NodeRGBA;
    X.init();
    return X;
};
w6b0K[q0K]._p = cc.NodeRGBA.prototype;
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.R0K, _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, H8m.H9S, _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.t4P, _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
delete w6b0K[q0K]._p;
cc.AtlasNode = cc.NodeRGBA.extend({
    textureAtlas: H8m.H6P,
    quadsToDraw: H8m.U7H,
    RGBAProtocol: !H8m.U7H,
    _itemsPerRow: H8m.U7H,
    _itemsPerColumn: H8m.U7H,
    _itemWidth: H8m.U7H,
    _itemHeight: H8m.U7H,
    _colorUnmodified: H8m.H6P,
    _opacityModifyRGB: !H8m.h7H,
    _blendFunc: H8m.H6P,
    _ignoreContentScaleFactor: !H8m.h7H,
    _className: H8m.x4S,
    ctor: function() {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._colorUnmodified = cc.color.WHITE;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !H8m.h7H;
    },
    updateAtlasValues: function() {
        var X = "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses";
        cc.log(X);
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.NodeRGBA.prototype.getColor.call(this);
    },
    setOpacityModifyRGB: function(X) {
        var S = this.color;
        this._opacityModifyRGB = X;
        this.color = S;
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    setBlendFunc: function(X, S) {
        this._blendFunc = void H8m.U7H === S ? X : {
            src: X,
            dst: S
        };
    },
    setTextureAtlas: function(X) {
        this.textureAtlas = X;
    },
    getTextureAtlas: function() {
        return this.textureAtlas;
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw;
    },
    setQuadsToDraw: function(X) {
        this.quadsToDraw = X;
    },
    _textureForCanvas: H8m.H6P,
    _originalTexture: H8m.H6P,
    _uniformColor: H8m.H6P,
    _colorF32Array: H8m.H6P,
    initWithTileFile: function(X, S, P, O) {
        var Z = "cc.AtlasNode.initWithTileFile(): title should not be null";
        if (!X)
            throw Z;
        X = cc.textureCache.addImage(X);
        return this.initWithTexture(X, S, P, O);
    },
    initWithTexture: H8m.H6P,
    _initWithTextureForCanvas: function(X, S, P, O) {
        this._itemWidth = S;
        this._itemHeight = P;
        this._opacityModifyRGB = !H8m.U7H;
        this._originalTexture = X;
        if (!this._originalTexture)
            return cc.log(H8m.N9K), !H8m.h7H;
        this._textureForCanvas = this._originalTexture;
        this._calculateMaxItems();
        this.quadsToDraw = O;
        return !H8m.U7H;
    },
    _initWithTextureForWebGL: function(X, S, P, O) {
        this._itemWidth = S;
        this._itemHeight = P;
        this._colorUnmodified = cc.color.WHITE;
        this._opacityModifyRGB = !H8m.U7H;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        S = this._realColor;
        this._colorF32Array = new Float32Array([H8m.V3h(S.r, H8m.s0K), H8m.s3h(S.g, H8m.s0K), H8m.U3h(S.b, H8m.s0K), H8m.b3h(this._realOpacity, H8m.s0K)]);
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(X, O);
        if (!this.textureAtlas)
            return cc.log(H8m.N9K), !H8m.h7H;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        this.quadsToDraw = O;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), H8m.i2H);
        return !H8m.U7H;
    },
    draw: H8m.H6P,
    _drawForWebGL: function(X) {
        X = X || cc._renderContext;
        cc.NODE_DRAW_SETUP(this);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        X.uniform4fv(this._uniformColor, this._colorF32Array);
        this.textureAtlas.drawNumberOfQuads(this.quadsToDraw, H8m.U7H);
    },
    setColor: H8m.H6P,
    _setColorForCanvas: function(X) {
        var S = this._realColor;
        if (H8m.F3h(S.r, X.r) || H8m.k5h(S.g, X.g) || H8m.L5h(S.b, X.b)) {
            S = cc.color(X.r, X.g, X.b);
            this._colorUnmodified = X;
            if (this._opacityModifyRGB) {
                var P = this._displayedOpacity;
                S.r = H8m.i5h(S.r, P, H8m.s0K);
                S.g = H8m.z5h(S.g, P, H8m.s0K);
                S.b = H8m.w5h(S.b, P, H8m.s0K);
            }
            cc.NodeRGBA.prototype.setColor.call(this, X);
            this.texture && (X = this._originalTexture.getHtmlElementObj()) && (S = cc.textureCache.getTextureColors(X)) && (P = cc.rect(0, 0, X.width, X.height), X = cc.generateTintImage(X, S, this._realColor, P), S = new cc.Texture2D, S.initWithElement(X), S.handleLoadedTexture(), this.texture = S);
        }
    },
    _setColorForWebGL: function(X) {
        var S = cc.color(X.r, X.g, X.b);
        this._colorUnmodified = X;
        var P = this._displayedOpacity;
        this._opacityModifyRGB && (S.r = H8m.O5h(S.r, P, H8m.s0K), S.g = H8m.p5h(S.g, P, H8m.s0K), S.b = H8m.N5h(S.b, P, H8m.s0K));
        cc.NodeRGBA.prototype.setColor.call(this, X);
        X = this._displayedColor;
        this._colorF32Array = new Float32Array([H8m.n5h(X.r, H8m.s0K), H8m.G5h(X.g, H8m.s0K), H8m.W5h(X.b, H8m.s0K), H8m.v5h(P, H8m.s0K)]);
    },
    setOpacity: function(X) {},
    _setOpacityForCanvas: function(X) {
        cc.NodeRGBA.prototype.setOpacity.call(this, X);
        this._opacityModifyRGB && (this.color = this._colorUnmodified);
    },
    _setOpacityForWebGL: function(X) {
        cc.NodeRGBA.prototype.setOpacity.call(this, X);
        this._opacityModifyRGB ? this.color = this._colorUnmodified : (X = this._displayedColor, this._colorF32Array = new Float32Array([H8m.u5h(X.r, H8m.s0K), H8m.H5h(X.g, H8m.s0K), H8m.f5h(X.b, H8m.s0K), H8m.I5h(this._displayedOpacity, H8m.s0K)]));
    },
    getTexture: H8m.H6P,
    _getTextureForCanvas: function() {
        return this._textureForCanvas;
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture;
    },
    setTexture: H8m.H6P,
    _setTextureForCanvas: function(X) {
        this._textureForCanvas = X;
    },
    _setTextureForWebGL: function(X) {
        this.textureAtlas.texture = X;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
    },
    _calculateMaxItems: H8m.H6P,
    _calculateMaxItemsForCanvas: function() {
        var X = this.texture.getContentSize();
        this._itemsPerColumn = H8m.g6h(0, X.height / this._itemHeight);
        this._itemsPerRow = H8m.K6h(0, X.width / this._itemWidth);
    },
    _calculateMaxItemsForWebGL: function() {
        var X = this.texture,
            S = X.getContentSize();
        this._ignoreContentScaleFactor && (S = X.getContentSizeInPixels());
        this._itemsPerColumn = H8m.d6h(0, S.height / this._itemHeight);
        this._itemsPerRow = H8m.t6h(0, S.width / this._itemWidth);
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA);
    },
    _updateOpacityModifyRGB: function() {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha();
    },
    _setIgnoreContentScaleFactor: function(X) {
        this._ignoreContentScaleFactor = X;
    }
});
w6b0K[q0K]._p = cc.AtlasNode.prototype;
H8m.w6h(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
delete w6b0K[q0K]._p;
cc.AtlasNode.create = function(X, S, P, O) {
    var Z = new cc.AtlasNode;
    return Z.initWithTileFile(X, S, P, O) ? Z : H8m.H6P;
};
H8m.F0(H8m.t4i);
H8m.I0(H8m.V9i);
H8m.X3(H8m.s9i);
H8m.L3(H8m.O4i);
H8m.K3(H8m.b2S);
H8m.c3(H8m.u2S);
H8m.S3(H8m.y2S);
H8m.t3(H8m.f8i);
H8m.j3(H8m.v9i);
H8m.a3();
cc.Texture2DWebGL = cc.Class.extend({
    _pVRHaveAlphaPremultiplied: !0,
    _pixelFormat: null,
    _pixelsWide: 0,
    _pixelsHigh: 0,
    _name: "",
    _contentSize: null,
    maxS: 0,
    maxT: 0,
    _hasPremultipliedAlpha: !1,
    _hasMipmaps: !1,
    shaderProgram: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _webTextureObj: null,
    url: null,
    _loadedEventListeners: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0);
        this._pixelFormat = cc.Texture2D.defaultPixelFormat;
    },
    releaseTexture: function() {
        this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
        cc.loader.release(this.url);
    },
    getPixelFormat: function() {
        return this._pixelFormat;
    },
    getPixelsWide: function() {
        return this._pixelsWide;
    },
    getPixelsHigh: function() {
        return this._pixelsHigh;
    },
    getName: function() {
        return this._webTextureObj;
    },
    getContentSize: function() {
        return cc.size(H8m.e6h(this._contentSize.width, cc.CONTENT_SCALE_FACTOR()), H8m.Q6h(this._contentSize.height, cc.CONTENT_SCALE_FACTOR()));
    },
    _getWidth: function() {
        return H8m.r6h(this._contentSize.width, cc.CONTENT_SCALE_FACTOR());
    },
    _getHeight: function() {
        return H8m.N6h(this._contentSize.height, cc.CONTENT_SCALE_FACTOR());
    },
    getContentSizeInPixels: function() {
        return this._contentSize;
    },
    getMaxS: function() {
        return this.maxS;
    },
    setMaxS: function(X) {
        this.maxS = X;
    },
    getMaxT: function() {
        return this.maxT;
    },
    setMaxT: function(X) {
        this.maxT = X;
    },
    getShaderProgram: function() {
        return this.shaderProgram;
    },
    setShaderProgram: function(X) {
        this.shaderProgram = X;
    },
    hasPremultipliedAlpha: function() {
        return this._hasPremultipliedAlpha;
    },
    hasMipmaps: function() {
        return this._hasMipmaps;
    },
    description: function() {
        return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e";
    },
    releaseData: function(X) {},
    keepData: function(X, S) {
        return X;
    },
    initWithData: function(X, S, P, O, Z) {
        var Y = cc.Texture2D,
            T = cc._renderContext,
            R = T.RGBA,
            E = T.UNSIGNED_BYTE,
            V = H8m.m6h(P, cc.Texture2D._B[S], 8);
        H8m.G6h(0, V % 8) ? T.pixelStorei(T.UNPACK_ALIGNMENT, 8) : H8m.W6h(0, V % 4) ? T.pixelStorei(T.UNPACK_ALIGNMENT, 4) : H8m.v6h(0, V % 2) ? T.pixelStorei(T.UNPACK_ALIGNMENT, 2) : T.pixelStorei(T.UNPACK_ALIGNMENT, 1);
        this._webTextureObj = T.createTexture();
        cc.glBindTexture2D(this);
        T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MIN_FILTER, T.LINEAR);
        T.texParameteri(T.TEXTURE_2D, T.TEXTURE_MAG_FILTER, T.LINEAR);
        T.texParameteri(T.TEXTURE_2D, T.TEXTURE_WRAP_S, T.CLAMP_TO_EDGE);
        T.texParameteri(T.TEXTURE_2D, T.TEXTURE_WRAP_T, T.CLAMP_TO_EDGE);
        switch (S) {
        case Y.PIXEL_FORMAT_RGBA8888:
            R = T.RGBA;
            break;
        case Y.PIXEL_FORMAT_RGB888:
            R = T.RGB;
            break;
        case Y.PIXEL_FORMAT_RGBA4444:
            E = T.UNSIGNED_SHORT_4_4_4_4;
            break;
        case Y.PIXEL_FORMAT_RGB5A1:
            E = T.UNSIGNED_SHORT_5_5_5_1;
            break;
        case Y.PIXEL_FORMAT_RGB565:
            E = T.UNSIGNED_SHORT_5_6_5;
            break;
        case Y.PIXEL_FORMAT_AI88:
            R = T.LUMINANCE_ALPHA;
            break;
        case Y.PIXEL_FORMAT_A8:
            R = T.ALPHA;
            break;
        case Y.PIXEL_FORMAT_I8:
            R = T.LUMINANCE;
            break;
        default:
            throw "NSInternalInconsistencyException";
        }
        T.texImage2D(T.TEXTURE_2D, 0, R, P, O, 0, R, E, X);
        this._contentSize.width = Z.width;
        this._contentSize.height = Z.height;
        this._pixelsWide = P;
        this._pixelsHigh = O;
        this._pixelFormat = S;
        this.maxS = H8m.u6h(Z.width, P);
        this.maxT = H8m.H6h(Z.height, O);
        this._hasMipmaps = this._hasPremultipliedAlpha = !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        return this._isLoaded = !0;
    },
    drawAtPoint: function(X) {
        var S = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
            P = H8m.f6h(this._pixelsWide, this.maxS),
            O = H8m.I6h(this._pixelsHigh, this.maxT);
        X = [X.x, X.y, 0, P + X.x, X.y, 0, X.x, O + X.y, 0, P + X.x, O + X.y, 0];
        cc.glEnableVertexAttribs(H8m.g2h(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS));
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        cc.glBindTexture2D(this);
        P = cc._renderContext;
        P.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, P.FLOAT, !1, 0, X);
        P.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, P.FLOAT, !1, 0, S);
        P.drawArrays(P.TRIANGLE_STRIP, 0, 4);
    },
    drawInRect: function(X) {
        var S = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
        X = [X.x, X.y, X.x + X.width, X.y, X.x, X.y + X.height, X.x + X.width, X.y + X.height];
        cc.glEnableVertexAttribs(H8m.K2h(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS));
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        cc.glBindTexture2D(this);
        var P = cc._renderContext;
        P.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, P.FLOAT, !1, 0, X);
        P.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, P.FLOAT, !1, 0, S);
        P.drawArrays(P.TRIANGLE_STRIP, 0, 4);
    },
    initWithImage: function(X) {
        if (H8m.d2h(null, X))
            return cc.log("cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil"), !1;
        var S = X.getWidth(),
            P = X.getHeight(),
            O = cc.configuration.getMaxTextureSize();
        if (H8m.t2h(S, O) || H8m.w2h(P, O))
            return cc.log("cocos2d: WARNING: Image (" + S + " x " + P + ") is bigger than the supported " + O + " x " + O), !1;
        this._isLoaded = !0;
        return this._initPremultipliedATextureWithImage(X, S, P);
    },
    initWithElement: function(X) {
        X && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = X);
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj;
    },
    isLoaded: function() {
        return this._isLoaded;
    },
    handleLoadedTexture: function() {
        if (cc._rendererInitialized) {
            if (!this._htmlElementObj) {
                var X = cc.loader.getRes(this.url);
                if (!X)
                    return;
                this.initWithElement(X);
            }
            this._isLoaded = !0;
            X = cc._renderContext;
            cc.glBindTexture2D(this);
            X.pixelStorei(X.UNPACK_ALIGNMENT, 4);
            X.texImage2D(X.TEXTURE_2D, 0, X.RGBA, X.RGBA, X.UNSIGNED_BYTE, this._htmlElementObj);
            X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MIN_FILTER, X.LINEAR);
            X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MAG_FILTER, X.LINEAR);
            X.texParameteri(X.TEXTURE_2D, X.TEXTURE_WRAP_S, X.CLAMP_TO_EDGE);
            X.texParameteri(X.TEXTURE_2D, X.TEXTURE_WRAP_T, X.CLAMP_TO_EDGE);
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            cc.glBindTexture2D(null);
            X = this._htmlElementObj.height;
            this._pixelsWide = this._contentSize.width = this._htmlElementObj.width;
            this._pixelsHigh = this._contentSize.height = X;
            this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
            this.maxT = this.maxS = 1;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this._callLoadedEventCallbacks();
        }
    },
    initWithString: function(X, S, P, O, Z, Y) {
        cc.log("initWithString isn't supported on cocos2d-html5");
        return null;
    },
    initWithETCFile: function(X) {
        cc.log("initWithETCFile does not support on HTML5");
        return !1;
    },
    initWithPVRFile: function(X) {
        cc.log("initWithPVRFile does not support on HTML5");
        return !1;
    },
    initWithPVRTCData: function(X, S, P, O, Z, Y) {
        cc.log("initWithPVRTCData does not support on HTML5");
        return !1;
    },
    setTexParameters: function(X) {
        var S = cc._renderContext;
        cc.assert(H8m.e2h(this._pixelsWide, cc.NextPOT(this._pixelsWide)) && H8m.Q2h(this._pixelsHigh, cc.NextPOT(this._pixelsHigh)) || H8m.r2h(X.wrapS, S.CLAMP_TO_EDGE) && H8m.N2h(X.wrapT, S.CLAMP_TO_EDGE), "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
        cc.glBindTexture2D(this);
        S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MIN_FILTER, X.minFilter);
        S.texParameteri(S.TEXTURE_2D, S.TEXTURE_MAG_FILTER, X.magFilter);
        S.texParameteri(S.TEXTURE_2D, S.TEXTURE_WRAP_S, X.wrapS);
        S.texParameteri(S.TEXTURE_2D, S.TEXTURE_WRAP_T, X.wrapT);
    },
    setAntiAliasTexParameters: function() {
        var X = cc._renderContext;
        cc.glBindTexture2D(this);
        this._hasMipmaps ? X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MIN_FILTER, X.LINEAR_MIPMAP_NEAREST) : X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MIN_FILTER, X.LINEAR);
        X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MAG_FILTER, X.NEAREST);
    },
    setAliasTexParameters: function() {
        var X = cc._renderContext;
        cc.glBindTexture2D(this);
        this._hasMipmaps ? X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MIN_FILTER, X.NEAREST_MIPMAP_NEAREST) : X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MIN_FILTER, X.NEAREST);
        X.texParameteri(X.TEXTURE_2D, X.TEXTURE_MAG_FILTER, X.NEAREST);
    },
    generateMipmap: function() {
        cc.assert(H8m.m2h(this._pixelsWide, cc.NextPOT(this._pixelsWide)) && H8m.A2h(this._pixelsHigh, cc.NextPOT(this._pixelsHigh)), "Mimpap texture only works in POT textures");
        cc.glBindTexture2D(this);
        cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
        this._hasMipmaps = !0;
    },
    stringForFormat: function() {
        return cc.Texture2D._M[this._pixelFormat];
    },
    bitsPerPixelForFormat: function(X) {
        X = X || this._pixelFormat;
        var S = cc.Texture2D._B[X];
        if (H8m.E2h(null, S))
            return S;
        cc.log("bitsPerPixelForFormat: " + X + ", cannot give useful result, it's a illegal pixel format");
        return -1;
    },
    _initPremultipliedATextureWithImage: function(X, S, P) {
        var O = cc.Texture2D,
            Z = X.getData(),
            Y = null,
            Y = null,
            T = X.hasAlpha(),
            R = cc.size(X.getWidth(), X.getHeight()),
            E = O.defaultPixelFormat,
            V = X.getBitsPerComponent();
        T || (H8m.C2h(8, V) ? E = O.PIXEL_FORMAT_RGB888 : (cc.log("cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha"), E = O.PIXEL_FORMAT_RGB565));
        var U = H8m.h2h(S, P);
        if (H8m.y2h(E, O.PIXEL_FORMAT_RGB565))
            if (T)
                for (Z = new Uint16Array(H8m.q2h(S, P)), Y = X.getData(), V = 0; H8m.l2h(V, U); ++V)
                    Z[V] = H8m.X9N((Y[V] >> 0 & 255) >> 3 << 11, (Y[V] >> 8 & 255) >> 2 << 5, (Y[V] >> 16 & 255) >> 3 << 0);
            else
                for (Z = new Uint16Array(H8m.K9N(S, P)), Y = X.getData(), V = 0; H8m.d9N(V, U); ++V)
                    Z[V] = H8m.t9N((Y[V] & 255) >> 3 << 11, (Y[V] & 255) >> 2 << 5, (Y[V] & 255) >> 3 << 0);
        else if (H8m.a9N(E, O.PIXEL_FORMAT_RGBA4444))
            for (Z = new Uint16Array(H8m.O9N(S, P)), Y = X.getData(), V = 0; H8m.B9N(V, U); ++V)
                Z[V] = H8m.Z9N((Y[V] >> 0 & 255) >> 4 << 12, (Y[V] >> 8 & 255) >> 4 << 8, (Y[V] >> 16 & 255) >> 4 << 4, (Y[V] >> 24 & 255) >> 4 << 0);
        else if (H8m.m9N(E, O.PIXEL_FORMAT_RGB5A1))
            for (Z = new Uint16Array(H8m.A9N(S, P)), Y = X.getData(), V = 0; H8m.E9N(V, U); ++V)
                Z[V] = H8m.C9N((Y[V] >> 0 & 255) >> 3 << 11, (Y[V] >> 8 & 255) >> 3 << 6, (Y[V] >> 16 & 255) >> 3 << 1, (Y[V] >> 24 & 255) >> 7 << 0);
        else if (H8m.U9N(E, O.PIXEL_FORMAT_A8))
            for (Z = new Uint8Array(H8m.b9N(S, P)), Y = X.getData(), V = 0; H8m.F9N(V, U); ++V)
                Z[V] = H8m.k1N(Y >> 24, 255);
        if (T && H8m.L1N(E, O.PIXEL_FORMAT_RGB888))
            for (Y = X.getData(), Z = new Uint8Array(H8m.i1N(S, P, 3)), V = 0; H8m.z1N(V, U); ++V)
                Z[H8m.j1N(3, V)] = H8m.x1N(Y >> 0, 255), Z[H8m.o1N(3, V) + 1] = H8m.p1N(Y >> 8, 255), Z[H8m.Y1N(3, V) + 2] = H8m.T1N(Y >> 16, 255);
        this.initWithData(Z, E, S, P, R);
        X.getData();
        this._hasPremultipliedAlpha = X.isPremultipliedAlpha();
        return !0;
    },
    addLoadedEventListener: function(X, S) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    removeLoadedEventListener: function(X) {
        if (this._loadedEventListeners)
            for (var S = this._loadedEventListeners, P = 0; H8m.R1N(P, S.length); P++)
                H8m.M1N(S[P].eventTarget, X) && S.splice(P, 1);
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var X = this._loadedEventListeners, S = 0, P = X.length; H8m.V1N(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    }
});
cc.Texture2DCanvas = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _loadedEventListeners: null,
    url: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0);
        this._isLoaded = !1;
        this._htmlElementObj = null;
    },
    getPixelsWide: function() {
        return this._contentSize.width;
    },
    getPixelsHigh: function() {
        return this._contentSize.height;
    },
    getContentSize: function() {
        var X = cc.CONTENT_SCALE_FACTOR();
        return cc.size(H8m.s1N(this._contentSize.width, X), H8m.U1N(this._contentSize.height, X));
    },
    _getWidth: function() {
        return H8m.b1N(this._contentSize.width, cc.CONTENT_SCALE_FACTOR());
    },
    _getHeight: function() {
        return H8m.F1N(this._contentSize.height, cc.CONTENT_SCALE_FACTOR());
    },
    getContentSizeInPixels: function() {
        return this._contentSize;
    },
    initWithElement: function(X) {
        X && (this._htmlElementObj = X);
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj;
    },
    isLoaded: function() {
        return this._isLoaded;
    },
    handleLoadedTexture: function() {
        if (!this._isLoaded) {
            if (!this._htmlElementObj) {
                var X = cc.loader.getRes(this.url);
                if (!X)
                    return;
                this.initWithElement(X);
            }
            this._isLoaded = !0;
            X = this._htmlElementObj;
            this._contentSize.width = X.width;
            this._contentSize.height = X.height;
            this._callLoadedEventCallbacks();
        }
    },
    description: function() {
        return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e";
    },
    initWithData: function(X, S, P, O, Z) {
        return !1;
    },
    initWithImage: function(X) {
        return !1;
    },
    initWithString: function(X, S, P, O, Z, Y) {
        return !1;
    },
    releaseTexture: function() {},
    getName: function() {
        return null;
    },
    getMaxS: function() {
        return 1;
    },
    setMaxS: function(X) {},
    getMaxT: function() {
        return 1;
    },
    setMaxT: function(X) {},
    getPixelFormat: function() {
        return null;
    },
    getShaderProgram: function() {
        return null;
    },
    setShaderProgram: function(X) {},
    hasPremultipliedAlpha: function() {
        return !1;
    },
    hasMipmaps: function() {
        return !1;
    },
    releaseData: function(X) {},
    keepData: function(X, S) {
        return X;
    },
    drawAtPoint: function(X) {},
    drawInRect: function(X) {},
    initWithETCFile: function(X) {
        cc.log("initWithETCFile does not support on HTML5");
        return !1;
    },
    initWithPVRFile: function(X) {
        cc.log("initWithPVRFile does not support on HTML5");
        return !1;
    },
    initWithPVRTCData: function(X, S, P, O, Z, Y) {
        cc.log("initWithPVRTCData does not support on HTML5");
        return !1;
    },
    setTexParameters: function(X) {},
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return "";
    },
    bitsPerPixelForFormat: function(X) {
        return -1;
    },
    addLoadedEventListener: function(X, S) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    removeLoadedEventListener: function(X) {
        if (this._loadedEventListeners)
            for (var S = this._loadedEventListeners, P = 0; H8m.k8N(P, S.length); P++)
                H8m.L8N(S[P].eventTarget, X) && S.splice(P, 1);
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var X = this._loadedEventListeners, S = 0, P = X.length; H8m.i8N(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    }
});
H8m.x3();
cc.Texture2D.PVRImagesHavePremultipliedAlpha = function(X) {
    cc.PVRHaveAlphaPremultiplied_ = X;
};
H8m.e3(cc);
H8m.o3(H8m.U7H);
H8m.B3(H8m.h7H);
H8m.r3(H8m.s7H);
H8m.Y3(H8m.v7H);
H8m.J3(H8m.q7H);
H8m.m3(H8m.b7H);
H8m.R3(H8m.H7H);
H8m.G3(H8m.y7H);
H8m.E3(H8m.F7H);
H8m.V3(H8m.f7H);
H8m.v3(_c);
w6b0K[q0K]._M = cc.Texture2D._M = {};
H8m.h3(H8m.O2S);
H8m.U3(H8m.S0i);
H8m.H3(H8m.K1i);
H8m.q3(H8m.y5i);
H8m.l3(H8m.D6S);
H8m.k5(H8m.T1K);
H8m.g5(H8m.e2i);
H8m.D5(H8m.Z6S);
H8m.i5(H8m.C4K);
H8m.d5(H8m.c4K);
w6b0K[q0K]._B = cc.Texture2D._B = {};
H8m.z5(H8m.J9i);
H8m.P5(H8m.e9i);
H8m.w5(H8m.U9i);
H8m.x5(H8m.F7H);
H8m.O5(H8m.F7H);
H8m.Q5(H8m.U9i);
H8m.p5(H8m.U9i);
H8m.Z5(H8m.U9i);
H8m.N5(H8m.q7H);
H8m.T5(H8m.v7H);
w6b0K[q0K]._p = cc.Texture2D.prototype;
cc.defineGetterSetter(_p, H8m.p5P, _p.getName);
cc.defineGetterSetter(_p, H8m.S8K, _p.getPixelFormat);
cc.defineGetterSetter(_p, H8m.p4P, _p.getPixelsWide);
cc.defineGetterSetter(_p, H8m.x9S, _p.getPixelsHigh);
cc.defineGetterSetter(_p, H8m.D3H, _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, H8m.m5S, _p._getHeight, _p._setHeight);
H8m.n5(_c);
delete w6b0K[q0K]._p;
delete w6b0K[q0K]._c;
delete w6b0K[q0K]._M;
delete w6b0K[q0K]._B;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: H8m.S8N(0, 1E3 * Math.random()),
    _loadedTexturesBefore: {},
    handleLoadedTexture: function(X) {
        var S = this._textures;
        H8m.P8N(cc._renderType, cc._RENDER_TYPE_WEBGL) || cc._rendererInitialized || (S = this._loadedTexturesBefore);
        var P = S[X];
        P || (P = S[X] = new cc.Texture2D, P.url = X);
        P.handleLoadedTexture();
    },
    _initializingRenderer: function() {
        var X,
            S = this._loadedTexturesBefore,
            P = this._textures;
        for (X in S) {
            var O = S[X];
            O.handleLoadedTexture();
            P[X] = O;
        }
        this._loadedTexturesBefore = {};
    },
    addPVRTCImage: function(X) {
        cc.log("TextureCache:addPVRTCImage does not support on HTML5");
    },
    addETCImage: function(X) {
        cc.log("TextureCache:addPVRTCImage does not support on HTML5");
    },
    description: function() {
        return "\x3cTextureCache | Number of textures \x3d " + this._textures.length + "\x3e";
    },
    textureForKey: function(X) {
        return this._textures[X] || this._textures[cc.loader._aliases[X]];
    },
    getKeyByTexture: function(X) {
        for (var S in this._textures)
            if (H8m.a8N(this._textures[S], X))
                return S;
        return null;
    },
    _generalTextureKey: function() {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq;
    },
    getTextureColors: function(X) {
        var S = this.getKeyByTexture(X);
        S || (S = H8m.O8N(X, HTMLImageElement) ? X.src : this._generalTextureKey());
        this._textureColorsCache[S] || (this._textureColorsCache[S] = cc.generateTextureCacheForColor(X));
        return this._textureColorsCache[S];
    },
    addPVRImage: function(X) {
        cc.log("addPVRImage does not support on HTML5");
    },
    removeAllTextures: function() {
        var X = this._textures,
            S;
        for (S in X)
            X[S] && X[S].releaseTexture();
        this._textures = {};
    },
    removeTexture: function(X) {
        if (X) {
            var S = this._textures,
                P;
            for (P in S)
                H8m.B8N(S[P], X) && (S[P].releaseTexture(), delete S[P]);
        }
    },
    removeTextureForKey: function(X) {
        H8m.Z8N(null, X) && this._textures[X] && delete this._textures[X];
    },
    addImage: function(S, P, O) {
        if (!S)
            throw "cc.Texture.addImage(): path should be non-null";
        H8m.J8N(2, arguments.length) && (O = P, P = null);
        var Z = this._textures;
        H8m.n8N(cc._renderType, cc._RENDER_TYPE_WEBGL) || cc._rendererInitialized || (Z = this._loadedTexturesBefore);
        var Y = Z[S] || Z[cc.loader._aliases[S]];
        if (Y)
            return O && O.call(P), Y;
        cc.loader.getRes(S) || cc.loader.load(S, function(X) {
            O && O.call(P);
        });
        Y = Z[S] = new cc.Texture2D;
        Y.url = S;
        return Y;
    },
    cacheImage: function(X, S) {
        if (H8m.G8N(S, cc.Texture2D))
            this._textures[X] = S;
        else {
            var P = new cc.Texture2D;
            P.initWithElement(S);
            P.handleLoadedTexture();
            this._textures[X] = P;
        }
    },
    addUIImage: function(X, S) {
        if (!X)
            throw "cc.Texture.addUIImage(): image should be non-null";
        if (S && this._textures[S])
            return this._textures[S];
        var P = new cc.Texture2D;
        P.initWithImage(X);
        H8m.W8N(null, S) && H8m.v8N(null, P) ? this._textures[S] = P : cc.log("cocos2d: Couldn't add UIImage in TextureCache");
        return P;
    },
    dumpCachedTextureInfo: function() {
        var X = 0,
            S = 0,
            P = this._textures,
            O;
        for (O in P) {
            var Z = P[O];
            X++;
            H8m.u8N(Z.getHtmlElementObj(), HTMLImageElement) ? cc.log("cocos2d: '" + O + "' id\x3d" + Z.getHtmlElementObj().src + " " + Z.pixelsWidth + " x " + Z.pixelsHeight) : cc.log("cocos2d: '" + O + "' id\x3d HTMLCanvasElement " + Z.pixelsWidth + " x " + Z.pixelsHeight);
            S += H8m.H8N(Z.pixelsWidth, Z.pixelsHeight, 4);
        }
        P = this._textureColorsCache;
        for (O in P) {
            var Z = P[O],
                Y;
            for (Y in Z) {
                var T = Z[Y];
                X++;
                cc.log("cocos2d: '" + O + "' id\x3d HTMLCanvasElement " + T.width + " x " + T.height);
                S += H8m.F8N(T.width, T.height, 4);
            }
        }
        cc.log("cocos2d: TextureCache dumpDebugInfo: " + X + " textures, HTMLCanvasElement for " + H8m.X4N(S, 1024) + " KB (" + (H8m.D4N(S, 1048576)).toFixed(2) + " MB)");
    },
    _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = H8m.c4N(0, 1E3 * Math.random());
        this._loadedTexturesBefore = {};
    }
};
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function() {
        this._buffersVBO = [];
    },
    getTotalQuads: function() {
        return this._totalQuads;
    },
    getCapacity: function() {
        return this._capacity;
    },
    getTexture: function() {
        return this.texture;
    },
    setTexture: function(X) {
        this.texture = X;
    },
    setDirty: function(X) {
        this.dirty = X;
    },
    isDirty: function() {
        return this.dirty;
    },
    getQuads: function() {
        return this._quads;
    },
    setQuads: function(X) {
        this._quads = X;
    },
    _copyQuadsToTextureAtlas: function(X, S) {
        if (X)
            for (var P = 0; H8m.z4N(P, X.length); P++)
                this._setQuadToArray(X[P], S + P);
    },
    _setQuadToArray: function(X, S) {
        var P = this._quads;
        P[S] ? (P[S].bl = X.bl, P[S].br = X.br, P[S].tl = X.tl, P[S].tr = X.tr) : P[S] = new cc.V3F_C4B_T2F_Quad(X.tl, X.bl, X.tr, X.br, this._quadsArrayBuffer, H8m.j4N(S, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT));
    },
    description: function() {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" + this._totalQuads + "\x3e";
    },
    _setupIndices: function() {
        if (H8m.x4N(0, this._capacity))
            for (var X = this._indices, S = this._capacity, P = 0; H8m.o4N(P, S); P++)
                cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (X[H8m.p4N(6, P) + 0] = H8m.Y4N(4, P) + 0, X[H8m.T4N(6, P) + 1] = H8m.R4N(4, P) + 0, X[H8m.M4N(6, P) + 2] = H8m.V4N(4, P) + 2, X[H8m.s4N(6, P) + 3] = H8m.U4N(4, P) + 1, X[H8m.b4N(6, P) + 4] = H8m.F4N(4, P) + 3, X[H8m.k7N(6, P) + 5] = H8m.L7N(4, P) + 3) : (X[H8m.i7N(6, P) + 0] = H8m.S7N(4, P) + 0, X[H8m.P7N(6, P) + 1] = H8m.a7N(4, P) + 1, X[H8m.O7N(6, P) + 2] = H8m.B7N(4, P) + 2, X[H8m.Z7N(6, P) + 3] = H8m.J7N(4, P) + 3, X[H8m.n7N(6, P) + 4] = H8m.G7N(4, P) + 2, X[H8m.W7N(6, P) + 5] = H8m.v7N(4, P) + 1);
    },
    _setupVBO: function() {
        var X = cc._renderContext;
        this._buffersVBO[0] = X.createBuffer();
        this._buffersVBO[1] = X.createBuffer();
        this._quadsWebBuffer = X.createBuffer();
        this._mapBuffers();
    },
    _mapBuffers: function() {
        var X = cc._renderContext;
        X.bindBuffer(X.ARRAY_BUFFER, this._quadsWebBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._quadsArrayBuffer, X.DYNAMIC_DRAW);
        X.bindBuffer(X.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        X.bufferData(X.ELEMENT_ARRAY_BUFFER, this._indices, X.STATIC_DRAW);
    },
    initWithFile: function(X, S) {
        var P = cc.textureCache.addImage(X);
        if (P)
            return this.initWithTexture(P, S);
        cc.log("cocos2d: Could not open file: " + X);
        return !1;
    },
    initWithTexture: function(X, S) {
        if (!X)
            throw "cc.TextureAtlas.initWithTexture():texture should be non-null";
        this._capacity = S |= 0;
        this._totalQuads = 0;
        this.texture = X;
        this._quads = [];
        this._indices = new Uint16Array(H8m.u7N(6, S));
        var P = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(H8m.H7N(P, S));
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && H8m.f7N(0, S))
            return !1;
        for (var O = this._quads, Z = 0; H8m.I7N(Z, S); Z++)
            O[Z] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, H8m.g0N(Z, P));
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0;
    },
    updateQuad: function(X, S) {
        if (!X)
            throw "cc.TextureAtlas.updateQuad(): quad should be non-null";
        if (H8m.K0N(0, S) || H8m.d0N(S, this._capacity))
            throw "cc.TextureAtlas.updateQuad(): Invalid index";
        this._totalQuads = Math.max(S + 1, this._totalQuads);
        this._setQuadToArray(X, S);
        this.dirty = !0;
    },
    insertQuad: function(X, S) {
        if (H8m.t0N(S, this._capacity))
            throw "cc.TextureAtlas.insertQuad(): Invalid index";
        this._totalQuads++;
        if (H8m.w0N(this._totalQuads, this._capacity))
            cc.log("cc.TextureAtlas.insertQuad(): invalid totalQuads");
        else {
            var P = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                O = H8m.e0N(S, P),
                Z = H8m.Q0N((this._totalQuads - 1 - S), P);
            this._quads[H8m.r0N(this._totalQuads, 1)] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, H8m.N0N((this._totalQuads - 1), P));
            this._quadsReader.set(this._quadsReader.subarray(O, O + Z), O + P);
            this._setQuadToArray(X, S);
            this.dirty = !0;
        }
    },
    insertQuads: function(X, S, P) {
        P = P || X.length;
        if (H8m.m0N(S + P, this._capacity))
            throw "cc.TextureAtlas.insertQuad(): Invalid index + amount";
        var O = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += P;
        if (H8m.A0N(this._totalQuads, this._capacity))
            cc.log("cc.TextureAtlas.insertQuad(): invalid totalQuads");
        else {
            var Z = H8m.E0N(S, O),
                Y = H8m.C0N((this._totalQuads - 1 - S - P), O),
                T = H8m.h0N(this._totalQuads, 1, P),
                R;
            for (R = 0; H8m.H0N(R, P); R++)
                this._quads[T + R] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, H8m.f0N((this._totalQuads - 1), O));
            this._quadsReader.set(this._quadsReader.subarray(Z, Z + Y), Z + H8m.I0N(O, P));
            for (R = 0; H8m.g3N(R, P); R++)
                this._setQuadToArray(X[R], S + R);
            this.dirty = !0;
        }
    },
    insertQuadFromIndex: function(X, S) {
        if (H8m.K3N(X, S)) {
            if (H8m.d3N(0, S) && H8m.t3N(S, this._totalQuads))
                throw "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex";
            if (H8m.w3N(0, X) && H8m.e3N(X, this._totalQuads))
                throw "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex";
            var P = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                O = this._quadsReader,
                Z = O.subarray(H8m.Q3N(X, P), P),
                Y;
            H8m.r3N(X, S) ? (Y = H8m.N3N(S, P), O.set(O.subarray(Y, Y + H8m.m3N((X - S), P)), Y + P), O.set(Z, Y)) : (Y = H8m.A3N((X + 1), P), O.set(O.subarray(Y, Y + H8m.E3N((S - X), P)), H8m.C3N(Y, P)), O.set(Z, H8m.h3N(S, P)));
            this.dirty = !0;
        }
    },
    removeQuadAtIndex: function(X) {
        if (H8m.y3N(X, this._totalQuads))
            throw "cc.TextureAtlas.removeQuadAtIndex(): Invalid index";
        var S = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (H8m.q3N(X, this._totalQuads)) {
            var P = H8m.l3N((X + 1), S);
            this._quadsReader.set(this._quadsReader.subarray(P, P + H8m.X5N((this._totalQuads - X), S)), H8m.D5N(P, S));
        }
        this.dirty = !0;
    },
    removeQuadsAtIndex: function(X, S) {
        if (H8m.c5N(X + S, this._totalQuads))
            throw "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds";
        this._totalQuads -= S;
        if (H8m.z5N(X, this._totalQuads)) {
            var P = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                O = H8m.j5N((X + S), P),
                Z = H8m.x5N(X, P);
            this._quadsReader.set(this._quadsReader.subarray(O, O + H8m.o5N((this._totalQuads - X), P)), Z);
        }
        this.dirty = !0;
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0;
    },
    _setDirty: function(X) {
        this.dirty = X;
    },
    resizeCapacity: function(X) {
        if (H8m.p5N(X, this._capacity))
            return !0;
        var S = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            P = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, X);
        var O = this._capacity = H8m.Y5N(0, X),
            Z = this._totalQuads;
        if (H8m.T5N(null, this._quads))
            for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(H8m.R5N(S, O)), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), X = 0; H8m.M5N(X, O); X++)
                this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, H8m.V5N(X, S));
        else {
            var Y,
                T,
                R = this._quads;
            if (H8m.s5N(O, P)) {
                Y = [];
                T = new ArrayBuffer(H8m.U5N(S, O));
                for (X = 0; H8m.b5N(X, Z); X++)
                    Y[X] = new cc.V3F_C4B_T2F_Quad(R[X].tl, R[X].bl, R[X].tr, R[X].br, T, H8m.F5N(X, S));
                for (; H8m.k6N(X, O); X++)
                    Y[X] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, T, H8m.L6N(X, S));
            } else
                for (Z = Math.max(Z, O), Y = [], T = new ArrayBuffer(H8m.i6N(S, O)), X = 0; H8m.S6N(X, Z); X++)
                    Y[X] = new cc.V3F_C4B_T2F_Quad(R[X].tl, R[X].bl, R[X].tr, R[X].br, T, H8m.P6N(X, S));
            this._quadsReader = new Uint8Array(T);
            this._quads = Y;
            this._quadsArrayBuffer = T;
        }
        H8m.a6N(null, this._indices) ? this._indices = new Uint16Array(H8m.O6N(6, O)) : H8m.B6N(O, P) ? (S = new Uint16Array(H8m.Z6N(6, O)), S.set(this._indices, 0), this._indices = S) : this._indices = this._indices.subarray(0, H8m.J6N(6, O));
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0;
    },
    increaseTotalQuadsWith: function(X) {
        this._totalQuads += X;
    },
    moveQuadsFromIndex: function(X, S, P) {
        if (void 0 === P) {
            P = S;
            S = H8m.n6N(this._totalQuads, X);
            if (H8m.G6N(P + (this._totalQuads - X), this._capacity))
                throw "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds";
            if (H8m.W6N(0, S))
                return;
        } else {
            if (H8m.v6N(P + S, this._totalQuads))
                throw "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex";
            if (H8m.u6N(X, this._totalQuads))
                throw "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex";
            if (H8m.H6N(X, P))
                return;
        }
        var O = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            Z = H8m.f6N(X, O),
            Y = H8m.I6N(S, O),
            T = this._quadsReader,
            R = T.subarray(Z, Z + Y),
            E = H8m.g2N(P, O);
        H8m.K2N(P, X) ? (S = H8m.d2N(P, O), T.set(T.subarray(S, S + H8m.t2N((X - P), O)), S + Y)) : (S = H8m.w2N((X + S), O), T.set(T.subarray(S, S + H8m.e2N((P - X), O)), Z));
        T.set(R, E);
        this.dirty = !0;
    },
    fillWithEmptyQuadsFromIndex: function(X, S) {
        for (var P = H8m.Q2N(S, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT), O = new Uint8Array(this._quadsArrayBuffer, H8m.r2N(X, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT), P), Z = 0; H8m.N2N(Z, P); Z++)
            O[Z] = 0;
    },
    drawNumberOfQuads: function(X, S) {
        S = S || 0;
        if (H8m.m2N(0, X) && this.texture && this.texture.isLoaded()) {
            var P = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            P.bindBuffer(P.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && P.bufferData(P.ARRAY_BUFFER, this._quadsArrayBuffer, P.DYNAMIC_DRAW);
            P.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, P.FLOAT, !1, 24, 0);
            P.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, P.UNSIGNED_BYTE, !0, 24, 12);
            P.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, P.FLOAT, !1, 24, 16);
            this.dirty && (this.dirty = !1);
            P.bindBuffer(P.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? P.drawElements(P.TRIANGLE_STRIP, H8m.A2N(6, X), P.UNSIGNED_SHORT, H8m.E2N(6, S, this._indices.BYTES_PER_ELEMENT)) : P.drawElements(P.TRIANGLES, H8m.v2N(6, X), P.UNSIGNED_SHORT, H8m.u2N(6, S, this._indices.BYTES_PER_ELEMENT));
            cc.g_NumberOfDraws++;
        }
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0);
    },
    _releaseBuffer: function() {
        var X = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && X.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && X.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && X.deleteBuffer(this._quadsWebBuffer);
    }
});
w6b0K[q0K]._p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, H8m.z2i, _p.getTotalQuads);
cc.defineGetterSetter(_p, H8m.r8K, _p.getCapacity);
cc.defineGetterSetter(_p, H8m.I6S, _p.getQuads, _p.setQuads);
delete w6b0K[q0K]._p;
cc.TextureAtlas.create = function(X, S) {
    var P = new cc.TextureAtlas;
    if (H8m.u6P == typeof X) {
        if (P.initWithFile(X, S))
            return P;
    } else if (H8m.b2N(X, cc.Texture2D) && P.initWithTexture(file, S))
        return P;
    return H8m.H6P;
};
cc.Scene = cc.Node.extend({
    _className: H8m.n7H,
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !H8m.U7H;
        this.setAnchorPoint(H8m.E1S, H8m.E1S);
        this.setContentSize(cc.director.getWinSize());
    }
});
cc.Scene.create = function() {
    return new cc.Scene;
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _length: 0,
    _count: 0,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var P = this,
            O = cc.director.getWinSize(),
            Z = 200,
            Y = cc.p(H8m.F2N(O.width, 2), H8m.k9f(O.height, 2)),
            O = P._bgLayer = cc.LayerColor.create(cc.color(32, 32, 32, 255));
        O.setPosition(0, 0);
        P.addChild(O, 0);
        cc.loader.loadImg("data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k\x3d", {
            isCrossOrigin: !1
        }, function(X, S) {
            Z = S.height;
            P._initStage(S, Y);
        });
        var T = P._label = cc.LabelTTF.create("Loading... 0%", "Arial", 14);
        T.setColor(cc.color(180, 180, 180));
        T.setPosition(cc.pAdd(Y, cc.p(0, -Z / 2 - 10)));
        O.addChild(this._label, 10);
        return !0;
    },
    _initStage: function(X, S) {
        var P = this._texture2d = new cc.Texture2D;
        P.initWithElement(X);
        P.handleLoadedTexture();
        P = this._logo = cc.Sprite.create(P);
        P.setScale(cc.CONTENT_SCALE_FACTOR());
        P.x = S.x;
        P.y = S.y;
        this._bgLayer.addChild(P, 10);
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3);
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%");
    },
    initWithResources: function(X, S) {
        "string" == typeof X && (X = [X]);
        this.resources = X || [];
        this.cb = S;
    },
    _startLoading: function() {
        var P = this;
        P.unschedule(P._startLoading);
        var O = P.resources;
        P._length = O.length;
        cc.loader.load(O, function(X, S) {
            P._count = S;
        }, function() {
            P.cb();
        });
        P.schedule(P._updatePercent);
    },
    _updatePercent: function() {
        var X = this._count,
            S = this._length,
            P;
        P = Math.min(H8m.L9f(X / S * 100, 0), 100);
        this._label.setString("Loading... " + P + "%");
        H8m.i9f(X, S) && this.unschedule(this._updatePercent);
    }
});
cc.LoaderScene.preload = function(X, S) {
    var P = cc;
    P.loaderScene || (P.loaderScene = new cc.LoaderScene, P.loaderScene.init());
    P.loaderScene.initWithResources(X, S);
    cc.director.runScene(P.loaderScene);
    return P.loaderScene;
};
cc.Layer = cc.Node.extend({
    _className: H8m.H3i,
    ctor: function() {
        var X = cc.Node.prototype;
        X.ctor.call(this);
        this._ignoreAnchorPointForPosition = !H8m.U7H;
        X.setAnchorPoint.call(this, H8m.E1S, H8m.E1S);
        X.setContentSize.call(this, cc.winSize);
    }
});
cc.Layer.create = function() {
    return new cc.Layer;
};
cc.LayerRGBA = cc.Layer.extend({
    RGBAProtocol: !0,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeOpacityEnabled: !1,
    _cascadeColorEnabled: !1,
    _className: "LayerRGBA",
    ctor: function() {
        cc.Layer.prototype.ctor.call(this);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
    },
    init: function() {
        var X = cc.Layer.prototype;
        this._ignoreAnchorPointForPosition = !0;
        X.setAnchorPoint.call(this, 0.5, 0.5);
        X.setContentSize.call(this, cc.winSize);
        this.cascadeColor = this.cascadeOpacity = !1;
        return !0;
    },
    getOpacity: function() {
        return this._realOpacity;
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity;
    },
    setOpacity: function(X) {
        this._displayedOpacity = this._realOpacity = X;
        var S = 255,
            P = this._parent;
        P && P.RGBAProtocol && P.cascadeOpacity && (S = P.getDisplayedOpacity());
        this.updateDisplayedOpacity(S);
        this._displayedColor.a = this._realColor.a = X;
    },
    updateDisplayedOpacity: function(X) {
        this._displayedOpacity = H8m.S9f(0, this._realOpacity * X / 255);
        if (this._cascadeOpacityEnabled) {
            X = this._children;
            for (var S = 0; H8m.P9f(S, X.length); S++) {
                var P = X[S];
                P && P.RGBAProtocol && P.updateDisplayedOpacity(this._displayedOpacity);
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled;
    },
    setCascadeOpacityEnabled: function(X) {
        H8m.a9f(this._cascadeOpacityEnabled, X) && ((this._cascadeOpacityEnabled = X) ? this._enableCascadeOpacity() : this._disableCascadeOpacity());
    },
    _enableCascadeOpacity: function() {
        var X = 255,
            S = this._parent;
        S && S.RGBAProtocol && S.cascadeOpacity && (X = S.getDisplayedOpacity());
        this.updateDisplayedOpacity(X);
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        for (var X = this._children, S = 0; H8m.O9f(S, X.length); S++) {
            var P = X[S];
            P && P.RGBAProtocol && P.updateDisplayedOpacity(255);
        }
    },
    getColor: function() {
        var X = this._realColor;
        return cc.color(X.r, X.g, X.b, X.a);
    },
    getDisplayedColor: function() {
        var X = this._displayedColor;
        return cc.color(X.r, X.g, X.b);
    },
    setColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        S.r = P.r = X.r;
        S.g = P.g = X.g;
        S.b = P.b = X.b;
        S = (S = this._parent) && S.RGBAProtocol && S.cascadeColor ? S.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(S);
        void 0 === X.a || X.a_undefined || this.setOpacity(X.a);
    },
    updateDisplayedColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        S.r = H8m.B9f(0, P.r * X.r / 255);
        S.g = H8m.Z9f(0, P.g * X.g / 255);
        S.b = H8m.J9f(0, P.b * X.b / 255);
        if (this._cascadeColorEnabled)
            for (X = this._children, P = 0; H8m.n9f(P, X.length); P++) {
                var O = X[P];
                O && O.RGBAProtocol && O.updateDisplayedColor(S);
            }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled;
    },
    setCascadeColorEnabled: function(X) {
        H8m.G9f(this._cascadeColorEnabled, X) && ((this._cascadeColorEnabled = X) ? this._enableCascadeColor() : this._disableCascadeColor());
    },
    _enableCascadeColor: function() {
        var X;
        X = (X = this._parent) && X.RGBAProtocol && X.cascadeColor ? X.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(X);
    },
    _disableCascadeColor: function() {
        var X = this._displayedColor,
            S = this._realColor;
        X.r = S.r;
        X.g = S.g;
        X.b = S.b;
        for (var X = this._children, S = cc.color.WHITE, P = 0; H8m.W9f(P, X.length); P++) {
            var O = X[P];
            O && O.RGBAProtocol && O.updateDisplayedColor(S);
        }
    },
    addChild: function(X, S, P) {
        cc.Node.prototype.addChild.call(this, X, S, P);
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity();
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !1;
    }
});
w6b0K[q0K]._p = cc.LayerRGBA.prototype;
cc.defineGetterSetter(_p, H8m.R0K, _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.H9S, _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.t4P, _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
delete w6b0K[q0K]._p;
cc.LayerColor = cc.LayerRGBA.extend({
    _blendFunc: H8m.H6P,
    _className: H8m.h5H,
    getBlendFunc: function() {
        return this._blendFunc;
    },
    changeWidthAndHeight: function(X, S) {
        this.width = X;
        this.height = S;
    },
    changeWidth: function(X) {
        this.width = X;
    },
    changeHeight: function(X) {
        this.height = X;
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !H8m.h7H;
    },
    setColor: function(X) {
        cc.LayerRGBA.prototype.setColor.call(this, X);
        this._updateColor();
    },
    setOpacity: function(X) {
        cc.LayerRGBA.prototype.setOpacity.call(this, X);
        this._updateColor();
    },
    _isLighterMode: !H8m.h7H,
    _squareVertices: H8m.H6P,
    _squareColors: H8m.H6P,
    _verticesFloat32Buffer: H8m.H6P,
    _colorsUint8Buffer: H8m.H6P,
    _squareVerticesAB: H8m.H6P,
    _squareColorsAB: H8m.H6P,
    ctor: H8m.H6P,
    _ctorForCanvas: function(X, S, P) {
        cc.LayerRGBA.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, X, S, P);
    },
    _ctorForWebGL: function(X, S, P) {
        this._squareVerticesAB = new ArrayBuffer(H8m.J9i);
        this._squareColorsAB = new ArrayBuffer(H8m.U9i);
        var O = this._squareVerticesAB,
            Z = this._squareColorsAB,
            Y = cc.Vertex2F.BYTES_PER_ELEMENT,
            T = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(H8m.U7H, H8m.U7H, O, H8m.U7H), new cc.Vertex2F(H8m.U7H, H8m.U7H, O, Y), new cc.Vertex2F(H8m.U7H, H8m.U7H, O, H8m.v9f(H8m.s7H, Y)), new cc.Vertex2F(H8m.U7H, H8m.U7H, O, H8m.u9f(H8m.v7H, Y))];
        this._squareColors = [cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K, Z, H8m.U7H), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K, Z, T), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K, Z, H8m.H9f(H8m.s7H, T)), cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K, Z, H8m.f9f(H8m.v7H, T))];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer();
        cc.LayerRGBA.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, X, S, P);
    },
    init: function(X, S, P) {
        H8m.I9f(cc._renderType, cc._RENDER_TYPE_CANVAS) && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var O = cc.director.getWinSize();
        X = X || cc.color(H8m.U7H, H8m.U7H, H8m.U7H, H8m.s0K);
        S = void 0 === S ? O.width : S;
        P = void 0 === P ? O.height : P;
        O = this._displayedColor;
        O.r = X.r;
        O.g = X.g;
        O.b = X.b;
        O = this._realColor;
        O.r = X.r;
        O.g = X.g;
        O.b = X.b;
        this._realOpacity = this._displayedOpacity = X.a;
        X = cc.LayerColor.prototype;
        X.setContentSize.call(this, S, P);
        X._updateColor.call(this);
        return !H8m.U7H;
    },
    setBlendFunc: function(X, S) {
        this._blendFunc = void H8m.U7H === S ? X : {
            src: X,
            dst: S
        };
        H8m.g1f(cc._renderType, cc._RENDER_TYPE_CANVAS) && (this._isLighterMode = this._blendFunc && H8m.K1f(H8m.h7H, this._blendFunc.src) && H8m.d1f(H8m.l2i, this._blendFunc.dst));
    },
    setContentSize: H8m.H6P,
    _setContentSizeForWebGL: function(X, S) {
        var P = this._squareVertices;
        void 0 === S ? (P[1].x = X.width, P[2].y = X.height, P[3].x = X.width, P[3].y = X.height) : (P[1].x = X, P[2].y = S, P[3].x = X, P[3].y = S);
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype.setContentSize.call(this, X, S);
    },
    _setWidthForWebGL: function(X) {
        var S = this._squareVertices;
        S[H8m.h7H].x = X;
        S[H8m.v7H].x = X;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setWidth.call(this, X);
    },
    _setHeightForWebGL: function(X) {
        var S = this._squareVertices;
        S[H8m.s7H].y = X;
        S[H8m.v7H].y = X;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setHeight.call(this, X);
    },
    _updateColor: H8m.H6P,
    _updateColorForCanvas: function() {},
    _updateColorForWebGL: function() {
        for (var X = this._displayedColor, S = this._displayedOpacity, P = this._squareColors, O = H8m.U7H; H8m.t1f(H8m.q7H, O); O++)
            P[O].r = X.r, P[O].g = X.g, P[O].b = X.b, P[O].a = S;
        this._bindLayerColorsBufferData();
    },
    updateDisplayedColor: function(X) {
        cc.LayerRGBA.prototype.updateDisplayedColor.call(this, X);
        this._updateColor();
    },
    updateDisplayedOpacity: function(X) {
        cc.LayerRGBA.prototype.updateDisplayedOpacity.call(this, X);
        this._updateColor();
    },
    _bindLayerVerticesBufferData: function() {
        var X = cc._renderContext;
        X.bindBuffer(X.ARRAY_BUFFER, this._verticesFloat32Buffer);
        X.bufferData(X.ARRAY_BUFFER, this._squareVerticesAB, X.STATIC_DRAW);
    },
    _bindLayerColorsBufferData: function() {
        var X = cc._renderContext;
        X.bindBuffer(X.ARRAY_BUFFER, this._colorsUint8Buffer);
        X.bufferData(X.ARRAY_BUFFER, this._squareColorsAB, X.STATIC_DRAW);
    },
    draw: H8m.H6P,
    _drawForCanvas: function(X) {
        X = X || cc._renderContext;
        var S = cc.view,
            P = this._displayedColor;
        X.fillStyle = "rgba(" + (H8m.w1f(0, P.r)) + "," + (H8m.e1f(0, P.g)) + "," + (H8m.Q1f(0, P.b)) + "," + H8m.r1f(this._displayedOpacity, 255) + ")";
        X.fillRect(0, 0, H8m.N1f(this.width, S.getScaleX()), -this.height * S.getScaleY());
        cc.g_NumberOfDraws++;
    },
    _drawForWebGL: function(X) {
        X = X || cc._renderContext;
        cc.NODE_DRAW_SETUP(this);
        cc.glEnableVertexAttribs(H8m.m1f(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_COLOR));
        X.bindBuffer(X.ARRAY_BUFFER, this._verticesFloat32Buffer);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, H8m.s7H, X.FLOAT, !H8m.h7H, H8m.U7H, H8m.U7H);
        X.bindBuffer(X.ARRAY_BUFFER, this._colorsUint8Buffer);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, H8m.q7H, X.UNSIGNED_BYTE, !H8m.U7H, H8m.U7H, H8m.U7H);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        X.drawArrays(X.TRIANGLE_STRIP, H8m.U7H, H8m.q7H);
    }
});
w6b0K[q0K]._p = cc.LayerColor.prototype;
H8m.A1f(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.ctor = _p._ctorForWebGL, _p.setContentSize = _p._setContentSizeForWebGL, _p._setWidth = _p._setWidthForWebGL, _p._setHeight = _p._setHeightForWebGL, _p._updateColor = _p._updateColorForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setContentSize = cc.LayerRGBA.prototype.setContentSize, _p._setWidth = cc.LayerRGBA.prototype._setWidth, _p._setHeight = cc.LayerRGBA.prototype._setHeight, _p._updateColor = _p._updateColorForCanvas, _p.draw = _p._drawForCanvas);
cc.defineGetterSetter(_p, H8m.D3H, _p._getWidth, _p._setWidth);
cc.defineGetterSetter(_p, H8m.m5S, _p._getHeight, _p._setHeight);
delete w6b0K[q0K]._p;
cc.LayerColor.create = function(X, S, P) {
    return new cc.LayerColor(X, S, P);
};
cc.LayerGradient = cc.LayerColor.extend({
    _startColor: null,
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _gradientStartPoint: null,
    _gradientEndPoint: null,
    _className: "LayerGradient",
    ctor: function(X, S, P) {
        cc.LayerColor.prototype.ctor.call(this);
        this._startColor = cc.color(0, 0, 0, 255);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerGradient.prototype.init.call(this, X, S, P);
    },
    init: function(X, S, P) {
        X = X || cc.color(0, 0, 0, 255);
        S = S || cc.color(0, 0, 0, 255);
        P = P || cc.p(0, -1);
        var O = this._startColor,
            Z = this._endColor;
        O.r = X.r;
        O.g = X.g;
        O.b = X.b;
        this._startOpacity = X.a;
        Z.r = S.r;
        Z.g = S.g;
        Z.b = S.b;
        this._endOpacity = S.a;
        this._alongVector = P;
        this._compressedInterpolation = !0;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerColor.prototype.init.call(this, cc.color(X.r, X.g, X.b, 255));
        cc.LayerGradient.prototype._updateColor.call(this);
        return !0;
    },
    setContentSize: function(X, S) {
        cc.LayerColor.prototype.setContentSize.call(this, X, S);
        this._updateColor();
    },
    _setWidth: function(X) {
        cc.LayerColor.prototype._setWidth.call(this, X);
        this._updateColor();
    },
    _setHeight: function(X) {
        cc.LayerColor.prototype._setHeight.call(this, X);
        this._updateColor();
    },
    getStartColor: function() {
        return this._realColor;
    },
    setStartColor: function(X) {
        this.color = X;
    },
    setEndColor: function(X) {
        this._endColor = X;
        this._updateColor();
    },
    getEndColor: function() {
        return this._endColor;
    },
    setStartOpacity: function(X) {
        this._startOpacity = X;
        this._updateColor();
    },
    getStartOpacity: function() {
        return this._startOpacity;
    },
    setEndOpacity: function(X) {
        this._endOpacity = X;
        this._updateColor();
    },
    getEndOpacity: function() {
        return this._endOpacity;
    },
    setVector: function(X) {
        this._alongVector.x = X.x;
        this._alongVector.y = X.y;
        this._updateColor();
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y);
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation;
    },
    setCompressedInterpolation: function(X) {
        this._compressedInterpolation = X;
        this._updateColor();
    },
    draw: function(X) {
        if (H8m.E1f(cc._renderType, cc._RENDER_TYPE_WEBGL))
            cc.LayerColor.prototype.draw.call(this, X);
        else {
            X = X || cc._renderContext;
            this._isLighterMode && (X.globalCompositeOperation = "lighter");
            X.save();
            var S = cc.view,
                P = H8m.C1f(this._displayedOpacity, 255),
                O = H8m.h1f(this.width, S.getScaleX()),
                S = H8m.y1f(this.height, S.getScaleY()),
                Z = X.createLinearGradient(this._gradientStartPoint.x, this._gradientStartPoint.y, this._gradientEndPoint.x, this._gradientEndPoint.y),
                Y = this._displayedColor,
                T = this._endColor;
            Z.addColorStop(0, "rgba(" + Math.round(Y.r) + "," + Math.round(Y.g) + "," + Math.round(Y.b) + "," + (H8m.q1f(this._startOpacity, 255, P)).toFixed(4) + ")");
            Z.addColorStop(1, "rgba(" + Math.round(T.r) + "," + Math.round(T.g) + "," + Math.round(T.b) + "," + (H8m.I1f(this._endOpacity, 255, P)).toFixed(4) + ")");
            X.fillStyle = Z;
            X.fillRect(0, 0, O, -S);
            H8m.L8f(0, this._rotation) && X.rotate(this._rotationRadians);
            X.restore();
        }
    },
    _updateColor: function() {
        var X = this._alongVector;
        if (H8m.i8f(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            var S = H8m.S8f(0.5, this.width),
                P = H8m.P8f(0.5, this.height);
            this._gradientStartPoint.x = S * -X.x + S;
            this._gradientStartPoint.y = H8m.a8f(P * X.y, P);
            this._gradientEndPoint.x = H8m.O8f(S, X.x) + S;
            this._gradientEndPoint.y = P * -X.y - P;
        } else if (P = cc.pLength(X), H8m.B8f(0, P)) {
            S = Math.sqrt(2);
            X = cc.p(H8m.Z8f(X.x, P), H8m.J8f(X.y, P));
            this._compressedInterpolation && (P = H8m.n8f(1, (Math.abs(X.x) + Math.abs(X.y))), X = cc.pMult(X, H8m.G8f(P, S)));
            var O = H8m.W8f(this._displayedOpacity, 255),
                P = this._displayedColor,
                Z = this._endColor,
                P = {
                    r: P.r,
                    g: P.g,
                    b: P.b,
                    a: H8m.v8f(this._startOpacity, O)
                },
                O = {
                    r: Z.r,
                    g: Z.g,
                    b: Z.b,
                    a: H8m.u8f(this._endOpacity, O)
                },
                Y = this._squareColors,
                Z = Y[0],
                T = Y[1],
                R = Y[2],
                Y = Y[3];
            Z.r = O.r + H8m.H8f((S + X.x + X.y), (2 * S), (P.r - O.r));
            Z.g = O.g + H8m.F8f((S + X.x + X.y), (2 * S), (P.g - O.g));
            Z.b = O.b + H8m.X4f((S + X.x + X.y), (2 * S), (P.b - O.b));
            Z.a = O.a + H8m.K4f((S + X.x + X.y), (2 * S), (P.a - O.a));
            T.r = O.r + H8m.S4f((S - X.x + X.y), (2 * S), (P.r - O.r));
            T.g = O.g + H8m.j4f((S - X.x + X.y), (2 * S), (P.g - O.g));
            T.b = O.b + H8m.e4f((S - X.x + X.y), (2 * S), (P.b - O.b));
            T.a = O.a + H8m.B4f((S - X.x + X.y), (2 * S), (P.a - O.a));
            R.r = O.r + H8m.Y4f((S + X.x - X.y), (2 * S), (P.r - O.r));
            R.g = O.g + H8m.m4f((S + X.x - X.y), (2 * S), (P.g - O.g));
            R.b = O.b + H8m.G4f((S + X.x - X.y), (2 * S), (P.b - O.b));
            R.a = O.a + H8m.V4f((S + X.x - X.y), (2 * S), (P.a - O.a));
            Y.r = O.r + H8m.h4f((S - X.x - X.y), (2 * S), (P.r - O.r));
            Y.g = O.g + H8m.H4f((S - X.x - X.y), (2 * S), (P.g - O.g));
            Y.b = O.b + H8m.F4f((S - X.x - X.y), (2 * S), (P.b - O.b));
            Y.a = O.a + H8m.X7f((S - X.x - X.y), (2 * S), (P.a - O.a));
            this._bindLayerColorsBufferData();
        }
    }
});
w6b0K[q0K]._p = cc.LayerGradient.prototype;
cc.defineGetterSetter(_p, H8m.r6H, _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, H8m.k1P, _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, H8m.h5S, _p.getStartOpacity, _p.setStartOpacity);
cc.defineGetterSetter(_p, H8m.F7P, _p.getEndOpacity, _p.setEndOpacity);
cc.defineGetterSetter(_p, H8m.X2i, _p.getVector, _p.setVector);
delete w6b0K[q0K]._p;
cc.LayerGradient.create = function(X, S, P) {
    return new cc.LayerGradient(X, S, P);
};
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: H8m.U7H,
    _layers: H8m.H6P,
    _className: H8m.K8K,
    ctor: function(X) {
        cc.Layer.prototype.ctor.call(this);
        X && cc.LayerMultiplex.prototype.initWithLayers.call(this, X);
    },
    initWithLayers: function(X) {
        H8m.K7f(0, X.length) && H8m.d7f(null, X[X.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
        this._layers = X;
        this._enabledLayer = H8m.U7H;
        this.addChild(this._layers[this._enabledLayer]);
        return !H8m.U7H;
    },
    switchTo: function(X) {
        H8m.t7f(X, this._layers.length) ? cc.log("cc.LayerMultiplex.switchTo():Invalid index in MultiplexLayer switchTo message") : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = X, this.addChild(this._layers[X]));
    },
    switchToAndReleaseMe: function(X) {
        H8m.w7f(X, this._layers.length) ? cc.log("cc.LayerMultiplex.switchToAndReleaseMe():Invalid index in MultiplexLayer switchTo message") : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = X, this.addChild(this._layers[X]));
    },
    addLayer: function(X) {
        var S = "cc.Layer.addLayer(): layer should be non-null";
        X ? this._layers.push(X) : cc.log(S);
    }
});
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(arguments);
};
H8m.A5();
cc.generateTextureCacheForColor = function(V) {
    function U() {
        var X = cc.generateTextureCacheForColor,
            S = V.width,
            P = V.height;
        k9[0].width = S;
        k9[0].height = P;
        k9[1].width = S;
        k9[1].height = P;
        k9[2].width = S;
        k9[2].height = P;
        k9[3].width = S;
        k9[3].height = P;
        X.canvas.width = S;
        X.canvas.height = P;
        var O = X.canvas.getContext("2d");
        O.drawImage(V, 0, 0);
        X.tempCanvas.width = S;
        X.tempCanvas.height = P;
        for (var O = O.getImageData(0, 0, S, P).data, Z = 0; H8m.e7f(4, Z); Z++) {
            var Y = k9[Z].getContext("2d");
            Y.getImageData(0, 0, S, P).data;
            X.tempCtx.drawImage(V, 0, 0);
            for (var T = X.tempCtx.getImageData(0, 0, S, P), R = T.data, E = 0; H8m.Q7f(E, O.length); E += 4)
                R[E] = H8m.r7f(0, Z) ? O[E] : 0, R[E + 1] = H8m.N7f(1, Z) ? O[E + 1] : 0, R[E + 2] = H8m.m7f(2, Z) ? O[E + 2] : 0, R[E + 3] = O[E + 3];
            Y.putImageData(T, 0, 0);
        }
        V.onload = null;
    }
    if (V.channelCache)
        return V.channelCache;
    var k9 = [w6b0K[I0K]['createElement']("canvas"), w6b0K[I0K]['createElement']("canvas"), w6b0K[I0K]['createElement']("canvas"), w6b0K[I0K]['createElement']("canvas")];
    try {
        U();
    } catch (X) {
        V.onload = U;
    }
    return V.channelCache = k9;
};
cc.generateTextureCacheForColor.canvas = w6b0K[I0K]['createElement']("canvas");
cc.generateTextureCacheForColor.tempCanvas = w6b0K[I0K]['createElement'](H8m.e6S);
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext(H8m.C9K);
cc.generateTintImage2 = function(X, S, P) {
    P || (P = cc.rect(0, 0, X.width, X.height), P = cc.RECT_PIXELS_TO_POINTS(P));
    var O = w6b0K[I0K]['createElement'](H8m.e6S),
        Z = O.getContext(H8m.C9K);
    H8m.A7f(O.width, P.width) && (O.width = P.width);
    H8m.E7f(O.height, P.height) && (O.height = P.height);
    Z.save();
    Z.drawImage(X, P.x, P.y, P.width, P.height, 0, 0, P.width, P.height);
    Z.globalCompositeOperation = "source-in";
    Z.globalAlpha = H8m.C7f(S.a, 255);
    Z.fillStyle = "rgb(" + S.r + "," + S.g + "," + S.b + ")";
    Z.fillRect(0, 0, P.width, P.height);
    Z.restore();
    return O;
};
cc.generateTintImage = function(X, S, P, O, Z) {
    O || (O = cc.rect(0, 0, X.width, X.height));
    X = H8m.h7f(P.r, 255);
    var Y = H8m.y7f(P.g, 255);
    P = H8m.q7f(P.b, 255);
    var T = Math.min(O.width, S[0].width),
        R = Math.min(O.height, S[0].height),
        E;
    Z ? (E = Z.getContext("2d"), E.clearRect(0, 0, T, R)) : (Z = w6b0K[I0K]['createElement']("canvas"), Z.width = T, Z.height = R, E = Z.getContext("2d"));
    E.save();
    E.globalCompositeOperation = "lighter";
    var V = E.globalAlpha;
    H8m.l7f(0, X) && (E.globalAlpha = H8m.X0f(X, V), E.drawImage(S[0], O.x, O.y, T, R, 0, 0, T, R));
    H8m.D0f(0, Y) && (E.globalAlpha = H8m.c0f(Y, V), E.drawImage(S[1], O.x, O.y, T, R, 0, 0, T, R));
    H8m.z0f(0, P) && (E.globalAlpha = H8m.j0f(P, V), E.drawImage(S[2], O.x, O.y, T, R, 0, 0, T, R));
    H8m.x0f(1, X + Y + P) && (E.globalAlpha = V, E.drawImage(S[3], O.x, O.y, T, R, 0, 0, T, R));
    E.restore();
    return Z;
};
cc.cutRotateImageToCanvas = function(X, S) {
    if (!X)
        return H8m.H6P;
    if (!S)
        return X;
    var P = w6b0K[I0K]['createElement'](H8m.e6S);
    P.width = S.width;
    P.height = S.height;
    var O = P.getContext(H8m.C9K);
    O.translate(H8m.o0f(P.width, 2), H8m.p0f(P.height, 2));
    O.rotate(-1.5707963267948966);
    O.drawImage(X, S.x, S.y, S.height, S.width, -S.height / 2, -S.width / 2, S.height, S.width);
    return P;
};
cc.RENDER_IN_SUBPIXEL = function(X) {
    return H8m.Y0f(H8m.U7H, X);
};
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL && (cc.RENDER_IN_SUBPIXEL = function(X) {
    return X;
});
cc.Sprite = cc.NodeRGBA.extend({
    RGBAProtocol: !0,
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    textureLoaded: function() {
        return this._textureLoaded;
    },
    addLoadedEventListener: function(X, S) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var X = this._loadedEventListeners, S = 0, P = X.length; H8m.T0f(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    },
    isDirty: function() {
        return this.dirty;
    },
    setDirty: function(X) {
        this.dirty = X;
    },
    isTextureRectRotated: function() {
        return this._rectRotated;
    },
    getAtlasIndex: function() {
        return this.atlasIndex;
    },
    setAtlasIndex: function(X) {
        this.atlasIndex = X;
    },
    getTextureRect: function() {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height);
    },
    getTextureAtlas: function() {
        return this.textureAtlas;
    },
    setTextureAtlas: function(X) {
        this.textureAtlas = X;
    },
    getOffsetPosition: function() {
        return this._offsetPosition;
    },
    _getOffsetX: function() {
        return this._offsetPosition.x;
    },
    _getOffsetY: function() {
        return this._offsetPosition.y;
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    initWithSpriteFrame: function(X) {
        if (!X)
            throw "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null";
        X.textureLoaded() || (this._textureLoaded = !1, X.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var S = this.initWithTexture(X.getTexture(), X.getRect());
        this.setSpriteFrame(X);
        return S;
    },
    _spriteFrameLoadedCallback: null,
    _spriteFrameLoadedCallbackForWebGL: function(X) {
        this.setNodeDirty(!0);
        this.setTextureRect(X.getRect(), X.isRotated(), X.getOriginalSize());
        this._callLoadedEventCallbacks();
    },
    _spriteFrameLoadedCallbackForCanvas: function(X) {
        this.setNodeDirty(!0);
        this.setTextureRect(X.getRect(), X.isRotated(), X.getOriginalSize());
        X = this.color;
        H8m.R0f(255, X.r) && H8m.M0f(255, X.g) && H8m.V0f(255, X.b) || this._changeTextureColor();
        this._callLoadedEventCallbacks();
    },
    initWithSpriteFrameName: function(X) {
        if (!X)
            throw "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        X = cc.spriteFrameCache.getSpriteFrame(X);
        return this.initWithSpriteFrame(X);
    },
    useBatchNode: function(X) {
        this.textureAtlas = X.textureAtlas;
        this._batchNode = X;
    },
    setVertexRect: function(X) {
        this._rect.x = X.x;
        this._rect.y = X.y;
        this._rect.width = X.width;
        this._rect.height = X.height;
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            for (var X, S, P = this._children, O, Z = 1; H8m.s0f(Z, P.length); Z++) {
                S = P[Z];
                X = H8m.U0f(Z, 1);
                for (O = P[X]; H8m.b0f(0, X) && (H8m.F0f(S._localZOrder, O._localZOrder) || H8m.k3f(S._localZOrder, O._localZOrder) && H8m.L3f(S.arrivalOrder, O.arrivalOrder));)
                    P[X + 1] = O, X -= 1, O = P[X];
                P[X + 1] = S;
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(P, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1;
        }
    },
    reorderChild: function(X, S) {
        if (!X)
            throw "cc.Sprite.reorderChild(): child should be non-null";
        -1 === this._children.indexOf(X) ? cc.log("cc.Sprite.reorderChild(): this child is not in children list") : H8m.i3f(S, X.zIndex) && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, X, S));
    },
    removeChild: function(X, S) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(X);
        cc.Node.prototype.removeChild.call(this, X, S);
    },
    removeAllChildren: function(X) {
        var S = this._children,
            P = this._batchNode;
        if (P && H8m.S3f(null, S))
            for (var O = 0, Z = S.length; H8m.P3f(O, Z); O++)
                P.removeSpriteFromAtlas(S[O]);
        cc.Node.prototype.removeAllChildren.call(this, X);
        this._hasChildren = !1;
    },
    setDirtyRecursively: function(X) {
        this.dirty = this._recursiveDirty = X;
        X = this._children;
        for (var S, P = X ? X.length : 0, O = 0; H8m.a3f(O, P); O++)
            S = X[O], H8m.O3f(S, cc.Sprite) && S.setDirtyRecursively(!0);
    },
    setNodeDirty: function(X) {
        cc.Node.prototype.setNodeDirty.call(this);
        X || !this._batchNode || this._recursiveDirty || (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0);
    },
    ignoreAnchorPointForPosition: function(X) {
        this._batchNode ? cc.log("cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode") : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, X);
    },
    setFlippedX: function(X) {
        H8m.B3f(this._flippedX, X) && (this._flippedX = X, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0));
    },
    setFlippedY: function(X) {
        H8m.Z3f(this._flippedY, X) && (this._flippedY = X, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0));
    },
    isFlippedX: function() {
        return this._flippedX;
    },
    isFlippedY: function() {
        return this._flippedY;
    },
    setOpacityModifyRGB: null,
    _setOpacityModifyRGBForWebGL: function(X) {
        H8m.J3f(this._opacityModifyRGB, X) && (this._opacityModifyRGB = X, this.updateColor());
    },
    _setOpacityModifyRGBForCanvas: function(X) {
        H8m.n3f(this._opacityModifyRGB, X) && (this._opacityModifyRGB = X, this.setNodeDirty(!0));
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
    },
    updateDisplayedOpacity: null,
    _updateDisplayedOpacityForWebGL: function(X) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, X);
        this.updateColor();
    },
    _updateDisplayedOpacityForCanvas: function(X) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, X);
        this._setNodeDirtyForCache();
    },
    setDisplayFrameWithAnimationName: function(X, S) {
        if (!X)
            throw "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null";
        var P = cc.animationCache.getAnimation(X);
        P ? (P = P.getFrames()[S]) ? this.setSpriteFrame(P.getSpriteFrame()) : cc.log("cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index") : cc.log("cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found");
    },
    getBatchNode: function() {
        return this._batchNode;
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var X = this._parent; X && H8m.G3f(X, this._batchNode);)
                X._setReorderChildDirtyRecursively(), X = X.parent;
        }
    },
    getTexture: function() {
        return this._texture;
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _isLighterMode: !1,
    _originalTexture: null,
    _textureRect_Canvas: null,
    _drawSize_Canvas: null,
    ctor: null,
    _ctorForWebGL: function(X, S) {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._textureLoaded = this._quadDirty = !0;
        this._softInit(X, S);
    },
    _ctorForCanvas: function(X, S) {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._newTextureWhenChangeColor = !1;
        this._textureLoaded = !0;
        this._textureRect_Canvas = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        };
        this._drawSize_Canvas = cc.size(0, 0);
        this._softInit(X, S);
    },
    _softInit: function(X, S) {
        if (void 0 === X)
            cc.Sprite.prototype.init.call(this);
        else if ("string" === typeof X)
            if (H8m.W3f("#", X[0])) {
                var P = X.substr(1, H8m.v3f(X.length, 1)),
                    P = cc.spriteFrameCache.getSpriteFrame(P);
                this.initWithSpriteFrame(P);
            } else
                cc.Sprite.prototype.init.call(this, X, S);
        else if ("object" === typeof X)
            if (H8m.u3f(X, cc.Texture2D))
                this.initWithTexture(X, S);
            else if (H8m.H3f(X, cc.SpriteFrame))
                this.initWithSpriteFrame(X);
            else if (H8m.f3f(X, HTMLImageElement) || H8m.I3f(X, HTMLCanvasElement))
                P = new cc.Texture2D, P.initWithElement(X), P.handleLoadedTexture(), this.initWithTexture(P);
    },
    getQuad: function() {
        return this._quad;
    },
    setBlendFunc: null,
    _setBlendFuncForWebGL: function(X, S) {
        var P = this._blendFunc;
        void 0 === S ? (P.src = X.src, P.dst = X.dst) : (P.src = X, P.dst = S);
    },
    _setBlendFuncForCanvas: function(X, S) {
        var P = this._blendFunc;
        void 0 === S ? (P.src = X.src, P.dst = X.dst) : (P.src = X, P.dst = S);
        this._isLighterMode = P && (H8m.g5f(P.src, cc.SRC_ALPHA) && H8m.K5f(P.dst, cc.ONE) || H8m.d5f(P.src, cc.ONE) && H8m.t5f(P.dst, cc.ONE));
    },
    init: null,
    _initForWebGL: function() {
        if (H8m.w5f(0, arguments.length))
            return this.initWithFile(arguments[0], arguments[1]);
        cc.NodeRGBA.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var X = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        this._quad.bl.colors = X;
        this._quad.br.colors = X;
        this._quad.tl.colors = X;
        this._quad.tr.colors = X;
        this._quadDirty = !0;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0;
    },
    _initForCanvas: function() {
        if (H8m.e5f(0, arguments.length))
            return this.initWithFile(arguments[0], arguments[1]);
        cc.NodeRGBA.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0;
    },
    initWithFile: function(X, S) {
        if (!X)
            throw "cc.Sprite.initWithFile(): filename should be non-null";
        var P = cc.textureCache.textureForKey(X);
        if (!P)
            P = cc.textureCache.addImage(X);
        else if (!S) {
            var O = P.getContentSize();
            S = cc.rect(0, 0, O.width, O.height);
        }
        return this.initWithTexture(P, S);
    },
    initWithTexture: null,
    _initWithTextureForWebGL: function(X, S, P) {
        if (H8m.Q5f(0, arguments.length))
            throw "Sprite.initWithTexture(): Argument must be non-nil ";
        P = P || !1;
        if (!cc.NodeRGBA.prototype.init.call(this))
            return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var O = cc.color(255, 255, 255, 255),
            Z = this._quad;
        Z.bl.colors = O;
        Z.br.colors = O;
        Z.tl.colors = O;
        Z.tr.colors = O;
        this._textureLoaded = O = X.isLoaded();
        if (!O)
            return this._rectRotated = P || !1, S && (O = this._rect, O.x = S.x, O.y = S.y, O.width = S.width, O.height = S.height), X.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        S || (S = cc.rect(0, 0, X.width, X.height));
        this.texture = X;
        this.setTextureRect(S, P);
        this.batchNode = null;
        return this._quadDirty = !0;
    },
    _initWithTextureForCanvas: function(X, S, P) {
        if (H8m.r5f(0, arguments.length))
            throw "Sprite.initWithTexture(): Argument must be non-nil ";
        P = P || !1;
        if (!cc.NodeRGBA.prototype.init.call(this))
            return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var O = X.isLoaded();
        this._textureLoaded = O;
        if (!O)
            return this._rectRotated = P || !1, S && (this._rect.x = S.x, this._rect.y = S.y, this._rect.width = S.width, this._rect.height = S.height), X.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        S || (S = cc.rect(0, 0, X.width, X.height));
        this.texture = this._originalTexture = X;
        this.setTextureRect(S, P);
        this.batchNode = null;
        return !0;
    },
    _textureLoadedCallback: null,
    _textureLoadedCallbackForWebGL: function(X) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var S = this._rect;
            S ? cc._rectEqualToZero(S) && (S.width = X.width, S.height = X.height) : S = cc.rect(0, 0, X.width, X.height);
            this.texture = X;
            this.setTextureRect(S, this._rectRotated);
            this.batchNode = null;
            this._quadDirty = !0;
            this._callLoadedEventCallbacks();
        }
    },
    _textureLoadedCallbackForCanvas: function(X) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var S = this._rect;
            S ? cc._rectEqualToZero(S) && (S.width = X.width, S.height = X.height) : S = cc.rect(0, 0, X.width, X.height);
            this.texture = this._originalTexture = X;
            this.setTextureRect(S, this._rectRotated);
            this.batchNode = null;
            this._callLoadedEventCallbacks();
        }
    },
    setTextureRect: null,
    _setTextureRectForWebGL: function(X, S, P) {
        this._rectRotated = S || !1;
        this.setContentSize(P || X);
        this.setVertexRect(X);
        this._setTextureCoords(X);
        X = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (X.x = -X.x);
        this._flippedY && (X.y = -X.y);
        var O = this._rect;
        this._offsetPosition.x = X.x + H8m.N5f((this._contentSize.width - O.width), 2);
        this._offsetPosition.y = X.y + H8m.m5f((this._contentSize.height - O.height), 2);
        if (this._batchNode)
            this.dirty = !0;
        else {
            X = 0 + this._offsetPosition.x;
            S = 0 + this._offsetPosition.y;
            P = X + O.width;
            var O = S + O.height,
                Z = this._quad;
            Z.bl.vertices = {
                x: X,
                y: S,
                z: 0
            };
            Z.br.vertices = {
                x: P,
                y: S,
                z: 0
            };
            Z.tl.vertices = {
                x: X,
                y: O,
                z: 0
            };
            Z.tr.vertices = {
                x: P,
                y: O,
                z: 0
            };
            this._quadDirty = !0;
        }
    },
    _setTextureRectForCanvas: function(X, S, P) {
        this._rectRotated = S || !1;
        this.setContentSize(P || X);
        this.setVertexRect(X);
        S = this._textureRect_Canvas;
        P = cc.CONTENT_SCALE_FACTOR();
        S.x = H8m.A5f(0, X.x * P);
        S.y = H8m.E5f(0, X.y * P);
        S.width = H8m.C5f(0, X.width * P);
        S.height = H8m.h5f(0, X.height * P);
        S.validRect = !(H8m.y5f(0, S.width) || H8m.q5f(0, S.height) || H8m.l5f(0, S.x) || H8m.X6f(0, S.y));
        X = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (X.x = -X.x);
        this._flippedY && (X.y = -X.y);
        this._offsetPosition.x = X.x + H8m.D6f((this._contentSize.width - this._rect.width), 2);
        this._offsetPosition.y = X.y + H8m.c6f((this._contentSize.height - this._rect.height), 2);
        this._batchNode && (this.dirty = !0);
    },
    updateTransform: null,
    _updateTransformForWebGL: function() {
        if (this.dirty) {
            var X = this._quad,
                S = this._parent;
            if (!this._visible || S && H8m.z6f(S, this._batchNode) && S._shouldBeHidden)
                X.br.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, X.tl.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, X.tr.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, X.bl.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, this._shouldBeHidden = !0;
            else {
                this._shouldBeHidden = !1;
                var P = this._transformToBatch = S && H8m.j6f(S, this._batchNode) ? cc.AffineTransformConcat(this.nodeToParentTransform(), S._transformToBatch) : this.nodeToParentTransform(),
                    O = this._rect,
                    S = this._offsetPosition.x,
                    Z = this._offsetPosition.y,
                    Y = S + O.width,
                    T = Z + O.height,
                    O = P.tx,
                    R = P.ty,
                    E = P.a,
                    V = P.b,
                    U = P.d,
                    P = -P.c,
                    k9 = H8m.x6f(S, V) + H8m.o6f(Z, U) + R,
                    L9 = H8m.p6f(Y * E, Z * P, O),
                    K9 = H8m.N6f(Y, V) + H8m.m6f(Z, U) + R,
                    c9 = H8m.A6f(Y * E, T * P, O),
                    Y = H8m.W6f(Y, V) + H8m.v6f(T, U) + R,
                    t9 = H8m.u6f(S * E, T * P, O),
                    T = H8m.b6f(S, V) + H8m.F6f(T, U) + R,
                    R = this._vertexZ;
                X.bl.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(H8m.k2f(S * E, Z * P, O)),
                    y: cc.RENDER_IN_SUBPIXEL(k9),
                    z: R
                };
                X.br.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(L9),
                    y: cc.RENDER_IN_SUBPIXEL(K9),
                    z: R
                };
                X.tl.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(t9),
                    y: cc.RENDER_IN_SUBPIXEL(T),
                    z: R
                };
                X.tr.vertices = {
                    x: cc.RENDER_IN_SUBPIXEL(c9),
                    y: cc.RENDER_IN_SUBPIXEL(Y),
                    z: R
                };
            }
            this.textureAtlas.updateQuad(X, this.atlasIndex);
            this.dirty = this._recursiveDirty = !1;
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
        cc.SPRITE_DEBUG_DRAW && (X = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(X, 4, !0));
    },
    _updateTransformForCanvas: function() {
        if (this.dirty) {
            var X = this._parent;
            !this._visible || X && H8m.D2f(X, this._batchNode) && X._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = X && H8m.c2f(X, this._batchNode) ? cc.AffineTransformConcat(this.nodeToParentTransform(), X._transformToBatch) : this.nodeToParentTransform());
            this.dirty = this._recursiveDirty = !1;
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
    },
    addChild: null,
    _addChildForWebGL: function(X, S, P) {
        if (!X)
            throw "cc.Sprite.addChild(): child should be non-null";
        H8m.z2f(null, S) && (S = X._localZOrder);
        H8m.j2f(null, P) && (P = X.tag);
        if (this._batchNode) {
            if (!(H8m.x2f(X, cc.Sprite))) {
                cc.log("cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode");
                return;
            }
            H8m.o2f(X.texture._webTextureObj, this.textureAtlas.texture._webTextureObj) && cc.log("cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode");
            this._batchNode.appendChild(X);
            this._reorderChildDirty || this._setReorderChildDirtyRecursively();
        }
        cc.NodeRGBA.prototype.addChild.call(this, X, S, P);
        this._hasChildren = !0;
    },
    _addChildForCanvas: function(X, S, P) {
        if (!X)
            throw "cc.Sprite.addChild(): child should be non-null";
        H8m.p2f(null, S) && (S = X._localZOrder);
        H8m.Y2f(null, P) && (P = X.tag);
        cc.NodeRGBA.prototype.addChild.call(this, X, S, P);
        this._hasChildren = !0;
    },
    updateColor: function() {
        var X = this._displayedColor,
            S = this._displayedOpacity,
            X = {
                r: X.r,
                g: X.g,
                b: X.b,
                a: S
            };
        this._opacityModifyRGB && (X.r *= H8m.T2f(S, 255), X.g *= H8m.R2f(S, 255), X.b *= H8m.M2f(S, 255));
        S = this._quad;
        S.bl.colors = X;
        S.br.colors = X;
        S.tl.colors = X;
        S.tr.colors = X;
        this._batchNode && (H8m.V2f(this.atlasIndex, cc.SPRITE_INDEX_NOT_INITIALIZED) ? this.textureAtlas.updateQuad(S, this.atlasIndex) : this.dirty = !0);
        this._quadDirty = !0;
    },
    setOpacity: null,
    _setOpacityForWebGL: function(X) {
        cc.NodeRGBA.prototype.setOpacity.call(this, X);
        this.updateColor();
    },
    _setOpacityForCanvas: function(X) {
        cc.NodeRGBA.prototype.setOpacity.call(this, X);
        this._setNodeDirtyForCache();
    },
    setColor: null,
    _setColorForWebGL: function(X) {
        cc.NodeRGBA.prototype.setColor.call(this, X);
        this.updateColor();
    },
    _setColorForCanvas: function(X) {
        var S = this.color;
        if (H8m.h2f(S.r, X.r) || H8m.y2f(S.g, X.g) || H8m.q2f(S.b, X.b) || H8m.l2f(S.a, X.a))
            cc.NodeRGBA.prototype.setColor.call(this, X), this._changeTextureColor(), this._setNodeDirtyForCache();
    },
    updateDisplayedColor: null,
    _updateDisplayedColorForWebGL: function(X) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, X);
        this.updateColor();
    },
    _updateDisplayedColorForCanvas: function(X) {
        var S = this.color;
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, X);
        X = this._displayedColor;
        if (H8m.X92(S.r, X.r) || H8m.D92(S.g, X.g) || H8m.c92(S.b, X.b))
            this._changeTextureColor(), this._setNodeDirtyForCache();
    },
    setSpriteFrame: null,
    _setSpriteFrameForWebGL: function(P) {
        if ("string" == typeof P && (P = cc.spriteFrameCache.getSpriteFrame(P), !P))
            throw "Invalid spriteFrameName";
        this.setNodeDirty(!0);
        var O = P.getOffset();
        this._unflippedOffsetPositionFromCenter.x = O.x;
        this._unflippedOffsetPositionFromCenter.y = O.y;
        O = P.getTexture();
        P.textureLoaded() || (this._textureLoaded = !1, P.addLoadedEventListener(function(X) {
            this._textureLoaded = !0;
            var S = X.getTexture();
            H8m.z92(S, this._texture) && (this.texture = S);
            this.setTextureRect(X.getRect(), X.isRotated(), X.getOriginalSize());
            this._callLoadedEventCallbacks();
        }, this));
        H8m.j92(O, this._texture) && (this.texture = O);
        this._rectRotated = P.isRotated();
        this.setTextureRect(P.getRect(), this._rectRotated, P.getOriginalSize());
    },
    _setSpriteFrameForCanvas: function(P) {
        if ("string" == typeof P && (P = cc.spriteFrameCache.getSpriteFrame(P), !P))
            throw "Invalid spriteFrameName";
        this.setNodeDirty(!0);
        var O = P.getOffset();
        this._unflippedOffsetPositionFromCenter.x = O.x;
        this._unflippedOffsetPositionFromCenter.y = O.y;
        this._rectRotated = P.isRotated();
        var O = P.getTexture(),
            Z = P.textureLoaded();
        Z || (this._textureLoaded = !1, P.addLoadedEventListener(function(X) {
            this._textureLoaded = !0;
            var S = X.getTexture();
            H8m.x92(S, this._texture) && (this.texture = S);
            this.setTextureRect(X.getRect(), X.isRotated(), X.getOriginalSize());
            this._callLoadedEventCallbacks();
        }, this));
        H8m.o92(O, this._texture) && (this.texture = O);
        this._rectRotated && (this._originalTexture = O);
        this.setTextureRect(P.getRect(), this._rectRotated, P.getOriginalSize());
        this._colorized = !1;
        Z && (P = this.color, H8m.p92(255, P.r) && H8m.Y92(255, P.g) && H8m.T92(255, P.b) || this._changeTextureColor());
    },
    setDisplayFrame: function(X) {
        cc.log("setDisplayFrame is deprecated, please use setSpriteFrame instead.");
        this.setSpriteFrame(X);
    },
    isFrameDisplayed: null,
    _isFrameDisplayedForWebGL: function(X) {
        return cc.rectEqualToRect(X.getRect(), this._rect) && H8m.R92(X.getTexture().getName(), this._texture.getName()) && cc.pointEqualToPoint(X.getOffset(), this._unflippedOffsetPositionFromCenter);
    },
    _isFrameDisplayedForCanvas: function(X) {
        return H8m.M92(X.getTexture(), this._texture) ? !1 : cc.rectEqualToRect(X.getRect(), this._rect);
    },
    displayFrame: function() {
        return cc.SpriteFrame.create(this._texture, cc.RECT_POINTS_TO_PIXELS(this._rect), this._rectRotated, cc.POINT_POINTS_TO_PIXELS(this._unflippedOffsetPositionFromCenter), cc.SIZE_POINTS_TO_PIXELS(this._contentSize));
    },
    setBatchNode: null,
    _setBatchNodeForWebGL: function(X) {
        if (this._batchNode = X)
            this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas;
        else {
            this.atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
            this.textureAtlas = null;
            this.dirty = this._recursiveDirty = !1;
            X = this._offsetPosition.x;
            var S = this._offsetPosition.y,
                P = X + this._rect.width,
                O = S + this._rect.height,
                Z = this._quad;
            Z.bl.vertices = {
                x: X,
                y: S,
                z: 0
            };
            Z.br.vertices = {
                x: P,
                y: S,
                z: 0
            };
            Z.tl.vertices = {
                x: X,
                y: O,
                z: 0
            };
            Z.tr.vertices = {
                x: P,
                y: O,
                z: 0
            };
            this._quadDirty = !0;
        }
    },
    _setBatchNodeForCanvas: function(X) {
        (this._batchNode = X) ? (this._transformToBatch = cc.AffineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1);
    },
    setTexture: null,
    _setTextureForWebGL: function(X) {
        if (X && "string" === typeof X)
            X = cc.textureCache.addImage(X), this._setTextureForWebGL(X), X = X.getContentSize(), this.setTextureRect(cc.rect(0, 0, X.width, X.height));
        else {
            if (X && !(H8m.V92(X, cc.Texture2D)))
                throw "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.";
            this._batchNode && H8m.s92(this._batchNode.texture, X) ? cc.log("cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode") : (this.shaderProgram = X ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), this._batchNode || H8m.U92(this._texture, X) || (this._texture = X, this._updateBlendFunc()));
        }
    },
    _setTextureForCanvas: function(X) {
        if (X && "string" === typeof X)
            X = cc.textureCache.addImage(X), this._setTextureForCanvas(X), X = X.getContentSize(), this.setTextureRect(cc.rect(0, 0, X.width, X.height));
        else {
            if (X && !(H8m.b92(X, cc.Texture2D)))
                throw "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.";
            H8m.F92(this._texture, X) && (X && H8m.k12(X.getHtmlElementObj(), HTMLImageElement) && (this._originalTexture = X), this._texture = X);
        }
    },
    _updateBlendFunc: function() {
        this._batchNode ? cc.log("cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode") : this._texture && this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0) : (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1);
    },
    _changeTextureColor: function() {
        var X,
            S = this._texture,
            P = this._textureRect_Canvas;
        S && P.validRect && this._originalTexture && (X = S.getHtmlElementObj()) && (S = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (this._colorized = !0, H8m.L12(X, HTMLCanvasElement) && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(X, S, this._displayedColor, P, X) : (X = cc.generateTintImage(X, S, this._displayedColor, P), S = new cc.Texture2D, S.initWithElement(X), S.handleLoadedTexture(), this.texture = S));
    },
    _setTextureCoords: function(X) {
        X = cc.RECT_POINTS_TO_PIXELS(X);
        var S = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (S) {
            var P = S.pixelsWidth,
                O = S.pixelsHeight,
                Z,
                Y = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (S = H8m.i12((2 * X.x + 1), (2 * P)), P = S + H8m.S12((2 * X.height - 2), (2 * P)), Z = H8m.P12((2 * X.y + 1), (2 * O)), X = Z + H8m.a12((2 * X.width - 2), (2 * O))) : (S = H8m.O12(X.x, P), P = H8m.B12((X.x + X.height), P), Z = H8m.Z12(X.y, O), X = H8m.J12((X.y + X.width), O)), this._flippedX && (O = Z, Z = X, X = O), this._flippedY && (O = S, S = P, P = O), Y.bl.texCoords.u = S, Y.bl.texCoords.v = Z, Y.br.texCoords.u = S, Y.br.texCoords.v = X, Y.tl.texCoords.u = P, Y.tl.texCoords.v = Z, Y.tr.texCoords.u = P, Y.tr.texCoords.v = X) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (S = H8m.n12((2 * X.x + 1), (2 * P)), P = S + H8m.G12((2 * X.width - 2), (2 * P)), Z = H8m.W12((2 * X.y + 1), (2 * O)), X = Z + H8m.v12((2 * X.height - 2), (2 * O))) : (S = H8m.u12(X.x, P), P = H8m.H12((X.x + X.width), P), Z = H8m.F12(X.y, O), X = H8m.k82((X.y + X.height), O)), this._flippedX && (O = S, S = P, P = O), this._flippedY && (O = Z, Z = X, X = O), Y.bl.texCoords.u = S, Y.bl.texCoords.v = X, Y.br.texCoords.u = P, Y.br.texCoords.v = X, Y.tl.texCoords.u = S, Y.tl.texCoords.v = Z, Y.tr.texCoords.u = P, Y.tr.texCoords.v = Z);
            this._quadDirty = !0;
        }
    },
    draw: null,
    _drawForWebGL: function() {
        if (this._textureLoaded) {
            var X = cc._renderContext,
                S = this._texture;
            S ? S._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, S), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), X.bindBuffer(X.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (X.bufferData(X.ARRAY_BUFFER, this._quad.arrayBuffer, X.DYNAMIC_DRAW), this._quadDirty = !1), X.vertexAttribPointer(0, 3, X.FLOAT, !1, 24, 0), X.vertexAttribPointer(1, 4, X.UNSIGNED_BYTE, !0, 24, 12), X.vertexAttribPointer(2, 2, X.FLOAT, !1, 24, 16), X.drawArrays(X.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(H8m.L82(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_COLOR)), X.bindBuffer(X.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW), this._quadDirty = !1), X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, X.FLOAT, !1, 24, 0), X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, X.UNSIGNED_BYTE, !0, 24, 12), X.drawArrays(X.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (H8m.i82(0, cc.SPRITE_DEBUG_DRAW) || this._showNode)
                H8m.S82(1, cc.SPRITE_DEBUG_DRAW) || this._showNode ? (X = this._quad, X = [cc.p(X.tl.vertices.x, X.tl.vertices.y), cc.p(X.bl.vertices.x, X.bl.vertices.y), cc.p(X.br.vertices.x, X.br.vertices.y), cc.p(X.tr.vertices.x, X.tr.vertices.y)], cc._drawingUtil.drawPoly(X, 4, !0)) : H8m.P82(2, cc.SPRITE_DEBUG_DRAW) && (X = this.getTextureRect(), S = this.getOffsetPosition(), X = [cc.p(S.x, S.y), cc.p(S.x + X.width, S.y), cc.p(S.x + X.width, S.y + X.height), cc.p(S.x, S.y + X.height)], cc._drawingUtil.drawPoly(X, 4, !0));
        }
    },
    _drawForCanvas: function(X) {
        if (this._textureLoaded) {
            X = X || cc._renderContext;
            this._isLighterMode && (X.globalCompositeOperation = "lighter");
            var S = cc.view.getScaleX(),
                P = cc.view.getScaleY();
            X.globalAlpha = H8m.a82(this._displayedOpacity, 255);
            var O = this._rect,
                Z = this._contentSize,
                Y = this._offsetPosition,
                T = this._drawSize_Canvas,
                R = H8m.O82(0, Y.x),
                E = -Y.y - O.height,
                V = this._textureRect_Canvas;
            T.width = H8m.B82(O.width, S);
            T.height = H8m.Z82(O.height, P);
            if (this._flippedX || this._flippedY)
                X.save(), this._flippedX && (R = -Y.x - O.width, X.scale(-1, 1)), this._flippedY && (E = Y.y, X.scale(1, -1));
            R *= S;
            E *= P;
            this._texture && V.validRect ? (Z = this._texture.getHtmlElementObj(), this._colorized ? X.drawImage(Z, 0, 0, V.width, V.height, R, E, T.width, T.height) : X.drawImage(Z, V.x, V.y, V.width, V.height, R, E, T.width, T.height)) : H8m.J82(0, Z.width) && (T = this.color, X.fillStyle = "rgba(" + T.r + "," + T.g + "," + T.b + ",1)", X.fillRect(R, E, H8m.n82(Z.width, S), H8m.G82(Z.height, P)));
            H8m.W82(1, cc.SPRITE_DEBUG_DRAW) || this._showNode ? (X.strokeStyle = "rgba(0,255,0,1)", R /= S, E = -(H8m.v82(E, P)), R = [cc.p(R, E), cc.p(R + O.width, E), cc.p(R + O.width, H8m.u82(E, O.height)), cc.p(R, H8m.H82(E, O.height))], cc._drawingUtil.drawPoly(R, 4, !0)) : H8m.f82(2, cc.SPRITE_DEBUG_DRAW) && (X.strokeStyle = "rgba(0,255,0,1)", S = this._rect, E = -E, R = [cc.p(R, E), cc.p(R + S.width, E), cc.p(R + S.width, H8m.I82(E, S.height)), cc.p(R, H8m.g42(E, S.height))], cc._drawingUtil.drawPoly(R, 4, !0));
            (this._flippedX || this._flippedY) && X.restore();
            cc.g_NumberOfDraws++;
        }
    }
});
w6b0K[q0K]._p = cc.Sprite.prototype;
H8m.K42(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p._spriteFrameLoadedCallback = _p._spriteFrameLoadedCallbackForWebGL, _p.setOpacityModifyRGB = _p._setOpacityModifyRGBForWebGL, _p.updateDisplayedOpacity = _p._updateDisplayedOpacityForWebGL, _p.ctor = _p._ctorForWebGL, _p.setBlendFunc = _p._setBlendFuncForWebGL, _p.init = _p._initForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p._textureLoadedCallback = _p._textureLoadedCallbackForWebGL, _p.setTextureRect = _p._setTextureRectForWebGL, _p.updateTransform = _p._updateTransformForWebGL, _p.addChild = _p._addChildForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.setColor = _p._setColorForWebGL, _p.updateDisplayedColor = _p._updateDisplayedColorForWebGL, _p.setSpriteFrame = _p._setSpriteFrameForWebGL, _p.isFrameDisplayed = _p._isFrameDisplayedForWebGL, _p.setBatchNode = _p._setBatchNodeForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.draw = _p._drawForWebGL) : (_p._spriteFrameLoadedCallback = _p._spriteFrameLoadedCallbackForCanvas, _p.setOpacityModifyRGB = _p._setOpacityModifyRGBForCanvas, _p.updateDisplayedOpacity = _p._updateDisplayedOpacityForCanvas, _p.ctor = _p._ctorForCanvas, _p.setBlendFunc = _p._setBlendFuncForCanvas, _p.init = _p._initForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p._textureLoadedCallback = _p._textureLoadedCallbackForCanvas, _p.setTextureRect = _p._setTextureRectForCanvas, _p.updateTransform = _p._updateTransformForCanvas, _p.addChild = _p._addChildForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.setColor = _p._setColorForCanvas, _p.updateDisplayedColor = _p._updateDisplayedColorForCanvas, _p.setSpriteFrame = _p._setSpriteFrameForCanvas, _p.isFrameDisplayed = _p._isFrameDisplayedForCanvas, _p.setBatchNode = _p._setBatchNodeForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.draw = _p._drawForCanvas);
cc.defineGetterSetter(_p, H8m.R0K, _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.r7P, _p.isFlippedX, _p.setFlippedX);
cc.defineGetterSetter(_p, H8m.j3i, _p.isFlippedY, _p.setFlippedY);
cc.defineGetterSetter(_p, H8m.A8S, _p._getOffsetX);
cc.defineGetterSetter(_p, H8m.H1S, _p._getOffsetY);
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, H8m.R3P, _p.isTextureRectRotated);
cc.defineGetterSetter(_p, H8m.q9S, _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, H8m.G3P, _p.getQuad);
delete w6b0K[q0K]._p;
cc.Sprite.create = function(X, S) {
    return new cc.Sprite(X, S);
};
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: H8m.H6P,
    _delayPerUnit: H8m.U7H,
    _userInfo: H8m.H6P,
    ctor: function() {
        this._delayPerUnit = H8m.U7H;
    },
    clone: function() {
        var X = new cc.AnimationFrame;
        X.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return X;
    },
    copyWithZone: function(X) {
        return cc.clone(this);
    },
    copy: function(X) {
        X = new cc.AnimationFrame;
        X.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return X;
    },
    initWithSpriteFrame: function(X, S, P) {
        this._spriteFrame = X;
        this._delayPerUnit = S;
        this._userInfo = P;
        return !H8m.U7H;
    },
    getSpriteFrame: function() {
        return this._spriteFrame;
    },
    setSpriteFrame: function(X) {
        this._spriteFrame = X;
    },
    getDelayUnits: function() {
        return this._delayPerUnit;
    },
    setDelayUnits: function(X) {
        this._delayPerUnit = X;
    },
    getUserInfo: function() {
        return this._userInfo;
    },
    setUserInfo: function(X) {
        this._userInfo = X;
    }
});
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function() {
        this._frames = [];
    },
    getFrames: function() {
        return this._frames;
    },
    setFrames: function(X) {
        this._frames = X;
    },
    addSpriteFrame: function(X) {
        var S = new cc.AnimationFrame;
        S.initWithSpriteFrame(X, 1, null);
        this._frames.push(S);
        this._totalDelayUnits++;
    },
    addSpriteFrameWithFile: function(X) {
        X = cc.textureCache.addImage(X);
        var S = cc.rect(0, 0, 0, 0);
        S.width = X.width;
        S.height = X.height;
        X = cc.SpriteFrame.create(X, S);
        this.addSpriteFrame(X);
    },
    addSpriteFrameWithTexture: function(X, S) {
        var P = cc.SpriteFrame.create(X, S);
        this.addSpriteFrame(P);
    },
    initWithAnimationFrames: function(X, S, P) {
        cc.arrayVerifyType(X, cc.AnimationFrame);
        this._delayPerUnit = S;
        this._loops = P;
        this._totalDelayUnits = 0;
        S = this._frames;
        for (P = S.length = 0; H8m.d42(P, X.length); P++) {
            var O = X[P];
            S.push(O);
            this._totalDelayUnits += O.getDelayUnits();
        }
        return !0;
    },
    clone: function() {
        var X = new cc.Animation;
        X.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        X.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return X;
    },
    copyWithZone: function(X) {
        X = new cc.Animation;
        X.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        X.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return X;
    },
    _copyFrames: function() {
        for (var X = [], S = 0; H8m.t42(S, this._frames.length); S++)
            X.push(this._frames[S].clone());
        return X;
    },
    copy: function(X) {
        return this.copyWithZone(null);
    },
    getLoops: function() {
        return this._loops;
    },
    setLoops: function(X) {
        this._loops = X;
    },
    setRestoreOriginalFrame: function(X) {
        this._restoreOriginalFrame = X;
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame;
    },
    getDuration: function() {
        return H8m.w42(this._totalDelayUnits, this._delayPerUnit);
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit;
    },
    setDelayPerUnit: function(X) {
        this._delayPerUnit = X;
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits;
    },
    initWithSpriteFrames: function(X, S) {
        cc.arrayVerifyType(X, cc.SpriteFrame);
        this._loops = 1;
        this._delayPerUnit = S || 0;
        this._totalDelayUnits = 0;
        var P = this._frames;
        P.length = 0;
        if (X) {
            for (var O = 0; H8m.e42(O, X.length); O++) {
                var Z = X[O],
                    Y = new cc.AnimationFrame;
                Y.initWithSpriteFrame(Z, 1, null);
                P.push(Y);
            }
            this._totalDelayUnits += X.length;
        }
        return !0;
    },
    retain: function() {},
    release: function() {}
});
cc.Animation.create = function(X, S, P) {
    var O = arguments.length,
        Z = new cc.Animation;
    H8m.Q42(0, O) ? Z.initWithSpriteFrames(null, 0) : (O = X[0]) && (H8m.r42(O, cc.SpriteFrame) ? Z.initWithSpriteFrames(X, S) : H8m.N42(O, cc.AnimationFrame) && Z.initWithAnimationFrames(X, S, P));
    return Z;
};
cc.animationCache = {
    _animations: {},
    addAnimation: function(X, S) {
        this._animations[S] = X;
    },
    removeAnimation: function(X) {
        X && this._animations[X] && delete this._animations[X];
    },
    getAnimation: function(X) {
        return this._animations[X] ? this._animations[X] : null;
    },
    _addAnimationsWithDictionary: function(X, S) {
        var P = X.animations;
        if (P) {
            var O = 1,
                Z = X.properties;
            if (Z)
                for (var O = H8m.m42(null, Z.format) ? parseInt(Z.format) : O, Z = Z.spritesheets, Y = cc.spriteFrameCache, T = cc.path, R = 0; H8m.A42(R, Z.length); R++)
                    Y.addSpriteFrames(T.changeBasename(S, Z[R]));
            switch (O) {
            case 1:
                this._parseVersion1(P);
                break;
            case 2:
                this._parseVersion2(P);
                break;
            default:
                cc.log("cc.AnimationCache. Invalid animation format");
            }
        } else
            cc.log("cocos2d: cc.AnimationCache: No animations were found in provided dictionary.");
    },
    addAnimations: function(X) {
        if (!X)
            throw "cc.AnimationCache.addAnimations(): Invalid texture file name";
        var S = cc.loader.getRes(X);
        S ? this._addAnimationsWithDictionary(S, X) : cc.log("cc.AnimationCache.addAnimations(): File could not be found");
    },
    _parseVersion1: function(X) {
        var S = cc.spriteFrameCache,
            P;
        for (P in X) {
            var O = X[P],
                Z = O.frames,
                O = parseFloat(O.delay) || 0,
                Y = null;
            if (Z) {
                for (var Y = [], T = 0; H8m.E42(T, Z.length); T++) {
                    var R = S.getSpriteFrame(Z[T]);
                    if (R) {
                        var E = new cc.AnimationFrame;
                        E.initWithSpriteFrame(R, 1, null);
                        Y.push(E);
                    } else
                        cc.log("cocos2d: cc.AnimationCache: Animation '" + P + "' refers to frame '" + Z[T] + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
                }
                H8m.C42(0, Y.length) ? cc.log("cocos2d: cc.AnimationCache: None of the frames for animation '" + P + "' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.") : (H8m.h42(Y.length, Z.length) && cc.log("cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '" + P + "' may be missing."), Y = cc.Animation.create(Y, O, 1), cc.animationCache.addAnimation(Y, P));
            } else
                cc.log("cocos2d: cc.AnimationCache: Animation '" + P + "' found in dictionary without any frames - cannot add to animation cache.");
        }
    },
    _parseVersion2: function(X) {
        var S = cc.spriteFrameCache,
            P;
        for (P in X) {
            var O = X[P],
                Z = O.loop,
                Y = parseInt(O.loops),
                Z = Z ? cc.REPEAT_FOREVER : isNaN(Y) ? 1 : Y,
                Y = O.restoreOriginalFrame && !0 == O.restoreOriginalFrame ? !0 : !1,
                T = O.frames;
            if (T) {
                for (var R = [], E = 0; H8m.y42(E, T.length); E++) {
                    var V = T[E],
                        U = V.spriteframe,
                        k9 = S.getSpriteFrame(U);
                    if (k9) {
                        var U = parseFloat(V.delayUnits) || 0,
                            V = V.notification,
                            L9 = new cc.AnimationFrame;
                        L9.initWithSpriteFrame(k9, U, V);
                        R.push(L9);
                    } else
                        cc.log("cocos2d: cc.AnimationCache: Animation '" + P + "' refers to frame '" + U + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
                }
                O = parseFloat(O.delayPerUnit) || 0;
                T = new cc.Animation;
                T.initWithAnimationFrames(R, O, Z);
                T.setRestoreOriginalFrame(Y);
                cc.animationCache.addAnimation(T, P);
            } else
                cc.log("cocos2d: CCAnimationCache: Animation '" + P + "' found in dictionary without any frames - cannot add to animation cache.");
        }
    },
    _clear: function() {
        this._animations = {};
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    _eventListeners: null,
    ctor: function() {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
    },
    textureLoaded: function() {
        return this._textureLoaded;
    },
    addLoadedEventListener: function(X, S) {
        H8m.q42(null, this._eventListeners) && (this._eventListeners = []);
        this._eventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    _callLoadedEventCallbacks: function() {
        var X = this._eventListeners;
        if (X) {
            for (var S = 0, P = X.length; H8m.l42(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    },
    getRectInPixels: function() {
        var X = this._rectInPixels;
        return cc.rect(X.x, X.y, X.width, X.height);
    },
    setRectInPixels: function(X) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = X.x;
        this._rectInPixels.y = X.y;
        this._rectInPixels.width = X.width;
        this._rectInPixels.height = X.height;
        this._rect = cc.RECT_PIXELS_TO_POINTS(X);
    },
    isRotated: function() {
        return this._rotated;
    },
    setRotated: function(X) {
        this._rotated = X;
    },
    getRect: function() {
        var X = this._rect;
        return cc.rect(X.x, X.y, X.width, X.height);
    },
    setRect: function(X) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = X.x;
        this._rect.y = X.y;
        this._rect.width = X.width;
        this._rect.height = X.height;
        this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect);
    },
    getOffsetInPixels: function() {
        return this._offsetInPixels;
    },
    setOffsetInPixels: function(X) {
        this._offsetInPixels.x = X.x;
        this._offsetInPixels.y = X.y;
        cc._POINT_PIXELS_TO_POINTS_OUT(this._offsetInPixels, this._offset);
    },
    getOriginalSizeInPixels: function() {
        return this._originalSizeInPixels;
    },
    setOriginalSizeInPixels: function(X) {
        this._originalSizeInPixels.width = X.width;
        this._originalSizeInPixels.height = X.height;
    },
    getOriginalSize: function() {
        return this._originalSize;
    },
    setOriginalSize: function(X) {
        this._originalSize.width = X.width;
        this._originalSize.height = X.height;
    },
    getTexture: function() {
        if (this._texture)
            return this._texture;
        if (H8m.X72("", this._textureFilename)) {
            var X = cc.textureCache.addImage(this._textureFilename);
            X && (this._textureLoaded = X.isLoaded());
            return X;
        }
        return null;
    },
    setTexture: function(O) {
        if (H8m.D72(this._texture, O)) {
            var Z = O.isLoaded();
            this._textureLoaded = Z;
            this._texture = O;
            Z || O.addLoadedEventListener(function(X) {
                this._textureLoaded = !0;
                if (this._rotated && H8m.c72(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
                    var S = X.getHtmlElementObj(),
                        S = cc.cutRotateImageToCanvas(S, this.getRect()),
                        P = new cc.Texture2D;
                    P.initWithElement(S);
                    P.handleLoadedTexture();
                    this.setTexture(P);
                    S = this.getRect();
                    this.setRect(cc.rect(0, 0, S.width, S.height));
                }
                S = this._rect;
                H8m.z72(0, S.width) && H8m.j72(0, S.height) && (S = X.width, X = X.height, this._rect.width = S, this._rect.height = X, this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = S, this._originalSize.height = X);
                this._callLoadedEventCallbacks();
            }, this);
        }
    },
    getOffset: function() {
        return this._offset;
    },
    setOffset: function(X) {
        this._offset.x = X.x;
        this._offset.y = X.y;
    },
    clone: function() {
        var X = new cc.SpriteFrame;
        X.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        X.setTexture(this._texture);
        return X;
    },
    copyWithZone: function() {
        var X = new cc.SpriteFrame;
        X.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        X.setTexture(this._texture);
        return X;
    },
    copy: function() {
        return this.copyWithZone();
    },
    initWithTexture: function(X, S, P, O, Z) {
        H8m.x72(2, arguments.length) && (S = cc.RECT_POINTS_TO_PIXELS(S));
        O = O || cc.p(0, 0);
        Z = Z || S;
        P = P || !1;
        "string" == typeof X ? (this._texture = null, this._textureFilename = X) : H8m.o72(X, cc.Texture2D) && this.setTexture(X);
        this._rectInPixels = S;
        this._rect = cc.RECT_PIXELS_TO_POINTS(S);
        this._offsetInPixels.x = O.x;
        this._offsetInPixels.y = O.y;
        cc._POINT_PIXELS_TO_POINTS_OUT(O, this._offset);
        this._originalSizeInPixels.width = Z.width;
        this._originalSizeInPixels.height = Z.height;
        cc._SIZE_PIXELS_TO_POINTS_OUT(Z, this._originalSize);
        this._rotated = P;
        return !0;
    }
});
cc.SpriteFrame.create = function(X, S, P, O, Z) {
    var Y = new cc.SpriteFrame;
    switch (arguments.length) {
    case 2:
        Y.initWithTexture(X, S);
        break;
    case 5:
        Y.initWithTexture(X, S, P, O, Z);
        break;
    default:
        throw "Argument must be non-nil ";
    }
    return Y;
};
cc.SpriteFrame._frameWithTextureForCanvas = function(X, S, P, O, Z) {
    var Y = new cc.SpriteFrame;
    Y._texture = X;
    Y._rectInPixels = S;
    Y._rect = cc.RECT_PIXELS_TO_POINTS(S);
    Y._offsetInPixels.x = O.x;
    Y._offsetInPixels.y = O.y;
    cc._POINT_PIXELS_TO_POINTS_OUT(Y._offsetInPixels, Y._offset);
    Y._originalSizeInPixels.width = Z.width;
    Y._originalSizeInPixels.height = Z.height;
    cc._SIZE_PIXELS_TO_POINTS_OUT(Y._originalSizeInPixels, Y._originalSize);
    Y._rotated = P;
    return Y;
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(X) {
        return (X = this._CCNS_REG2.exec(X)) ? cc.rect(parseFloat(X[1]), parseFloat(X[2]), parseFloat(X[3]), parseFloat(X[4])) : cc.rect(0, 0, 0, 0);
    },
    _pointFromString: function(X) {
        return (X = this._CCNS_REG1.exec(X)) ? cc.p(parseFloat(X[1]), parseFloat(X[2])) : cc.p(0, 0);
    },
    _sizeFromString: function(X) {
        return (X = this._CCNS_REG1.exec(X)) ? cc.size(parseFloat(X[1]), parseFloat(X[2])) : cc.size(0, 0);
    },
    _getFrameConfig: function(X) {
        var S = cc.loader.getRes(X);
        if (!S)
            throw "Please load the resource first : " + X;
        cc.loader.release(X);
        if (S._inited)
            return this._frameConfigCache[X] = S;
        var P = S.frames,
            O = S.metadata || S.meta,
            S = {},
            Z = {},
            Y = 0;
        O && (Y = O.format, Y = H8m.p72(1, Y.length) ? parseInt(Y) : Y, Z.image = O.textureFileName || O.textureFileName || O.image);
        for (var T in P) {
            var R = P[T];
            if (R) {
                O = {};
                if (H8m.Y72(0, Y)) {
                    O.rect = cc.rect(R.x, R.y, R.width, R.height);
                    O.rotated = !1;
                    O.offset = cc.p(R.offsetX, R.offsetY);
                    var E = R.originalWidth,
                        R = R.originalHeight;
                    E && R || cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    E = Math.abs(E);
                    R = Math.abs(R);
                    O.size = cc.size(E, R);
                } else if (H8m.T72(1, Y) || H8m.R72(2, Y))
                    O.rect = this._rectFromString(R.frame), O.rotated = R.rotated || !1, O.offset = this._pointFromString(R.offset), O.size = this._sizeFromString(R.sourceSize);
                else if (H8m.M72(3, Y)) {
                    var E = this._sizeFromString(R.spriteSize),
                        V = this._rectFromString(R.textureRect);
                    E && (V = cc.rect(V.x, V.y, E.width, E.height));
                    O.rect = V;
                    O.rotated = R.textureRotated || !1;
                    O.offset = this._pointFromString(R.spriteOffset);
                    O.size = this._sizeFromString(R.spriteSourceSize);
                    O.aliases = R.aliases;
                } else
                    E = R.frame, V = R.sourceSize, T = R.filename || T, O.rect = cc.rect(E.x, E.y, E.w, E.h), O.rotated = R.rotated || !1, O.offset = cc.p(0, 0), O.size = cc.size(V.w, V.h);
                S[T] = O;
            }
        }
        return this._frameConfigCache[X] = {
            _inited: !0,
            frames: S,
            meta: Z
        };
    },
    addSpriteFrames: function(X, S) {
        if (!X)
            throw "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null";
        var P = this._frameConfigCache[X] || this._getFrameConfig(X),
            O = P.frames,
            P = P.meta;
        if (!S)
            P = cc.path.changeBasename(X, P.image || ".png"), S = cc.textureCache.addImage(P);
        else if (!(H8m.V72(S, cc.Texture2D)))
            if ("string" == typeof S)
                S = cc.textureCache.addImage(S);
            else
                throw "Argument must be non-nil";
        var P = this._spriteFramesAliases,
            Z = this._spriteFrames,
            Y;
        for (Y in O) {
            var T = O[Y],
                R = Z[Y];
            if (!R) {
                R = cc.SpriteFrame.create(S, T.rect, T.rotated, T.offset, T.size);
                if (T = T.aliases)
                    for (var E = 0, V = T.length; H8m.s72(E, V); E++) {
                        var U = T[E];
                        P[U] && cc.log("cocos2d: WARNING: an alias with name " + U + " already exists");
                        P[U] = Y;
                    }
                H8m.U72(cc._renderType, cc._RENDER_TYPE_CANVAS) && R.isRotated() && R.getTexture().isLoaded() && (T = R.getTexture().getHtmlElementObj(), T = cc.cutRotateImageToCanvas(T, R.getRectInPixels()), E = new cc.Texture2D, E.initWithElement(T), E.handleLoadedTexture(), R.setTexture(E), T = R._rect, R.setRect(cc.rect(0, 0, T.width, T.height)));
                Z[Y] = R;
            }
        }
    },
    _checkConflict: function(X) {
        X = X.frames;
        for (var S in X)
            this._spriteFrames[S] && cc.log("cocos2d: WARNING: Sprite frame: " + S + " has already been added by another source, please fix name conflit");
    },
    addSpriteFrame: function(X, S) {
        this._spriteFrames[S] = X;
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
    },
    removeSpriteFrameByName: function(X) {
        X && (this._spriteFramesAliases[X] && delete this._spriteFramesAliases[X], this._spriteFrames[X] && delete this._spriteFrames[X]);
    },
    removeSpriteFramesFromFile: function(X) {
        var S = this._spriteFrames,
            P = this._spriteFramesAliases;
        if (X = this._frameConfigCache[X]) {
            X = X.frames;
            for (var O in X)
                if (S[O]) {
                    delete S[O];
                    for (var Z in P)
                        H8m.b72(P[Z], O) && delete P[Z];
                }
        }
    },
    removeSpriteFramesFromTexture: function(X) {
        var S = this._spriteFrames,
            P = this._spriteFramesAliases,
            O;
        for (O in S) {
            var Z = S[O];
            if (Z && H8m.F72(Z.getTexture(), X)) {
                delete S[O];
                for (var Y in P)
                    H8m.k02(P[Y], O) && delete P[Y];
            }
        }
    },
    getSpriteFrame: function(X) {
        var S = this._spriteFrames[X];
        if (!S) {
            var P = this._spriteFramesAliases[X];
            P && ((S = this._spriteFrames[P.toString()]) || delete this._spriteFramesAliases[X]);
        }
        S || cc.log("cocos2d: cc.SpriteFrameCahce: Frame " + X + " not found");
        return S;
    },
    _clear: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {};
    }
};
H8m.G5(H8m.r9i);
cc.SpriteBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    addSpriteWithoutQuad: function(X, S, P) {
        if (!X)
            throw "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null";
        if (!(H8m.L02(X, cc.Sprite)))
            return cc.log("cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children"), null;
        X.atlasIndex = S;
        var O = 0,
            Z = this._descendants;
        if (Z && H8m.i02(0, Z.length))
            for (var Y = 0; H8m.S02(Y, Z.length); Y++) {
                var T = Z[Y];
                T && H8m.P02(T.atlasIndex, S) && ++O;
            }
        Z.splice(O, 0, X);
        cc.Node.prototype.addChild.call(this, X, S, P);
        this.reorderBatch(!1);
        return this;
    },
    getTextureAtlas: function() {
        return this.textureAtlas;
    },
    setTextureAtlas: function(X) {
        H8m.a02(X, this.textureAtlas) && (this.textureAtlas = X);
    },
    getDescendants: function() {
        return this._descendants;
    },
    initWithFile: function(X, S) {
        var P = cc.textureCache.textureForKey(X);
        P || (P = cc.textureCache.addImage(X));
        return this.initWithTexture(P, S);
    },
    _setNodeDirtyForCache: function() {
        this._cacheDirty = !0;
    },
    init: function(X, S) {
        var P = cc.textureCache.textureForKey(X);
        P || (P = cc.textureCache.addImage(X));
        return this.initWithTexture(P, S);
    },
    increaseAtlasCapacity: function() {
        var X = this.textureAtlas.capacity,
            S = Math.floor(H8m.O02(4, (X + 1), 3));
        cc.log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + X + " to " + S + ".");
        this.textureAtlas.resizeCapacity(S) || cc.log("cocos2d: WARNING: Not enough memory to resize the atlas");
    },
    removeChildAtIndex: function(X, S) {
        this.removeChild(this._children[X], S);
    },
    rebuildIndexInOrder: function(X, S) {
        var P = X.children;
        if (P && H8m.p02(0, P.length))
            for (var O = 0; H8m.Y02(O, P.length); O++) {
                var Z = P[O];
                Z && H8m.T02(0, Z.zIndex) && (S = this.rebuildIndexInOrder(Z, S));
            }
        !X == this && (X.atlasIndex = S, S++);
        if (P && H8m.R02(0, P.length))
            for (O = 0; H8m.M02(O, P.length); O++)
                (Z = P[O]) && H8m.V02(0, Z.zIndex) && (S = this.rebuildIndexInOrder(Z, S));
        return S;
    },
    highestAtlasIndexInChild: function(X) {
        var S = X.children;
        return S && H8m.s02(0, S.length) ? this.highestAtlasIndexInChild(S[H8m.U02(S.length, 1)]) : X.atlasIndex;
    },
    lowestAtlasIndexInChild: function(X) {
        var S = X.children;
        return S && H8m.b02(0, S.length) ? this.lowestAtlasIndexInChild(S[H8m.F02(S.length, 1)]) : X.atlasIndex;
    },
    atlasIndexForChild: function(X, S) {
        var P = X.parent,
            O = P.children,
            Z = O.indexOf(X),
            Y = null;
        H8m.k32(0, Z) && H8m.L32(Z, cc.UINT_MAX) && (Y = O[H8m.i32(Z, 1)]);
        return H8m.S32(P, this) ? H8m.P32(0, Z) ? 0 : this.highestAtlasIndexInChild(Y) + 1 : H8m.a32(0, Z) ? H8m.O32(0, S) ? P.atlasIndex : P.atlasIndex + 1 : H8m.B32(0, Y.zIndex) && H8m.Z32(0, S) || H8m.J32(0, Y.zIndex) && H8m.n32(0, S) ? this.highestAtlasIndexInChild(Y) + 1 : P.atlasIndex + 1;
    },
    reorderBatch: function(X) {
        this._reorderChildDirty = X;
    },
    setBlendFunc: function(X, S) {
        this._blendFunc = void 0 === S ? X : {
            src: X,
            dst: S
        };
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    reorderChild: function(X, S) {
        if (!X)
            throw "cc.SpriteBatchNode.addChild():child should be non-null";
        -1 === this._children.indexOf(X) ? cc.log("cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite") : H8m.G32(S, X.zIndex) && (cc.Node.prototype.reorderChild.call(this, X, S), this.setNodeDirty());
    },
    removeChild: function(X, S) {
        H8m.W32(null, X) && (-1 === this._children.indexOf(X) ? cc.log("cc.SpriteBatchNode.addChild(): sprite batch node should contain the child") : (this.removeSpriteFromAtlas(X), cc.Node.prototype.removeChild.call(this, X, S)));
    },
    _mvpMatrix: null,
    _textureForCanvas: null,
    _useCache: !1,
    _originalTexture: null,
    ctor: null,
    _ctorForCanvas: function(X, S) {
        cc.Node.prototype.ctor.call(this);
        var P;
        S = S || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof X ? (P = cc.textureCache.textureForKey(X)) || (P = cc.textureCache.addImage(X)) : H8m.v32(X, cc.Texture2D) && (P = X);
        P && this.initWithTexture(P, S);
    },
    _ctorForWebGL: function(X, S) {
        cc.Node.prototype.ctor.call(this);
        this._mvpMatrix = new cc.kmMat4;
        var P;
        S = S || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof X ? (P = cc.textureCache.textureForKey(X)) || (P = cc.textureCache.addImage(X)) : H8m.u32(X, cc.Texture2D) && (P = X);
        P && this.initWithTexture(P, S);
    },
    updateQuadFromSprite: null,
    _updateQuadFromSpriteForCanvas: function(X, S) {
        if (!X)
            throw "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null";
        H8m.H32(X, cc.Sprite) ? (X.batchNode = this, X.atlasIndex = S, X.dirty = !0, X.updateTransform()) : cc.log("cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    _updateQuadFromSpriteForWebGL: function(X, S) {
        if (!X)
            throw "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null";
        if (H8m.f32(X, cc.Sprite)) {
            for (var P = this.textureAtlas.capacity; H8m.I32(S, P) || H8m.g52(P, this.textureAtlas.totalQuads);)
                this.increaseAtlasCapacity();
            X.batchNode = this;
            X.atlasIndex = S;
            X.dirty = !0;
            X.updateTransform();
        } else
            cc.log("cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    _swap: function(X, S) {
        var P = this._descendants,
            O = this.textureAtlas,
            Z = O.quads,
            Y = P[X],
            T = cc.V3F_C4B_T2F_QuadCopy(Z[X]);
        P[S].atlasIndex = X;
        P[X] = P[S];
        O.updateQuad(Z[S], X);
        P[S] = Y;
        O.updateQuad(T, S);
    },
    insertQuadFromSprite: null,
    _insertQuadFromSpriteForCanvas: function(X, S) {
        if (!X)
            throw "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null";
        H8m.K52(X, cc.Sprite) ? (X.batchNode = this, X.atlasIndex = S, X.dirty = !0, X.updateTransform(), this._children.splice(S, 0, X)) : cc.log("cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    _insertQuadFromSpriteForWebGL: function(X, S) {
        if (!X)
            throw "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null";
        if (H8m.d52(X, cc.Sprite)) {
            for (var P = this.textureAtlas; H8m.t52(S, P.capacity) || H8m.w52(P.capacity, P.totalQuads);)
                this.increaseAtlasCapacity();
            X.batchNode = this;
            X.atlasIndex = S;
            P.insertQuad(X.quad, S);
            X.dirty = !0;
            X.updateTransform();
        } else
            cc.log("cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    _updateAtlasIndex: function(X, S) {
        var P = 0,
            O = X.children;
        O && (P = O.length);
        var Z = 0;
        if (H8m.e52(0, P))
            Z = X.atlasIndex, X.atlasIndex = S, X.arrivalOrder = 0, H8m.Q52(Z, S) && this._swap(Z, S), S++;
        else {
            Z = !0;
            H8m.r52(0, O[0].zIndex) && (Z = X.atlasIndex, X.atlasIndex = S, X.arrivalOrder = 0, H8m.N52(Z, S) && this._swap(Z, S), S++, Z = !1);
            for (P = 0; H8m.m52(P, O.length); P++) {
                var Y = O[P];
                Z && H8m.A52(0, Y.zIndex) && (Z = X.atlasIndex, X.atlasIndex = S, X.arrivalOrder = 0, H8m.E52(Z, S) && this._swap(Z, S), S++, Z = !1);
                S = this._updateAtlasIndex(Y, S);
            }
            Z && (Z = X.atlasIndex, X.atlasIndex = S, X.arrivalOrder = 0, H8m.C52(Z, S) && this._swap(Z, S), S++);
        }
        return S;
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA);
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(X, S) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._textureForCanvas = this._originalTexture = X;
        return !0;
    },
    _initWithTextureForWebGL: function(X, S) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        S = S || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(X, S);
        this._updateBlendFunc();
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0;
    },
    insertChild: function(X, S) {
        X.batchNode = this;
        X.atlasIndex = S;
        X.dirty = !0;
        var P = this.textureAtlas;
        H8m.h52(P.totalQuads, P.capacity) && this.increaseAtlasCapacity();
        P.insertQuad(X.quad, S);
        this._descendants.splice(S, 0, X);
        var P = S + 1,
            O = this._descendants;
        if (O && H8m.y52(0, O.length))
            for (; H8m.q52(P, O.length); P++)
                O[P].atlasIndex++;
        var O = X.children,
            Z;
        if (O)
            for (P = 0, l = O.length || 0; H8m.l52(P, l); P++)
                if (Z = O[P]) {
                    var Y = this.atlasIndexForChild(Z, Z.zIndex);
                    this.insertChild(Z, Y);
                }
    },
    appendChild: null,
    _appendChildForCanvas: function(X) {
        this._reorderChildDirty = !0;
        X.batchNode = this;
        X.dirty = !0;
        this._descendants.push(X);
        X.atlasIndex = H8m.X62(this._descendants.length, 1);
        X = X.children;
        for (var S = 0, P = X.length || 0; H8m.D62(S, P); S++)
            this.appendChild(X[S]);
    },
    _appendChildForWebGL: function(X) {
        this._reorderChildDirty = !0;
        X.batchNode = this;
        X.dirty = !0;
        this._descendants.push(X);
        var S = H8m.c62(this._descendants.length, 1);
        X.atlasIndex = S;
        var P = this.textureAtlas;
        H8m.z62(P.totalQuads, P.capacity) && this.increaseAtlasCapacity();
        P.insertQuad(X.quad, S);
        X = X.children;
        S = 0;
        for (P = X.length || 0; H8m.j62(S, P); S++)
            this.appendChild(X[S]);
    },
    removeSpriteFromAtlas: null,
    _removeSpriteFromAtlasForCanvas: function(X) {
        X.batchNode = null;
        var S = this._descendants,
            P = S.indexOf(X);
        if (-1 != P) {
            S.splice(P, 1);
            for (var O = S.length; H8m.x62(P, O); ++P)
                S[P].atlasIndex--;
        }
        if (X = X.children)
            for (S = 0, P = X.length || 0; H8m.o62(S, P); S++)
                X[S] && this.removeSpriteFromAtlas(X[S]);
    },
    _removeSpriteFromAtlasForWebGL: function(X) {
        this.textureAtlas.removeQuadAtIndex(X.atlasIndex);
        X.batchNode = null;
        var S = this._descendants,
            P = S.indexOf(X);
        if (-1 != P) {
            S.splice(P, 1);
            for (var O = S.length; H8m.p62(P, O); ++P)
                S[P].atlasIndex--;
        }
        if (X = X.children)
            for (S = 0, P = X.length || 0; H8m.Y62(S, P); S++)
                X[S] && this.removeSpriteFromAtlas(X[S]);
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas;
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture;
    },
    setTexture: null,
    _setTextureForCanvas: function(X) {
        this._textureForCanvas = X;
        for (var S = this._children, P = 0; H8m.T62(P, S.length); P++)
            S[P].texture = X;
    },
    _setTextureForWebGL: function(X) {
        this.textureAtlas.texture = X;
        this._updateBlendFunc();
    },
    visit: null,
    _visitForCanvas: function(X) {
        var S = X || cc._renderContext;
        if (this._visible) {
            S.save();
            this.transform(X);
            var P = this._children;
            if (P)
                for (this.sortAllChildren(), X = 0; H8m.R62(X, P.length); X++)
                    P[X] && P[X].visit(S);
            S.restore();
        }
    },
    _visitForWebGL: function(X) {
        X = X || cc._renderContext;
        if (this._visible) {
            cc.kmGLPushMatrix();
            var S = this.grid;
            S && S.isActive() && (S.beforeDraw(), this.transformAncestors());
            this.sortAllChildren();
            this.transform(X);
            this.draw(X);
            S && S.isActive() && S.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0;
        }
    },
    addChild: null,
    _addChildForCanvas: function(X, S, P) {
        if (H8m.M62(null, X))
            throw "cc.SpriteBatchNode.addChild(): child should be non-null";
        H8m.V62(X, cc.Sprite) ? (S = H8m.s62(null, S) ? X.zIndex : S, P = H8m.U62(null, P) ? X.tag : P, cc.Node.prototype.addChild.call(this, X, S, P), this.appendChild(X), this.setNodeDirty()) : cc.log("cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    _addChildForWebGL: function(X, S, P) {
        if (H8m.b62(null, X))
            throw "cc.SpriteBatchNode.addChild(): child should be non-null";
        H8m.F62(X, cc.Sprite) ? H8m.k22(X.texture, this.textureAtlas.texture) ? cc.log("cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture") : (S = H8m.L22(null, S) ? X.zIndex : S, P = H8m.i22(null, P) ? X.tag : P, cc.Node.prototype.addChild.call(this, X, S, P), this.appendChild(X), this.setNodeDirty()) : cc.log("cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children");
    },
    removeAllChildren: null,
    _removeAllChildrenForCanvas: function(X) {
        var S = this._descendants;
        if (S && H8m.S22(0, S.length))
            for (var P = 0, O = S.length; H8m.P22(P, O); P++)
                S[P] && (S[P].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, X);
        this._descendants.length = 0;
    },
    _removeAllChildrenForWebGL: function(X) {
        var S = this._descendants;
        if (S && H8m.a22(0, S.length))
            for (var P = 0, O = S.length; H8m.O22(P, O); P++)
                S[P] && (S[P].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, X);
        this._descendants.length = 0;
        this.textureAtlas.removeAllQuads();
    },
    sortAllChildren: null,
    _sortAllChildrenForCanvas: function() {
        if (this._reorderChildDirty) {
            var X,
                S = 0,
                P = this._children,
                O = P.length,
                Z;
            for (X = 1; H8m.B22(X, O); X++) {
                var Y = P[X],
                    S = H8m.Z22(X, 1);
                for (Z = P[S]; H8m.J22(0, S) && (H8m.n22(Y._localZOrder, Z._localZOrder) || H8m.G22(Y._localZOrder, Z._localZOrder) && H8m.W22(Y.arrivalOrder, Z.arrivalOrder));)
                    P[S + 1] = Z, S -= 1, Z = P[S];
                P[S + 1] = Y;
            }
            H8m.v22(0, P.length) && this._arrayMakeObjectsPerformSelector(P, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1;
        }
    },
    _sortAllChildrenForWebGL: function() {
        if (this._reorderChildDirty) {
            var X = this._children,
                S,
                P = 0,
                O = X.length,
                Z;
            for (S = 1; H8m.u22(S, O); S++) {
                var Y = X[S],
                    P = H8m.H22(S, 1);
                for (Z = X[P]; H8m.f22(0, P) && (H8m.I22(Y._localZOrder, Z._localZOrder) || H8m.g9E(Y._localZOrder, Z._localZOrder) && H8m.K9E(Y.arrivalOrder, Z.arrivalOrder));)
                    X[P + 1] = Z, P -= 1, Z = X[P];
                X[P + 1] = Y;
            }
            if (H8m.d9E(0, X.length))
                for (this._arrayMakeObjectsPerformSelector(X, cc.Node.StateCallbackType.sortAllChildren), S = P = 0; H8m.t9E(S, X.length); S++)
                    P = this._updateAtlasIndex(X[S], P);
            this._reorderChildDirty = !1;
        }
    },
    draw: null,
    _drawForWebGL: function() {
        H8m.w9E(0, this.textureAtlas.totalQuads) && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads());
    }
});
w6b0K[q0K]._p = cc.SpriteBatchNode.prototype;
H8m.e9E(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL, _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas, _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw);
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, H8m.p6H, _p.getDescendants);
delete w6b0K[q0K]._p;
cc.SpriteBatchNode.create = function(X, S) {
    return new cc.SpriteBatchNode(X, S);
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var X = this._valueDict;
        X["cocos2d.x.version"] = cc.ENGINE_VERSION;
        X["cocos2d.x.compiled_with_profiler"] = !1;
        X["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0;
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize;
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth;
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits;
    },
    supportsNPOT: function() {
        return this._supportsNPOT;
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC;
    },
    supportsETC: function() {
        return !1;
    },
    supportsS3TC: function() {
        return !1;
    },
    supportsATITC: function() {
        return !1;
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888;
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer;
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO;
    },
    checkForGLExtension: function(X) {
        return -1 < this._GlExtensions.indexOf(X);
    },
    getValue: function(X, S) {
        this._inited || this._init();
        var P = this._valueDict;
        return P[X] ? P[X] : S;
    },
    setValue: function(X, S) {
        this._valueDict[X] = S;
    },
    dumpInfo: function() {
        H8m.Q9E(0, cc.ENABLE_GL_STATE_CACHE) && (cc.log(""), cc.log("cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)"), cc.log(""));
    },
    gatherGPUInfo: function() {
        if (H8m.r9E(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            this._inited || this._init();
            var X = cc._renderContext,
                S = this._valueDict;
            S["gl.vendor"] = X.getParameter(X.VENDOR);
            S["gl.renderer"] = X.getParameter(X.RENDERER);
            S["gl.version"] = X.getParameter(X.VERSION);
            this._GlExtensions = "";
            for (var P = X.getSupportedExtensions(), O = 0; H8m.N9E(O, P.length); O++)
                this._GlExtensions += P[O] + " ";
            this._maxTextureSize = X.getParameter(X.MAX_TEXTURE_SIZE);
            S["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = X.getParameter(X.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            S["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            S["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            S["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            S["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            S["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            S["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
            cc.CHECK_GL_ERROR_DEBUG();
        }
    },
    loadConfigFile: function(X) {
        this._inited || this._init();
        var S = cc.loader.getRes(X);
        if (!S)
            throw "Please load the resource first : " + X;
        if (S = S.data)
            for (var P in S)
                this._valueDict[P] = S[P];
        else
            cc.log("Expected 'data' dict, but not found. Config file: " + X);
    }
};
H8m.E5(H8m.U7H);
H8m.V5(H8m.U7H);
H8m.v5(H8m.h7H);
H8m.h5(H8m.v7H);
H8m.U5(cc);
H8m.H5(H8m.U7H);
H8m.q5(H8m.h7H);
H8m.l5(H8m.s7H);
H8m.k6(H8m.v7H);
H8m.g6(H8m.s7H);
cc.DirectorDelegate = cc.Class.extend({
    updateProjection: function() {}
});
cc.GLToClipTransform = function(X) {
    var S = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, S);
    var P = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, P);
    cc.kmMat4Multiply(X, S, P);
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var X = this;
        X._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            X._lastUpdate = Date.now();
        });
    },
    init: function() {
        this._oldAnimationInterval = this._animationInterval = H8m.m9E(1, cc.defaultFPS);
        this._scenesStack = [];
        this._projection = cc.DIRECTOR_PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt = 0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        this._actionManager = new cc.ActionManager;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0;
    },
    calculateDeltaTime: function() {
        var X = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = H8m.A9E((X - this._lastUpdate), 1E3);
        H8m.E9E(0, cc.game.config[cc.game.CONFIG_KEY.debugMode]) && H8m.C9E(0.2, this._deltaTime) && (this._deltaTime = H8m.h9E(1, 60));
        this._lastUpdate = X;
    },
    convertToGL: function(X) {
        var S = new cc.kmMat4;
        cc.GLToClipTransform(S);
        var P = new cc.kmMat4;
        cc.kmMat4Inverse(P, S);
        var S = H8m.y9E(S.mat[14], S.mat[15]),
            O = this._openGLView.getDesignResolutionSize();
        X = new cc.kmVec3(H8m.q9E(2 * X.x / O.width, 1), H8m.l9E(1, 2 * X.y / O.height), S);
        S = new cc.kmVec3;
        cc.kmVec3TransformCoord(S, X, P);
        return cc.p(S.x, S.y);
    },
    convertToUI: function(X) {
        var S = new cc.kmMat4;
        cc.GLToClipTransform(S);
        var P = new cc.kmVec3;
        X = new cc.kmVec3(X.x, X.y, 0);
        cc.kmVec3TransformCoord(P, X, S);
        S = this._openGLView.getDesignResolutionSize();
        return cc.p(H8m.X1E(S.width, (0.5 * P.x + 0.5)), S.height * (0.5 * -P.y + 0.5));
    },
    drawScene: function() {
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode && this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF();
    },
    _clearCanvas: function() {
        var X = this._openGLView.getViewPortRect();
        cc._renderContext.clearRect(-X.x, X.y, X.width, -X.height);
    },
    _clearWebGL: function() {
        var X = cc._renderContext;
        X.clear(H8m.D1E(X.COLOR_BUFFER_BIT, X.DEPTH_BUFFER_BIT));
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    _beforeVisitSceneWebGL: function() {
        cc.kmGLPushMatrix();
    },
    _afterVisitSceneWebGL: function() {
        cc.kmGLPopMatrix();
    },
    end: function() {
        this._purgeDirectorInNextLoop = !0;
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor;
    },
    getNotificationNode: function() {
        return this._notificationNode;
    },
    getWinSize: function() {
        return this._winSizeInPoints;
    },
    getWinSizeInPixels: function() {
        return cc.size(H8m.c1E(this._winSizeInPoints.width, this._contentScaleFactor), H8m.z1E(this._winSizeInPoints.height, this._contentScaleFactor));
    },
    getVisibleSize: function() {
        return this._openGLView ? this._openGLView.getVisibleSize() : this.getWinSize();
    },
    getVisibleOrigin: function() {
        return this._openGLView ? this._openGLView.getVisibleOrigin() : cc.p(0, 0);
    },
    getZEye: function() {
        return H8m.j1E(this._winSizeInPoints.height, 1.1566);
    },
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0);
    },
    popScene: function() {
        if (!this._runningScene)
            throw "running scene should not null";
        this._scenesStack.pop();
        var X = this._scenesStack.length;
        H8m.x1E(0, X) ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[H8m.o1E(X, 1)]);
    },
    purgeCachedData: function() {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear();
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks();
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.CHECK_GL_ERROR_DEBUG();
    },
    pushScene: function(X) {
        if (!X)
            throw "the scene should not null";
        this._sendCleanupToScene = !1;
        this._scenesStack.push(X);
        this._nextScene = X;
    },
    runScene: function(X) {
        if (!X)
            throw "the scene should not be null";
        if (this._runningScene) {
            var S = this._scenesStack.length;
            H8m.p1E(0, S) ? (this._sendCleanupToScene = !0, this._scenesStack[S] = X) : (this._sendCleanupToScene = !0, this._scenesStack[H8m.Y1E(S, 1)] = X);
            this._nextScene = X;
        } else
            this.pushScene(X), this.startAnimation();
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log("cocos2d: Director: Error in gettimeofday"), this._paused = !1, this._deltaTime = 0);
    },
    setAlphaBlending: function(X) {
        X ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO);
    },
    setContentScaleFactor: function(X) {
        H8m.T1E(X, this._contentScaleFactor) && (this._contentScaleFactor = X, this._createStatsLabel());
    },
    setDepthTest: function(X) {
        if (H8m.R1E(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            var S = cc._renderContext;
            X ? (S.clearDepth(1), S.enable(S.DEPTH_TEST), S.depthFunc(S.LEQUAL)) : S.disable(S.DEPTH_TEST);
        }
    },
    setDefaultValues: function() {},
    setGLDefaultValues: function() {
        this.setAlphaBlending(!0);
        this.setDepthTest(!1);
        this.setProjection(this._projection);
        cc._renderContext.clearColor(0, 0, 0, 1);
    },
    setNextDeltaTimeZero: function(X) {
        this._nextDeltaTimeZero = X;
    },
    setNextScene: function() {
        var X = !1,
            S = !1;
        cc.TransitionScene && (X = this._runningScene ? H8m.M1E(this._runningScene, cc.TransitionScene) : !1, S = this._nextScene ? H8m.V1E(this._nextScene, cc.TransitionScene) : !1);
        if (!S) {
            if (S = this._runningScene)
                S.onExitTransitionDidStart(), S.onExit();
            this._sendCleanupToScene && S && S.cleanup();
        }
        this._runningScene = this._nextScene;
        this._nextScene = null;
        X || H8m.s1E(null, this._runningScene) || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish());
    },
    setNotificationNode: function(X) {
        this._notificationNode = X;
    },
    getDelegate: function() {
        return this._projectionDelegate;
    },
    setDelegate: function(X) {
        this._projectionDelegate = X;
    },
    setOpenGLView: function(X) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = X || cc.view;
        H8m.U1E(cc._renderType, cc._RENDER_TYPE_CANVAS) && (X = cc.configuration, X.gatherGPUInfo(), X.dumpInfo(), this._createStatsLabel(), this.setGLDefaultValues());
    },
    setViewport: function() {
        if (this._openGLView) {
            var X = this._winSizeInPoints;
            this._openGLView.setViewPortInPoints(0, 0, X.width, X.height);
        }
    },
    setProjection: function(X) {
        var S = this._winSizeInPoints;
        if (H8m.b1E(cc._renderType, cc._RENDER_TYPE_CANVAS))
            this._projection = X, cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        else {
            this.setViewport();
            switch (X) {
            case cc.DIRECTOR_PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                var P = new cc.kmMat4;
                cc.kmMat4OrthographicProjection(P, 0, S.width, 0, S.height, -1024, 1024);
                cc.kmGLMultMatrix(P);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.DIRECTOR_PROJECTION_3D:
                var O = this.getZEye(),
                    Z = new cc.kmMat4,
                    P = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                cc.kmMat4PerspectiveProjection(Z, 60, H8m.F1E(S.width, S.height), 0.1, H8m.k8E(2, O));
                cc.kmGLMultMatrix(Z);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                O = cc.kmVec3Fill(null, H8m.L8E(S.width, 2), H8m.i8E(S.height, 2), O);
                S = cc.kmVec3Fill(null, H8m.S8E(S.width, 2), H8m.P8E(S.height, 2), 0);
                Z = cc.kmVec3Fill(null, 0, 1, 0);
                cc.kmMat4LookAt(P, O, S, Z);
                cc.kmGLMultMatrix(P);
                break;
            case cc.DIRECTOR_PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log("cocos2d: Director: unrecognized projection");
            }
            this._projection = X;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged);
            cc.setProjectionMatrixDirty();
        }
    },
    _showStats: function() {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel && this._SPFLabel && this._drawsLabel ? (H8m.a8E(this._accumDt, cc.DIRECTOR_FPS_INTERVAL) && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = H8m.O8E(this._frames, this._accumDt), this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (H8m.B8E(0, cc.g_NumberOfDraws)).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0;
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene;
    },
    getRunningScene: function() {
        return this._runningScene;
    },
    getAnimationInterval: function() {
        return this._animationInterval;
    },
    isDisplayStats: function() {
        return this._displayStats;
    },
    setDisplayStats: function(X) {
        this._displayStats = X;
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame;
    },
    getOpenGLView: function() {
        return this._openGLView;
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero;
    },
    isPaused: function() {
        return this._paused;
    },
    getTotalFrames: function() {
        return this._totalFrames;
    },
    getProjection: function() {
        return this._projection;
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1);
    },
    popToSceneStackLevel: function(X) {
        if (!this._runningScene)
            throw "A running Scene is needed";
        var S = this._scenesStack,
            P = S.length;
        if (H8m.Z8E(0, P))
            this.end();
        else if (!(H8m.J8E(X, P))) {
            for (; H8m.n8E(P, X);) {
                var O = S.pop();
                O.running && (O.onExitTransitionDidStart(), O.onExit());
                O.cleanup();
                P--;
            }
            this._nextScene = S[H8m.G8E(S.length, 1)];
            this._sendCleanupToScene = !1;
        }
    },
    getScheduler: function() {
        return this._scheduler;
    },
    setScheduler: function(X) {
        H8m.W8E(this._scheduler, X) && (this._scheduler = X);
    },
    getActionManager: function() {
        return this._actionManager;
    },
    setActionManager: function(X) {
        H8m.v8E(this._actionManager, X) && (this._actionManager = X);
    },
    getDeltaTime: function() {
        return this._deltaTime;
    },
    _createStatsLabel: null,
    _createStatsLabelForWebGL: function() {
        if (!cc.LabelAtlas)
            return this._createStatsLabelForCanvas();
        if (H8m.u8E(null, cc.Director._fpsImageLoaded) && !1 != cc.Director._fpsImageLoaded) {
            var X = new cc.Texture2D;
            X.initWithElement(cc.Director._fpsImage);
            X.handleLoadedTexture();
            var S = H8m.H8E(cc.view.getDesignResolutionSize().height, 320);
            H8m.f8E(0, S) && (S = H8m.I8E(this._winSizeInPoints.height, 320));
            var P = new cc.LabelAtlas;
            P._setIgnoreContentScaleFactor(!0);
            P.initWithString("00.0", X, 12, 32, ".");
            P.scale = S;
            this._FPSLabel = P;
            P = new cc.LabelAtlas;
            P._setIgnoreContentScaleFactor(!0);
            P.initWithString("0.000", X, 12, 32, ".");
            P.scale = S;
            this._SPFLabel = P;
            P = new cc.LabelAtlas;
            P._setIgnoreContentScaleFactor(!0);
            P.initWithString("000", X, 12, 32, ".");
            P.scale = S;
            this._drawsLabel = P;
            X = cc.DIRECTOR_STATS_POSITION;
            this._drawsLabel.setPosition(X.x, H8m.g4E(34, S) + X.y);
            this._SPFLabel.setPosition(X.x, H8m.K4E(17, S) + X.y);
            this._FPSLabel.setPosition(X);
        }
    },
    _createStatsLabelForCanvas: function() {
        var X = 0,
            X = H8m.d4E(this._winSizeInPoints.width, this._winSizeInPoints.height) ? H8m.t4E(0, this._winSizeInPoints.height / 320 * 24) : H8m.w4E(0, this._winSizeInPoints.width / 320 * 24);
        this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", X);
        this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", X);
        this._drawsLabel = cc.LabelTTF.create("0000", "Arial", X);
        X = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(H8m.e4E(this._drawsLabel.width, 2) + X.x, H8m.Q4E(5, this._drawsLabel.height, 2) + X.y);
        this._SPFLabel.setPosition(H8m.Z4E(this._SPFLabel.width, 2) + X.x, H8m.J4E(3, this._SPFLabel.height, 2) + X.y);
        this._FPSLabel.setPosition(H8m.R4E(this._FPSLabel.width, 2) + X.x, H8m.M4E(this._FPSLabel.height, 2) + X.y);
    },
    _calculateMPF: function() {
        this._secondsPerFrame = H8m.V4E((Date.now() - this._lastUpdate), 1E3);
    }
});
H8m.s4E(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (cc.Director.prototype._clear = cc.Director.prototype._clearWebGL, cc.Director.prototype._beforeVisitScene = cc.Director.prototype._beforeVisitSceneWebGL, cc.Director.prototype._afterVisitScene = cc.Director.prototype._afterVisitSceneWebGL, cc.Director.prototype._createStatsLabel = cc.Director.prototype._createStatsLabelForWebGL) : (cc.Director.prototype._clear = cc.Director.prototype._clearCanvas, cc.Director.prototype._createStatsLabel = cc.Director.prototype._createStatsLabelForCanvas);
H8m.D6(H8m.E5S);
H8m.i6(H8m.g2P);
H8m.d6(H8m.H7S);
H8m.z6(H8m.p4i);
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !H8m.h7H,
    startAnimation: function() {
        this._nextDeltaTimeZero = !H8m.U7H;
        this.invalid = !H8m.h7H;
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !H8m.h7H, this.purgeDirector()) : this.invalid || this.drawScene();
    },
    stopAnimation: function() {
        this.invalid = !H8m.U7H;
    },
    setAnimationInterval: function(X) {
        this._animationInterval = X;
        this.invalid || (this.stopAnimation(), this.startAnimation());
    }
});
H8m.P6(H8m.H6P);
H8m.w6();
cc.Director._getInstance = function() {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !H8m.h7H, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector;
};
H8m.a6(H8m.H8i);
cc.Director._fpsImage = new Image;
cc.Director._fpsImage.addEventListener(H8m.B4K, function() {
    var X = function() {
        cc.Director._fpsImageLoaded = !H8m.U7H;
    };
    X();
});
H8m.O6(H8m.K5P);
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: null,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.kmMat4;
        this.restore();
    },
    description: function() {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e";
    },
    setDirty: function(X) {
        this._dirty = X;
    },
    isDirty: function() {
        return this._dirty;
    },
    restore: function() {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX = this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        cc.kmMat4Identity(this._lookupMatrix);
        this._dirty = !1;
    },
    locate: function() {
        if (this._dirty) {
            var X = new cc.kmVec3,
                S = new cc.kmVec3,
                P = new cc.kmVec3;
            cc.kmVec3Fill(X, this._eyeX, this._eyeY, this._eyeZ);
            cc.kmVec3Fill(S, this._centerX, this._centerY, this._centerZ);
            cc.kmVec3Fill(P, this._upX, this._upY, this._upZ);
            cc.kmMat4LookAt(this._lookupMatrix, X, S, P);
            this._dirty = !1;
        }
        cc.kmGLMultMatrix(this._lookupMatrix);
    },
    setEyeXYZ: function(X, S, P) {
        this.setEye(X, S, P);
    },
    setEye: function(X, S, P) {
        this._eyeX = X;
        this._eyeY = S;
        this._eyeZ = P;
        this._dirty = !0;
    },
    setCenterXYZ: function(X, S, P) {
        this.setCenter(X, S, P);
    },
    setCenter: function(X, S, P) {
        this._centerX = X;
        this._centerY = S;
        this._centerZ = P;
        this._dirty = !0;
    },
    setUpXYZ: function(X, S, P) {
        this.setUp(X, S, P);
    },
    setUp: function(X, S, P) {
        this._upX = X;
        this._upY = S;
        this._upZ = P;
        this._dirty = !0;
    },
    getEyeXYZ: function(X, S, P) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        };
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        };
    },
    getCenterXYZ: function(X, S, P) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        };
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        };
    },
    getUpXYZ: function(X, S, P) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        };
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        };
    },
    _DISALLOW_COPY_AND_ASSIGN: function(X) {}
});
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON;
};
H8m.Q6();
cc.arrayVerifyType = function(X, S) {
    if (X && H8m.U4E(0, X.length))
        for (var P = 0; H8m.b4E(P, X.length); P++)
            if (!(H8m.F4E(X[P], S)))
                return cc.log("element type is wrong!"), !1;
    return !0;
};
cc.arrayRemoveObject = function(X, S) {
    for (var P = 0, O = X.length; H8m.k7E(P, O); P++)
        if (H8m.L7E(X[P], S)) {
            X.splice(P, 1);
            break;
        }
};
cc.arrayRemoveArray = function(X, S) {
    for (var P = 0, O = S.length; H8m.i7E(P, O); P++)
        cc.arrayRemoveObject(X, S[P]);
};
cc.arrayAppendObjectsToIndex = function(X, S, P) {
    X.splice.apply(X, [P, H8m.U7H].concat(S));
    return X;
};
cc.ListEntry = function(X, S, P, O, Z, Y) {
    this.prev = X;
    this.next = S;
    this.target = P;
    this.priority = O;
    this.paused = Z;
    this.markedForDeletion = Y;
};
cc.HashUpdateEntry = function(X, S, P, O) {
    this.list = X;
    this.entry = S;
    this.target = P;
    this.hh = O;
};
cc.HashTimerEntry = function(X, S, P, O, Z, Y, T) {
    this.timers = X;
    this.target = S;
    this.timerIndex = P;
    this.currentTimer = O;
    this.currentTimerSalvaged = Z;
    this.paused = Y;
    this.hh = T;
};
cc.Timer = cc.Class.extend({
    _interval: H8m.U7H,
    _callback: H8m.H6P,
    _target: H8m.H6P,
    _elapsed: H8m.U7H,
    _runForever: !H8m.h7H,
    _useDelay: !H8m.h7H,
    _timesExecuted: H8m.U7H,
    _repeat: H8m.U7H,
    _delay: H8m.U7H,
    getInterval: function() {
        return this._interval;
    },
    setInterval: function(X) {
        this._interval = X;
    },
    getCallback: function() {
        return this._callback;
    },
    ctor: function(X, S, P, O, Z) {
        this._target = X;
        this._callback = S;
        this._elapsed = -H8m.h7H;
        this._interval = P || H8m.U7H;
        this._delay = Z || H8m.U7H;
        this._useDelay = H8m.S7E(H8m.U7H, this._delay);
        this._repeat = H8m.P7E(H8m.H6P, O) ? cc.REPEAT_FOREVER : O;
        this._runForever = H8m.a7E(this._repeat, cc.REPEAT_FOREVER);
    },
    _doCallback: function() {
        if (H8m.u6P == typeof this._callback)
            this._target[this._callback](this._elapsed);
        else
            this._callback.call(this._target, this._elapsed);
    },
    update: function(X) {
        if (-H8m.h7H == this._elapsed)
            this._timesExecuted = this._elapsed = H8m.U7H;
        else {
            var S = this._target,
                P = this._callback;
            this._elapsed += X;
            this._runForever && !this._useDelay ? H8m.O7E(this._elapsed, this._interval) && (S && P && this._doCallback(), this._elapsed = H8m.U7H) : (this._useDelay ? H8m.B7E(this._elapsed, this._delay) && (S && P && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted += H8m.h7H, this._useDelay = !H8m.h7H) : H8m.Z7E(this._elapsed, this._interval) && (S && P && this._doCallback(), this._elapsed = H8m.U7H, this._timesExecuted += H8m.h7H), H8m.J7E(this._timesExecuted, this._repeat) && cc.director.getScheduler().unscheduleCallbackForTarget(S, P));
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1;
        this._updates = [[], [], []];
        this._hashForUpdates = {};
        this._arrayForUpdates = [];
        this._hashForTimers = {};
        this._arrayForTimers = [];
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1;
    },
    _removeHashElement: function(X) {
        delete this._hashForTimers[X.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, X);
        X.Timer = null;
        X.target = null;
    },
    _removeUpdateFromHash: function(X) {
        if (X = this._hashForUpdates[X.target.__instanceId])
            cc.arrayRemoveObject(X.list, X.entry), delete this._hashForUpdates[X.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, X), X.entry = null, X.target = null;
    },
    _priorityIn: function(X, S, P, O) {
        O = new cc.ListEntry(null, null, S, P, O, !1);
        if (X) {
            for (var Z = H8m.n7E(X.length, 1), Y = 0; H8m.G7E(Y, Z) && !(H8m.W7E(P, X[Y].priority)); Y++)
                ;
            X.splice(Y, 0, O);
        } else
            X = [], X.push(O);
        P = new cc.HashUpdateEntry(X, O, S, null);
        this._arrayForUpdates.push(P);
        this._hashForUpdates[S.__instanceId] = P;
        return X;
    },
    _appendIn: function(X, S, P) {
        P = new cc.ListEntry(null, null, S, 0, P, !1);
        X.push(P);
        X = new cc.HashUpdateEntry(X, P, S, null);
        this._arrayForUpdates.push(X);
        this._hashForUpdates[S.__instanceId] = X;
    },
    setTimeScale: function(X) {
        this._timeScale = X;
    },
    getTimeScale: function() {
        return this._timeScale;
    },
    update: function(X) {
        var S = this._updates,
            P = this._arrayForTimers,
            O;
        this._updateHashLocked = !0;
        H8m.v7E(1, this._timeScale) && (X *= this._timeScale);
        for (var Z = 0, Y = S.length; H8m.u7E(Z, Y) && H8m.H7E(0, Z); Z++)
            for (var T = this._updates[Z], R = 0, E = T.length; H8m.f7E(R, E); R++)
                O = T[R], O.paused || O.markedForDeletion || O.target.update(X);
        Z = 0;
        for (Y = P.length; H8m.I7E(Z, Y); Z++) {
            O = P[Z];
            if (!O)
                break;
            this._currentTarget = O;
            this._currentTargetSalvaged = !1;
            if (!O.paused)
                for (O.timerIndex = 0; H8m.g0E(O.timerIndex, O.timers.length); O.timerIndex++)
                    O.currentTimer = O.timers[O.timerIndex], O.currentTimerSalvaged = !1, O.currentTimer.update(X), O.currentTimer = null;
            this._currentTargetSalvaged && H8m.K0E(0, O.timers.length) && (this._removeHashElement(O), Z--);
        }
        Z = 0;
        for (Y = S.length; H8m.d0E(Z, Y); Z++)
            for (T = this._updates[Z], R = 0, E = T.length; H8m.t0E(R, E);) {
                O = T[R];
                if (!O)
                    break;
                O.markedForDeletion ? this._removeUpdateFromHash(O) : R++;
            }
        this._updateHashLocked = !1;
        this._currentTarget = null;
    },
    scheduleCallbackForTarget: function(X, S, P, O, Z, Y) {
        if (!S)
            throw "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.";
        if (!X)
            throw "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.";
        P = P || 0;
        O = H8m.w0E(null, O) ? cc.REPEAT_FOREVER : O;
        Z = Z || 0;
        Y = Y || !1;
        var T = this._hashForTimers[X.__instanceId];
        T || (T = new cc.HashTimerEntry(null, X, 0, null, null, Y, null), this._arrayForTimers.push(T), this._hashForTimers[X.__instanceId] = T);
        if (H8m.e0E(null, T.timers))
            T.timers = [];
        else
            for (var R = 0; H8m.Q0E(R, T.timers.length); R++)
                if (Y = T.timers[R], H8m.r0E(S, Y._callback)) {
                    //cc.log("CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:" + Y.getInterval().toFixed(4) + " to " + P.toFixed(4));
                    Y._interval = P;
                    return;
                }
        Y = new cc.Timer(X, S, P, O, Z);
        T.timers.push(Y);
    },
    scheduleUpdateForTarget: function(X, S, P) {
        var O = this._updates,
            Z = this._hashForUpdates[X.__instanceId];
        Z ? Z.entry.markedForDeletion = !1 : H8m.N0E(0, S) ? this._appendIn(O[1], X, P) : H8m.m0E(0, S) ? O[0] = this._priorityIn(O[0], X, S, P) : O[2] = this._priorityIn(O[2], X, S, P);
    },
    unscheduleCallbackForTarget: function(X, S) {
        if (H8m.A0E(null, X) && H8m.E0E(null, S)) {
            var P = this._hashForTimers[X.__instanceId];
            if (P)
                for (var O = P.timers, Z = 0, Y = O.length; H8m.C0E(Z, Y); Z++) {
                    var T = O[Z];
                    if (H8m.h0E(S, T._callback)) {
                        H8m.y0E(T, P.currentTimer) || P.currentTimerSalvaged || (P.currentTimerSalvaged = !0);
                        O.splice(Z, 1);
                        H8m.q0E(P.timerIndex, Z) && P.timerIndex--;
                        H8m.l0E(0, O.length) && (H8m.X3E(this._currentTarget, P) ? this._currentTargetSalvaged = !0 : this._removeHashElement(P));
                        break;
                    }
                }
        }
    },
    unscheduleUpdateForTarget: function(X) {
        H8m.D3E(null, X) && (X = this._hashForUpdates[X.__instanceId], H8m.c3E(null, X) && (this._updateHashLocked ? X.entry.markedForDeletion = !0 : this._removeUpdateFromHash(X.entry)));
    },
    unscheduleAllCallbacksForTarget: function(X) {
        if (H8m.z3E(null, X)) {
            var S = this._hashForTimers[X.__instanceId];
            if (S) {
                var P = S.timers;
                !S.currentTimerSalvaged && H8m.j3E(0, P.indexOf(S.currentTimer)) && (S.currentTimerSalvaged = !0);
                P.length = 0;
                H8m.x3E(this._currentTarget, S) ? this._currentTargetSalvaged = !0 : this._removeHashElement(S);
            }
            this.unscheduleUpdateForTarget(X);
        }
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    unscheduleAllCallbacksWithMinPriority: function(X) {
        for (var S = this._arrayForTimers, P = this._updates, O = 0, Z = S.length; H8m.o3E(O, Z); O++)
            this.unscheduleAllCallbacksForTarget(S[O].target);
        for (O = 2; H8m.p3E(0, O); O--)
            if (!(H8m.Y3E(1, O) && H8m.T3E(0, X) || H8m.R3E(0, O) && H8m.M3E(0, X)))
                for (var S = P[O], Z = 0, Y = S.length; H8m.V3E(Z, Y); Z++)
                    this.unscheduleUpdateForTarget(S[Z].target);
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    pauseAllTargetsWithMinPriority: function(X) {
        X = [];
        for (var S, P = this._arrayForTimers, O = this._updates, Z = 0, Y = P.length; H8m.s3E(Z, Y); Z++)
            if (S = P[Z])
                S.paused = !0, X.push(S.target);
        Z = 0;
        for (Y = O.length; H8m.U3E(Z, Y); Z++)
            for (var P = O[Z], T = 0, R = P.length; H8m.b3E(T, R); T++)
                if (S = P[T])
                    S.paused = !0, X.push(S.target);
        return X;
    },
    resumeTargets: function(X) {
        if (X)
            for (var S = 0; H8m.F3E(S, X.length); S++)
                this.resumeTarget(X[S]);
    },
    pauseTarget: function(X) {
        if (!X)
            throw "cc.Scheduler.pauseTarget():target should be non-null";
        var S = this._hashForTimers[X.__instanceId];
        S && (S.paused = !0);
        if (X = this._hashForUpdates[X.__instanceId])
            X.entry.paused = !0;
    },
    resumeTarget: function(X) {
        if (!X)
            throw "cc.Scheduler.resumeTarget():target should be non-null";
        var S = this._hashForTimers[X.__instanceId];
        S && (S.paused = !1);
        if (X = this._hashForUpdates[X.__instanceId])
            X.entry.paused = !1;
    },
    isTargetPaused: function(X) {
        if (!X)
            throw "cc.Scheduler.isTargetPaused():target should be non-null";
        return (X = this._hashForTimers[X.__instanceId]) ? X.paused : !1;
    }
});
H8m.B6();
cc.DrawingPrimitive = cc.Class.extend({
    _renderContext: H8m.H6P,
    setRenderContext: function(X) {
        this._renderContext = X;
    },
    getRenderContext: function() {
        return this._renderContext;
    },
    ctor: function(X) {
        this._renderContext = X;
    },
    drawPoint: function(X) {
        var S = "DrawingPrimitive.drawPoint() not implement!";
        cc.log(S);
    },
    drawPoints: function(X, S) {
        var P = "DrawingPrimitive.drawPoints() not implement!";
        cc.log(P);
    },
    drawLine: function(X, S) {
        var P = "DrawingPrimitive.drawLine() not implement!";
        cc.log(P);
    },
    drawRect: function(X, S) {
        var P = "DrawingPrimitive.drawRect() not implement!";
        cc.log(P);
    },
    drawSolidRect: function(X, S, P) {
        var O = "DrawingPrimitive.drawSolidRect() not implement!";
        cc.log(O);
    },
    drawPoly: function(X, S, P, O) {
        var Z = "DrawingPrimitive.drawPoly() not implement!";
        cc.log(Z);
    },
    drawSolidPoly: function(X, S, P) {
        var O = "DrawingPrimitive.drawSolidPoly() not implement!";
        cc.log(O);
    },
    drawCircle: function(X, S, P, O, Z) {
        var Y = "DrawingPrimitive.drawCircle() not implement!";
        cc.log(Y);
    },
    drawQuadBezier: function(X, S, P, O) {
        var Z = "DrawingPrimitive.drawQuadBezier() not implement!";
        cc.log(Z);
    },
    drawCubicBezier: function(X, S, P, O, Z) {
        var Y = "DrawingPrimitive.drawCubicBezier() not implement!";
        cc.log(Y);
    },
    drawCatmullRom: function(X, S) {
        cc.log(H8m.z8S);
    },
    drawCardinalSpline: function(X, S, P) {
        cc.log(H8m.z8S);
    }
});
cc.DrawingPrimitiveCanvas = cc.DrawingPrimitive.extend({
    _cacheArray: [],
    drawPoint: function(X, S) {
        S || (S = 1);
        var P = cc.view.getScaleX(),
            O = cc.view.getScaleY(),
            O = cc.p(H8m.k5E(X.x, P), H8m.L5E(X.y, O));
        this._renderContext.beginPath();
        this._renderContext.arc(O.x, -O.y, H8m.i5E(S, P), 0, H8m.S5E(2, Math.PI), !1);
        this._renderContext.closePath();
        this._renderContext.fill();
    },
    drawPoints: function(X, S, P) {
        if (H8m.P5E(null, X)) {
            P || (P = 1);
            S = this._renderContext;
            var O = cc.view.getScaleX(),
                Z = cc.view.getScaleY();
            S.beginPath();
            for (var Y = 0, T = X.length; H8m.a5E(Y, T); Y++)
                S.arc(H8m.O5E(X[Y].x, O), -X[Y].y * Z, H8m.B5E(P, O), 0, H8m.Z5E(2, Math.PI), !1);
            S.closePath();
            S.fill();
        }
    },
    drawLine: function(X, S) {
        var P = this._renderContext,
            O = cc.view.getScaleX(),
            Z = cc.view.getScaleY();
        P.beginPath();
        P.moveTo(H8m.J5E(X.x, O), -X.y * Z);
        P.lineTo(H8m.n5E(S.x, O), -S.y * Z);
        P.closePath();
        P.stroke();
    },
    drawRect: function(X, S) {
        this.drawLine(cc.p(X.x, X.y), cc.p(S.x, X.y));
        this.drawLine(cc.p(S.x, X.y), cc.p(S.x, S.y));
        this.drawLine(cc.p(S.x, S.y), cc.p(X.x, S.y));
        this.drawLine(cc.p(X.x, S.y), cc.p(X.x, X.y));
    },
    drawSolidRect: function(X, S, P) {
        X = [X, cc.p(S.x, X.y), S, cc.p(X.x, S.y)];
        this.drawSolidPoly(X, 4, P);
    },
    drawPoly: function(X, S, P, O) {
        O = O || !1;
        if (H8m.G5E(null, X)) {
            if (H8m.W5E(3, X.length))
                throw Error("Polygon's point must greater than 2");
            var Z = X[0];
            S = this._renderContext;
            var Y = cc.view.getScaleX(),
                T = cc.view.getScaleY();
            S.beginPath();
            S.moveTo(H8m.v5E(Z.x, Y), -Z.y * T);
            for (var Z = 1, R = X.length; H8m.u5E(Z, R); Z++)
                S.lineTo(H8m.H5E(X[Z].x, Y), -X[Z].y * T);
            P && S.closePath();
            O ? S.fill() : S.stroke();
        }
    },
    drawSolidPoly: function(X, S, P) {
        this.setDrawColor(P.r, P.g, P.b, P.a);
        this.drawPoly(X, S, !0, !0);
    },
    drawCircle: function(X, S, P, O, Z) {
        Z = Z || !1;
        O = this._renderContext;
        var Y = cc.view.getScaleX(),
            T = cc.view.getScaleY();
        O.beginPath();
        O.arc(H8m.f5E(0, X.x * Y), 0 | -(H8m.I5E(X.y, T)), H8m.g6E(S, Y), -P, -(H8m.K6E(P, 2 * Math.PI)), !1);
        Z && O.lineTo(H8m.d6E(0, X.x * Y), 0 | -(H8m.t6E(X.y, T)));
        O.stroke();
    },
    drawQuadBezier: function(X, S, P, O) {
        for (var Z = this._cacheArray, Y = Z.length = 0, T = 0; H8m.w6E(T, O); T++) {
            var R = H8m.e6E(Math.pow(1 - Y, 2), X.x) + H8m.Q6E(2, (1 - Y), Y, S.x) + H8m.Y6E(Y, Y, P.x),
                E = H8m.m6E(Math.pow(1 - Y, 2), X.y) + H8m.A6E(2, (1 - Y), Y, S.y) + H8m.V6E(Y, Y, P.y);
            Z.push(cc.p(R, E));
            Y += H8m.h6E(1, O);
        }
        Z.push(cc.p(P.x, P.y));
        this.drawPoly(Z, O + 1, !1, !1);
    },
    drawCubicBezier: function(X, S, P, O, Z) {
        for (var Y = this._cacheArray, T = Y.length = 0, R = 0; H8m.y6E(R, Z); R++) {
            var E = H8m.q6E(Math.pow(1 - T, 3), X.x) + H8m.l6E(3, Math.pow(1 - T, 2), T, S.x) + H8m.L2E(3, (1 - T), T, T, P.x) + H8m.S2E(T, T, T, O.x),
                V = H8m.w2E(Math.pow(1 - T, 3), X.y) + H8m.e2E(3, Math.pow(1 - T, 2), T, S.y) + H8m.p2E(3, (1 - T), T, T, P.y) + H8m.T2E(T, T, T, O.y);
            Y.push(cc.p(E, V));
            T += H8m.G2E(1, Z);
        }
        Y.push(cc.p(O.x, O.y));
        this.drawPoly(Y, Z + 1, !1, !1);
    },
    drawCatmullRom: function(X, S) {
        this.drawCardinalSpline(X, 0.5, S);
    },
    drawCardinalSpline: function(X, S, P) {
        cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
        var O = this._cacheArray;
        O.length = 0;
        for (var Z, Y, T = H8m.W2E(1, X.length), R = 0; H8m.v2E(R, P + 1); R++)
            Y = H8m.u2E(R, P), H8m.H2E(1, Y) ? (Z = H8m.f2E(X.length, 1), Y = 1) : (Z = H8m.I2E(0, Y / T), Y = H8m.g93((Y - T * Z), T)), Z = cc.CardinalSplineAt(cc.getControlPointAt(X, H8m.K93(Z, 1)), cc.getControlPointAt(X, H8m.d93(Z, 0)), cc.getControlPointAt(X, Z + 1), cc.getControlPointAt(X, Z + 2), S, Y), O.push(Z);
        this.drawPoly(O, P + 1, !1, !1);
    },
    drawImage: function(X, S, P, O, Z) {
        switch (arguments.length) {
        case 2:
            this._renderContext.drawImage(X, S.x, -(S.y + X.height));
            break;
        case 3:
            this._renderContext.drawImage(X, S.x, -(S.y + P.height), P.width, P.height);
            break;
        case 5:
            this._renderContext.drawImage(X, S.x, S.y, P.width, P.height, O.x, -(O.y + Z.height), Z.width, Z.height);
            break;
        default:
            throw Error("Argument must be non-nil");
        }
    },
    drawStar: function(X, S, P) {
        X = X || this._renderContext;
        S *= cc.view.getScaleX();
        P = "rgba(" + (H8m.t93(0, P.r)) + "," + (H8m.w93(0, P.g)) + "," + (H8m.e93(0, P.b));
        X.fillStyle = P + ",1)";
        var O = H8m.Q93(S, 10);
        X.beginPath();
        X.moveTo(-S, S);
        X.lineTo(0, O);
        X.lineTo(S, S);
        X.lineTo(O, 0);
        X.lineTo(S, -S);
        X.lineTo(0, -O);
        X.lineTo(-S, -S);
        X.lineTo(-O, 0);
        X.lineTo(-S, S);
        X.closePath();
        X.fill();
        var Z = X.createRadialGradient(0, 0, O, 0, 0, S);
        Z.addColorStop(0, P + ", 1)");
        Z.addColorStop(0.3, P + ", 0.8)");
        Z.addColorStop(1, P + ", 0.0)");
        X.fillStyle = Z;
        X.beginPath();
        X.arc(0, 0, H8m.r93(S, O), 0, cc.PI2, !1);
        X.closePath();
        X.fill();
    },
    drawColorBall: function(X, S, P) {
        X = X || this._renderContext;
        S *= cc.view.getScaleX();
        P = "rgba(" + (H8m.N93(0, P.r)) + "," + (H8m.m93(0, P.g)) + "," + (H8m.A93(0, P.b));
        var O = X.createRadialGradient(0, 0, H8m.E93(S, 10), 0, 0, S);
        O.addColorStop(0, P + ", 1)");
        O.addColorStop(0.3, P + ", 0.8)");
        O.addColorStop(0.6, P + ", 0.4)");
        O.addColorStop(1, P + ", 0.0)");
        X.fillStyle = O;
        X.beginPath();
        X.arc(0, 0, S, 0, cc.PI2, !1);
        X.closePath();
        X.fill();
    },
    fillText: function(X, S, P) {
        this._renderContext.fillText(X, S, -P);
    },
    setDrawColor: function(X, S, P, O) {
        this._renderContext.fillStyle = "rgba(" + X + "," + S + "," + P + "," + H8m.C93(O, 255) + ")";
        this._renderContext.strokeStyle = "rgba(" + X + "," + S + "," + P + "," + H8m.h93(O, 255) + ")";
    },
    setPointSize: function(X) {},
    setLineWidth: function(X) {
        this._renderContext.lineWidth = H8m.y93(X, cc.view.getScaleX());
    }
});
cc.DrawingPrimitiveWebGL = cc.DrawingPrimitive.extend({
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(X) {
        H8m.q93(null, X) && (X = cc._renderContext);
        if (!X instanceof WebGLRenderingContext)
            throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        cc.DrawingPrimitive.prototype.ctor.call(this, X);
        this._colorArray = new Float32Array([1, 1, 1, 1]);
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0);
    },
    drawInit: function() {
        this._initialized = !1;
    },
    drawPoint: function(X) {
        this.lazy_init();
        var S = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        S.uniform4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var P = S.createBuffer();
        S.bindBuffer(S.ARRAY_BUFFER, P);
        S.bufferData(S.ARRAY_BUFFER, new Float32Array([X.x, X.y]), S.STATIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, S.FLOAT, !1, 0, 0);
        S.drawArrays(S.POINTS, 0, 1);
        S.deleteBuffer(P);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawPoints: function(X, S) {
        if (X && H8m.l93(0, X.length)) {
            this.lazy_init();
            var P = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            P.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var O = P.createBuffer();
            P.bindBuffer(P.ARRAY_BUFFER, O);
            P.bufferData(P.ARRAY_BUFFER, this._pointsToTypeArray(X), P.STATIC_DRAW);
            P.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, P.FLOAT, !1, 0, 0);
            P.drawArrays(P.POINTS, 0, X.length);
            P.deleteBuffer(O);
            cc.INCREMENT_GL_DRAWS(1);
        }
    },
    _pointsToTypeArray: function(X) {
        for (var S = new Float32Array(H8m.X13(2, X.length)), P = 0; H8m.D13(P, X.length); P++)
            S[H8m.c13(2, P)] = X[P].x, S[H8m.z13(2, P) + 1] = X[P].y;
        return S;
    },
    drawLine: function(X, S) {
        this.lazy_init();
        var P = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        P.uniform4fv(this._colorLocation, this._colorArray);
        var O = P.createBuffer();
        P.bindBuffer(P.ARRAY_BUFFER, O);
        P.bufferData(P.ARRAY_BUFFER, this._pointsToTypeArray([X, S]), P.STATIC_DRAW);
        P.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, P.FLOAT, !1, 0, 0);
        P.drawArrays(P.LINES, 0, 2);
        P.deleteBuffer(O);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawRect: function(X, S) {
        this.drawLine(cc.p(X.x, X.y), cc.p(S.x, X.y));
        this.drawLine(cc.p(S.x, X.y), cc.p(S.x, S.y));
        this.drawLine(cc.p(S.x, S.y), cc.p(X.x, S.y));
        this.drawLine(cc.p(X.x, S.y), cc.p(X.x, X.y));
    },
    drawSolidRect: function(X, S, P) {
        X = [X, cc.p(S.x, X.y), S, cc.p(X.x, S.y)];
        this.drawSolidPoly(X, 4, P);
    },
    drawPoly: function(X, S, P) {
        this.lazy_init();
        S = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        S.uniform4fv(this._colorLocation, this._colorArray);
        var O = S.createBuffer();
        S.bindBuffer(S.ARRAY_BUFFER, O);
        S.bufferData(S.ARRAY_BUFFER, this._pointsToTypeArray(X), S.STATIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, S.FLOAT, !1, 0, 0);
        P ? S.drawArrays(S.LINE_LOOP, 0, X.length) : S.drawArrays(S.LINE_STRIP, 0, X.length);
        S.deleteBuffer(O);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawSolidPoly: function(X, S, P) {
        this.lazy_init();
        P && this.setDrawColor(P.r, P.g, P.b, P.a);
        S = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        S.uniform4fv(this._colorLocation, this._colorArray);
        P = S.createBuffer();
        S.bindBuffer(S.ARRAY_BUFFER, P);
        S.bufferData(S.ARRAY_BUFFER, this._pointsToTypeArray(X), S.STATIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, S.FLOAT, !1, 0, 0);
        S.drawArrays(S.TRIANGLE_FAN, 0, X.length);
        S.deleteBuffer(P);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawCircle: function(X, S, P, O, Z) {
        this.lazy_init();
        var Y = 1;
        Z && Y++;
        var T = H8m.j13(2, Math.PI, O);
        if (Z = new Float32Array(H8m.e13(2, (O + 2)))) {
            for (var R = 0; H8m.Q13(R, O); R++) {
                var E = H8m.r13(R, T),
                    V = H8m.N13(S, Math.cos(E + P)) + X.x,
                    E = H8m.m13(S, Math.sin(E + P)) + X.y;
                Z[H8m.A13(2, R)] = V;
                Z[H8m.E13(2, R) + 1] = E;
            }
            Z[H8m.C13(2, (O + 1))] = X.x;
            Z[H8m.h13(2, (O + 1)) + 1] = X.y;
            X = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            X.uniform4fv(this._colorLocation, this._colorArray);
            S = X.createBuffer();
            X.bindBuffer(X.ARRAY_BUFFER, S);
            X.bufferData(X.ARRAY_BUFFER, Z, X.STATIC_DRAW);
            X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, 0, 0);
            X.drawArrays(X.LINE_STRIP, 0, O + Y);
            X.deleteBuffer(S);
            cc.INCREMENT_GL_DRAWS(1);
        }
    },
    drawQuadBezier: function(X, S, P, O) {
        this.lazy_init();
        for (var Z = new Float32Array(H8m.y13(2, (O + 1))), Y = 0, T = 0; H8m.q13(T, O); T++)
            Z[H8m.l13(2, T)] = H8m.X83(Math.pow(1 - Y, 2), X.x) + H8m.D83(2, (1 - Y), Y, S.x) + H8m.S83(Y, Y, P.x), Z[H8m.j83(2, T) + 1] = H8m.x83(Math.pow(1 - Y, 2), X.y) + H8m.o83(2, (1 - Y), Y, S.y) + H8m.Z83(Y, Y, P.y), Y += H8m.T83(1, O);
        Z[H8m.R83(2, O)] = P.x;
        Z[H8m.M83(2, O) + 1] = P.y;
        X = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        X.uniform4fv(this._colorLocation, this._colorArray);
        S = X.createBuffer();
        X.bindBuffer(X.ARRAY_BUFFER, S);
        X.bufferData(X.ARRAY_BUFFER, Z, X.STATIC_DRAW);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, 0, 0);
        X.drawArrays(X.LINE_STRIP, 0, O + 1);
        X.deleteBuffer(S);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawCubicBezier: function(X, S, P, O, Z) {
        this.lazy_init();
        for (var Y = new Float32Array(H8m.V83(2, (Z + 1))), T = 0, R = 0; H8m.s83(R, Z); R++)
            Y[H8m.U83(2, R)] = H8m.b83(Math.pow(1 - T, 3), X.x) + H8m.F83(3, Math.pow(1 - T, 2), T, S.x) + H8m.g43(3, (1 - T), T, T, P.x) + H8m.d43(T, T, T, O.x), Y[H8m.j43(2, R) + 1] = H8m.x43(Math.pow(1 - T, 3), X.y) + H8m.o43(3, Math.pow(1 - T, 2), T, S.y) + H8m.Z43(3, (1 - T), T, T, P.y) + H8m.n43(T, T, T, O.y), T += H8m.E43(1, Z);
        Y[H8m.C43(2, Z)] = O.x;
        Y[H8m.h43(2, Z) + 1] = O.y;
        X = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        X.uniform4fv(this._colorLocation, this._colorArray);
        S = X.createBuffer();
        X.bindBuffer(X.ARRAY_BUFFER, S);
        X.bufferData(X.ARRAY_BUFFER, Y, X.STATIC_DRAW);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, 0, 0);
        X.drawArrays(X.LINE_STRIP, 0, Z + 1);
        X.deleteBuffer(S);
        cc.INCREMENT_GL_DRAWS(1);
    },
    drawCatmullRom: function(X, S) {
        this.drawCardinalSpline(X, 0.5, S);
    },
    drawCardinalSpline: function(X, S, P) {
        this.lazy_init();
        for (var O = new Float32Array(H8m.y43(2, (P + 1))), Z, Y, T = H8m.q43(1, X.length), R = 0; H8m.l43(R, P + 1); R++)
            Y = H8m.X73(R, P), H8m.D73(1, Y) ? (Z = H8m.c73(X.length, 1), Y = 1) : (Z = H8m.z73(0, Y / T), Y = H8m.j73((Y - T * Z), T)), Z = cc.CardinalSplineAt(cc.getControlPointAt(X, H8m.x73(Z, 1)), cc.getControlPointAt(X, Z), cc.getControlPointAt(X, Z + 1), cc.getControlPointAt(X, Z + 2), S, Y), O[H8m.o73(2, R)] = Z.x, O[H8m.p73(2, R) + 1] = Z.y;
        X = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        X.uniform4fv(this._colorLocation, this._colorArray);
        S = X.createBuffer();
        X.bindBuffer(X.ARRAY_BUFFER, S);
        X.bufferData(X.ARRAY_BUFFER, O, X.STATIC_DRAW);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, 0, 0);
        X.drawArrays(X.LINE_STRIP, 0, P + 1);
        X.deleteBuffer(S);
        cc.INCREMENT_GL_DRAWS(1);
    },
    setDrawColor: function(X, S, P, O) {
        this._colorArray[0] = H8m.Y73(X, 255);
        this._colorArray[1] = H8m.T73(S, 255);
        this._colorArray[2] = H8m.R73(P, 255);
        this._colorArray[3] = H8m.M73(O, 255);
    },
    setPointSize: function(X) {
        this._pointSize = H8m.V73(X, cc.CONTENT_SCALE_FACTOR());
    },
    setLineWidth: function(X) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(X);
    }
});
H8m.p6();
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._shadowEnabled = this._isMultiLine = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._setColorsString();
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize);
    },
    _measureConfig: function() {
        this._getLabelContext().font = this._fontStyleStr;
    },
    _measure: function(X) {
        return this._getLabelContext().measureText(X).width;
    },
    _checkNextline: function(X, S) {
        var P = this._measure(X),
            O = Math.floor(H8m.s73(X.length, S, P)),
            Z = X.indexOf("\n");
        if (H8m.y73(0.8 * O, Z) && H8m.q73(0, Z))
            return Z + 1;
        if (H8m.l73(P, S))
            return X.length;
        for (var P = !1, Y = S + 1, Z = -1, T = O, R, E = cc.LabelTTF._checkRegEx, V = cc.LabelTTF._reverseCheckRegEx, U = cc.LabelTTF._checkEnRegEx, k9 = X.substr(O); R = E.exec(k9);) {
            T += R[0].length;
            Y = X.substr(0, T);
            Y = this._measure(Y);
            if (H8m.X03("\n", R[2]) && H8m.D03(Y, S)) {
                P = !0;
                Z = T;
                break;
            }
            if (H8m.c03(Y, S)) {
                -1 != Z && (P = !0);
                break;
            }
            Z = T;
            k9 = X.substr(T);
        }
        if (P)
            return Z;
        k9 = X.substr(0, O);
        for (Z = O; R = V.exec(k9);)
            if (Z = R[1].length, k9 = R[1], Y = this._measure(k9), H8m.z03(Y, S)) {
                U.test(R[2]) && Z++;
                break;
            }
        return Z || 1;
    },
    description: function() {
        return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e";
    },
    setColor: null,
    _setColorForCanvas: function(X) {
        cc.NodeRGBA.prototype.setColor.call(this, X);
        this._setColorsStringForCanvas();
    },
    _setColorsString: null,
    _setColorsStringForCanvas: function() {
        this._needUpdateTexture = !0;
        var X = this._displayedColor,
            S = this._displayedOpacity,
            P = this._strokeColor,
            O = this._textFillColor;
        this._shadowColorStr = "rgba(" + (H8m.j03(0, 0.5 * X.r)) + "," + (H8m.x03(0, 0.5 * X.g)) + "," + (H8m.o03(0, 0.5 * X.b)) + "," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (H8m.p03(0, X.r / 255 * O.r)) + "," + (H8m.Y03(0, X.g / 255 * O.g)) + "," + (H8m.T03(0, X.b / 255 * O.b)) + ", " + H8m.R03(S, 255) + ")";
        this._strokeColorStr = "rgba(" + (H8m.M03(0, X.r / 255 * P.r)) + "," + (H8m.V03(0, X.g / 255 * P.g)) + "," + (H8m.s03(0, X.b / 255 * P.b)) + ", " + H8m.U03(S, 255) + ")";
    },
    _setColorsStringForWebGL: function() {
        this._needUpdateTexture = !0;
        var X = this._strokeColor,
            S = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (H8m.b03(0, S.r)) + "," + (H8m.F03(0, S.g)) + "," + (H8m.k33(0, S.b)) + ", 1)";
        this._strokeColorStr = "rgba(" + (H8m.L33(0, X.r)) + "," + (H8m.i33(0, X.g)) + "," + (H8m.S33(0, X.b)) + ", 1)";
    },
    updateDisplayedColor: null,
    _updateDisplayedColorForCanvas: function(X) {
        cc.NodeRGBA.prototype.updateDisplayedColor.call(this, X);
        this._setColorsString();
    },
    setOpacity: null,
    _setOpacityForCanvas: function(X) {
        H8m.P33(this._opacity, X) && (cc.Sprite.prototype.setOpacity.call(this, X), this._setColorsString(), this._needUpdateTexture = !0);
    },
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function(X) {
        cc.NodeRGBA.prototype.updateDisplayedOpacity.call(this, X);
        this._setColorsString();
    },
    getString: function() {
        return this._string;
    },
    getHorizontalAlignment: function() {
        return this._hAlignment;
    },
    getVerticalAlignment: function() {
        return this._vAlignment;
    },
    getDimensions: function() {
        return cc.size(this._dimensions.width, this._dimensions.height);
    },
    getFontSize: function() {
        return this._fontSize;
    },
    getFontName: function() {
        return this._fontName;
    },
    initWithString: function(X, S, P, O, Z, Y) {
        X = X ? X + "" : "";
        P = P || 16;
        O = O || cc.size(0, P);
        Z = Z || cc.TEXT_ALIGNMENT_LEFT;
        Y = Y || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        return cc.Sprite.prototype.init.call(this) ? (this._opacityModifyRGB = !1, this._dimensions = cc.size(O.width, O.height), this._fontName = S || "Arial", this._hAlignment = Z, this._vAlignment = Y, this._fontSize = P, this._fontStyleStr = this._fontSize + "px '" + S + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(S, this._fontSize), this.string = X, this._setColorsString(), this._updateTexture(), this._needUpdateTexture = !1, !0) : !1;
    },
    initWithStringAndTextDefinition: null,
    _initWithStringAndTextDefinitionForCanvas: function(X, S) {
        if (!cc.Sprite.prototype.init.call(this))
            return !1;
        this._updateWithTextDefinition(S, !1);
        this.string = X;
        return !0;
    },
    _initWithStringAndTextDefinitionForWebGL: function(X, S) {
        if (!cc.Sprite.prototype.init.call(this))
            return !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM);
        this._updateWithTextDefinition(S, !1);
        this.string = X;
        return !0;
    },
    setTextDefinition: function(X) {
        X && this._updateWithTextDefinition(X, !0);
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1);
    },
    enableShadow: function(X, S, P, O) {
        P = P || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var Z = this._shadowOffset;
        if (Z && H8m.a33(Z.x, X) || H8m.O33(Z._y, S))
            Z.x = X, Z.y = S;
        H8m.B33(this._shadowOpacity, P) && (this._shadowOpacity = P);
        this._setColorsString();
        H8m.Z33(this._shadowBlur, O) && (this._shadowBlur = O);
        this._needUpdateTexture = !0;
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x;
    },
    _setShadowOffsetX: function(X) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        H8m.J33(this._shadowOffset.x, X) && (this._shadowOffset.x = X, this._needUpdateTexture = !0);
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y;
    },
    _setShadowOffsetY: function(X) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        H8m.n33(this._shadowOffset._y, X) && (this._shadowOffset._y = X, this._needUpdateTexture = !0);
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y);
    },
    _setShadowOffset: function(X) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (H8m.G33(this._shadowOffset.x, X.x) || H8m.W33(this._shadowOffset.y, X.y))
            this._shadowOffset.x = X.x, this._shadowOffset.y = X.y, this._needUpdateTexture = !0;
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity;
    },
    _setShadowOpacity: function(X) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        H8m.v33(this._shadowOpacity, X) && (this._shadowOpacity = X, this._setColorsString(), this._needUpdateTexture = !0);
    },
    _getShadowBlur: function() {
        return this._shadowBlur;
    },
    _setShadowBlur: function(X) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        H8m.u33(this._shadowBlur, X) && (this._shadowBlur = X, this._needUpdateTexture = !0);
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0);
    },
    enableStroke: function(X, S) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var P = this._strokeColor;
        if (H8m.H33(P.r, X.r) || H8m.f33(P.g, X.g) || H8m.I33(P.b, X.b))
            P.r = X.r, P.g = X.g, P.b = X.b, this._setColorsString();
        H8m.g53(this._strokeSize, S) && (this._strokeSize = S || 0);
        this._needUpdateTexture = !0;
    },
    _getStrokeStyle: function() {
        return this._strokeColor;
    },
    _setStrokeStyle: function(X) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var S = this._strokeColor;
        if (H8m.K53(S.r, X.r) || H8m.d53(S.g, X.g) || H8m.t53(S.b, X.b))
            S.r = X.r, S.g = X.g, S.b = X.b, this._setColorsString(), this._needUpdateTexture = !0;
    },
    _getLineWidth: function() {
        return this._strokeSize;
    },
    _setLineWidth: function(X) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        H8m.w53(this._strokeSize, X) && (this._strokeSize = X || 0, this._needUpdateTexture = !0);
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0);
    },
    setFontFillColor: null,
    _setFontFillColorForCanvas: function(X) {
        var S = this._textFillColor;
        if (H8m.e53(S.r, X.r) || H8m.Q53(S.g, X.g) || H8m.r53(S.b, X.b))
            S.r = X.r, S.g = X.g, S.b = X.b, this._setColorsString(), this._needUpdateTexture = !0;
    },
    _setFontFillColorForWebGL: function(X) {
        var S = this._textFillColor;
        if (H8m.N53(S.r, X.r) || H8m.m53(S.g, X.g) || H8m.A53(S.b, X.b))
            S.r = X.r, S.g = X.g, S.b = X.b, this._setColorsString(), this._needUpdateTexture = !0;
    },
    _getFillStyle: function() {
        return this._textFillColor;
    },
    _updateWithTextDefinition: function(X, S) {
        X.fontDimensions ? (this._dimensions.width = X.boundingWidth, this._dimensions.height = X.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = X.textAlign;
        this._vAlignment = X.verticalAlign;
        this._fontName = X.fontName;
        this._fontSize = X.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        X.shadowEnabled && this.enableShadow(X.shadowOffsetX, X.shadowOffsetY, X.shadowOpacity, X.shadowBlur);
        X.strokeEnabled && this.enableStroke(X.strokeStyle, X.lineWidth);
        this.setFontFillColor(X.fillStyle);
        S && this._updateTexture();
    },
    _prepareTextDefinition: function(X) {
        var S = new cc.FontDefinition;
        X ? (S.fontSize = this._fontSize, S.boundingWidth = H8m.E53(cc.CONTENT_SCALE_FACTOR(), this._dimensions.width), S.boundingHeight = H8m.C53(cc.CONTENT_SCALE_FACTOR(), this._dimensions.height)) : (S.fontSize = this._fontSize, S.boundingWidth = this._dimensions.width, S.boundingHeight = this._dimensions.height);
        S.fontName = this._fontName;
        S.textAlign = this._hAlignment;
        S.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            S.strokeEnabled = !0;
            var P = this._strokeColor;
            S.strokeStyle = cc.color(P.r, P.g, P.b);
            S.lineWidth = this._strokeSize;
        } else
            S.strokeEnabled = !1;
        this._shadowEnabled ? (S.shadowEnabled = !0, S.shadowBlur = this._shadowBlur, S.shadowOpacity = this._shadowOpacity, S.shadowOffsetX = H8m.h53((X ? cc.CONTENT_SCALE_FACTOR() : 1), this._shadowOffset.x), S.shadowOffsetY = H8m.y53((X ? cc.CONTENT_SCALE_FACTOR() : 1), this._shadowOffset.y)) : S._shadowEnabled = !1;
        X = this._textFillColor;
        S.fillStyle = cc.color(X.r, X.g, X.b);
        return S;
    },
    _fontClientHeight: 18,
    setString: function(X) {
        X = String(X);
        H8m.q53(this._originalText, X) && (this._originalText = X + "", this._updateString(), this._needUpdateTexture = !0);
    },
    _updateString: function() {
        this._string = this._originalText;
    },
    setHorizontalAlignment: function(X) {
        H8m.l53(X, this._hAlignment) && (this._hAlignment = X, this._needUpdateTexture = !0);
    },
    setVerticalAlignment: function(X) {
        H8m.X63(X, this._vAlignment) && (this._vAlignment = X, this._needUpdateTexture = !0);
    },
    setDimensions: function(X) {
        if (H8m.D63(X.width, this._dimensions.width) || H8m.c63(X.height, this._dimensions.height))
            this._dimensions = X, this._updateString(), this._needUpdateTexture = !0;
    },
    _getBoundingWidth: function() {
        return this._dimensions.width;
    },
    _setBoundingWidth: function(X) {
        H8m.z63(X, this._dimensions.width) && (this._dimensions.width = X, this._updateString(), this._needUpdateTexture = !0);
    },
    _getBoundingHeight: function() {
        return this._dimensions.height;
    },
    _setBoundingHeight: function(X) {
        H8m.j63(X, this._dimensions.height) && (this._dimensions.height = X, this._updateString(), this._needUpdateTexture = !0);
    },
    setFontSize: function(X) {
        H8m.x63(this._fontSize, X) && (this._fontSize = X, this._fontStyleStr = X + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, X), this._needUpdateTexture = !0);
    },
    setFontName: function(X) {
        this._fontName && H8m.o63(this._fontName, X) && (this._fontName = X, this._fontStyleStr = this._fontSize + "px '" + X + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(X, this._fontSize), this._needUpdateTexture = !0);
    },
    _getFont: function() {
        return this._fontStyleStr;
    },
    _setFont: function(X) {
        var S = cc.LabelTTF._fontStyleRE.exec(X);
        S && (this._fontSize = parseInt(S[1]), this._fontName = S[2], this._fontStyleStr = X, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0);
    },
    _drawTTFInCanvas: function(X) {
        if (X) {
            var S = this._strokeShadowOffsetX,
                P = this._strokeShadowOffsetY,
                O = H8m.p63(this._contentSize.height, P),
                Z = this._vAlignment,
                Y = this._hAlignment,
                T = this._fontClientHeight,
                R = this._strokeSize;
            X.setTransform(1, 0, 0, 1, 0 + H8m.Y63(0.5, S), O + H8m.T63(0.5, P));
            H8m.R63(X.font, this._fontStyleStr) && (X.font = this._fontStyleStr);
            X.fillStyle = this._fillColorStr;
            var E = P = 0,
                V = this._strokeEnabled;
            V && (X.lineWidth = H8m.M63(2, R), X.strokeStyle = this._strokeColorStr);
            this._shadowEnabled && (R = this._shadowOffset, X.shadowColor = this._shadowColorStr, X.shadowOffsetX = R.x, X.shadowOffsetY = -R.y, X.shadowBlur = this._shadowBlur);
            X.textBaseline = cc.LabelTTF._textBaseline[Z];
            X.textAlign = cc.LabelTTF._textAlign[Y];
            S = H8m.V63(this._contentSize.width, S);
            P = H8m.s63(Y, cc.TEXT_ALIGNMENT_RIGHT) ? P + S : H8m.U63(Y, cc.TEXT_ALIGNMENT_CENTER) ? P + H8m.b63(S, 2) : P + 0;
            if (this._isMultiLine)
                for (Y = this._strings.length, H8m.F63(Z, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) ? E = T + O - H8m.k23(T, Y) : H8m.L23(Z, cc.VERTICAL_TEXT_ALIGNMENT_CENTER) && (E = H8m.i23(T, 2) + H8m.S23((O - T * Y), 2)), Z = 0; H8m.P23(Z, Y); Z++)
                    S = this._strings[Z], R = -O + T * Z + E, V && X.strokeText(S, P, R), X.fillText(S, P, R);
            else
                H8m.a23(Z, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) && (E = H8m.O23(Z, cc.VERTICAL_TEXT_ALIGNMENT_TOP) ? H8m.B23(E, O) : H8m.Z23(E, 0.5 * O)), V && X.strokeText(this._string, P, E), X.fillText(this._string, P, E);
        }
    },
    _getLabelContext: function() {
        if (this._labelContext)
            return this._labelContext;
        if (!this._labelCanvas) {
            var X = w6b0K[I0K]['createElement']("canvas"),
                S = new cc.Texture2D;
            S.initWithElement(X);
            this.texture = S;
            this._labelCanvas = X;
        }
        return this._labelContext = this._labelCanvas.getContext("2d");
    },
    _updateTTF: function() {
        var X = this._dimensions.width,
            S,
            P,
            O = this._lineWidths;
        O.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (H8m.J23(0, X)) {
            var Z = this._string;
            this._strings = [];
            S = 0;
            for (P = this._string.length; H8m.n23(S, P);) {
                var Y = this._checkNextline(Z.substr(S), X),
                    T = Z.substr(S, Y);
                this._strings.push(T);
                S += Y;
            }
        } else
            for (this._strings = this._string.split("\n"), S = 0, P = this._strings.length; H8m.G23(S, P); S++)
                O.push(this._measure(this._strings[S]));
        H8m.W23(0, this._strings.length) && (this._isMultiLine = !0);
        P = S = 0;
        this._strokeEnabled && (S = P = H8m.v23(2, this._strokeSize));
        this._shadowEnabled && (Z = this._shadowOffset, S += H8m.u23(2, Math.abs(Z.x)), P += H8m.H23(2, Math.abs(Z.y)));
        X = H8m.f23(0, X) ? this._isMultiLine ? cc.size(H8m.I23(0, Math.max.apply(Math, O) + S), H8m.g9a(0, this._fontClientHeight * this._strings.length + P)) : cc.size(H8m.K9a(0, this._measure(this._string) + S), H8m.d9a(0, this._fontClientHeight + P)) : H8m.t9a(0, this._dimensions.height) ? this._isMultiLine ? cc.size(H8m.w9a(0, X + S), H8m.e9a(0, this._fontClientHeight * this._strings.length + P)) : cc.size(H8m.Q9a(0, X + S), H8m.r9a(0, this._fontClientHeight + P)) : cc.size(H8m.N9a(0, X + S), H8m.m9a(0, this._dimensions.height + P));
        this.setContentSize(X);
        this._strokeShadowOffsetX = S;
        this._strokeShadowOffsetY = P;
        O = this._anchorPoint;
        this._anchorPointInPoints.x = H8m.A9a(0.5, S) + H8m.E9a((X.width - S), O.x);
        this._anchorPointInPoints.y = H8m.C9a(0.5, P) + H8m.h9a((X.height - P), O.y);
    },
    getContentSize: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this);
    },
    _getWidth: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this);
    },
    _getHeight: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this);
    },
    _updateTexture: function() {
        var X = this._getLabelContext(),
            S = this._labelCanvas,
            P = this._contentSize;
        if (H8m.y9a(0, this._string.length))
            return S.width = 1, S.height = P.height, this.setTextureRect(cc.rect(0, 0, 1, P.height)), !0;
        X.font = this._fontStyleStr;
        this._updateTTF();
        var O = P.width,
            P = P.height,
            Z = H8m.q9a(S.width, O) && H8m.l9a(S.height, P);
        S.width = O;
        S.height = P;
        Z && X.clearRect(0, 0, O, P);
        this._drawTTFInCanvas(X);
        this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, O, P));
        return !0;
    },
    visit: function(X) {
        this._string && H8m.X1a("", this._string) && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, X || cc._renderContext));
    },
    draw: null,
    _drawForWebGL: function(X) {
        if (this._string && H8m.D1a("", this._string)) {
            X = X || cc._renderContext;
            var S = this._texture;
            S && S._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(S), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), X.bindBuffer(X.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (X.bufferData(X.ARRAY_BUFFER, this._quad.arrayBuffer, X.STATIC_DRAW), this._quadDirty = !1), X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, X.FLOAT, !1, 24, 0), X.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, X.FLOAT, !1, 24, 16), X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, X.UNSIGNED_BYTE, !0, 24, 12), X.drawArrays(X.TRIANGLE_STRIP, 0, 4));
            if (H8m.c1a(1, cc.SPRITE_DEBUG_DRAW))
                X = this._quad, X = [cc.p(X.tl.vertices.x, X.tl.vertices.y), cc.p(X.bl.vertices.x, X.bl.vertices.y), cc.p(X.br.vertices.x, X.br.vertices.y), cc.p(X.tr.vertices.x, X.tr.vertices.y)], cc._drawingUtil.drawPoly(X, 4, !0);
            else if (H8m.z1a(2, cc.SPRITE_DEBUG_DRAW)) {
                X = this.getTextureRect()._size;
                var S = this.offsetX,
                    P = this.offsetY;
                X = [cc.p(S, P), cc.p(S + X.width, P), cc.p(S + X.width, P + X.height), cc.p(S, P + X.height)];
                cc._drawingUtil.drawPoly(X, 4, !0);
            }
            cc.g_NumberOfDraws++;
        }
    },
    _setTextureRectForCanvas: function(X, S, P) {
        this._rectRotated = S || !1;
        this.setContentSize(P || X);
        this.setVertexRect(X);
        S = this._textureRect_Canvas;
        S.x = X.x;
        S.y = X.y;
        S.width = X.width;
        S.height = X.height;
        S.validRect = !(H8m.j1a(0, S.width) || H8m.x1a(0, S.height) || H8m.o1a(0, S.x) || H8m.p1a(0, S.y));
        X = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (X.x = -X.x);
        this._flippedY && (X.y = -X.y);
        this._offsetPosition.x = X.x + H8m.Y1a((this._contentSize.width - this._rect.width), 2);
        this._offsetPosition.y = X.y + H8m.T1a((this._contentSize.height - this._rect.height), 2);
        this._batchNode && (this.dirty = !0);
    },
    _setTextureCoords: function(X) {
        var S = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (S) {
            var P = S.pixelsWidth,
                O = S.pixelsHeight,
                Z,
                Y = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (S = H8m.R1a((2 * X.x + 1), (2 * P)), P = S + H8m.M1a((2 * X.height - 2), (2 * P)), Z = H8m.V1a((2 * X.y + 1), (2 * O)), X = Z + H8m.s1a((2 * X.width - 2), (2 * O))) : (S = H8m.U1a(X.x, P), P = H8m.b1a((X.x + X.height), P), Z = H8m.F1a(X.y, O), X = H8m.k8a((X.y + X.width), O)), this._flippedX && (O = Z, Z = X, X = O), this._flippedY && (O = S, S = P, P = O), Y.bl.texCoords.u = S, Y.bl.texCoords.v = Z, Y.br.texCoords.u = S, Y.br.texCoords.v = X, Y.tl.texCoords.u = P, Y.tl.texCoords.v = Z, Y.tr.texCoords.u = P, Y.tr.texCoords.v = X) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (S = H8m.L8a((2 * X.x + 1), (2 * P)), P = S + H8m.i8a((2 * X.width - 2), (2 * P)), Z = H8m.S8a((2 * X.y + 1), (2 * O)), X = Z + H8m.P8a((2 * X.height - 2), (2 * O))) : (S = H8m.a8a(X.x, P), P = H8m.O8a((X.x + X.width), P), Z = H8m.B8a(X.y, O), X = H8m.Z8a((X.y + X.height), O)), this._flippedX && (O = S, S = P, P = O), this._flippedY && (O = Z, Z = X, X = O), Y.bl.texCoords.u = S, Y.bl.texCoords.v = X, Y.br.texCoords.u = P, Y.br.texCoords.v = X, Y.tl.texCoords.u = S, Y.tl.texCoords.v = Z, Y.tr.texCoords.u = P, Y.tr.texCoords.v = Z);
            this._quadDirty = !0;
        }
    }
});
w6b0K[q0K]._p = cc.LabelTTF.prototype;
H8m.J8a(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.setColor = cc.Sprite.prototype.setColor, _p._setColorsString = _p._setColorsStringForWebGL, _p.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor, _p.setOpacity = cc.Sprite.prototype.setOpacity, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = _p._initWithStringAndTextDefinitionForWebGL, _p.setFontFillColor = _p._setFontFillColorForWebGL, _p.draw = _p._drawForWebGL, _p.setTextureRect = cc.Sprite.prototype._setTextureRectForWebGL) : (_p.setColor = _p._setColorForCanvas, _p._setColorsString = _p._setColorsStringForCanvas, _p.updateDisplayedColor = _p._updateDisplayedColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.updateDisplayedOpacity = _p._updateDisplayedOpacityForCanvas, _p.initWithStringAndTextDefinition = _p._initWithStringAndTextDefinitionForCanvas, _p.setFontFillColor = _p._setFontFillColorForCanvas, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = _p._setTextureRectForCanvas);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.u6P, _p.getString, _p.setString);
cc.defineGetterSetter(_p, H8m.c1P, _p.getHorizontalAlignment, _p.setHorizontalAlignment);
cc.defineGetterSetter(_p, H8m.i7P, _p.getVerticalAlignment, _p.setVerticalAlignment);
cc.defineGetterSetter(_p, H8m.e3P, _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, H8m.e4K, _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, H8m.E5P, _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, H8m.T6P, _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, H8m.C9i, _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, H8m.i9K, _p._getFillStyle, _p.setFontFillColor);
cc.defineGetterSetter(_p, H8m.m1S, _p._getStrokeStyle, _p._setStrokeStyle);
cc.defineGetterSetter(_p, H8m.y1K, _p._getLineWidth, _p._setLineWidth);
cc.defineGetterSetter(_p, H8m.H1P, _p._getShadowOffsetX, _p._setShadowOffsetX);
cc.defineGetterSetter(_p, H8m.K8P, _p._getShadowOffsetY, _p._setShadowOffsetY);
cc.defineGetterSetter(_p, H8m.d6P, _p._getShadowOpacity, _p._setShadowOpacity);
cc.defineGetterSetter(_p, H8m.t8i, _p._getShadowBlur, _p._setShadowBlur);
delete w6b0K[q0K]._p;
H8m.r6();
H8m.Z6();
H8m.Y6(/(.+?)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/);
H8m.J6(/(.*)([\s\n\r\-\/\\\:]|[\u4E00-\u9FA5]|[\uFE30-\uFFA0])/);
H8m.m6(/[\s\-\/\\\:]/);
H8m.R6(/^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/);
cc.LabelTTF.create = function(X, S, P, O, Z, Y) {
    var T = new cc.LabelTTF;
    return S && H8m.n8a(S, cc.FontDefinition) && T.initWithStringAndTextDefinition(X, S) || T.initWithString(X, S, P, O, Z, Y) ? T : H8m.H6P;
};
H8m.G6();
cc.LabelTTF.__labelHeightDiv = w6b0K[I0K]['createElement'](H8m.E3H);
H8m.M6(H8m.o8S);
H8m.W6(H8m.w2i);
H8m.C6(H8m.I2H);
H8m.s6(H8m.I2H);
H8m.u6(H8m.t2S);
w6b0K[I0K][h5K]['appendChild'](cc.LabelTTF.__labelHeightDiv);
cc.LabelTTF.__getFontHeightByDiv = function(X, S) {
    var P = "ajghl~!",
        O = cc.LabelTTF.__fontHeightCache[X + H8m.y7P + S];
    if (H8m.G8a(H8m.U7H, O))
        return O;
    var Z = cc.LabelTTF.__labelHeightDiv;
    Z.innerHTML = P;
    Z.style.fontFamily = X;
    Z.style.fontSize = S + H8m.G1i;
    O = Z.clientHeight;
    cc.LabelTTF.__fontHeightCache[X + H8m.y7P + S] = O;
    Z.innerHTML = H8m.u4S;
    return O;
};
cc.LabelTTF.__fontHeightCache = {};
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null;
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(X, S) {
        for (var P = 0; H8m.W8a(P, X.length); P++)
            if (H8m.v8a(S, X[P].target))
                return X[P];
        return null;
    },
    ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1;
    },
    addAction: function(X, S, P) {
        if (!X)
            throw "cc.ActionManager.addAction(): action must be non-null";
        if (!S)
            throw "cc.ActionManager.addAction(): action must be non-null";
        var O = this._hashTargets[S.__instanceId];
        O || (O = new cc.HashElement, O.paused = P, O.target = S, this._hashTargets[S.__instanceId] = O, this._arrayTargets.push(O));
        this._actionAllocWithHashElement(O);
        O.actions.push(X);
        X.startWithTarget(S);
    },
    removeAllActions: function() {
        for (var X = this._arrayTargets, S = 0; H8m.u8a(S, X.length); S++) {
            var P = X[S];
            P && this.removeAllActionsFromTarget(P.target, !0);
        }
    },
    removeAllActionsFromTarget: function(X, S) {
        if (H8m.H8a(null, X)) {
            var P = this._hashTargets[X.__instanceId];
            P && (-1 === P.actions.indexOf(P.currentAction) || P.currentActionSalvaged || (P.currentActionSalvaged = !0), P.actions.length = 0, H8m.f8a(this._currentTarget, P) || S ? this._deleteHashElement(P) : this._currentTargetSalvaged = !0);
        }
    },
    removeAction: function(X) {
        if (H8m.I8a(null, X)) {
            var S = X.getOriginalTarget();
            if (S = this._hashTargets[S.__instanceId])
                for (var P = 0; H8m.g4a(P, S.actions.length); P++) {
                    if (H8m.K4a(S.actions[P], X)) {
                        S.actions.splice(P, 1);
                        break;
                    }
                }
            else
                cc.log("cocos2d: removeAction: Target not found");
        }
    },
    removeActionByTag: function(X, S) {
        H8m.d4a(X, cc.ACTION_TAG_INVALID) && cc.log("cc.ActionManager.removeActionByTag(): an invalid tag");
        if (!S)
            throw "cc.ActionManager.removeActionByTag(): target must be non-null";
        var P = this._hashTargets[S.__instanceId];
        if (P)
            for (var O = P.actions.length, Z = 0; H8m.t4a(Z, O); ++Z) {
                var Y = P.actions[Z];
                if (Y && H8m.w4a(Y.getTag(), X) && H8m.e4a(Y.getOriginalTarget(), S)) {
                    this._removeActionAtIndex(Z, P);
                    break;
                }
            }
    },
    getActionByTag: function(X, S) {
        H8m.Q4a(X, cc.ACTION_TAG_INVALID) && cc.log("cc.ActionManager.getActionByTag(): an invalid tag");
        var P = this._hashTargets[S.__instanceId];
        if (P) {
            if (H8m.r4a(null, P.actions))
                for (var O = 0; H8m.N4a(O, P.actions.length); ++O) {
                    var Z = P.actions[O];
                    if (Z && H8m.m4a(Z.getTag(), X))
                        return Z;
                }
            cc.log("cocos2d : getActionByTag(tag \x3d" + X + "): Action not found");
        }
        return null;
    },
    numberOfRunningActionsInTarget: function(X) {
        return (X = this._hashTargets[X.__instanceId]) ? X.actions ? X.actions.length : 0 : 0;
    },
    pauseTarget: function(X) {
        if (X = this._hashTargets[X.__instanceId])
            X.paused = !0;
    },
    resumeTarget: function(X) {
        if (X = this._hashTargets[X.__instanceId])
            X.paused = !1;
    },
    pauseAllRunningActions: function() {
        for (var X = [], S = this._arrayTargets, P = 0; H8m.A4a(P, S.length); P++) {
            var O = S[P];
            O && !O.paused && (O.paused = !0, X.push(O.target));
        }
        return X;
    },
    resumeTargets: function(X) {
        if (X)
            for (var S = 0; H8m.E4a(S, X.length); S++)
                X[S] && this.resumeTarget(X[S]);
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this);
    },
    _removeActionAtIndex: function(X, S) {
        H8m.C4a(S.actions[X], S.currentAction) || S.currentActionSalvaged || (S.currentActionSalvaged = !0);
        S.actions.splice(X, 1);
        H8m.h4a(S.actionIndex, X) && S.actionIndex--;
        H8m.y4a(0, S.actions.length) && (H8m.q4a(this._currentTarget, S) ? this._currentTargetSalvaged = !0 : this._deleteHashElement(S));
    },
    _deleteHashElement: function(X) {
        X && (delete this._hashTargets[X.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, X), X.actions = null, X.target = null);
    },
    _actionAllocWithHashElement: function(X) {
        H8m.l4a(null, X.actions) && (X.actions = []);
    },
    update: function(X) {
        for (var S = this._arrayTargets, P, O = 0; H8m.X7a(O, S.length); O++) {
            P = this._currentTarget = S[O];
            if (!P.paused)
                for (P.actionIndex = 0; H8m.D7a(P.actionIndex, P.actions.length); P.actionIndex++)
                    if (P.currentAction = P.actions[P.actionIndex], P.currentAction) {
                        P.currentActionSalvaged = !1;
                        P.currentAction.step(X);
                        if (P.currentActionSalvaged)
                            P.currentAction = null;
                        else if (P.currentAction.isDone()) {
                            P.currentAction.stop();
                            var Z = P.currentAction;
                            P.currentAction = null;
                            this.removeAction(Z);
                        }
                        P.currentAction = null;
                    }
            this._currentTargetSalvaged && H8m.c7a(0, P.actions.length) && this._deleteHashElement(P);
        }
    }
});
H8m.y6(Number);
H8m.b6(Number);
H8m.F6(Number);
H8m.I6(H8m.U7H);
H8m.X2(H8m.h7H);
H8m.L2(H8m.W1S);
H8m.K2(H8m.M4S);
H8m.c2(H8m.C1P);
H8m.S2(H8m.W2i);
cc.kmSQR = function(X) {
    return H8m.z7a(X, X);
};
cc.kmDegreesToRadians = function(X) {
    return H8m.j7a(X, cc.kmPIOver180);
};
cc.kmRadiansToDegrees = function(X) {
    return H8m.x7a(X, cc.kmPIUnder180);
};
cc.kmMin = function(X, S) {
    return H8m.o7a(X, S) ? X : S;
};
cc.kmMax = function(X, S) {
    return H8m.p7a(X, S) ? X : S;
};
cc.kmAlmostEqual = function(X, S) {
    return H8m.Y7a(X + cc.kmEpsilon, S) && H8m.T7a(X - cc.kmEpsilon, S);
};
cc.kmVec2 = function(X, S) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
};
cc.kmVec2Fill = function(X, S, P) {
    X.x = S;
    X.y = P;
    return X;
};
cc.kmVec2Length = function(X) {
    return Math.sqrt(cc.kmSQR(X.x) + cc.kmSQR(X.y));
};
cc.kmVec2LengthSq = function(X) {
    return cc.kmSQR(X.x) + cc.kmSQR(X.y);
};
cc.kmVec2Normalize = function(X, S) {
    var P = H8m.R7a(H8m.h7H, cc.kmVec2Length(S)),
        O = new cc.kmVec2;
    O.x = H8m.M7a(S.x, P);
    O.y = H8m.V7a(S.y, P);
    X.x = O.x;
    X.y = O.y;
    return X;
};
cc.kmVec2Add = function(X, S, P) {
    X.x = S.x + P.x;
    X.y = S.y + P.y;
    return X;
};
cc.kmVec2Dot = function(X, S) {
    return H8m.s7a(X.x, S.x) + H8m.U7a(X.y, S.y);
};
cc.kmVec2Subtract = function(X, S, P) {
    X.x = H8m.b7a(S.x, P.x);
    X.y = H8m.F7a(S.y, P.y);
    return X;
};
cc.kmVec2Transform = function(X, S, P) {
    var O = new cc.kmVec2;
    O.x = H8m.k0a(S.x, P.mat[H8m.U7H]) + H8m.L0a(S.y, P.mat[H8m.v7H]) + P.mat[H8m.H7H];
    O.y = H8m.i0a(S.x, P.mat[H8m.h7H]) + H8m.S0a(S.y, P.mat[H8m.q7H]) + P.mat[H8m.y7H];
    X.x = O.x;
    X.y = O.y;
    return X;
};
cc.kmVec2TransformCoord = function(X, S, P) {
    return H8m.H6P;
};
cc.kmVec2Scale = function(X, S, P) {
    X.x = H8m.P0a(S.x, P);
    X.y = H8m.a0a(S.y, P);
    return X;
};
cc.kmVec2AreEqual = function(X, S) {
    return H8m.O0a(X.x, S.x + cc.kmEpsilon) && H8m.B0a(X.x, S.x - cc.kmEpsilon) && H8m.Z0a(X.y, S.y + cc.kmEpsilon) && H8m.J0a(X.y, S.y - cc.kmEpsilon);
};
cc.kmVec3 = function(X, S, P) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.z = P || H8m.U7H;
};
cc.kmVec3Fill = function(X, S, P, O) {
    if (!X)
        return new cc.kmVec3(S, P, O);
    X.x = S;
    X.y = P;
    X.z = O;
    return X;
};
cc.kmVec3Length = function(X) {
    return Math.sqrt(cc.kmSQR(X.x) + cc.kmSQR(X.y) + cc.kmSQR(X.z));
};
cc.kmVec3LengthSq = function(X) {
    return cc.kmSQR(X.x) + cc.kmSQR(X.y) + cc.kmSQR(X.z);
};
cc.kmVec3Normalize = function(X, S) {
    var P = H8m.n0a(H8m.h7H, cc.kmVec3Length(S));
    X.x = H8m.G0a(S.x, P);
    X.y = H8m.W0a(S.y, P);
    X.z = H8m.v0a(S.z, P);
    return X;
};
cc.kmVec3Cross = function(X, S, P) {
    X.x = H8m.u0a(S.y * P.z, S.z * P.y);
    X.y = H8m.H0a(S.z * P.x, S.x * P.z);
    X.z = H8m.f0a(S.x * P.y, S.y * P.x);
    return X;
};
cc.kmVec3Dot = function(X, S) {
    return H8m.I0a(X.x, S.x) + H8m.g3a(X.y, S.y) + H8m.K3a(X.z, S.z);
};
cc.kmVec3Add = function(X, S, P) {
    X.x = S.x + P.x;
    X.y = S.y + P.y;
    X.z = S.z + P.z;
    return X;
};
cc.kmVec3Subtract = function(X, S, P) {
    X.x = H8m.d3a(S.x, P.x);
    X.y = H8m.t3a(S.y, P.y);
    X.z = H8m.w3a(S.z, P.z);
    return X;
};
cc.kmVec3Transform = function(X, S, P) {
    X.x = H8m.e3a(S.x, P.mat[H8m.U7H]) + H8m.Q3a(S.y, P.mat[H8m.q7H]) + H8m.r3a(S.z, P.mat[H8m.F7H]) + P.mat[H8m.l9i];
    X.y = H8m.N3a(S.x, P.mat[H8m.h7H]) + H8m.m3a(S.y, P.mat[H8m.b7H]) + H8m.A3a(S.z, P.mat[H8m.f7H]) + P.mat[H8m.b9i];
    X.z = H8m.E3a(S.x, P.mat[H8m.s7H]) + H8m.C3a(S.y, P.mat[H8m.H7H]) + H8m.h3a(S.z, P.mat[H8m.e1i]) + P.mat[H8m.f9i];
    return X;
};
cc.kmVec3TransformNormal = function(X, S, P) {
    X.x = H8m.y3a(S.x, P.mat[H8m.U7H]) + H8m.q3a(S.y, P.mat[H8m.q7H]) + H8m.l3a(S.z, P.mat[H8m.F7H]);
    X.y = H8m.X5a(S.x, P.mat[H8m.h7H]) + H8m.D5a(S.y, P.mat[H8m.b7H]) + H8m.c5a(S.z, P.mat[H8m.f7H]);
    X.z = H8m.z5a(S.x, P.mat[H8m.s7H]) + H8m.j5a(S.y, P.mat[H8m.H7H]) + H8m.x5a(S.z, P.mat[H8m.e1i]);
    return X;
};
cc.kmVec3TransformCoord = function(X, S, P) {
    var O = new cc.kmVec4,
        Z = new cc.kmVec4;
    cc.kmVec4Fill(Z, S.x, S.y, S.z, H8m.h7H);
    cc.kmVec4Transform(O, Z, P);
    X.x = H8m.o5a(O.x, O.w);
    X.y = H8m.p5a(O.y, O.w);
    X.z = H8m.Y5a(O.z, O.w);
    return X;
};
cc.kmVec3Scale = function(X, S, P) {
    X.x = H8m.T5a(S.x, P);
    X.y = H8m.R5a(S.y, P);
    X.z = H8m.M5a(S.z, P);
    return X;
};
cc.kmVec3AreEqual = function(X, S) {
    return H8m.V5a(X.x, S.x + cc.kmEpsilon) && H8m.s5a(X.x, S.x - cc.kmEpsilon) && H8m.U5a(X.y, S.y + cc.kmEpsilon) && H8m.b5a(X.y, S.y - cc.kmEpsilon) && H8m.F5a(X.z, S.z + cc.kmEpsilon) && H8m.k6a(X.z, S.z - cc.kmEpsilon) ? H8m.h7H : H8m.U7H;
};
cc.kmVec3InverseTransform = function(X, S, P) {
    S = new cc.kmVec3(H8m.L6a(S.x, P.mat[H8m.l9i]), H8m.i6a(S.y, P.mat[H8m.b9i]), H8m.S6a(S.z, P.mat[H8m.f9i]));
    X.x = H8m.P6a(S.x, P.mat[H8m.U7H]) + H8m.a6a(S.y, P.mat[H8m.h7H]) + H8m.O6a(S.z, P.mat[H8m.s7H]);
    X.y = H8m.B6a(S.x, P.mat[H8m.q7H]) + H8m.Z6a(S.y, P.mat[H8m.b7H]) + H8m.J6a(S.z, P.mat[H8m.H7H]);
    X.z = H8m.n6a(S.x, P.mat[H8m.F7H]) + H8m.G6a(S.y, P.mat[H8m.f7H]) + H8m.W6a(S.z, P.mat[H8m.e1i]);
    return X;
};
cc.kmVec3InverseTransformNormal = function(X, S, P) {
    X.x = H8m.v6a(S.x, P.mat[H8m.U7H]) + H8m.u6a(S.y, P.mat[H8m.h7H]) + H8m.H6a(S.z, P.mat[H8m.s7H]);
    X.y = H8m.f6a(S.x, P.mat[H8m.q7H]) + H8m.I6a(S.y, P.mat[H8m.b7H]) + H8m.g2a(S.z, P.mat[H8m.H7H]);
    X.z = H8m.K2a(S.x, P.mat[H8m.F7H]) + H8m.d2a(S.y, P.mat[H8m.f7H]) + H8m.t2a(S.z, P.mat[H8m.e1i]);
    return X;
};
cc.kmVec3Assign = function(X, S) {
    if (H8m.w2a(X, S))
        return X;
    X.x = S.x;
    X.y = S.y;
    X.z = S.z;
    return X;
};
cc.kmVec3Zero = function(X) {
    X.x = H8m.U7H;
    X.y = H8m.U7H;
    X.z = H8m.U7H;
    return X;
};
cc.kmVec3ToTypeArray = function(X) {
    if (!X)
        return H8m.H6P;
    var S = new Float32Array(H8m.v7H);
    S[H8m.U7H] = X.x;
    S[H8m.h7H] = X.y;
    S[H8m.s7H] = X.z;
    return S;
};
cc.kmVec4 = function(X, S, P, O) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.z = P || H8m.U7H;
    this.w = O || H8m.U7H;
};
cc.kmVec4Fill = function(X, S, P, O, Z) {
    X.x = S;
    X.y = P;
    X.z = O;
    X.w = Z;
    return X;
};
cc.kmVec4Add = function(X, S, P) {
    X.x = S.x + P.x;
    X.y = S.y + P.y;
    X.z = S.z + P.z;
    X.w = S.w + P.w;
    return X;
};
cc.kmVec4Dot = function(X, S) {
    return H8m.e2a(X.x, S.x) + H8m.Q2a(X.y, S.y) + H8m.r2a(X.z, S.z) + H8m.N2a(X.w, S.w);
};
cc.kmVec4Length = function(X) {
    return Math.sqrt(cc.kmSQR(X.x) + cc.kmSQR(X.y) + cc.kmSQR(X.z) + cc.kmSQR(X.w));
};
cc.kmVec4LengthSq = function(X) {
    return cc.kmSQR(X.x) + cc.kmSQR(X.y) + cc.kmSQR(X.z) + cc.kmSQR(X.w);
};
cc.kmVec4Lerp = function(X, S, P, O) {
    return X;
};
cc.kmVec4Normalize = function(X, S) {
    var P = H8m.m2a(H8m.h7H, cc.kmVec4Length(S));
    X.x *= P;
    X.y *= P;
    X.z *= P;
    X.w *= P;
    return X;
};
cc.kmVec4Scale = function(X, S, P) {
    cc.kmVec4Normalize(X, S);
    X.x *= P;
    X.y *= P;
    X.z *= P;
    X.w *= P;
    return X;
};
cc.kmVec4Subtract = function(X, S, P) {
    X.x = H8m.A2a(S.x, P.x);
    X.y = H8m.E2a(S.y, P.y);
    X.z = H8m.C2a(S.z, P.z);
    X.w = H8m.h2a(S.w, P.w);
    return X;
};
cc.kmVec4Transform = function(X, S, P) {
    X.x = H8m.y2a(S.x, P.mat[H8m.U7H]) + H8m.q2a(S.y, P.mat[H8m.q7H]) + H8m.l2a(S.z, P.mat[H8m.F7H]) + H8m.X9L(S.w, P.mat[H8m.l9i]);
    X.y = H8m.D9L(S.x, P.mat[H8m.h7H]) + H8m.c9L(S.y, P.mat[H8m.b7H]) + H8m.z9L(S.z, P.mat[H8m.f7H]) + H8m.j9L(S.w, P.mat[H8m.b9i]);
    X.z = H8m.x9L(S.x, P.mat[H8m.s7H]) + H8m.o9L(S.y, P.mat[H8m.H7H]) + H8m.p9L(S.z, P.mat[H8m.e1i]) + H8m.Y9L(S.w, P.mat[H8m.f9i]);
    X.w = H8m.T9L(S.x, P.mat[H8m.v7H]) + H8m.R9L(S.y, P.mat[H8m.y7H]) + H8m.M9L(S.z, P.mat[H8m.F9i]) + H8m.V9L(S.w, P.mat[H8m.u9i]);
    return X;
};
cc.kmVec4TransformArray = function(X, S, P, O, Z, Y) {
    for (var T = H8m.U7H; H8m.s9L(T, Y);)
        cc.kmVec4Transform(X + H8m.U9L(T, S), P + H8m.b9L(T, O), Z), ++T;
    return X;
};
cc.kmVec4AreEqual = function(X, S) {
    return H8m.F9L(X.x, S.x + cc.kmEpsilon) && H8m.k1L(X.x, S.x - cc.kmEpsilon) && H8m.L1L(X.y, S.y + cc.kmEpsilon) && H8m.i1L(X.y, S.y - cc.kmEpsilon) && H8m.S1L(X.z, S.z + cc.kmEpsilon) && H8m.P1L(X.z, S.z - cc.kmEpsilon) && H8m.a1L(X.w, S.w + cc.kmEpsilon) && H8m.O1L(X.w, S.w - cc.kmEpsilon);
};
cc.kmVec4Assign = function(X, S) {
    var P = "destVec and srcVec are same object";
    if (H8m.B1L(X, S))
        return cc.log(P), X;
    X.x = S.x;
    X.y = S.y;
    X.z = S.z;
    X.w = S.w;
    return X;
};
cc.kmVec4ToTypeArray = function(X) {
    if (!X)
        return H8m.H6P;
    var S = new Float32Array(H8m.q7H);
    S[H8m.U7H] = X.x;
    S[H8m.h7H] = X.y;
    S[H8m.s7H] = X.z;
    S[H8m.v7H] = X.w;
    return S;
};
cc.kmRay2 = function(X, S) {
    this.start = X || new cc.kmVec2;
    this.start = X || new cc.kmVec2;
};
cc.kmRay2Fill = function(X, S, P, O, Z) {
    X.start.x = S;
    X.start.y = P;
    X.dir.x = O;
    X.dir.y = Z;
};
cc.kmRay2IntersectLineSegment = function(X, S, P, O) {
    var Z = X.start.x,
        Y = X.start.y,
        T = X.start.x + X.dir.x;
    X = X.start.y + X.dir.y;
    var R = S.x,
        E = S.y,
        V = P.x,
        U = P.y,
        k9 = H8m.Z1L((U - E) * (T - Z), (V - R) * (X - Y));
    if (k9 > -cc.kmEpsilon && H8m.J1L(k9, cc.kmEpsilon))
        return cc.KM_FALSE;
    E = H8m.n1L(((V - R) * (Y - E) - (U - E) * (Z - R)), k9);
    R = Z + H8m.G1L(E, (T - Z));
    E = Y + H8m.W1L(E, (X - Y));
    if (H8m.v1L(R, cc.kmMin(S.x, P.x) - cc.kmEpsilon) || H8m.u1L(R, cc.kmMax(S.x, P.x) + cc.kmEpsilon) || H8m.H1L(E, cc.kmMin(S.y, P.y) - cc.kmEpsilon) || H8m.f1L(E, cc.kmMax(S.y, P.y) + cc.kmEpsilon) || H8m.I1L(R, cc.kmMin(Z, T) - cc.kmEpsilon) || H8m.g8L(R, cc.kmMax(Z, T) + cc.kmEpsilon) || H8m.K8L(E, cc.kmMin(Y, X) - cc.kmEpsilon) || H8m.d8L(E, cc.kmMax(Y, X) + cc.kmEpsilon))
        return cc.KM_FALSE;
    O.x = R;
    O.y = E;
    return cc.KM_TRUE;
};
cc.calculate_line_normal = function(X, S, P) {
    var O = new cc.kmVec2;
    cc.kmVec2Subtract(O, S, X);
    P.x = -O.y;
    P.y = O.x;
    cc.kmVec2Normalize(P, P);
};
cc.kmRay2IntersectTriangle = function(X, S, P, O, Z, Y) {
    var T = new cc.kmVec2,
        R = new cc.kmVec2,
        E = new cc.kmVec2,
        V = H8m.H5P,
        U = cc.KM_FALSE,
        k9;
    cc.kmRay2IntersectLineSegment(X, S, P, T) && (k9 = new cc.kmVec2, U = cc.KM_TRUE, k9 = cc.kmVec2Length(cc.kmVec2Subtract(k9, T, X.start)), H8m.t8L(k9, V) && (R.x = T.x, R.y = T.y, V = k9, cc.calculate_line_normal(S, P, E)));
    cc.kmRay2IntersectLineSegment(X, P, O, T) && (k9 = new cc.kmVec2, U = cc.KM_TRUE, k9 = cc.kmVec2Length(cc.kmVec2Subtract(k9, T, X.start)), H8m.w8L(k9, V) && (R.x = T.x, R.y = T.y, V = k9, cc.calculate_line_normal(P, O, E)));
    cc.kmRay2IntersectLineSegment(X, O, S, T) && (k9 = new cc.kmVec2, U = cc.KM_TRUE, k9 = cc.kmVec2Length(cc.kmVec2Subtract(k9, T, X.start)), H8m.e8L(k9, V) && (R.x = T.x, R.y = T.y, cc.calculate_line_normal(O, S, E)));
    U && (Z.x = R.x, Z.y = R.y, Y && (Y.x = E.x, Y.y = E.y));
    return U;
};
cc.kmRay2IntersectCircle = function(X, S, P, O) {
    var Z = "cc.kmRay2IntersectCircle() has not been implemented.";
    cc.log(Z);
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
    this.mat = new Float32Array([H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H]);
};
cc.kmMat3Fill = function(X, S) {
    for (var P = H8m.U7H; H8m.Q8L(H8m.f7H, P); P++)
        X.mat[P] = S;
    return X;
};
cc.kmMat3Adjugate = function(X, S) {
    X.mat[H8m.U7H] = H8m.r8L(S.mat[H8m.q7H] * S.mat[H8m.F7H], S.mat[H8m.b7H] * S.mat[H8m.y7H]);
    X.mat[H8m.h7H] = H8m.N8L(S.mat[H8m.s7H] * S.mat[H8m.y7H], S.mat[H8m.h7H] * S.mat[H8m.F7H]);
    X.mat[H8m.s7H] = H8m.m8L(S.mat[H8m.h7H] * S.mat[H8m.b7H], S.mat[H8m.s7H] * S.mat[H8m.q7H]);
    X.mat[H8m.v7H] = H8m.A8L(S.mat[H8m.b7H] * S.mat[H8m.H7H], S.mat[H8m.v7H] * S.mat[H8m.F7H]);
    X.mat[H8m.q7H] = H8m.E8L(S.mat[H8m.U7H] * S.mat[H8m.F7H], S.mat[H8m.s7H] * S.mat[H8m.H7H]);
    X.mat[H8m.b7H] = H8m.C8L(S.mat[H8m.s7H] * S.mat[H8m.v7H], S.mat[H8m.U7H] * S.mat[H8m.b7H]);
    X.mat[H8m.H7H] = H8m.h8L(S.mat[H8m.v7H] * S.mat[H8m.y7H], S.mat[H8m.q7H] * S.mat[H8m.H7H]);
    X.mat[H8m.F7H] = H8m.y8L(S.mat[H8m.U7H] * S.mat[H8m.q7H], S.mat[H8m.h7H] * S.mat[H8m.v7H]);
    return X;
};
cc.kmMat3Identity = function(X) {
    X.mat[H8m.h7H] = X.mat[H8m.s7H] = X.mat[H8m.v7H] = X.mat[H8m.b7H] = X.mat[H8m.H7H] = X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.U7H] = X.mat[H8m.q7H] = X.mat[H8m.F7H] = H8m.h7H;
    return X;
};
cc.kmMat3Inverse = function(X, S, P) {
    var O = new cc.kmMat3;
    if (H8m.q8L(H8m.U7H, S))
        return H8m.H6P;
    S = H8m.l8L(H8m.h7H, S);
    cc.kmMat3Adjugate(O, P);
    cc.kmMat3ScalarMultiply(X, O, S);
    return X;
};
cc.kmMat3._identity = new Float32Array([H8m.h7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.h7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.h7H]);
cc.kmMat3IsIdentity = function(X) {
    for (var S = H8m.U7H; H8m.X4L(H8m.f7H, S); S++)
        if (H8m.D4L(cc.kmMat3._identity[S], X.mat[S]))
            return !H8m.h7H;
    return !H8m.U7H;
};
cc.kmMat3Transpose = function(X, S) {
    var P,
        O;
    for (P = H8m.U7H; H8m.c4L(H8m.v7H, P); ++P)
        for (O = H8m.U7H; H8m.z4L(H8m.v7H, O); ++O)
            X.mat[H8m.j4L(H8m.v7H, P) + O] = S.mat[H8m.x4L(H8m.v7H, O) + P];
    return X;
};
cc.kmMat3Determinant = function(X) {
    var S;
    S = H8m.o4L(X.mat[H8m.U7H], X.mat[H8m.q7H], X.mat[H8m.F7H]) + H8m.r4L(X.mat[H8m.h7H], X.mat[H8m.b7H], X.mat[H8m.H7H]) + H8m.J4L(X.mat[H8m.s7H], X.mat[H8m.v7H], X.mat[H8m.y7H]);
    return S -= H8m.R4L(X.mat[H8m.s7H], X.mat[H8m.q7H], X.mat[H8m.H7H]) + H8m.E4L(X.mat[H8m.U7H], X.mat[H8m.b7H], X.mat[H8m.y7H]) + H8m.v4L(X.mat[H8m.h7H], X.mat[H8m.v7H], X.mat[H8m.F7H]);
};
cc.kmMat3Multiply = function(X, S, P) {
    S = S.mat;
    P = P.mat;
    X.mat[H8m.U7H] = H8m.U4L(S[H8m.U7H], P[H8m.U7H]) + H8m.b4L(S[H8m.v7H], P[H8m.h7H]) + H8m.F4L(S[H8m.H7H], P[H8m.s7H]);
    X.mat[H8m.h7H] = H8m.k7L(S[H8m.h7H], P[H8m.U7H]) + H8m.L7L(S[H8m.q7H], P[H8m.h7H]) + H8m.i7L(S[H8m.y7H], P[H8m.s7H]);
    X.mat[H8m.s7H] = H8m.S7L(S[H8m.s7H], P[H8m.U7H]) + H8m.P7L(S[H8m.b7H], P[H8m.h7H]) + H8m.a7L(S[H8m.F7H], P[H8m.s7H]);
    X.mat[H8m.v7H] = H8m.O7L(S[H8m.U7H], P[H8m.v7H]) + H8m.B7L(S[H8m.v7H], P[H8m.q7H]) + H8m.Z7L(S[H8m.H7H], P[H8m.b7H]);
    X.mat[H8m.q7H] = H8m.J7L(S[H8m.h7H], P[H8m.v7H]) + H8m.n7L(S[H8m.q7H], P[H8m.q7H]) + H8m.G7L(S[H8m.y7H], P[H8m.b7H]);
    X.mat[H8m.b7H] = H8m.W7L(S[H8m.s7H], P[H8m.v7H]) + H8m.v7L(S[H8m.b7H], P[H8m.q7H]) + H8m.u7L(S[H8m.F7H], P[H8m.b7H]);
    X.mat[H8m.H7H] = H8m.H7L(S[H8m.U7H], P[H8m.H7H]) + H8m.f7L(S[H8m.v7H], P[H8m.y7H]) + H8m.I7L(S[H8m.H7H], P[H8m.F7H]);
    X.mat[H8m.y7H] = H8m.g0L(S[H8m.h7H], P[H8m.H7H]) + H8m.K0L(S[H8m.q7H], P[H8m.y7H]) + H8m.d0L(S[H8m.y7H], P[H8m.F7H]);
    X.mat[H8m.F7H] = H8m.t0L(S[H8m.s7H], P[H8m.H7H]) + H8m.w0L(S[H8m.b7H], P[H8m.y7H]) + H8m.e0L(S[H8m.F7H], P[H8m.F7H]);
    return X;
};
cc.kmMat3ScalarMultiply = function(X, S, P) {
    for (var O = H8m.U7H; H8m.Q0L(H8m.f7H, O); O++)
        X.mat[O] = H8m.r0L(S.mat[O], P);
    return X;
};
cc.kmMat3RotationAxisAngle = function(X, S, P) {
    var O = Math.cos(P);
    P = Math.sin(P);
    X.mat[H8m.U7H] = O + H8m.N0L(S.x, S.x, (H8m.h7H - O));
    X.mat[H8m.h7H] = H8m.n0L(S.z, P) + H8m.G0L(S.y, S.x, (H8m.h7H - O));
    X.mat[H8m.s7H] = -S.y * P + H8m.V0L(S.z, S.x, (H8m.h7H - O));
    X.mat[H8m.v7H] = -S.z * P + H8m.h0L(S.x, S.y, (H8m.h7H - O));
    X.mat[H8m.q7H] = O + H8m.H0L(S.y, S.y, (H8m.h7H - O));
    X.mat[H8m.b7H] = H8m.F0L(S.x, P) + H8m.k3L(S.z, S.y, (H8m.h7H - O));
    X.mat[H8m.H7H] = H8m.D3L(S.y, P) + H8m.c3L(S.x, S.z, (H8m.h7H - O));
    X.mat[H8m.y7H] = -S.x * P + H8m.t3L(S.y, S.z, (H8m.h7H - O));
    X.mat[H8m.F7H] = O + H8m.a3L(S.z, S.z, (H8m.h7H - O));
    return X;
};
cc.kmMat3Assign = function(X, S) {
    var P = "cc.kmMat3Assign(): pOut equals pIn";
    if (H8m.o3L(X, S))
        return cc.log(P), X;
    for (var O = H8m.U7H; H8m.p3L(H8m.f7H, O); O++)
        X.mat[O] = S.mat[O];
    return X;
};
cc.kmMat3AreEqual = function(X, S) {
    if (H8m.Y3L(X, S))
        return !H8m.U7H;
    for (var P = H8m.U7H; H8m.T3L(H8m.f7H, P); ++P)
        if (!(H8m.R3L(X.mat[P] + cc.kmEpsilon, S.mat[P]) && H8m.M3L(X.mat[P] - cc.kmEpsilon, S.mat[P])))
            return !H8m.h7H;
    return !H8m.U7H;
};
cc.kmMat3RotationX = function(X, S) {
    X.mat[H8m.U7H] = H8m.h7H;
    X.mat[H8m.h7H] = H8m.U7H;
    X.mat[H8m.s7H] = H8m.U7H;
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = Math.cos(S);
    X.mat[H8m.b7H] = Math.sin(S);
    X.mat[H8m.H7H] = H8m.U7H;
    X.mat[H8m.y7H] = -Math.sin(S);
    X.mat[H8m.F7H] = Math.cos(S);
    return X;
};
cc.kmMat3RotationY = function(X, S) {
    X.mat[H8m.U7H] = Math.cos(S);
    X.mat[H8m.h7H] = H8m.U7H;
    X.mat[H8m.s7H] = -Math.sin(S);
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = H8m.h7H;
    X.mat[H8m.b7H] = H8m.U7H;
    X.mat[H8m.H7H] = Math.sin(S);
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = Math.cos(S);
    return X;
};
cc.kmMat3RotationZ = function(X, S) {
    X.mat[H8m.U7H] = Math.cos(S);
    X.mat[H8m.h7H] = -Math.sin(S);
    X.mat[H8m.s7H] = H8m.U7H;
    X.mat[H8m.v7H] = Math.sin(S);
    X.mat[H8m.q7H] = Math.cos(S);
    X.mat[H8m.b7H] = H8m.U7H;
    X.mat[H8m.H7H] = H8m.U7H;
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.h7H;
    return X;
};
cc.kmMat3Rotation = function(X, S) {
    X.mat[H8m.U7H] = Math.cos(S);
    X.mat[H8m.h7H] = Math.sin(S);
    X.mat[H8m.s7H] = H8m.U7H;
    X.mat[H8m.v7H] = -Math.sin(S);
    X.mat[H8m.q7H] = Math.cos(S);
    X.mat[H8m.b7H] = H8m.U7H;
    X.mat[H8m.H7H] = H8m.U7H;
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.h7H;
    return X;
};
cc.kmMat3Scaling = function(X, S, P) {
    cc.kmMat3Identity(X);
    X.mat[H8m.U7H] = S;
    X.mat[H8m.q7H] = P;
    return X;
};
cc.kmMat3Translation = function(X, S, P) {
    cc.kmMat3Identity(X);
    X.mat[H8m.H7H] = S;
    X.mat[H8m.y7H] = P;
    return X;
};
cc.kmMat3RotationQuaternion = function(X, S) {
    if (!S || !X)
        return H8m.H6P;
    X.mat[H8m.U7H] = H8m.V3L(H8m.h7H, H8m.s7H * (S.y * S.y + S.z * S.z));
    X.mat[H8m.h7H] = H8m.s3L(H8m.s7H, (S.x * S.y - S.w * S.z));
    X.mat[H8m.s7H] = H8m.U3L(H8m.s7H, (S.x * S.z + S.w * S.y));
    X.mat[H8m.v7H] = H8m.b3L(H8m.s7H, (S.x * S.y + S.w * S.z));
    X.mat[H8m.q7H] = H8m.F3L(H8m.h7H, H8m.s7H * (S.x * S.x + S.z * S.z));
    X.mat[H8m.b7H] = H8m.k5L(H8m.s7H, (S.y * S.z - S.w * S.x));
    X.mat[H8m.H7H] = H8m.L5L(H8m.s7H, (S.x * S.z - S.w * S.y));
    X.mat[H8m.y7H] = H8m.i5L(H8m.s7H, (S.y * S.z + S.w * S.x));
    X.mat[H8m.F7H] = H8m.S5L(H8m.h7H, H8m.s7H * (S.x * S.x + S.y * S.y));
    return X;
};
cc.kmMat3RotationToAxisAngle = function(X, S, P) {
    cc.kmQuaternionRotationMatrix(void H8m.U7H, P);
    cc.kmQuaternionToAxisAngle(void H8m.U7H, X, S);
    return X;
};
cc.kmMat4 = function() {
    this.mat = new Float32Array([H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H]);
};
cc.kmMat4Fill = function(X, S) {
    X.mat[H8m.U7H] = X.mat[H8m.h7H] = X.mat[H8m.s7H] = X.mat[H8m.v7H] = X.mat[H8m.q7H] = X.mat[H8m.b7H] = X.mat[H8m.H7H] = X.mat[H8m.y7H] = X.mat[H8m.F7H] = X.mat[H8m.f7H] = X.mat[H8m.e1i] = X.mat[H8m.F9i] = X.mat[H8m.l9i] = X.mat[H8m.b9i] = X.mat[H8m.f9i] = X.mat[H8m.u9i] = S;
};
cc.kmMat4Identity = function(X) {
    X.mat[H8m.h7H] = X.mat[H8m.s7H] = X.mat[H8m.v7H] = X.mat[H8m.q7H] = X.mat[H8m.H7H] = X.mat[H8m.y7H] = X.mat[H8m.F7H] = X.mat[H8m.f7H] = X.mat[H8m.F9i] = X.mat[H8m.l9i] = X.mat[H8m.b9i] = X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.U7H] = X.mat[H8m.b7H] = X.mat[H8m.e1i] = X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4._get = function(X, S, P) {
    return X.mat[S + H8m.P5L(H8m.q7H, P)];
};
cc.kmMat4._set = function(X, S, P, O) {
    X.mat[S + H8m.a5L(H8m.q7H, P)] = O;
};
cc.kmMat4._swap = function(X, S, P, O, Z) {
    var Y = cc.kmMat4._get(X, S, P);
    cc.kmMat4._set(X, S, P, cc.kmMat4._get(X, O, Z));
    cc.kmMat4._set(X, O, Z, Y);
};
cc.kmMat4._gaussj = function(X, S) {
    var P,
        O = H8m.U7H,
        Z = H8m.U7H,
        Y,
        T,
        R,
        E = [H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H],
        V = [H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H],
        U = [H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H];
    for (P = H8m.U7H; H8m.O5L(H8m.q7H, P); P++) {
        for (Y = R = H8m.U7H; H8m.B5L(H8m.q7H, Y); Y++)
            if (H8m.Z5L(H8m.h7H, U[Y]))
                for (T = H8m.U7H; H8m.J5L(H8m.q7H, T); T++)
                    H8m.n5L(H8m.U7H, U[T]) && H8m.G5L(Math.abs(cc.kmMat4._get(X, Y, T)), R) && (R = Math.abs(cc.kmMat4._get(X, Y, T)), Z = Y, O = T);
        ++U[O];
        if (H8m.W5L(Z, O)) {
            for (Y = H8m.U7H; H8m.v5L(H8m.q7H, Y); Y++)
                cc.kmMat4._swap(X, Z, Y, O, Y);
            for (Y = H8m.U7H; H8m.u5L(H8m.q7H, Y); Y++)
                cc.kmMat4._swap(S, Z, Y, O, Y);
        }
        V[P] = Z;
        E[P] = O;
        if (H8m.H5L(H8m.U7H, cc.kmMat4._get(X, O, O)))
            return cc.KM_FALSE;
        T = H8m.f5L(H8m.h7H, cc.kmMat4._get(X, O, O));
        cc.kmMat4._set(X, O, O, H8m.h7H);
        for (Y = H8m.U7H; H8m.I5L(H8m.q7H, Y); Y++)
            cc.kmMat4._set(X, O, Y, H8m.g6L(cc.kmMat4._get(X, O, Y), T));
        for (Y = H8m.U7H; H8m.K6L(H8m.q7H, Y); Y++)
            cc.kmMat4._set(S, O, Y, H8m.d6L(cc.kmMat4._get(S, O, Y), T));
        for (T = H8m.U7H; H8m.t6L(H8m.q7H, T); T++)
            if (H8m.w6L(T, O)) {
                R = cc.kmMat4._get(X, T, O);
                cc.kmMat4._set(X, T, O, H8m.U7H);
                for (Y = H8m.U7H; H8m.e6L(H8m.q7H, Y); Y++)
                    cc.kmMat4._set(X, T, Y, H8m.Q6L(cc.kmMat4._get(X, T, Y), cc.kmMat4._get(X, O, Y) * R));
                for (Y = H8m.U7H; H8m.r6L(H8m.q7H, Y); Y++)
                    cc.kmMat4._set(S, T, Y, H8m.N6L(cc.kmMat4._get(X, T, Y), cc.kmMat4._get(S, O, Y) * R));
            }
    }
    for (Y = H8m.v7H; H8m.m6L(H8m.U7H, Y); Y--)
        if (H8m.A6L(V[Y], E[Y]))
            for (T = H8m.U7H; H8m.E6L(H8m.q7H, T); T++)
                cc.kmMat4._swap(X, T, V[Y], T, E[Y]);
    return cc.KM_TRUE;
};
cc.kmMat4._identity = new Float32Array([H8m.h7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.h7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.h7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H, H8m.h7H]);
cc.kmMat4Inverse = function(X, S) {
    var P = new cc.kmMat4,
        O = new cc.kmMat4;
    cc.kmMat4Assign(P, S);
    cc.kmMat4Identity(O);
    if (H8m.C6L(cc.kmMat4._gaussj(P, O), cc.KM_FALSE))
        return H8m.H6P;
    cc.kmMat4Assign(X, P);
    return X;
};
cc.kmMat4IsIdentity = function(X) {
    for (var S = H8m.U7H; H8m.h6L(H8m.U9i, S); S++)
        if (H8m.y6L(cc.kmMat4._identity[S], X.mat[S]))
            return !H8m.h7H;
    return !H8m.U7H;
};
cc.kmMat4Transpose = function(X, S) {
    var P,
        O,
        Z = X.mat,
        Y = S.mat;
    for (O = H8m.U7H; H8m.q6L(H8m.q7H, O); ++O)
        for (P = H8m.U7H; H8m.l6L(H8m.q7H, P); ++P)
            Z[H8m.X2L(H8m.q7H, O) + P] = Y[H8m.D2L(H8m.q7H, P) + O];
    return X;
};
cc.kmMat4Multiply = function(X, S, P) {
    var O = X.mat,
        Z = S.mat[H8m.U7H],
        Y = S.mat[H8m.h7H],
        T = S.mat[H8m.s7H],
        R = S.mat[H8m.v7H],
        E = S.mat[H8m.q7H],
        V = S.mat[H8m.b7H],
        U = S.mat[H8m.H7H],
        k9 = S.mat[H8m.y7H],
        L9 = S.mat[H8m.F7H],
        K9 = S.mat[H8m.f7H],
        c9 = S.mat[H8m.e1i],
        t9 = S.mat[H8m.F9i],
        S9 = S.mat[H8m.l9i],
        j9 = S.mat[H8m.b9i],
        a9 = S.mat[H8m.f9i];
    S = S.mat[H8m.u9i];
    var o9 = P.mat[H8m.U7H],
        T9 = P.mat[H8m.h7H],
        A9 = P.mat[H8m.s7H],
        F9 = P.mat[H8m.v7H],
        M9 = P.mat[H8m.q7H],
        s9 = P.mat[H8m.b7H],
        C9 = P.mat[H8m.H7H],
        n9 = P.mat[H8m.y7H],
        t1 = P.mat[H8m.F7H],
        o1 = P.mat[H8m.f7H],
        a1 = P.mat[H8m.e1i],
        j1 = P.mat[H8m.F9i],
        T1 = P.mat[H8m.l9i],
        e8 = P.mat[H8m.b9i],
        y1 = P.mat[H8m.f9i];
    P = P.mat[H8m.u9i];
    O[H8m.U7H] = H8m.c2L(o9, Z) + H8m.z2L(T9, E) + H8m.j2L(A9, L9) + H8m.x2L(F9, S9);
    O[H8m.h7H] = H8m.o2L(o9, Y) + H8m.p2L(T9, V) + H8m.Y2L(A9, K9) + H8m.T2L(F9, j9);
    O[H8m.s7H] = H8m.R2L(o9, T) + H8m.M2L(T9, U) + H8m.V2L(A9, c9) + H8m.s2L(F9, a9);
    O[H8m.v7H] = H8m.U2L(o9, R) + H8m.b2L(T9, k9) + H8m.F2L(A9, t9) + H8m.k9q(F9, S);
    O[H8m.q7H] = H8m.L9q(M9, Z) + H8m.i9q(s9, E) + H8m.S9q(C9, L9) + H8m.P9q(n9, S9);
    O[H8m.b7H] = H8m.a9q(M9, Y) + H8m.O9q(s9, V) + H8m.B9q(C9, K9) + H8m.Z9q(n9, j9);
    O[H8m.H7H] = H8m.J9q(M9, T) + H8m.n9q(s9, U) + H8m.G9q(C9, c9) + H8m.W9q(n9, a9);
    O[H8m.y7H] = H8m.v9q(M9, R) + H8m.u9q(s9, k9) + H8m.H9q(C9, t9) + H8m.f9q(n9, S);
    O[H8m.F7H] = H8m.I9q(t1, Z) + H8m.g1q(o1, E) + H8m.K1q(a1, L9) + H8m.d1q(j1, S9);
    O[H8m.f7H] = H8m.t1q(t1, Y) + H8m.w1q(o1, V) + H8m.e1q(a1, K9) + H8m.Q1q(j1, j9);
    O[H8m.e1i] = H8m.r1q(t1, T) + H8m.N1q(o1, U) + H8m.m1q(a1, c9) + H8m.A1q(j1, a9);
    O[H8m.F9i] = H8m.E1q(t1, R) + H8m.C1q(o1, k9) + H8m.h1q(a1, t9) + H8m.y1q(j1, S);
    O[H8m.l9i] = H8m.q1q(T1, Z) + H8m.l1q(e8, E) + H8m.X8q(y1, L9) + H8m.D8q(P, S9);
    O[H8m.b9i] = H8m.c8q(T1, Y) + H8m.z8q(e8, V) + H8m.j8q(y1, K9) + H8m.x8q(P, j9);
    O[H8m.f9i] = H8m.o8q(T1, T) + H8m.p8q(e8, U) + H8m.Y8q(y1, c9) + H8m.T8q(P, a9);
    O[H8m.u9i] = H8m.R8q(T1, R) + H8m.M8q(e8, k9) + H8m.V8q(y1, t9) + H8m.s8q(P, S);
    return X;
};
cc.getMat4MultiplyValue = function(X, S) {
    var P = X.mat,
        O = S.mat,
        Z = new Float32Array(H8m.U9i);
    Z[H8m.U7H] = H8m.U8q(P[H8m.U7H], O[H8m.U7H]) + H8m.b8q(P[H8m.q7H], O[H8m.h7H]) + H8m.F8q(P[H8m.F7H], O[H8m.s7H]) + H8m.k4q(P[H8m.l9i], O[H8m.v7H]);
    Z[H8m.h7H] = H8m.L4q(P[H8m.h7H], O[H8m.U7H]) + H8m.i4q(P[H8m.b7H], O[H8m.h7H]) + H8m.S4q(P[H8m.f7H], O[H8m.s7H]) + H8m.P4q(P[H8m.b9i], O[H8m.v7H]);
    Z[H8m.s7H] = H8m.a4q(P[H8m.s7H], O[H8m.U7H]) + H8m.O4q(P[H8m.H7H], O[H8m.h7H]) + H8m.B4q(P[H8m.e1i], O[H8m.s7H]) + H8m.Z4q(P[H8m.f9i], O[H8m.v7H]);
    Z[H8m.v7H] = H8m.J4q(P[H8m.v7H], O[H8m.U7H]) + H8m.n4q(P[H8m.y7H], O[H8m.h7H]) + H8m.G4q(P[H8m.F9i], O[H8m.s7H]) + H8m.W4q(P[H8m.u9i], O[H8m.v7H]);
    Z[H8m.q7H] = H8m.v4q(P[H8m.U7H], O[H8m.q7H]) + H8m.u4q(P[H8m.q7H], O[H8m.b7H]) + H8m.H4q(P[H8m.F7H], O[H8m.H7H]) + H8m.f4q(P[H8m.l9i], O[H8m.y7H]);
    Z[H8m.b7H] = H8m.I4q(P[H8m.h7H], O[H8m.q7H]) + H8m.g7q(P[H8m.b7H], O[H8m.b7H]) + H8m.K7q(P[H8m.f7H], O[H8m.H7H]) + H8m.d7q(P[H8m.b9i], O[H8m.y7H]);
    Z[H8m.H7H] = H8m.t7q(P[H8m.s7H], O[H8m.q7H]) + H8m.w7q(P[H8m.H7H], O[H8m.b7H]) + H8m.e7q(P[H8m.e1i], O[H8m.H7H]) + H8m.Q7q(P[H8m.f9i], O[H8m.y7H]);
    Z[H8m.y7H] = H8m.r7q(P[H8m.v7H], O[H8m.q7H]) + H8m.N7q(P[H8m.y7H], O[H8m.b7H]) + H8m.m7q(P[H8m.F9i], O[H8m.H7H]) + H8m.A7q(P[H8m.u9i], O[H8m.y7H]);
    Z[H8m.F7H] = H8m.E7q(P[H8m.U7H], O[H8m.F7H]) + H8m.C7q(P[H8m.q7H], O[H8m.f7H]) + H8m.h7q(P[H8m.F7H], O[H8m.e1i]) + H8m.y7q(P[H8m.l9i], O[H8m.F9i]);
    Z[H8m.f7H] = H8m.q7q(P[H8m.h7H], O[H8m.F7H]) + H8m.l7q(P[H8m.b7H], O[H8m.f7H]) + H8m.X0q(P[H8m.f7H], O[H8m.e1i]) + H8m.D0q(P[H8m.b9i], O[H8m.F9i]);
    Z[H8m.e1i] = H8m.c0q(P[H8m.s7H], O[H8m.F7H]) + H8m.z0q(P[H8m.H7H], O[H8m.f7H]) + H8m.j0q(P[H8m.e1i], O[H8m.e1i]) + H8m.x0q(P[H8m.f9i], O[H8m.F9i]);
    Z[H8m.F9i] = H8m.o0q(P[H8m.v7H], O[H8m.F7H]) + H8m.p0q(P[H8m.y7H], O[H8m.f7H]) + H8m.Y0q(P[H8m.F9i], O[H8m.e1i]) + H8m.T0q(P[H8m.u9i], O[H8m.F9i]);
    Z[H8m.l9i] = H8m.R0q(P[H8m.U7H], O[H8m.l9i]) + H8m.M0q(P[H8m.q7H], O[H8m.b9i]) + H8m.V0q(P[H8m.F7H], O[H8m.f9i]) + H8m.s0q(P[H8m.l9i], O[H8m.u9i]);
    Z[H8m.b9i] = H8m.U0q(P[H8m.h7H], O[H8m.l9i]) + H8m.b0q(P[H8m.b7H], O[H8m.b9i]) + H8m.F0q(P[H8m.f7H], O[H8m.f9i]) + H8m.k3q(P[H8m.b9i], O[H8m.u9i]);
    Z[H8m.f9i] = H8m.L3q(P[H8m.s7H], O[H8m.l9i]) + H8m.i3q(P[H8m.H7H], O[H8m.b9i]) + H8m.S3q(P[H8m.e1i], O[H8m.f9i]) + H8m.P3q(P[H8m.f9i], O[H8m.u9i]);
    Z[H8m.u9i] = H8m.a3q(P[H8m.v7H], O[H8m.l9i]) + H8m.O3q(P[H8m.y7H], O[H8m.b9i]) + H8m.B3q(P[H8m.F9i], O[H8m.f9i]) + H8m.Z3q(P[H8m.u9i], O[H8m.u9i]);
    return Z;
};
cc.getMat4MultiplyWithMat4 = function(X, S, P) {
    X = X.mat;
    S = S.mat;
    var O = P.mat;
    O[H8m.U7H] = H8m.J3q(X[H8m.U7H], S[H8m.U7H]) + H8m.n3q(X[H8m.q7H], S[H8m.h7H]) + H8m.G3q(X[H8m.F7H], S[H8m.s7H]) + H8m.W3q(X[H8m.l9i], S[H8m.v7H]);
    O[H8m.h7H] = H8m.v3q(X[H8m.h7H], S[H8m.U7H]) + H8m.u3q(X[H8m.b7H], S[H8m.h7H]) + H8m.H3q(X[H8m.f7H], S[H8m.s7H]) + H8m.f3q(X[H8m.b9i], S[H8m.v7H]);
    O[H8m.s7H] = H8m.I3q(X[H8m.s7H], S[H8m.U7H]) + H8m.g5q(X[H8m.H7H], S[H8m.h7H]) + H8m.K5q(X[H8m.e1i], S[H8m.s7H]) + H8m.d5q(X[H8m.f9i], S[H8m.v7H]);
    O[H8m.v7H] = H8m.t5q(X[H8m.v7H], S[H8m.U7H]) + H8m.w5q(X[H8m.y7H], S[H8m.h7H]) + H8m.e5q(X[H8m.F9i], S[H8m.s7H]) + H8m.Q5q(X[H8m.u9i], S[H8m.v7H]);
    O[H8m.q7H] = H8m.r5q(X[H8m.U7H], S[H8m.q7H]) + H8m.N5q(X[H8m.q7H], S[H8m.b7H]) + H8m.m5q(X[H8m.F7H], S[H8m.H7H]) + H8m.A5q(X[H8m.l9i], S[H8m.y7H]);
    O[H8m.b7H] = H8m.E5q(X[H8m.h7H], S[H8m.q7H]) + H8m.C5q(X[H8m.b7H], S[H8m.b7H]) + H8m.h5q(X[H8m.f7H], S[H8m.H7H]) + H8m.y5q(X[H8m.b9i], S[H8m.y7H]);
    O[H8m.H7H] = H8m.q5q(X[H8m.s7H], S[H8m.q7H]) + H8m.l5q(X[H8m.H7H], S[H8m.b7H]) + H8m.X6q(X[H8m.e1i], S[H8m.H7H]) + H8m.D6q(X[H8m.f9i], S[H8m.y7H]);
    O[H8m.y7H] = H8m.c6q(X[H8m.v7H], S[H8m.q7H]) + H8m.z6q(X[H8m.y7H], S[H8m.b7H]) + H8m.j6q(X[H8m.F9i], S[H8m.H7H]) + H8m.x6q(X[H8m.u9i], S[H8m.y7H]);
    O[H8m.F7H] = H8m.o6q(X[H8m.U7H], S[H8m.F7H]) + H8m.p6q(X[H8m.q7H], S[H8m.f7H]) + H8m.Y6q(X[H8m.F7H], S[H8m.e1i]) + H8m.T6q(X[H8m.l9i], S[H8m.F9i]);
    O[H8m.f7H] = H8m.R6q(X[H8m.h7H], S[H8m.F7H]) + H8m.M6q(X[H8m.b7H], S[H8m.f7H]) + H8m.V6q(X[H8m.f7H], S[H8m.e1i]) + H8m.s6q(X[H8m.b9i], S[H8m.F9i]);
    O[H8m.e1i] = H8m.U6q(X[H8m.s7H], S[H8m.F7H]) + H8m.b6q(X[H8m.H7H], S[H8m.f7H]) + H8m.F6q(X[H8m.e1i], S[H8m.e1i]) + H8m.k2q(X[H8m.f9i], S[H8m.F9i]);
    O[H8m.F9i] = H8m.L2q(X[H8m.v7H], S[H8m.F7H]) + H8m.i2q(X[H8m.y7H], S[H8m.f7H]) + H8m.S2q(X[H8m.F9i], S[H8m.e1i]) + H8m.P2q(X[H8m.u9i], S[H8m.F9i]);
    O[H8m.l9i] = H8m.a2q(X[H8m.U7H], S[H8m.l9i]) + H8m.O2q(X[H8m.q7H], S[H8m.b9i]) + H8m.B2q(X[H8m.F7H], S[H8m.f9i]) + H8m.Z2q(X[H8m.l9i], S[H8m.u9i]);
    O[H8m.b9i] = H8m.J2q(X[H8m.h7H], S[H8m.l9i]) + H8m.n2q(X[H8m.b7H], S[H8m.b9i]) + H8m.G2q(X[H8m.f7H], S[H8m.f9i]) + H8m.W2q(X[H8m.b9i], S[H8m.u9i]);
    O[H8m.f9i] = H8m.v2q(X[H8m.s7H], S[H8m.l9i]) + H8m.u2q(X[H8m.H7H], S[H8m.b9i]) + H8m.H2q(X[H8m.e1i], S[H8m.f9i]) + H8m.f2q(X[H8m.f9i], S[H8m.u9i]);
    O[H8m.u9i] = H8m.I2q(X[H8m.v7H], S[H8m.l9i]) + H8m.g9T(X[H8m.y7H], S[H8m.b9i]) + H8m.K9T(X[H8m.F9i], S[H8m.f9i]) + H8m.d9T(X[H8m.u9i], S[H8m.u9i]);
    return P.mat;
};
cc.kmMat4Assign = function(X, S) {
    var P = "cc.kmMat4Assign(): pOut equals pIn";
    if (H8m.t9T(X, S))
        return cc.log(P), X;
    var O = X.mat,
        Z = S.mat;
    O[H8m.U7H] = Z[H8m.U7H];
    O[H8m.h7H] = Z[H8m.h7H];
    O[H8m.s7H] = Z[H8m.s7H];
    O[H8m.v7H] = Z[H8m.v7H];
    O[H8m.q7H] = Z[H8m.q7H];
    O[H8m.b7H] = Z[H8m.b7H];
    O[H8m.H7H] = Z[H8m.H7H];
    O[H8m.y7H] = Z[H8m.y7H];
    O[H8m.F7H] = Z[H8m.F7H];
    O[H8m.f7H] = Z[H8m.f7H];
    O[H8m.e1i] = Z[H8m.e1i];
    O[H8m.F9i] = Z[H8m.F9i];
    O[H8m.l9i] = Z[H8m.l9i];
    O[H8m.b9i] = Z[H8m.b9i];
    O[H8m.f9i] = Z[H8m.f9i];
    O[H8m.u9i] = Z[H8m.u9i];
    return X;
};
cc.kmMat4AreEqual = function(X, S) {
    var P = "cc.kmMat4AreEqual(): pMat1 and pMat2 are same object.";
    if (H8m.w9T(X, S))
        return cc.log(P), !H8m.U7H;
    for (var O = H8m.U7H; H8m.e9T(H8m.U9i, O); O++)
        if (!(H8m.Q9T(X.mat[O] + cc.kmEpsilon, S.mat[O]) && H8m.r9T(X.mat[O] - cc.kmEpsilon, S.mat[O])))
            return !H8m.h7H;
    return !H8m.U7H;
};
cc.kmMat4RotationX = function(X, S) {
    X.mat[H8m.U7H] = H8m.h7H;
    X.mat[H8m.h7H] = H8m.U7H;
    X.mat[H8m.s7H] = H8m.U7H;
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = H8m.U7H;
    X.mat[H8m.b7H] = Math.cos(S);
    X.mat[H8m.H7H] = Math.sin(S);
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.U7H;
    X.mat[H8m.f7H] = -Math.sin(S);
    X.mat[H8m.e1i] = Math.cos(S);
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = H8m.U7H;
    X.mat[H8m.b9i] = H8m.U7H;
    X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4RotationY = function(X, S) {
    X.mat[H8m.U7H] = Math.cos(S);
    X.mat[H8m.h7H] = H8m.U7H;
    X.mat[H8m.s7H] = -Math.sin(S);
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = H8m.U7H;
    X.mat[H8m.b7H] = H8m.h7H;
    X.mat[H8m.H7H] = H8m.U7H;
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = Math.sin(S);
    X.mat[H8m.f7H] = H8m.U7H;
    X.mat[H8m.e1i] = Math.cos(S);
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = H8m.U7H;
    X.mat[H8m.b9i] = H8m.U7H;
    X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4RotationZ = function(X, S) {
    X.mat[H8m.U7H] = Math.cos(S);
    X.mat[H8m.h7H] = Math.sin(S);
    X.mat[H8m.s7H] = H8m.U7H;
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = -Math.sin(S);
    X.mat[H8m.b7H] = Math.cos(S);
    X.mat[H8m.H7H] = H8m.U7H;
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.U7H;
    X.mat[H8m.f7H] = H8m.U7H;
    X.mat[H8m.e1i] = H8m.h7H;
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = H8m.U7H;
    X.mat[H8m.b9i] = H8m.U7H;
    X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4RotationPitchYawRoll = function(X, S, P, O) {
    var Z = Math.cos(S);
    S = Math.sin(S);
    var Y = Math.cos(P);
    P = Math.sin(P);
    var T = Math.cos(O);
    O = Math.sin(O);
    var R = H8m.N9T(S, P),
        E = H8m.m9T(Z, P);
    X.mat[H8m.U7H] = H8m.A9T(Y, T);
    X.mat[H8m.q7H] = H8m.E9T(Y, O);
    X.mat[H8m.F7H] = -P;
    X.mat[H8m.h7H] = H8m.C9T(R * T, Z * O);
    X.mat[H8m.b7H] = H8m.h9T(R, O) + H8m.y9T(Z, T);
    X.mat[H8m.f7H] = H8m.q9T(S, Y);
    X.mat[H8m.s7H] = H8m.l9T(E, T) + H8m.X1T(S, O);
    X.mat[H8m.H7H] = H8m.D1T(E * O, S * T);
    X.mat[H8m.e1i] = H8m.c1T(Z, Y);
    X.mat[H8m.v7H] = X.mat[H8m.y7H] = X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4RotationQuaternion = function(X, S) {
    X.mat[H8m.U7H] = H8m.z1T(H8m.h7H, H8m.s7H * (S.y * S.y + S.z * S.z));
    X.mat[H8m.h7H] = H8m.j1T(H8m.s7H, (S.x * S.y + S.z * S.w));
    X.mat[H8m.s7H] = H8m.x1T(H8m.s7H, (S.x * S.z - S.y * S.w));
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = H8m.o1T(H8m.s7H, (S.x * S.y - S.z * S.w));
    X.mat[H8m.b7H] = H8m.p1T(H8m.h7H, H8m.s7H * (S.x * S.x + S.z * S.z));
    X.mat[H8m.H7H] = H8m.Y1T(H8m.s7H, (S.z * S.y + S.x * S.w));
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.T1T(H8m.s7H, (S.x * S.z + S.y * S.w));
    X.mat[H8m.f7H] = H8m.R1T(H8m.s7H, (S.y * S.z - S.x * S.w));
    X.mat[H8m.e1i] = H8m.M1T(H8m.h7H, H8m.s7H * (S.x * S.x + S.y * S.y));
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = H8m.U7H;
    X.mat[H8m.b9i] = H8m.U7H;
    X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4RotationTranslation = function(X, S, P) {
    X.mat[H8m.U7H] = S.mat[H8m.U7H];
    X.mat[H8m.h7H] = S.mat[H8m.h7H];
    X.mat[H8m.s7H] = S.mat[H8m.s7H];
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = S.mat[H8m.v7H];
    X.mat[H8m.b7H] = S.mat[H8m.q7H];
    X.mat[H8m.H7H] = S.mat[H8m.b7H];
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = S.mat[H8m.H7H];
    X.mat[H8m.f7H] = S.mat[H8m.y7H];
    X.mat[H8m.e1i] = S.mat[H8m.F7H];
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = P.x;
    X.mat[H8m.b9i] = P.y;
    X.mat[H8m.f9i] = P.z;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4Scaling = function(X, S, P, O) {
    X.mat[H8m.U7H] = S;
    X.mat[H8m.b7H] = P;
    X.mat[H8m.e1i] = O;
    X.mat[H8m.u9i] = H8m.h7H;
    X.mat[H8m.h7H] = X.mat[H8m.s7H] = X.mat[H8m.v7H] = X.mat[H8m.q7H] = X.mat[H8m.H7H] = X.mat[H8m.y7H] = X.mat[H8m.F7H] = X.mat[H8m.f7H] = X.mat[H8m.F9i] = X.mat[H8m.l9i] = X.mat[H8m.b9i] = X.mat[H8m.f9i] = H8m.U7H;
    return X;
};
cc.kmMat4Translation = function(X, S, P, O) {
    X.mat[H8m.U7H] = X.mat[H8m.b7H] = X.mat[H8m.e1i] = X.mat[H8m.u9i] = H8m.h7H;
    X.mat[H8m.h7H] = X.mat[H8m.s7H] = X.mat[H8m.v7H] = X.mat[H8m.q7H] = X.mat[H8m.H7H] = X.mat[H8m.y7H] = X.mat[H8m.F7H] = X.mat[H8m.f7H] = X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = S;
    X.mat[H8m.b9i] = P;
    X.mat[H8m.f9i] = O;
    return X;
};
cc.kmMat4GetUpVec3 = function(X, S) {
    X.x = S.mat[H8m.q7H];
    X.y = S.mat[H8m.b7H];
    X.z = S.mat[H8m.H7H];
    cc.kmVec3Normalize(X, X);
    return X;
};
cc.kmMat4GetRightVec3 = function(X, S) {
    X.x = S.mat[H8m.U7H];
    X.y = S.mat[H8m.h7H];
    X.z = S.mat[H8m.s7H];
    cc.kmVec3Normalize(X, X);
    return X;
};
cc.kmMat4GetForwardVec3 = function(X, S) {
    X.x = S.mat[H8m.F7H];
    X.y = S.mat[H8m.f7H];
    X.z = S.mat[H8m.e1i];
    cc.kmVec3Normalize(X, X);
    return X;
};
cc.kmMat4PerspectiveProjection = function(X, S, P, O, Z) {
    var Y = cc.kmDegreesToRadians(H8m.V1T(S, H8m.s7H));
    S = H8m.s1T(Z, O);
    var T = Math.sin(Y);
    if (H8m.U1T(H8m.U7H, S) || H8m.b1T(H8m.U7H, T) || H8m.F1T(H8m.U7H, P))
        return H8m.H6P;
    Y = H8m.k8T(Math.cos(Y), T);
    cc.kmMat4Identity(X);
    X.mat[H8m.U7H] = H8m.L8T(Y, P);
    X.mat[H8m.b7H] = Y;
    X.mat[H8m.e1i] = -(Z + O) / S;
    X.mat[H8m.F9i] = -H8m.h7H;
    X.mat[H8m.f9i] = -H8m.s7H * O * Z / S;
    X.mat[H8m.u9i] = H8m.U7H;
    return X;
};
cc.kmMat4OrthographicProjection = function(X, S, P, O, Z, Y, T) {
    cc.kmMat4Identity(X);
    X.mat[H8m.U7H] = H8m.i8T(H8m.s7H, (P - S));
    X.mat[H8m.b7H] = H8m.S8T(H8m.s7H, (Z - O));
    X.mat[H8m.e1i] = -H8m.s7H / (H8m.P8T(T, Y));
    X.mat[H8m.l9i] = -(H8m.a8T((P + S), (P - S)));
    X.mat[H8m.b9i] = -(H8m.O8T((Z + O), (Z - O)));
    X.mat[H8m.f9i] = -(H8m.B8T((T + Y), (T - Y)));
    return X;
};
cc.kmMat4LookAt = function(X, S, P, O) {
    var Z = new cc.kmVec3,
        Y = new cc.kmVec3,
        T = new cc.kmVec3,
        R = new cc.kmVec3,
        E = new cc.kmMat4;
    cc.kmVec3Subtract(Z, P, S);
    cc.kmVec3Normalize(Z, Z);
    cc.kmVec3Assign(Y, O);
    cc.kmVec3Normalize(Y, Y);
    cc.kmVec3Cross(T, Z, Y);
    cc.kmVec3Normalize(T, T);
    cc.kmVec3Cross(R, T, Z);
    cc.kmVec3Normalize(T, T);
    cc.kmMat4Identity(X);
    X.mat[H8m.U7H] = T.x;
    X.mat[H8m.q7H] = T.y;
    X.mat[H8m.F7H] = T.z;
    X.mat[H8m.h7H] = R.x;
    X.mat[H8m.b7H] = R.y;
    X.mat[H8m.f7H] = R.z;
    X.mat[H8m.s7H] = -Z.x;
    X.mat[H8m.H7H] = -Z.y;
    X.mat[H8m.e1i] = -Z.z;
    cc.kmMat4Translation(E, -S.x, -S.y, -S.z);
    cc.kmMat4Multiply(X, X, E);
    return X;
};
cc.kmMat4RotationAxisAngle = function(X, S, P) {
    var O = Math.cos(P);
    P = Math.sin(P);
    var Z = new cc.kmVec3;
    cc.kmVec3Normalize(Z, S);
    X.mat[H8m.U7H] = O + H8m.Z8T(Z.x, Z.x, (H8m.h7H - O));
    X.mat[H8m.h7H] = H8m.T8T(Z.z, P) + H8m.R8T(Z.y, Z.x, (H8m.h7H - O));
    X.mat[H8m.s7H] = -Z.y * P + H8m.E8T(Z.z, Z.x, (H8m.h7H - O));
    X.mat[H8m.v7H] = H8m.U7H;
    X.mat[H8m.q7H] = -Z.z * P + H8m.v8T(Z.x, Z.y, (H8m.h7H - O));
    X.mat[H8m.b7H] = O + H8m.U8T(Z.y, Z.y, (H8m.h7H - O));
    X.mat[H8m.H7H] = H8m.q8T(Z.x, P) + H8m.l8T(Z.z, Z.y, (H8m.h7H - O));
    X.mat[H8m.y7H] = H8m.U7H;
    X.mat[H8m.F7H] = H8m.g4T(Z.y, P) + H8m.K4T(Z.x, Z.z, (H8m.h7H - O));
    X.mat[H8m.f7H] = -Z.x * P + H8m.S4T(Z.y, Z.z, (H8m.h7H - O));
    X.mat[H8m.e1i] = O + H8m.j4T(Z.z, Z.z, (H8m.h7H - O));
    X.mat[H8m.F9i] = H8m.U7H;
    X.mat[H8m.l9i] = H8m.U7H;
    X.mat[H8m.b9i] = H8m.U7H;
    X.mat[H8m.f9i] = H8m.U7H;
    X.mat[H8m.u9i] = H8m.h7H;
    return X;
};
cc.kmMat4ExtractRotation = function(X, S) {
    X.mat[H8m.U7H] = S.mat[H8m.U7H];
    X.mat[H8m.h7H] = S.mat[H8m.h7H];
    X.mat[H8m.s7H] = S.mat[H8m.s7H];
    X.mat[H8m.v7H] = S.mat[H8m.q7H];
    X.mat[H8m.q7H] = S.mat[H8m.b7H];
    X.mat[H8m.b7H] = S.mat[H8m.H7H];
    X.mat[H8m.H7H] = S.mat[H8m.F7H];
    X.mat[H8m.y7H] = S.mat[H8m.f7H];
    X.mat[H8m.F7H] = S.mat[H8m.e1i];
    return X;
};
cc.kmMat4ExtractPlane = function(X, S, P) {
    var O = "cc.kmMat4ExtractPlane(): Invalid plane index";
    switch (P) {
    case cc.KM_PLANE_RIGHT:
        X.a = H8m.e4T(S.mat[H8m.v7H], S.mat[H8m.U7H]);
        X.b = H8m.Q4T(S.mat[H8m.y7H], S.mat[H8m.q7H]);
        X.c = H8m.r4T(S.mat[H8m.F9i], S.mat[H8m.F7H]);
        X.d = H8m.N4T(S.mat[H8m.u9i], S.mat[H8m.l9i]);
        break;
    case cc.KM_PLANE_LEFT:
        X.a = S.mat[H8m.v7H] + S.mat[H8m.U7H];
        X.b = S.mat[H8m.y7H] + S.mat[H8m.q7H];
        X.c = S.mat[H8m.F9i] + S.mat[H8m.F7H];
        X.d = S.mat[H8m.u9i] + S.mat[H8m.l9i];
        break;
    case cc.KM_PLANE_BOTTOM:
        X.a = S.mat[H8m.v7H] + S.mat[H8m.h7H];
        X.b = S.mat[H8m.y7H] + S.mat[H8m.b7H];
        X.c = S.mat[H8m.F9i] + S.mat[H8m.f7H];
        X.d = S.mat[H8m.u9i] + S.mat[H8m.b9i];
        break;
    case cc.KM_PLANE_TOP:
        X.a = H8m.m4T(S.mat[H8m.v7H], S.mat[H8m.h7H]);
        X.b = H8m.A4T(S.mat[H8m.y7H], S.mat[H8m.b7H]);
        X.c = H8m.E4T(S.mat[H8m.F9i], S.mat[H8m.f7H]);
        X.d = H8m.C4T(S.mat[H8m.u9i], S.mat[H8m.b9i]);
        break;
    case cc.KM_PLANE_FAR:
        X.a = H8m.h4T(S.mat[H8m.v7H], S.mat[H8m.s7H]);
        X.b = H8m.y4T(S.mat[H8m.y7H], S.mat[H8m.H7H]);
        X.c = H8m.q4T(S.mat[H8m.F9i], S.mat[H8m.e1i]);
        X.d = H8m.l4T(S.mat[H8m.u9i], S.mat[H8m.f9i]);
        break;
    case cc.KM_PLANE_NEAR:
        X.a = S.mat[H8m.v7H] + S.mat[H8m.s7H];
        X.b = S.mat[H8m.y7H] + S.mat[H8m.H7H];
        X.c = S.mat[H8m.F9i] + S.mat[H8m.e1i];
        X.d = S.mat[H8m.u9i] + S.mat[H8m.f9i];
        break;
    default:
        cc.log(O);
    }
    S = Math.sqrt(H8m.X7T(X.a, X.a) + H8m.D7T(X.b, X.b) + H8m.c7T(X.c, X.c));
    X.a /= S;
    X.b /= S;
    X.c /= S;
    X.d /= S;
    return X;
};
cc.kmMat4RotationToAxisAngle = function(X, S, P) {
    var O = new cc.kmQuaternion,
        Z = new cc.kmMat3;
    cc.kmMat4ExtractRotation(Z, P);
    cc.kmQuaternionRotationMatrix(O, Z);
    cc.kmQuaternionToAxisAngle(O, X, S);
    return X;
};
H8m.t2(H8m.U7H);
H8m.j2(H8m.h7H);
H8m.a2(H8m.s7H);
H8m.e2(H8m.v7H);
H8m.o2(H8m.q7H);
H8m.B2(H8m.b7H);
cc.kmPlane = function(X, S, P, O) {
    this.a = X || H8m.U7H;
    this.b = S || H8m.U7H;
    this.c = P || H8m.U7H;
    this.d = O || H8m.U7H;
};
H8m.r2(H8m.U7H);
H8m.Y2(H8m.h7H);
H8m.J2(H8m.s7H);
cc.kmPlaneDot = function(X, S) {
    return H8m.z7T(X.a, S.x) + H8m.j7T(X.b, S.y) + H8m.x7T(X.c, S.z) + H8m.o7T(X.d, S.w);
};
cc.kmPlaneDotCoord = function(X, S) {
    return H8m.p7T(X.a, S.x) + H8m.Y7T(X.b, S.y) + H8m.T7T(X.c, S.z) + X.d;
};
cc.kmPlaneDotNormal = function(X, S) {
    return H8m.R7T(X.a, S.x) + H8m.M7T(X.b, S.y) + H8m.V7T(X.c, S.z);
};
cc.kmPlaneFromPointNormal = function(X, S, P) {
    X.a = P.x;
    X.b = P.y;
    X.c = P.z;
    X.d = -cc.kmVec3Dot(P, S);
    return X;
};
cc.kmPlaneFromPoints = function(X, S, P, O) {
    var Z = new cc.kmVec3,
        Y = new cc.kmVec3,
        T = new cc.kmVec3;
    cc.kmVec3Subtract(Y, P, S);
    cc.kmVec3Subtract(T, O, S);
    cc.kmVec3Cross(Z, Y, T);
    cc.kmVec3Normalize(Z, Z);
    X.a = Z.x;
    X.b = Z.y;
    X.c = Z.z;
    X.d = cc.kmVec3Dot(cc.kmVec3Scale(Z, Z, -H8m.h7H), S);
    return X;
};
cc.kmPlaneIntersectLine = function(X, S, P, O) {
    var Z = "cc.kmPlaneIntersectLine() hasn't been implemented.";
    throw Z;
};
cc.kmPlaneNormalize = function(X, S) {
    var P = new cc.kmVec3;
    P.x = S.a;
    P.y = S.b;
    P.z = S.c;
    var O = H8m.s7T(H8m.h7H, cc.kmVec3Length(P));
    cc.kmVec3Normalize(P, P);
    X.a = P.x;
    X.b = P.y;
    X.c = P.z;
    X.d = H8m.U7T(S.d, O);
    return X;
};
cc.kmPlaneScale = function(X, S, P) {
    var O = "cc.kmPlaneScale() has not been implemented.";
    cc.log(O);
};
cc.kmPlaneClassifyPoint = function(X, S) {
    var P = H8m.b7T(X.a, S.x) + H8m.F7T(X.b, S.y) + H8m.k0T(X.c, S.z) + X.d;
    return H8m.L0T(H8m.x8i, P) ? cc.POINT_INFRONT_OF_PLANE : -H8m.x8i > P ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE;
};
cc.kmQuaternion = function(X, S, P, O) {
    this.x = X || H8m.U7H;
    this.y = S || H8m.U7H;
    this.z = P || H8m.U7H;
    this.w = O || H8m.U7H;
};
cc.kmQuaternionConjugate = function(X, S) {
    X.x = -S.x;
    X.y = -S.y;
    X.z = -S.z;
    X.w = S.w;
    return X;
};
cc.kmQuaternionDot = function(X, S) {
    return H8m.i0T(X.w, S.w) + H8m.S0T(X.x, S.x) + H8m.P0T(X.y, S.y) + H8m.a0T(X.z, S.z);
};
cc.kmQuaternionExp = function(X, S) {
    return X;
};
cc.kmQuaternionIdentity = function(X) {
    X.x = H8m.U7H;
    X.y = H8m.U7H;
    X.z = H8m.U7H;
    X.w = H8m.h7H;
    return X;
};
cc.kmQuaternionInverse = function(X, S) {
    var P = cc.kmQuaternionLength(S),
        O = new cc.kmQuaternion;
    if (H8m.O0T(Math.abs(P), cc.kmEpsilon))
        return X.x = H8m.U7H, X.y = H8m.U7H, X.z = H8m.U7H, X.w = H8m.U7H, X;
    cc.kmQuaternionScale(X, cc.kmQuaternionConjugate(O, S), H8m.B0T(H8m.h7H, P));
    return X;
};
cc.kmQuaternionIsIdentity = function(X) {
    return H8m.Z0T(H8m.U7H, X.x) && H8m.J0T(H8m.U7H, X.y) && H8m.n0T(H8m.U7H, X.z) && H8m.G0T(H8m.h7H, X.w);
};
cc.kmQuaternionLength = function(X) {
    return Math.sqrt(cc.kmQuaternionLengthSq(X));
};
cc.kmQuaternionLengthSq = function(X) {
    return H8m.W0T(X.x, X.x) + H8m.v0T(X.y, X.y) + H8m.u0T(X.z, X.z) + H8m.H0T(X.w, X.w);
};
cc.kmQuaternionLn = function(X, S) {
    return X;
};
cc.kmQuaternionMultiply = function(X, S, P) {
    X.w = H8m.f0T(S.w * P.w, S.x * P.x, S.y * P.y, S.z * P.z);
    X.x = H8m.X3T(S.w, P.x) + H8m.D3T(S.x, P.w) + H8m.c3T(S.y, P.z) - H8m.z3T(S.z, P.y);
    X.y = H8m.j3T(S.w, P.y) + H8m.x3T(S.y, P.w) + H8m.o3T(S.z, P.x) - H8m.p3T(S.x, P.z);
    X.z = H8m.Y3T(S.w, P.z) + H8m.T3T(S.z, P.w) + H8m.R3T(S.x, P.y) - H8m.M3T(S.y, P.x);
    return X;
};
cc.kmQuaternionNormalize = function(X, S) {
    var P = "cc.kmQuaternionNormalize(): pIn is an invalid value",
        O = cc.kmQuaternionLength(S);
    if (H8m.V3T(Math.abs(O), cc.kmEpsilon))
        throw P;
    cc.kmQuaternionScale(X, S, H8m.s3T(H8m.h7H, O));
    return X;
};
cc.kmQuaternionRotationAxis = function(X, S, P) {
    P *= H8m.E1S;
    var O = Math.sin(P);
    X.w = Math.cos(P);
    X.x = H8m.U3T(S.x, O);
    X.y = H8m.b3T(S.y, O);
    X.z = H8m.F3T(S.z, O);
    return X;
};
cc.kmQuaternionRotationMatrix = function(X, S) {
    var P,
        O,
        Z,
        Y;
    P = [];
    O = Y = H8m.U7H;
    if (!S)
        return H8m.H6P;
    P[H8m.U7H] = S.mat[H8m.U7H];
    P[H8m.h7H] = S.mat[H8m.v7H];
    P[H8m.s7H] = S.mat[H8m.H7H];
    P[H8m.q7H] = S.mat[H8m.h7H];
    P[H8m.b7H] = S.mat[H8m.q7H];
    P[H8m.H7H] = S.mat[H8m.y7H];
    P[H8m.F7H] = S.mat[H8m.s7H];
    P[H8m.f7H] = S.mat[H8m.b7H];
    P[H8m.e1i] = S.mat[H8m.F7H];
    P[H8m.u9i] = H8m.h7H;
    var T = P[H8m.U7H];
    O = T[H8m.U7H] + T[H8m.b7H] + T[H8m.e1i] + H8m.h7H;
    H8m.k5T(O, cc.kmEpsilon) ? (Y = H8m.L5T(H8m.s7H, Math.sqrt(O)), P = H8m.i5T((T[H8m.f7H] - T[H8m.H7H]), Y), O = H8m.S5T((T[H8m.s7H] - T[H8m.F7H]), Y), Z = H8m.P5T((T[H8m.q7H] - T[H8m.h7H]), Y), Y *= H8m.L5H) : H8m.a5T(T[H8m.U7H], T[H8m.b7H]) && H8m.O5T(T[H8m.U7H], T[H8m.e1i]) ? (Y = H8m.B5T(H8m.s7H, Math.sqrt(H8m.h7H + T[H8m.U7H] - T[H8m.b7H] - T[H8m.e1i])), P = H8m.Z5T(H8m.L5H, Y), O = H8m.J5T((T[H8m.q7H] + T[H8m.h7H]), Y), Z = H8m.n5T((T[H8m.s7H] + T[H8m.F7H]), Y), Y = H8m.G5T((T[H8m.f7H] - T[H8m.H7H]), Y)) : H8m.W5T(T[H8m.b7H], T[H8m.e1i]) ? (Y = H8m.v5T(H8m.s7H, Math.sqrt(H8m.h7H + T[H8m.b7H] - T[H8m.U7H] - T[H8m.e1i])), P = H8m.u5T((T[H8m.q7H] + T[H8m.h7H]), Y), O = H8m.H5T(H8m.L5H, Y), Z = H8m.f5T((T[H8m.f7H] + T[H8m.H7H]), Y), Y = H8m.I5T((T[H8m.s7H] - T[H8m.F7H]), Y)) : (Y = H8m.g6T(H8m.s7H, Math.sqrt(H8m.h7H + T[H8m.e1i] - T[H8m.U7H] - T[H8m.b7H])), P = H8m.K6T((T[H8m.s7H] + T[H8m.F7H]), Y), O = H8m.d6T((T[H8m.f7H] + T[H8m.H7H]), Y), Z = H8m.t6T(H8m.L5H, Y), Y = H8m.w6T((T[H8m.q7H] - T[H8m.h7H]), Y));
    X.x = P;
    X.y = O;
    X.z = Z;
    X.w = Y;
    return X;
};
cc.kmQuaternionRotationYawPitchRoll = function(X, S, P, O) {
    var Z,
        Y,
        T,
        R,
        E;
    Z = H8m.e6T(cc.kmDegreesToRadians(P), H8m.s7H);
    Y = H8m.Q6T(cc.kmDegreesToRadians(S), H8m.s7H);
    T = H8m.r6T(cc.kmDegreesToRadians(O), H8m.s7H);
    O = Math.cos(Z);
    S = Math.cos(Y);
    P = Math.cos(T);
    Z = Math.sin(Z);
    Y = Math.sin(Y);
    T = Math.sin(T);
    R = H8m.N6T(S, P);
    E = H8m.m6T(Y, T);
    X.w = H8m.A6T(O, R) + H8m.E6T(Z, E);
    X.x = H8m.C6T(Z * R, O * E);
    X.y = H8m.h6T(O, Y, P) + H8m.H6T(Z, S, T);
    X.z = H8m.F6T(O * S * T, Z * Y * P);
    cc.kmQuaternionNormalize(X, X);
    return X;
};
cc.kmQuaternionSlerp = function(X, S, P, O) {
    if (H8m.k2T(S.x, P.x) && H8m.L2T(S.y, P.y) && H8m.i2T(S.z, P.z) && H8m.S2T(S.w, P.w))
        return X.x = S.x, X.y = S.y, X.z = S.z, X.w = S.w, X;
    var Z = cc.kmQuaternionDot(S, P),
        Y = Math.acos(Z),
        T = Math.sqrt(H8m.P2T(H8m.h7H, cc.kmSQR(Z))),
        Z = H8m.a2T(Math.sin(O * Y), T);
    O = H8m.O2T(Math.sin((H8m.h7H - O) * Y), T);
    Y = new cc.kmQuaternion;
    T = new cc.kmQuaternion;
    cc.kmQuaternionScale(Y, S, O);
    cc.kmQuaternionScale(T, P, Z);
    cc.kmQuaternionAdd(X, Y, T);
    return X;
};
cc.kmQuaternionToAxisAngle = function(X, S, P) {
    Math.acos(X.w);
    P = Math.sqrt(cc.kmSQR(X.x) + cc.kmSQR(X.y) + cc.kmSQR(X.z));
    P > -cc.kmEpsilon && H8m.B2T(P, cc.kmEpsilon) || H8m.Z2T(P, H8m.s7H * cc.kmPI + cc.kmEpsilon) && H8m.J2T(P, H8m.s7H * cc.kmPI - cc.kmEpsilon) ? (S.x = H8m.U7H, S.y = H8m.U7H, S.z = H8m.h7H) : (S.x = H8m.n2T(X.x, P), S.y = H8m.G2T(X.y, P), S.z = H8m.W2T(X.z, P), cc.kmVec3Normalize(S, S));
};
cc.kmQuaternionScale = function(X, S, P) {
    X.x = H8m.v2T(S.x, P);
    X.y = H8m.u2T(S.y, P);
    X.z = H8m.H2T(S.z, P);
    X.w = H8m.f2T(S.w, P);
    return X;
};
cc.kmQuaternionAssign = function(X, S) {
    X.x = S.x;
    X.y = S.y;
    X.z = S.z;
    X.w = S.w;
    return X;
};
cc.kmQuaternionAdd = function(X, S, P) {
    X.x = S.x + P.x;
    X.y = S.y + P.y;
    X.z = S.z + P.z;
    X.w = S.w + P.w;
    return X;
};
cc.kmQuaternionRotationBetweenVec3 = function(X, S, P, O) {
    var Z = 0.999999,
        Y = new cc.kmVec3,
        T = new cc.kmVec3;
    cc.kmVec3Assign(Y, S);
    cc.kmVec3Assign(T, P);
    cc.kmVec3Normalize(Y, Y);
    cc.kmVec3Normalize(T, T);
    P = cc.kmVec3Dot(Y, T);
    if (H8m.I2T(H8m.h7H, P))
        return cc.kmQuaternionIdentity(X), X;
    -Z > P ? H8m.g9B(Math.abs(cc.kmVec3LengthSq(O)), cc.kmEpsilon) ? cc.kmQuaternionRotationAxis(X, O, cc.kmPI) : (Y = new cc.kmVec3, T = new cc.kmVec3, T.x = H8m.h7H, T.y = H8m.U7H, T.z = H8m.U7H, cc.kmVec3Cross(Y, T, S), H8m.K9B(Math.abs(cc.kmVec3LengthSq(Y)), cc.kmEpsilon) && (T = new cc.kmVec3, T.x = H8m.U7H, T.y = H8m.h7H, T.z = H8m.U7H, cc.kmVec3Cross(Y, T, S)), cc.kmVec3Normalize(Y, Y), cc.kmQuaternionRotationAxis(X, Y, cc.kmPI)) : (S = Math.sqrt(H8m.d9B(H8m.s7H, (H8m.h7H + P))), O = H8m.t9B(H8m.h7H, S), P = new cc.kmVec3, cc.kmVec3Cross(P, Y, T), X.x = H8m.w9B(P.x, O), X.y = H8m.e9B(P.y, O), X.z = H8m.Q9B(P.z, O), X.w = H8m.r9B(H8m.E1S, S), cc.kmQuaternionNormalize(X, X));
    return X;
};
cc.kmQuaternionMultiplyVec3 = function(X, S, P) {
    var O = new cc.kmVec3,
        Z = new cc.kmVec3,
        Y = new cc.kmVec3;
    Y.x = S.x;
    Y.y = S.y;
    Y.z = S.z;
    cc.kmVec3Cross(O, Y, P);
    cc.kmVec3Cross(Z, Y, O);
    cc.kmVec3Scale(O, O, H8m.N9B(H8m.s7H, S.w));
    cc.kmVec3Scale(Z, Z, H8m.s7H);
    cc.kmVec3Add(X, P, O);
    cc.kmVec3Add(X, X, Z);
    return X;
};
cc.kmAABB = function(X, S) {
    this.min = X || new cc.kmVec3;
    this.max = S || new cc.kmVec3;
};
cc.kmAABBContainsPoint = function(X, S) {
    return H8m.m9B(X.x, S.min.x) && H8m.A9B(X.x, S.max.x) && H8m.E9B(X.y, S.min.y) && H8m.C9B(X.y, S.max.y) && H8m.h9B(X.z, S.min.z) && H8m.y9B(X.z, S.max.z) ? cc.KM_TRUE : cc.KM_FALSE;
};
cc.kmAABBAssign = function(X, S) {
    cc.kmVec3Assign(X.min, S.min);
    cc.kmVec3Assign(X.max, S.max);
    return X;
};
cc.kmAABBScale = function(X, S, P) {
    var O = "cc.kmAABBScale hasn't been supported.";
    cc.log(O);
};
cc.km_mat4_stack = function(X, S, P, O) {
    this.top = P;
    this.stack = O;
};
H8m.m2(H8m.Y9i);
cc.km_mat4_stack_initialize = function(X) {
    X.stack = [];
    X.top = H8m.H6P;
};
cc.km_mat4_stack_push = function(X, S) {
    X.stack.push(X.top);
    X.top = new cc.kmMat4;
    cc.kmMat4Assign(X.top, S);
};
cc.km_mat4_stack_pop = function(X, S) {
    X.top = X.stack.pop();
};
cc.km_mat4_stack_release = function(X) {
    X.stack = H8m.H6P;
    X.top = H8m.H6P;
};
H8m.R2(H8m.w7K);
H8m.G2(H8m.B7K);
H8m.E2(H8m.I4K);
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
H8m.V2(H8m.H6P);
H8m.v2();
cc.lazyInitialize = function() {
    if (!cc.initialized) {
        var X = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
        cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
        cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
        cc.current_stack = cc.modelview_matrix_stack;
        cc.initialized = !H8m.U7H;
        cc.kmMat4Identity(X);
        cc.km_mat4_stack_push(cc.modelview_matrix_stack, X);
        cc.km_mat4_stack_push(cc.projection_matrix_stack, X);
        cc.km_mat4_stack_push(cc.texture_matrix_stack, X);
    }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function() {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack);
    cc.km_mat4_stack_release(cc.projection_matrix_stack);
    cc.km_mat4_stack_release(cc.texture_matrix_stack);
    cc.initialized = !H8m.h7H;
    cc.current_stack = H8m.H6P;
};
cc.kmGLPushMatrix = function() {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top);
};
cc.kmGLPushMatrixWitMat4 = function(X) {
    cc.current_stack.stack.push(cc.current_stack.top);
    cc.kmMat4Assign(X, cc.current_stack.top);
    cc.current_stack.top = X;
};
cc.kmGLPopMatrix = function() {
    cc.current_stack.top = cc.current_stack.stack.pop();
};
cc.kmGLMatrixMode = function(X) {
    switch (X) {
    case cc.KM_GL_MODELVIEW:
        cc.current_stack = cc.modelview_matrix_stack;
        break;
    case cc.KM_GL_PROJECTION:
        cc.current_stack = cc.projection_matrix_stack;
        break;
    case cc.KM_GL_TEXTURE:
        cc.current_stack = cc.texture_matrix_stack;
        break;
    default:
        throw H8m.L0S;
    }
};
cc.kmGLLoadIdentity = function() {
    cc.kmMat4Identity(cc.current_stack.top);
};
cc.kmGLLoadMatrix = function(X) {
    cc.kmMat4Assign(cc.current_stack.top, X);
};
cc.kmGLMultMatrix = function(X) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, X);
};
cc.kmGLTranslatef = function(X, S, P) {
    var O = new cc.kmMat4;
    cc.kmMat4Translation(O, X, S, P);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, O);
};
cc.kmGLRotatef = function(X, S, P, O) {
    S = new cc.kmVec3(S, P, O);
    P = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(P, S, cc.kmDegreesToRadians(X));
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, P);
};
cc.kmGLScalef = function(X, S, P) {
    var O = new cc.kmMat4;
    cc.kmMat4Scaling(O, X, S, P);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, O);
};
cc.kmGLGetMatrix = function(X, S) {
    switch (X) {
    case cc.KM_GL_MODELVIEW:
        cc.kmMat4Assign(S, cc.modelview_matrix_stack.top);
        break;
    case cc.KM_GL_PROJECTION:
        cc.kmMat4Assign(S, cc.projection_matrix_stack.top);
        break;
    case cc.KM_GL_TEXTURE:
        cc.kmMat4Assign(S, cc.texture_matrix_stack.top);
        break;
    default:
        throw H8m.L0S;
    }
};
H8m.s2(H8m.t9i);
H8m.u2(H8m.b6H);
H8m.y2(H8m.V8P);
H8m.b2(H8m.y8S);
H8m.F2(H8m.U4K);
H8m.I2(H8m.f3S);
H8m.X9y(H8m.r4i);
H8m.L9y(H8m.i2i);
H8m.K9y(H8m.p6i);
H8m.c9y(H8m.V7H);
H8m.S9y(H8m.K6i);
H8m.t9y(H8m.y2H);
H8m.j9y(H8m.p6P);
H8m.a9y(H8m.y2H);
H8m.e9y(H8m.S1P);
H8m.o9y(H8m.a9P);
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: H8m.U7H,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: H8m.h7H,
    TYPE_POSITION_COLOR: H8m.s7H,
    TYPE_POSITION_TEXTURE: H8m.v7H,
    TYPE_POSITION_TEXTURE_UCOLOR: H8m.q7H,
    TYPE_POSITION_TEXTURE_A8COLOR: H8m.b7H,
    TYPE_POSITION_UCOLOR: H8m.H7H,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: H8m.y7H,
    TYPE_MAX: H8m.F7H,
    _programs: {},
    _init: function() {
        this.loadDefaultShaders();
        return !H8m.U7H;
    },
    _loadDefaultShader: function(X, S) {
        var P = "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
            O = "aVertex";
        switch (S) {
        case this.TYPE_POSITION_TEXTURECOLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_COLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        case this.TYPE_POSITION_TEXTURE:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_UCOLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_TEXTURE_A8COLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            break;
        case this.TYPE_POSITION_UCOLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
            X.addAttribute(O, cc.VERTEX_ATTRIB_POSITION);
            break;
        case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
            X.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
            X.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            X.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
            X.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            break;
        default:
            cc.log(P);
            return;
        }
        X.link();
        X.updateUniforms();
    },
    loadDefaultShaders: function() {
        var X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = X;
        this._programs.ShaderPositionTextureColor = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = X;
        this._programs.ShaderPositionTextureColorAlphaTest = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = X;
        this._programs.ShaderPositionColor = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] = X;
        this._programs.ShaderPositionTexture = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = X;
        this._programs.ShaderPositionTextureUColor = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = X;
        this._programs.ShaderPositionTextureA8Color = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] = X;
        this._programs.ShaderPositionUColor = X;
        X = new cc.GLProgram;
        this._loadDefaultShader(X, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = X;
        this._programs.ShaderPositionLengthTextureColor = X;
    },
    reloadDefaultShaders: function() {
        var X = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURECOLOR);
        X = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        X = this.programForKey(cc.SHADER_POSITION_COLOR);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_COLOR);
        X = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE);
        X = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE_UCOLOR);
        X = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_TEXTURE_A8COLOR);
        X = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        X.reset();
        this._loadDefaultShader(X, this.TYPE_POSITION_UCOLOR);
    },
    programForKey: function(X) {
        return this._programs[X];
    },
    getProgram: function(X) {
        return this._programs[X];
    },
    addProgram: function(X, S) {
        this._programs[S] = X;
    }
};
H8m.B9y(H8m.U7H);
H8m.r9y(H8m.h7H);
H8m.Y9y(H8m.s7H);
H8m.J9y(H8m.v7H);
H8m.m9y(H8m.U7H);
H8m.R9y(H8m.h7H);
H8m.G9y(H8m.s7H);
H8m.E9y(H8m.v7H);
H8m.V9y(H8m.q7H);
H8m.v9y(H8m.b7H);
H8m.h9y(H8m.H7H);
H8m.U9y(H8m.y7H);
H8m.H9y(H8m.F7H);
H8m.q9y(H8m.X8P);
H8m.F9y(H8m.w8S);
H8m.I9y(H8m.w2H);
H8m.X1y(H8m.R5S);
H8m.L1y(H8m.Q1K);
H8m.K1y(H8m.n0K);
H8m.c1y(H8m.Q1P);
H8m.S1y(H8m.X1S);
H8m.t1y(H8m.k9P);
H8m.j1y(H8m.L6H);
H8m.a1y(H8m.Q8S);
H8m.e1y(H8m.H9K);
H8m.o1y(H8m.r3S);
H8m.B1y(H8m.F7i);
H8m.r1y(H8m.T0H);
H8m.Y1y(H8m.S9i);
H8m.J1y(H8m.j0H);
H8m.m1y(H8m.p3H);
H8m.R1y(H8m.o6i);
H8m.G1y(H8m.X1K);
cc.HashUniformEntry = function(X, S, P) {
    this.value = X;
    this.location = S;
    this.hh = P || {};
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(X, S, P) {
        if (H8m.q9B(null, X))
            return !1;
        P = !0;
        for (var O = null, Z = 0; H8m.l9B(Z, this._hashForUniforms.length); Z++)
            H8m.X1B(this._hashForUniforms[Z].location, X) && (O = this._hashForUniforms[Z]);
        O ? H8m.D1B(O.value, S) ? P = !1 : O.value = S : (O = new cc.HashUniformEntry, O.location = X, O.value = S, this._hashForUniforms.push(O));
        return P;
    },
    _description: function() {
        return "\x3cCCGLProgram \x3d " + this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e";
    },
    _compileShader: function(X, S, P) {
        if (!P || !X)
            return !1;
        this._glContext.shaderSource(X, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \n//CC INCLUDES END                \n" + P);
        this._glContext.compileShader(X);
        P = this._glContext.getShaderParameter(X, this._glContext.COMPILE_STATUS);
        P || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(X)), H8m.c1B(S, this._glContext.VERTEX_SHADER) ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return H8m.z1B(1, P);
    },
    ctor: function(X) {
        this._fragShader = this._vertShader = this._programObj = null;
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = X || cc._renderContext;
    },
    destroyProgram: function() {
        this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj);
    },
    initWithVertexShaderByteArray: function(X, S) {
        var P = this._glContext;
        this._programObj = P.createProgram();
        this._fragShader = this._vertShader = null;
        X && (this._vertShader = P.createShader(P.VERTEX_SHADER), this._compileShader(this._vertShader, P.VERTEX_SHADER, X) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        S && (this._fragShader = P.createShader(P.FRAGMENT_SHADER), this._compileShader(this._fragShader, P.FRAGMENT_SHADER, S) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && P.attachShader(this._programObj, this._vertShader);
        cc.CHECK_GL_ERROR_DEBUG();
        this._fragShader && P.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.CHECK_GL_ERROR_DEBUG();
        return !0;
    },
    initWithString: function(X, S) {
        return this.initWithVertexShaderByteArray(X, S);
    },
    initWithVertexShaderFilename: function(X, S) {
        var P = cc.loader.getRes(X);
        if (!P)
            throw "Please load the resource firset : " + X;
        var O = cc.loader.getRes(S);
        if (!O)
            throw "Please load the resource firset : " + S;
        return this.initWithVertexShaderByteArray(P, O);
    },
    init: function(X, S) {
        return this.initWithVertexShaderFilename(X, S);
    },
    addAttribute: function(X, S) {
        this._glContext.bindAttribLocation(this._programObj, S, X);
    },
    link: function() {
        if (!this._programObj)
            return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0;
    },
    use: function() {
        cc.glUseProgram(this._programObj);
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = H8m.j1B(null, this._uniforms[cc.UNIFORM_TIME]) || H8m.x1B(null, this._uniforms[cc.UNIFORM_SINTIME]) || H8m.o1B(null, this._uniforms[cc.UNIFORM_COSTIME]);
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0);
    },
    getUniformLocationForName: function(X) {
        if (!X)
            throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj)
            throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, X);
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX];
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER];
    },
    setUniformLocationWith1i: function(X, S) {
        this._updateUniformLocation(X, S) && this._glContext.uniform1i(X, S);
    },
    setUniformLocationWith2i: function(X, S, P) {
        this._updateUniformLocation(X, [S, P]) && this._glContext.uniform2i(X, S, P);
    },
    setUniformLocationWith3i: function(X, S, P, O) {
        this._updateUniformLocation(X, [S, P, O]) && this._glContext.uniform3i(X, S, P, O);
    },
    setUniformLocationWith4i: function(X, S, P, O, Z) {
        this._updateUniformLocation(X, [S, P, O, Z]) && this._glContext.uniform4i(X, S, P, O, Z);
    },
    setUniformLocationWith2iv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform2iv(X, S);
    },
    setUniformLocationWith3iv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform3iv(X, S);
    },
    setUniformLocationWith4iv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform4iv(X, S);
    },
    setUniformLocationI32: function(X, S) {
        this.setUniformLocationWith1i(X, S);
    },
    setUniformLocationWith1f: function(X, S) {
        this._updateUniformLocation(X, S) && this._glContext.uniform1f(X, S);
    },
    setUniformLocationWith2f: function(X, S, P) {
        this._updateUniformLocation(X, [S, P]) && this._glContext.uniform2f(X, S, P);
    },
    setUniformLocationWith3f: function(X, S, P, O) {
        this._updateUniformLocation(X, [S, P, O]) && this._glContext.uniform3f(X, S, P, O);
    },
    setUniformLocationWith4f: function(X, S, P, O, Z) {
        this._updateUniformLocation(X, [S, P, O, Z]) && this._glContext.uniform4f(X, S, P, O, Z);
    },
    setUniformLocationWith2fv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform2fv(X, S);
    },
    setUniformLocationWith3fv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform3fv(X, S);
    },
    setUniformLocationWith4fv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniform4fv(X, S);
    },
    setUniformLocationWithMatrix4fv: function(X, S, P) {
        this._updateUniformLocation(X, S) && this._glContext.uniformMatrix4fv(X, !1, S);
    },
    setUniformLocationF32: function() {
        if (!(H8m.p1B(2, arguments.length)))
            switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
            }
    },
    setUniformsForBuiltins: function() {
        var X = new cc.kmMat4,
            S = new cc.kmMat4,
            P = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, X);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, S);
        cc.kmMat4Multiply(P, X, S);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], X.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], S.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], P.mat, 1);
        this._usesTime && (X = cc.director, X = H8m.Y1B(X.getTotalFrames(), X.getAnimationInterval()), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], H8m.T1B(X, 10), X, H8m.R1B(2, X), H8m.M1B(4, X)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], H8m.V1B(X, 8), H8m.s1B(X, 4), H8m.U1B(X, 2), Math.sin(X)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], H8m.b1B(X, 8), H8m.F1B(X, 4), H8m.k8B(X, 2), Math.cos(X)));
        -1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top));
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(X) {
        cc.kmMat4Multiply(X, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, X.mat);
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat);
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader);
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader);
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj);
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj);
    },
    reset: function() {
        this._fragShader = this._vertShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var X = 0; H8m.L8B(X, this._hashForUniforms.length); X++)
            this._hashForUniforms[X].value = null, this._hashForUniforms[X] = null;
        this._hashForUniforms.length = 0;
    },
    getProgram: function() {
        return this._programObj;
    },
    retain: function() {},
    release: function() {}
});
cc.GLProgram.create = function(X, S) {
    var P = new cc.GLProgram;
    return P.init(X, S) ? P : H8m.H6P;
};
H8m.E1y(H8m.U7H);
H8m.V1y(H8m.h7H);
H8m.v1y(H8m.s7H);
H8m.h1y(H8m.q7H);
H8m.U1y();
H8m.y1y(H8m.U7H);
H8m.b1y();
H8m.q1y();
H8m.f1y();
H8m.F1y();
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = H8m.U9i, cc._currentShaderProgram = -H8m.h7H, cc._currentBoundTexture = [-H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H, -H8m.h7H], cc._blendingSource = -H8m.h7H, cc._blendingDest = -H8m.h7H, cc._GLServerState = H8m.U7H, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = H8m.U7H));
cc.glInvalidateStateCache = function() {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -H8m.h7H;
    cc._vertexAttribPosition = !H8m.h7H;
    cc._vertexAttribColor = !H8m.h7H;
    cc._vertexAttribTexCoords = !H8m.h7H;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -H8m.h7H;
        for (var X = H8m.U7H; H8m.i8B(X, cc.MAX_ACTIVETEXTURE); X++)
            cc._currentBoundTexture[X] = -H8m.h7H;
        cc._blendingSource = -H8m.h7H;
        cc._blendingDest = -H8m.h7H;
        cc._GLServerState = H8m.U7H;
    }
};
cc.glUseProgram = function(X) {
    H8m.S8B(X, cc._currentShaderProgram) && (cc._currentShaderProgram = X, cc._renderContext.useProgram(X));
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(X) {
    cc._renderContext.useProgram(X);
});
cc.glDeleteProgram = function(X) {
    cc.ENABLE_GL_STATE_CACHE && H8m.P8B(X, cc._currentShaderProgram) && (cc._currentShaderProgram = -H8m.h7H);
    gl.deleteProgram(X);
};
cc.glBlendFunc = function(X, S) {
    if (H8m.a8B(X, cc._blendingSource) || H8m.O8B(S, cc._blendingDest))
        cc._blendingSource = X, cc._blendingDest = S, cc.setBlending(X, S);
};
cc.setBlending = function(X, S) {
    var P = cc._renderContext;
    H8m.B8B(X, P.ONE) && H8m.Z8B(S, P.ZERO) ? P.disable(P.BLEND) : (P.enable(P.BLEND), cc._renderContext.blendFunc(X, S));
};
cc.glBlendFuncForParticle = function(X, S) {
    if (H8m.J8B(X, cc._blendingSource) || H8m.n8B(S, cc._blendingDest)) {
        cc._blendingSource = X;
        cc._blendingDest = S;
        var P = cc._renderContext;
        H8m.G8B(X, P.ONE) && H8m.W8B(S, P.ZERO) ? P.disable(P.BLEND) : (P.enable(P.BLEND), P.blendFuncSeparate(P.SRC_ALPHA, S, X, S));
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
    var X = cc._renderContext;
    X.blendEquation(X.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(X.BLEND_SRC, X.BLEND_DST);
};
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -H8m.h7H;
};
cc.glEnableVertexAttribs = function(X) {
    var S = cc._renderContext,
        P = H8m.v8B(X, cc.VERTEX_ATTRIB_FLAG_POSITION);
    H8m.u8B(P, cc._vertexAttribPosition) && (P ? S.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : S.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = P);
    P = H8m.H8B(X, cc.VERTEX_ATTRIB_FLAG_COLOR);
    H8m.f8B(P, cc._vertexAttribColor) && (P ? S.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : S.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = P);
    X &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    H8m.I8B(X, cc._vertexAttribTexCoords) && (X ? S.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : S.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = X);
};
cc.glBindTexture2D = function(X) {
    cc.glBindTexture2DN(H8m.U7H, X);
};
cc.glBindTexture2DN = function(X, S) {
    if (H8m.g4B(cc._currentBoundTexture[X], S)) {
        cc._currentBoundTexture[X] = S;
        var P = cc._renderContext;
        P.activeTexture(P.TEXTURE0 + X);
        S ? P.bindTexture(P.TEXTURE_2D, S._webTextureObj) : P.bindTexture(P.TEXTURE_2D, H8m.H6P);
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(X, S) {
    var P = cc._renderContext;
    P.activeTexture(P.TEXTURE0 + X);
    S ? P.bindTexture(P.TEXTURE_2D, S._webTextureObj) : P.bindTexture(P.TEXTURE_2D, H8m.H6P);
});
cc.glDeleteTexture = function(X) {
    cc.glDeleteTextureN(H8m.U7H, X);
};
cc.glDeleteTextureN = function(X, S) {
    cc.ENABLE_GL_STATE_CACHE && H8m.K4B(S, cc._currentBoundTexture[X]) && (cc._currentBoundTexture[X] = -H8m.h7H);
    cc._renderContext.deleteTexture(S);
};
cc.glBindVAO = function(X) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && H8m.d4B(cc._uVAO, X) && (cc._uVAO = X);
};
cc.glEnable = function(X) {};
H8m.l1y(H8m.U7H);
H8m.k8y(H8m.h7H);
H8m.g8y(H8m.s7H);
cc.NextPOT = function(X) {
    X -= H8m.h7H;
    X |= H8m.t4B(X, H8m.h7H);
    X |= H8m.w4B(X, H8m.s7H);
    X |= H8m.e4B(X, H8m.q7H);
    X |= H8m.Q4B(X, H8m.F7H);
    return (H8m.r4B(X, X >> H8m.U9i)) + H8m.h7H;
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _cacheCanvas: null,
    _cacheContext: null,
    _fBO: 0,
    _depthRenderBuffer: 0,
    _oldFBO: 0,
    _texture: null,
    _textureCopy: null,
    _uITextureImage: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    _clearColor: null,
    clearStencilVal: 0,
    _clearColorStr: null,
    _className: "RenderTexture",
    ctor: null,
    _ctorForCanvas: function() {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(255, 255, 255, 255);
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas = w6b0K[I0K]['createElement']("canvas");
        this._cacheContext = this._cacheCanvas.getContext("2d");
        this.anchorY = this.anchorX = 0;
    },
    _ctorForWebGL: function() {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(0, 0, 0, 0);
    },
    cleanup: null,
    _cleanupForCanvas: function() {
        cc.Node.prototype.onExit.call(this);
        this._cacheCanvas = this._cacheContext = null;
    },
    _cleanupForWebGL: function() {
        cc.Node.prototype.onExit.call(this);
        this._textureCopy = null;
        var X = cc._renderContext;
        X.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && X.deleteRenderbuffer(this._depthRenderBuffer);
        this._uITextureImage = null;
    },
    getSprite: function() {
        return this.sprite;
    },
    setSprite: function(X) {
        this.sprite = X;
    },
    initWithWidthAndHeight: null,
    _initWithWidthAndHeightForCanvas: function(X, S, P, O) {
        P = this._cacheCanvas;
        O = cc.CONTENT_SCALE_FACTOR();
        P.width = H8m.N4B(0, X * O);
        P.height = H8m.m4B(0, S * O);
        this._cacheContext.translate(0, P.height);
        X = new cc.Texture2D;
        X.initWithElement(P);
        X.handleLoadedTexture();
        this.sprite = cc.Sprite.create(X);
        return !0;
    },
    _initWithWidthAndHeightForWebGL: function(X, S, P, O) {
        H8m.A4B(P, cc.Texture2D.PIXEL_FORMAT_A8) && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var Z = cc._renderContext,
            Y = cc.CONTENT_SCALE_FACTOR();
        X = H8m.E4B(0, X * Y);
        S = H8m.C4B(0, S * Y);
        this._oldFBO = Z.getParameter(Z.FRAMEBUFFER_BINDING);
        var T;
        cc.configuration.supportsNPOT() ? (Y = X, T = S) : (Y = cc.NextPOT(X), T = cc.NextPOT(S));
        for (var R = new Uint8Array(H8m.h4B(Y, T, 4)), E = 0; H8m.H4B(E, Y * T * 4); E++)
            R[E] = 0;
        this._pixelFormat = P;
        this._texture = new cc.Texture2D;
        if (!this._texture)
            return !1;
        E = this._texture;
        E.initWithData(R, this._pixelFormat, Y, T, cc.size(X, S));
        P = Z.getParameter(Z.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy = new cc.Texture2D;
            if (!this._textureCopy)
                return !1;
            this._textureCopy.initWithData(R, this._pixelFormat, Y, T, cc.size(X, S));
        }
        this._fBO = Z.createFramebuffer();
        Z.bindFramebuffer(Z.FRAMEBUFFER, this._fBO);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_2D, E._webTextureObj, 0);
        H8m.f4B(0, O) && (this._depthRenderBuffer = Z.createRenderbuffer(), Z.bindRenderbuffer(Z.RENDERBUFFER, this._depthRenderBuffer), Z.renderbufferStorage(Z.RENDERBUFFER, O, Y, T), Z.framebufferRenderbuffer(Z.FRAMEBUFFER, Z.DEPTH_ATTACHMENT, Z.RENDERBUFFER, this._depthRenderBuffer));
        H8m.I4B(Z.checkFramebufferStatus(Z.FRAMEBUFFER), Z.FRAMEBUFFER_COMPLETE) && cc.log("Could not attach texture to the framebuffer");
        E.setAliasTexParameters();
        X = this.sprite = cc.Sprite.create(E);
        X.scaleY = -1;
        X.setBlendFunc(Z.ONE, Z.ONE_MINUS_SRC_ALPHA);
        Z.bindRenderbuffer(Z.RENDERBUFFER, P);
        Z.bindFramebuffer(Z.FRAMEBUFFER, this._oldFBO);
        this.autoDraw = !1;
        this.addChild(X);
        return !0;
    },
    begin: null,
    _beginForCanvas: function() {
        cc._renderContext = this._cacheContext;
        cc.view._setScaleXYForRenderTexture();
    },
    _beginForWebGL: function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var X = cc.director;
        X.setProjection(X.getProjection());
        var S = this._texture.getContentSizeInPixels(),
            P = cc.director.getWinSizeInPixels(),
            X = H8m.g7B(P.width, S.width),
            P = H8m.K7B(P.height, S.height),
            O = cc._renderContext;
        O.viewport(0, 0, S.width, S.height);
        S = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(S, -1 / X, H8m.d7B(1, X), -1 / P, H8m.t7B(1, P), -1, 1);
        cc.kmGLMultMatrix(S);
        this._oldFBO = O.getParameter(O.FRAMEBUFFER_BINDING);
        O.bindFramebuffer(O.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (O.framebufferTexture2D(O.FRAMEBUFFER, O.COLOR_ATTACHMENT0, O.TEXTURE_2D, this._textureCopy._webTextureObj, 0), O.clear(H8m.w7B(O.COLOR_BUFFER_BIT, O.DEPTH_BUFFER_BIT)), O.framebufferTexture2D(O.FRAMEBUFFER, O.COLOR_ATTACHMENT0, O.TEXTURE_2D, this._texture._webTextureObj, 0));
    },
    beginWithClear: function(X, S, P, O, Z, Y) {
        var T = cc._renderContext;
        Z = Z || T.COLOR_BUFFER_BIT;
        Y = Y || H8m.e7B(T.COLOR_BUFFER_BIT, T.DEPTH_BUFFER_BIT);
        this._beginWithClear(X, S, P, O, Z, Y, H8m.Q7B(T.COLOR_BUFFER_BIT, T.DEPTH_BUFFER_BIT, T.STENCIL_BUFFER_BIT));
    },
    _beginWithClear: null,
    _beginWithClearForCanvas: function(X, S, P, O, Z, Y, T) {
        this.begin();
        X = X || 0;
        S = S || 0;
        P = P || 0;
        O = isNaN(O) ? 1 : O;
        Z = this._cacheContext;
        Y = this._cacheCanvas;
        Z.save();
        Z.fillStyle = "rgba(" + (H8m.Z7B(0, X)) + "," + (H8m.J7B(0, S)) + "," + (H8m.n7B(0, P)) + "," + H8m.G7B(O, 255) + ")";
        Z.clearRect(0, 0, Y.width, -Y.height);
        Z.fillRect(0, 0, Y.width, -Y.height);
        Z.restore();
    },
    _beginWithClearForWebGL: function(X, S, P, O, Z, Y, T) {
        this.begin();
        var R = cc._renderContext,
            E = [0, 0, 0, 0],
            V = 0,
            U = 0;
        H8m.W7B(T, R.COLOR_BUFFER_BIT) && (E = R.getParameter(R.COLOR_CLEAR_VALUE), R.clearColor(X, S, P, O));
        H8m.v7B(T, R.DEPTH_BUFFER_BIT) && (V = R.getParameter(R.DEPTH_CLEAR_VALUE), R.clearDepth(Z));
        H8m.u7B(T, R.STENCIL_BUFFER_BIT) && (U = R.getParameter(R.STENCIL_CLEAR_VALUE), R.clearStencil(Y));
        R.clear(T);
        H8m.H7B(T, R.COLOR_BUFFER_BIT) && R.clearColor(E[0], E[1], E[2], E[3]);
        H8m.f7B(T, R.DEPTH_BUFFER_BIT) && R.clearDepth(V);
        H8m.I7B(T, R.STENCIL_BUFFER_BIT) && R.clearStencil(U);
    },
    end: null,
    _endForCanvas: function() {
        cc._renderContext = cc._mainRenderContextBackup;
        cc.view._resetScale();
    },
    _endForWebGL: function() {
        var X = cc._renderContext,
            S = cc.director;
        X.bindFramebuffer(X.FRAMEBUFFER, this._oldFBO);
        S.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix();
    },
    clear: function(X, S, P, O) {
        this.beginWithClear(X, S, P, O);
        this.end();
    },
    clearRect: null,
    _clearRectForCanvas: function(X, S, P, O) {
        this._cacheContext.clearRect(X, S, P, -O);
    },
    _clearRectForWebGL: function(X, S, P, O) {},
    clearDepth: null,
    _clearDepthForCanvas: function(X) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5");
    },
    _clearDepthForWebGL: function(X) {
        this.begin();
        var S = cc._renderContext,
            P = S.getParameter(S.DEPTH_CLEAR_VALUE);
        S.clearDepth(X);
        S.clear(S.DEPTH_BUFFER_BIT);
        S.clearDepth(P);
        this.end();
    },
    clearStencil: null,
    _clearStencilForCanvas: function(X) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5");
    },
    _clearStencilForWebGL: function(X) {
        var S = cc._renderContext,
            P = S.getParameter(S.STENCIL_CLEAR_VALUE);
        S.clearStencil(X);
        S.clear(S.STENCIL_BUFFER_BIT);
        S.clearStencil(P);
    },
    visit: null,
    _visitForCanvas: function(X) {
        this._visible && (X = X || cc._renderContext, X.save(), this.draw(X), this.transform(X), this.sprite.visit(), X.restore(), this.arrivalOrder = 0);
    },
    _visitForWebGL: function(X) {
        if (this._visible) {
            cc.kmGLPushMatrix();
            var S = this.grid;
            S && S.isActive() && (S.beforeDraw(), this.transformAncestors());
            this.transform(X);
            this.sprite.visit();
            this.draw(X);
            S && S.isActive() && S.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0;
        }
    },
    draw: null,
    _drawForCanvas: function(X) {
        X = X || cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            if (this.clearFlags) {
                var S = this._cacheCanvas;
                X.save();
                X.fillStyle = this._clearColorStr;
                X.clearRect(0, 0, S.width, -S.height);
                X.fillRect(0, 0, S.width, -S.height);
                X.restore();
            }
            this.sortAllChildren();
            X = this._children;
            for (var S = X.length, P = this.sprite, O = 0; H8m.g0B(O, S); O++) {
                var Z = X[O];
                H8m.K0B(Z, P) && Z.visit();
            }
            this.end();
        }
    },
    _drawForWebGL: function(X) {
        X = cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            var S = this.clearFlags;
            if (S) {
                var P = [0, 0, 0, 0],
                    O = 0,
                    Z = 0;
                H8m.d0B(S, X.COLOR_BUFFER_BIT) && (P = X.getParameter(X.COLOR_CLEAR_VALUE), X.clearColor(H8m.t0B(this._clearColor.r, 255), H8m.w0B(this._clearColor.g, 255), H8m.e0B(this._clearColor.b, 255), H8m.Q0B(this._clearColor.a, 255)));
                H8m.r0B(S, X.DEPTH_BUFFER_BIT) && (O = X.getParameter(X.DEPTH_CLEAR_VALUE), X.clearDepth(this.clearDepthVal));
                H8m.N0B(S, X.STENCIL_BUFFER_BIT) && (Z = X.getParameter(X.STENCIL_CLEAR_VALUE), X.clearStencil(this.clearStencilVal));
                X.clear(S);
                H8m.m0B(S, X.COLOR_BUFFER_BIT) && X.clearColor(P[0], P[1], P[2], P[3]);
                H8m.A0B(S, X.DEPTH_BUFFER_BIT) && X.clearDepth(O);
                H8m.E0B(S, X.STENCIL_BUFFER_BIT) && X.clearStencil(Z);
            }
            this.sortAllChildren();
            X = this._children;
            for (S = 0; H8m.C0B(S, X.length); S++)
                P = X[S], H8m.h0B(P, this.sprite) && P.visit();
            this.end();
        }
    },
    newCCImage: function(X) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null;
    },
    _memcpy: function(X, S, P, O, Z) {
        for (var Y = 0; H8m.y0B(Y, Z); Y++)
            X[S + Y] = P[O + Y];
    },
    saveToFile: function(X, S) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5");
    },
    listenToBackground: function(X) {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5");
    },
    listenToForeground: function(X) {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5");
    },
    getClearFlags: function() {
        return this.clearFlags;
    },
    setClearFlags: function(X) {
        this.clearFlags = X;
    },
    getClearColor: function() {
        return this._clearColor;
    },
    setClearColor: null,
    _setClearColorForCanvas: function(X) {
        var S = this._clearColor;
        S.r = X.r;
        S.g = X.g;
        S.b = X.b;
        S.a = X.a;
        this._clearColorStr = "rgba(" + (H8m.q0B(0, X.r)) + "," + (H8m.l0B(0, X.g)) + "," + (H8m.X3B(0, X.b)) + "," + H8m.D3B(X.a, 255) + ")";
    },
    _setClearColorForWebGL: function(X) {
        var S = this._clearColor;
        S.r = X.r;
        S.g = X.g;
        S.b = X.b;
        S.a = X.a;
    },
    getClearDepth: function() {
        return this.clearDepthVal;
    },
    setClearDepth: function(X) {
        this.clearDepthVal = X;
    },
    getClearStencil: function() {
        return this.clearStencilVal;
    },
    setClearStencil: function(X) {
        this.clearStencilVal = X;
    },
    isAutoDraw: function() {
        return this.autoDraw;
    },
    setAutoDraw: function(X) {
        this.autoDraw = X;
    }
});
w6b0K[q0K]._p = cc.RenderTexture.prototype;
H8m.c3B(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.ctor = _p._ctorForWebGL, _p.cleanup = _p._cleanupForWebGL, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL, _p.begin = _p._beginForWebGL, _p._beginWithClear = _p._beginWithClearForWebGL, _p.end = _p._endForWebGL, _p.clearRect = _p._clearRectForWebGL, _p.clearDepth = _p._clearDepthForWebGL, _p.clearStencil = _p._clearStencilForWebGL, _p.visit = _p._visitForWebGL, _p.draw = _p._drawForWebGL, _p.setClearColor = _p._setClearColorForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.cleanup = _p._cleanupForCanvas, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas, _p.begin = _p._beginForCanvas, _p._beginWithClear = _p._beginWithClearForCanvas, _p.end = _p._endForCanvas, _p.clearRect = _p._clearRectForCanvas, _p.clearDepth = _p._clearDepthForCanvas, _p.clearStencil = _p._clearStencilForCanvas, _p.visit = _p._visitForCanvas, _p.draw = _p._drawForCanvas, _p.setClearColor = _p._setClearColorForCanvas);
cc.defineGetterSetter(_p, H8m.w4i, _p.getClearColor, _p.setClearColor);
delete w6b0K[q0K]._p;
cc.RenderTexture.create = function(X, S, P, O) {
    P = P || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
    O = O || H8m.U7H;
    var Z = new cc.RenderTexture;
    return Z && Z.initWithWidthAndHeight(X, S, P, O) ? Z : H8m.H6P;
};
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelAtlas",
    ctor: function() {
        cc.AtlasNode.prototype.ctor.call(this);
    },
    textureLoaded: function() {
        return this._textureLoaded;
    },
    addLoadedEventListener: function(X, S) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            this._textureLoaded = !0;
            for (var X = this._loadedEventListeners, S = 0, P = X.length; H8m.z3B(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    },
    initWithString: function(S, P, O, Z, Y) {
        var T = S + "",
            R,
            E,
            V,
            U;
        if (H8m.j3B(2, arguments.length)) {
            U = cc.loader.getRes(P);
            if (H8m.x3B(1, parseInt(U.version, 10)))
                return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            R = cc.path.changeBasename(P, U.textureFilename);
            var k9 = cc.CONTENT_SCALE_FACTOR();
            E = H8m.o3B(parseInt(U.itemWidth, 10), k9);
            V = H8m.p3B(parseInt(U.itemHeight, 10), k9);
            U = String.fromCharCode(parseInt(U.firstChar, 10));
        } else
            R = P, E = O || 0, V = Z || 0, U = Y || " ";
        var L9 = null,
            L9 = H8m.Y3B(R, cc.Texture2D) ? R : cc.textureCache.addImage(R);
        (this._textureLoaded = R = L9.isLoaded()) || L9.addLoadedEventListener(function(X) {
            this.initWithTexture(L9, E, V, T.length);
            this.string = T;
            this._callLoadedEventCallbacks();
        }, this);
        return this.initWithTexture(L9, E, V, T.length) ? (this._mapStartChar = U, this.string = T, !0) : !1;
    },
    setColor: function(X) {
        cc.AtlasNode.prototype.setColor.call(this, X);
        this.updateAtlasValues();
    },
    getString: function() {
        return this._string;
    },
    draw: function(X) {
        cc.AtlasNode.prototype.draw.call(this, X);
        cc.LABELATLAS_DEBUG_DRAW && (X = this.size, X = [cc.p(0, 0), cc.p(X.width, 0), cc.p(X.width, X.height), cc.p(0, X.height)], cc._drawingUtil.drawPoly(X, 4, !0));
    },
    updateAtlasValues: null,
    _updateAtlasValuesForCanvas: function() {
        for (var X = this._string, S = X.length, P = this.texture, O = this._itemWidth, Z = this._itemHeight, Y = 0; H8m.T3B(Y, S); Y++) {
            var T = H8m.R3B(X.charCodeAt(Y), this._mapStartChar.charCodeAt(0)),
                R = parseInt(H8m.M3B(T, this._itemsPerRow), 10),
                T = parseInt(H8m.V3B(T, this._itemsPerRow), 10),
                R = cc.rect(H8m.s3B(R, O), H8m.U3B(T, Z), O, Z),
                T = X.charCodeAt(Y),
                E = this.getChildByTag(Y);
            E ? H8m.b3B(32, T) ? (E.init(), E.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (E.initWithTexture(P, R), E.visible = !0, E.opacity = this._displayedOpacity) : (E = new cc.Sprite, H8m.F3B(32, T) ? (E.init(), E.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : E.initWithTexture(P, R), this.addChild(E, 0, Y));
            E.setPosition(H8m.k5B(Y, O) + H8m.L5B(O, 2), H8m.i5B(Z, 2));
        }
    },
    _updateAtlasValuesForWebGL: function() {
        var X = this._string,
            S = X.length,
            P = this.textureAtlas,
            O = P.texture,
            Z = O.pixelsWidth,
            O = O.pixelsHeight,
            Y = this._itemWidth,
            T = this._itemHeight;
        this._ignoreContentScaleFactor || (Y = H8m.S5B(this._itemWidth, cc.CONTENT_SCALE_FACTOR()), T = H8m.P5B(this._itemHeight, cc.CONTENT_SCALE_FACTOR()));
        H8m.a5B(S, P.getCapacity()) && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var R = P.quads, E = this._displayedColor, E = {
                r: E.r,
                g: E.g,
                b: E.b,
                a: this._displayedOpacity
            }, V = this._itemWidth, U = 0; H8m.O5B(U, S); U++) {
            var k9 = H8m.B5B(X.charCodeAt(U), this._mapStartChar.charCodeAt(0)),
                L9 = H8m.Z5B(k9, this._itemsPerRow),
                K9 = H8m.J5B(0, k9 / this._itemsPerRow),
                c9;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (L9 = H8m.n5B((2 * L9 * Y + 1), (2 * Z)), k9 = L9 + H8m.G5B((2 * Y - 2), (2 * Z)), K9 = H8m.W5B((2 * K9 * T + 1), (2 * O)), c9 = K9 + H8m.v5B((2 * T - 2), (2 * O))) : (L9 = H8m.u5B(L9, Y, Z), k9 = L9 + H8m.b5B(Y, Z), K9 = H8m.F5B(K9, T, O), c9 = K9 + H8m.X6B(T, O));
            var t9 = R[U],
                S9 = t9.tl,
                j9 = t9.tr,
                a9 = t9.bl,
                t9 = t9.br;
            S9.texCoords.u = L9;
            S9.texCoords.v = K9;
            j9.texCoords.u = k9;
            j9.texCoords.v = K9;
            a9.texCoords.u = L9;
            a9.texCoords.v = c9;
            t9.texCoords.u = k9;
            t9.texCoords.v = c9;
            a9.vertices.x = H8m.D6B(U, V);
            a9.vertices.y = 0;
            a9.vertices.z = 0;
            t9.vertices.x = H8m.c6B(U, V) + V;
            t9.vertices.y = 0;
            t9.vertices.z = 0;
            S9.vertices.x = H8m.z6B(U, V);
            S9.vertices.y = this._itemHeight;
            S9.vertices.z = 0;
            j9.vertices.x = H8m.j6B(U, V) + V;
            j9.vertices.y = this._itemHeight;
            j9.vertices.z = 0;
            S9.colors = E;
            j9.colors = E;
            a9.colors = E;
            t9.colors = E;
        }
        H8m.x6B(0, S) && (P.dirty = !0, X = P.totalQuads, H8m.o6B(S, X) && P.increaseTotalQuadsWith(H8m.p6B(S, X)));
    },
    setString: null,
    _setStringForCanvas: function(X) {
        X = String(X);
        var S = X.length;
        this._string = X;
        this.width = H8m.Y6B(S, this._itemWidth);
        this.height = this._itemHeight;
        if (this._children) {
            X = this._children;
            for (var S = X.length, P = 0; H8m.T6B(P, S); P++) {
                var O = X[P];
                O && (O.visible = !1);
            }
        }
        this.updateAtlasValues();
        this.quadsToDraw = S;
    },
    _setStringForWebGL: function(X) {
        X = String(X);
        var S = X.length;
        H8m.R6B(S, this.textureAtlas.totalQuads) && this.textureAtlas.resizeCapacity(S);
        this._string = X;
        this.width = H8m.M6B(S, this._itemWidth);
        this.height = this._itemHeight;
        this.updateAtlasValues();
        this.quadsToDraw = S;
    },
    setOpacity: null,
    _setOpacityForCanvas: function(X) {
        if (H8m.V6B(this._displayedOpacity, X)) {
            cc.AtlasNode.prototype.setOpacity.call(this, X);
            for (var S = this._children, P = 0, O = S.length; H8m.s6B(P, O); P++)
                S[P] && (S[P].opacity = X);
        }
    },
    _setOpacityForWebGL: function(X) {
        H8m.U6B(this._opacity, X) && cc.AtlasNode.prototype.setOpacity.call(this, X);
    }
});
w6b0K[q0K]._p = cc.LabelAtlas.prototype;
H8m.b6B(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.updateAtlasValues = _p._updateAtlasValuesForWebGL, _p.setString = _p._setStringForWebGL, _p.setOpacity = _p._setOpacityForWebGL) : (_p.updateAtlasValues = _p._updateAtlasValuesForCanvas, _p.setString = _p._setStringForCanvas, _p.setOpacity = _p._setOpacityForCanvas);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.u6P, _p.getString, _p.setString);
delete w6b0K[q0K]._p;
cc.LabelAtlas.create = function(X, S, P, O, Z) {
    var Y = new cc.LabelAtlas;
    return Y && cc.LabelAtlas.prototype.initWithString.apply(Y, arguments) ? Y : H8m.H6P;
};
H8m.D8y();
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    RGBAProtocol: !0,
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !0,
    _cascadeOpacityEnabled: !0,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelBMFont",
    _setString: function(X, S) {
        S ? this._initialString = X : this._string = X;
        var P = this._children;
        if (P)
            for (var O = 0; H8m.F6B(O, P.length); O++) {
                var Z = P[O];
                Z && Z.setVisible(!1);
            }
        this._textureLoaded && (this.createFontChars(), S && this.updateLabel());
    },
    ctor: function() {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._reusedChar = [];
    },
    textureLoaded: function() {
        return this._textureLoaded;
    },
    addLoadedEventListener: function(X, S) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: X,
            eventTarget: S
        });
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var X = this._loadedEventListeners, S = 0, P = X.length; H8m.k2B(S, P); S++) {
                var O = X[S];
                O.eventCallback.call(O.eventTarget, this);
            }
            X.length = 0;
        }
    },
    draw: function(X) {
        cc.SpriteBatchNode.prototype.draw.call(this, X);
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            X = this.getContentSize();
            var S = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            X = [cc.p(S.x, S.y), cc.p(S.x + X.width, S.y), cc.p(S.x + X.width, S.y + X.height), cc.p(S.x, S.y + X.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(X, 4, !0);
        }
    },
    setColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        if (H8m.L2B(P.r, X.r) || H8m.i2B(P.g, X.g) || H8m.S2B(P.b, X.b) || H8m.P2B(P.a, X.a))
            S.r = P.r = X.r, S.g = P.g = X.g, S.b = P.b = X.b, this._textureLoaded && this._cascadeColorEnabled && (S = cc.color.WHITE, (P = this._parent) && P.RGBAProtocol && P.cascadeColor && (S = P.getDisplayedColor()), this.updateDisplayedColor(S)), void 0 === X.a || X.a_undefined || this.setOpacity(X.a);
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
    },
    setOpacityModifyRGB: function(X) {
        this._opacityModifyRGB = X;
        if (X = this._children)
            for (var S = 0; H8m.a2B(S, X.length); S++) {
                var P = X[S];
                P && P.RGBAProtocol && (P.opacityModifyRGB = this._opacityModifyRGB);
            }
    },
    getOpacity: function() {
        return this._realOpacity;
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity;
    },
    setOpacity: function(X) {
        this._displayedOpacity = this._realOpacity = X;
        if (this._cascadeOpacityEnabled) {
            var S = 255,
                P = this._parent;
            P && P.RGBAProtocol && P.cascadeOpacity && (S = P.getDisplayedOpacity());
            this.updateDisplayedOpacity(S);
        }
        this._displayedColor.a = this._realColor.a = X;
    },
    updateDisplayedOpacity: function(X) {
        this._displayedOpacity = H8m.O2B(this._realOpacity, X, 255);
        X = this._children;
        for (var S = 0; H8m.p2B(S, X.length); S++) {
            var P = X[S];
            H8m.Y2B(cc._renderType, cc._RENDER_TYPE_WEBGL) ? P.updateDisplayedOpacity(this._displayedOpacity) : (cc.NodeRGBA.prototype.updateDisplayedOpacity.call(P, this._displayedOpacity), P.setNodeDirty());
        }
        this._changeTextureColor();
    },
    isCascadeOpacityEnabled: function() {
        return !1;
    },
    setCascadeOpacityEnabled: function(X) {
        this._cascadeOpacityEnabled = X;
    },
    getColor: function() {
        var X = this._realColor;
        return cc.color(X.r, X.g, X.b, X.a);
    },
    getDisplayedColor: function() {
        return this._displayedColor;
    },
    updateDisplayedColor: function(X) {
        var S = this._displayedColor,
            P = this._realColor;
        S.r = H8m.T2B(P.r, X.r, 255);
        S.g = H8m.A2B(P.g, X.g, 255);
        S.b = H8m.W2B(P.b, X.b, 255);
        X = this._children;
        for (S = 0; H8m.s2B(S, X.length); S++)
            P = X[S], H8m.U2B(cc._renderType, cc._RENDER_TYPE_WEBGL) ? P.updateDisplayedColor(this._displayedColor) : (cc.NodeRGBA.prototype.updateDisplayedColor.call(P, this._displayedColor), P.setNodeDirty());
        this._changeTextureColor();
    },
    _changeTextureColor: function() {
        if (H8m.b2B(cc._renderType, cc._RENDER_TYPE_WEBGL)) {
            var X,
                S = this.texture;
            S && H8m.F2B(0, S.width) && (X = S.getHtmlElementObj()) && (S = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (H8m.k9m(X, HTMLCanvasElement) && !this._rectRotated ? cc.generateTintImage(X, S, this._displayedColor, null, X) : (X = cc.generateTintImage(X, S, this._displayedColor), S = new cc.Texture2D, S.initWithElement(X), S.handleLoadedTexture(), this.texture = S));
        }
    },
    isCascadeColorEnabled: function() {
        return !1;
    },
    setCascadeColorEnabled: function(X) {
        this._cascadeColorEnabled = X;
    },
    init: function() {
        return this.initWithString(null, null, null, null, null);
    },
    initWithString: function(S, P, O, Z, Y) {
        S = S || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (P) {
            var T = cc.loader.getRes(P);
            if (!T)
                return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = T;
            this._fntFile = P;
            P = cc.textureCache.addImage(T.atlasName);
            (this._textureLoaded = T = P.isLoaded()) || P.addLoadedEventListener(function(X) {
                this._textureLoaded = !0;
                this.initWithTexture(X, this._initialString.length);
                this.setString(this._initialString, !0);
                this._callLoadedEventCallbacks();
            }, this);
        } else
            P = new cc.Texture2D, T = new Image, P.initWithElement(T), this._textureLoaded = !1;
        return this.initWithTexture(P, S.length) ? (this._alignment = Z || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = Y || cc.p(0, 0), this._width = H8m.L9m(null, O) ? -1 : O, this._displayedOpacity = this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = this._cascadeOpacityEnabled = !0, this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), H8m.i9m(cc._renderType, cc._RENDER_TYPE_WEBGL) && (O = this.textureAtlas.texture, this._opacityModifyRGB = O.hasPremultipliedAlpha(), Z = this._reusedChar = new cc.Sprite, Z.initWithTexture(O, cc.rect(0, 0, 0, 0), !1), Z.batchNode = this), this.setString(S, !0), !0) : !1;
    },
    createFontChars: function() {
        var X = cc._renderType,
            S = H8m.S9m(X, cc._RENDER_TYPE_CANVAS) ? this.texture : this.textureAtlas.texture,
            P = 0,
            O = cc.size(0, 0),
            Z = 0,
            Y = 1,
            T = this._string,
            R = T ? T.length : 0;
        if (H8m.P9m(0, R)) {
            var E,
                V = this._config,
                U = V.kerningDict,
                k9 = V.commonHeight,
                L9 = V.fontDefDictionary;
            for (E = 0; H8m.a9m(E, R - 1); E++)
                H8m.O9m(10, T.charCodeAt(E)) && Y++;
            var K9 = H8m.B9m(k9, Y),
                Y = -(H8m.Z9m(k9, k9 * Y)),
                c9 = -1;
            for (E = 0; H8m.J9m(E, R); E++)
                if (k9 = T.charCodeAt(E), H8m.n9m(0, k9))
                    if (H8m.G9m(10, k9))
                        P = 0, Y -= V.commonHeight;
                    else {
                        var t9 = U[H8m.W9m(c9 << 16, k9 & 65535)] || 0,
                            S9 = L9[k9];
                        if (S9) {
                            var j9 = cc.rect(S9.rect.x, S9.rect.y, S9.rect.width, S9.rect.height),
                                j9 = cc.RECT_PIXELS_TO_POINTS(j9);
                            j9.x += this._imageOffset.x;
                            j9.y += this._imageOffset.y;
                            (c9 = this.getChildByTag(E)) ? H8m.v9m(32, k9) && H8m.u9m(X, cc._RENDER_TYPE_CANVAS) ? c9.setTextureRect(j9, !1, cc.size(0, 0)) : (c9.setTextureRect(j9, !1), c9.visible = !0) : (c9 = new cc.Sprite, H8m.H9m(32, k9) && H8m.f9m(X, cc._RENDER_TYPE_CANVAS) && (j9 = cc.rect(0, 0, 0, 0)), c9.initWithTexture(S, j9, !1), c9._newTextureWhenChangeColor = !0, this.addChild(c9, 0, E));
                            c9.opacityModifyRGB = this._opacityModifyRGB;
                            H8m.I9m(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (c9.updateDisplayedColor(this._displayedColor), c9.updateDisplayedOpacity(this._displayedOpacity)) : (cc.NodeRGBA.prototype.updateDisplayedColor.call(c9, this._displayedColor), cc.NodeRGBA.prototype.updateDisplayedOpacity.call(c9, this._displayedOpacity), c9.setNodeDirty());
                            j9 = cc.p(P + S9.xOffset + H8m.g1m(0.5, S9.rect.width) + t9, Y + (H8m.K1m(V.commonHeight, S9.yOffset)) - H8m.d1m(0.5, j9.height, cc.CONTENT_SCALE_FACTOR()));
                            c9.setPosition(cc.POINT_PIXELS_TO_POINTS(j9));
                            P += S9.xAdvance + t9;
                            c9 = k9;
                            H8m.P1m(Z, P) && (Z = P);
                        } else
                            cc.log("cocos2d: LabelBMFont: character not found " + T[E]);
                    }
            O.width = Z;
            O.height = K9;
            this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(O));
        }
    },
    updateString: function(X) {
        var S = this._children;
        if (S)
            for (var P = 0, O = S.length; H8m.a1m(P, O); P++) {
                var Z = S[P];
                Z && (Z.visible = !1);
            }
        this._config && this.createFontChars();
        X || this.updateLabel();
    },
    getString: function() {
        return this._initialString;
    },
    setString: function(X, S) {
        X = String(X);
        H8m.O1m(null, S) && (S = !0);
        if (H8m.B1m(null, X) || "string" != typeof X)
            X += "";
        this._initialString = X;
        this._setString(X, S);
    },
    _setStringForSetter: function(X) {
        this.setString(X, !1);
    },
    setCString: function(X) {
        this.setString(X, !0);
    },
    updateLabel: function() {
        this.string = this._initialString;
        if (H8m.Z1m(0, this._width)) {
            for (var X = this._string.length, S = [], P = [], O = 1, Z = 0, Y = !1, T = !1, R = -1, E = -1, V = 0, U, k9 = 0, L9 = this._children.length; H8m.J1m(k9, L9); k9++) {
                for (var K9 = 0; !(U = this.getChildByTag(k9 + V + K9));)
                    K9++;
                V += K9;
                if (H8m.n1m(Z, X))
                    break;
                var c9 = this._string[Z];
                T || (E = this._getLetterPosXLeft(U), T = !0);
                Y || (R = E, Y = !0);
                if (H8m.G1m(10, c9.charCodeAt(0))) {
                    P.push("\n");
                    S = S.concat(P);
                    P.length = 0;
                    Y = T = !1;
                    R = E = -1;
                    Z += K9;
                    O++;
                    if (H8m.W1m(Z, X))
                        break;
                    E || (E = this._getLetterPosXLeft(U), T = !0);
                    R || (R = E, Y = !0);
                    Z++;
                } else if (cc.isspace_unicode(c9))
                    P.push(c9), S = S.concat(P), P.length = 0, T = !1, E = -1, Z++;
                else if (H8m.v1m(this._getLetterPosXRight(U) - R, this._width))
                    if (this._lineBreakWithoutSpaces) {
                        cc.utf8_trim_ws(P);
                        P.push("\n");
                        S = S.concat(P);
                        P.length = 0;
                        Y = T = !1;
                        R = E = -1;
                        O++;
                        if (H8m.u1m(Z, X))
                            break;
                        E || (E = this._getLetterPosXLeft(U), T = !0);
                        R || (R = E, Y = !0);
                        k9--;
                    } else
                        P.push(c9), -1 != S.lastIndexOf(" ") ? cc.utf8_trim_ws(S) : S = [], H8m.H1m(0, S.length) && S.push("\n"), O++, Y = !1, R = -1, Z++;
                else
                    P.push(c9), Z++;
            }
            S = S.concat(P);
            k9 = S.length;
            U = "";
            for (Z = 0; H8m.f1m(Z, k9); ++Z)
                U += S[Z];
            U += String.fromCharCode(0);
            this._setString(U, !1);
        }
        if (H8m.I1m(this._alignment, cc.TEXT_ALIGNMENT_LEFT))
            for (S = Z = 0, X = this._string.length, P = [], O = 0; H8m.g8m(O, X); O++)
                if (H8m.K8m(10, this._string[O].charCodeAt(0)) || H8m.d8m(0, this._string[O].charCodeAt(0))) {
                    if (k9 = 0, Y = P.length, U = Z + Y - 1 + S, !(H8m.t8m(0, U)) && (k9 = this.getChildByTag(U), H8m.w8m(null, k9))) {
                        k9 = k9.getPositionX() + H8m.e8m(k9._getWidth(), 2);
                        T = 0;
                        switch (this._alignment) {
                        case cc.TEXT_ALIGNMENT_CENTER:
                            T = H8m.Q8m(this.width / 2, k9 / 2);
                            break;
                        case cc.TEXT_ALIGNMENT_RIGHT:
                            T = H8m.r8m(this.width, k9);
                        }
                        if (H8m.N8m(0, T))
                            for (k9 = 0; H8m.m8m(k9, Y); k9++)
                                (U = Z + k9 + S, H8m.A8m(0, U) || !(U = this.getChildByTag(U))) || (U.x += T);
                        Z += Y;
                        S++;
                        P.length = 0;
                    }
                } else
                    P.push(this._string[Z]);
    },
    setAlignment: function(X) {
        this._alignment = X;
        this.updateLabel();
    },
    _getAlignment: function() {
        return this._alignment;
    },
    setBoundingWidth: function(X) {
        this._width = X;
        this.updateLabel();
    },
    _getBoundingWidth: function() {
        return this._width;
    },
    setLineBreakWithoutSpace: function(X) {
        this._lineBreakWithoutSpaces = X;
        this.updateLabel();
    },
    setScale: function(X, S) {
        cc.Node.prototype.setScale.call(this, X, S);
        this.updateLabel();
    },
    setScaleX: function(X) {
        cc.Node.prototype.setScaleX.call(this, X);
        this.updateLabel();
    },
    setScaleY: function(X) {
        cc.Node.prototype.setScaleY.call(this, X);
        this.updateLabel();
    },
    setFntFile: function(S) {
        if (H8m.E8m(null, S) && H8m.C8m(S, this._fntFile)) {
            var P = cc.loader.getRes(S);
            P ? (this._fntFile = S, this._config = P, S = cc.textureCache.addImage(P.atlasName), this._textureLoaded = P = S.isLoaded(), this.texture = S, H8m.h8m(cc._renderType, cc._RENDER_TYPE_CANVAS) && (this._originalTexture = this.texture), P ? this.createFontChars() : S.addLoadedEventListener(function(X) {
                this._textureLoaded = !0;
                this.texture = X;
                this.createFontChars();
                this._changeTextureColor();
                this.updateLabel();
                this._callLoadedEventCallbacks();
            }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file");
        }
    },
    getFntFile: function() {
        return this._fntFile;
    },
    setAnchorPoint: function(X, S) {
        cc.Node.prototype.setAnchorPoint.call(this, X, S);
        this.updateLabel();
    },
    _setAnchor: function(X) {
        cc.Node.prototype._setAnchor.call(this, X);
        this.updateLabel();
    },
    _setAnchorX: function(X) {
        cc.Node.prototype._setAnchorX.call(this, X);
        this.updateLabel();
    },
    _setAnchorY: function(X) {
        cc.Node.prototype._setAnchorY.call(this, X);
        this.updateLabel();
    },
    _atlasNameFromFntFile: function(X) {},
    _kerningAmountForFirst: function(X, S) {
        var P = 0;
        if (this._configuration.kerningDictionary) {
            var O = this._configuration.kerningDictionary[(H8m.y8m(X << 16, S & 65535)).toString()];
            O && (P = O.amount);
        }
        return P;
    },
    _getLetterPosXLeft: function(X) {
        return H8m.f8m(X.getPositionX(), this._scaleX) + H8m.I8m(X._getWidth(), this._scaleX, X._getAnchorX());
    },
    _getLetterPosXRight: function(X) {
        return H8m.L4m(X.getPositionX() * this._scaleX, X._getWidth() * this._scaleX * X._getAnchorX());
    }
});
w6b0K[q0K]._p = cc.LabelBMFont.prototype;
cc.defineGetterSetter(_p, H8m.R0K, _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, H8m.E4P, _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, H8m.H9S, _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
cc.defineGetterSetter(_p, H8m.r1S, _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, H8m.t4P, _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
cc.defineGetterSetter(_p, H8m.u6P, _p.getString, _p._setStringForSetter);
cc.defineGetterSetter(_p, H8m.T6P, _p._getBoundingWidth, _p.setBoundingWidth);
cc.defineGetterSetter(_p, H8m.c1P, _p._getAlignment, _p.setAlignment);
delete w6b0K[q0K]._p;
cc.LabelBMFont.create = function(X, S, P, O, Z) {
    var Y = new cc.LabelBMFont;
    return void H8m.U7H === X ? Y && Y.init() ? Y : H8m.H6P : Y && Y.initWithString(X, S, P, O, Z) ? Y : H8m.H6P;
};
cc.isspace_unicode = function(X) {
    var S = 8287,
        P = 8239,
        O = 8233,
        Z = 8232,
        Y = 8202,
        T = ((6.65E2, 67) >= (3.95E2, 0x17E) ? (109., 144.) : (0x157, 0xE6) >= (0x12A, 141) ? (12.52E2, 5760) : (0x1F7, 7.7E1));
    X = X.charCodeAt(H8m.U7H);
    return H8m.i4m(H8m.f7H, X) && H8m.S4m(H8m.b9i, X) || H8m.P4m(H8m.J9i, X) || H8m.a4m(H8m.n3S, X) || H8m.O4m(H8m.N7S, X) || H8m.B4m(T, X) || H8m.Z4m(H8m.H5S, X) && H8m.J4m(Y, X) || H8m.n4m(Z, X) || H8m.G4m(O, X) || H8m.W4m(P, X) || H8m.v4m(S, X) || H8m.u4m(H8m.x8K, X);
};
cc.utf8_trim_ws = function(X) {
    var S = X.length;
    if (!(H8m.H4m(0, S)) && (S -= 1, cc.isspace_unicode(X[S]))) {
        for (var P = H8m.f4m(S, 1); H8m.I4m(0, P); --P)
            if (cc.isspace_unicode(X[P]))
                S = P;
            else
                break;
        cc.utf8_trim_from(X, S);
    }
};
cc.utf8_trim_from = function(X, S) {
    var P = X.length;
    H8m.g7m(S, P) || H8m.K7m(0, S) || X.splice(S, P);
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(X) {
        X = X.match(this.ITEM_EXP);
        var S = {};
        if (X)
            for (var P = 0, O = X.length; H8m.d7m(P, O); P++) {
                var Z = X[P],
                    Y = Z.indexOf("\x3d"),
                    T = Z.substring(0, Y),
                    Z = Z.substring(Y + 1);
                Z.match(this.INT_EXP) ? Z = parseInt(Z) : H8m.t7m('"', Z[0]) && (Z = Z.substring(1, H8m.w7m(Z.length, 1)));
                S[T] = Z;
            }
        return S;
    },
    parseFnt: function(X, S) {
        var P = {},
            O = this._parseStrToObj(X.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(O[0]);
        parseInt(O[1]);
        parseInt(O[2]);
        parseInt(O[3]);
        O = this._parseStrToObj(X.match(this.COMMON_EXP)[0]);
        P.commonHeight = O.lineHeight;
        if (H8m.e7m(cc._renderType, cc._RENDER_TYPE_WEBGL)) {
            var Z = cc.configuration.getMaxTextureSize();
            (H8m.Q7m(O.scaleW, Z.width) || H8m.r7m(O.scaleH, Z.height)) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported");
        }
        H8m.N7m(1, O.pages) && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        O = this._parseStrToObj(X.match(this.PAGE_EXP)[0]);
        H8m.m7m(0, O.id) && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        P.atlasName = cc.path.changeBasename(S, O.file);
        for (var Y = X.match(this.CHAR_EXP), T = P.fontDefDictionary = {}, O = 0, Z = Y.length; H8m.A7m(O, Z); O++) {
            var R = this._parseStrToObj(Y[O]);
            T[R.id] = {
                rect: {
                    x: R.x,
                    y: R.y,
                    width: R.width,
                    height: R.height
                },
                xOffset: R.xoffset,
                yOffset: R.yoffset,
                xAdvance: R.xadvance
            };
        }
        Y = P.kerningDict = {};
        if (T = X.match(this.KERNING_EXP))
            for (O = 0, Z = T.length; H8m.E7m(O, Z); O++)
                R = this._parseStrToObj(T[O]), Y[H8m.C7m(R.first << 16, R.second & 65535)] = R.amount;
        return P;
    },
    load: function(P, O, Z, Y) {
        var T = this;
        cc.loader.loadTxt(P, function(X, S) {
            if (X)
                return Y(X);
            Y(null, T.parseFnt(S, O));
        });
    }
};
cc.loader.register([H8m.D1i], cc._fntLoader);
cc.MotionStreak = cc.NodeRGBA.extend({
    texture: H8m.H6P,
    fastMode: !H8m.h7H,
    startingPositionInitialized: !H8m.h7H,
    _blendFunc: H8m.H6P,
    _stroke: H8m.U7H,
    _fadeDelta: H8m.U7H,
    _minSeg: H8m.U7H,
    _maxPoints: H8m.U7H,
    _nuPoints: H8m.U7H,
    _previousNuPoints: H8m.U7H,
    _pointVertexes: H8m.H6P,
    _pointState: H8m.H6P,
    _vertices: H8m.H6P,
    _colorPointer: H8m.H6P,
    _texCoords: H8m.H6P,
    _verticesBuffer: H8m.H6P,
    _colorPointerBuffer: H8m.H6P,
    _texCoordsBuffer: H8m.H6P,
    _className: H8m.q3i,
    ctor: function() {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._positionR = cc.p(H8m.U7H, H8m.U7H);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this.startingPositionInitialized = this.fastMode = !H8m.h7H;
        this.texture = H8m.H6P;
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = H8m.U7H;
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = H8m.H6P;
    },
    getTexture: function() {
        return this.texture;
    },
    setTexture: function(X) {
        H8m.h7m(this.texture, X) && (this.texture = X);
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    setBlendFunc: function(X, S) {
        void H8m.U7H === S ? this._blendFunc = X : (this._blendFunc.src = X, this._blendFunc.dst = S);
    },
    getOpacity: function() {
        var X = "cc.MotionStreak.getOpacity has not been supported.";
        cc.log(X);
        return H8m.U7H;
    },
    setOpacity: function(X) {
        var S = "cc.MotionStreak.setOpacity has not been supported.";
        cc.log(S);
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !H8m.h7H;
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._verticesBuffer && cc._renderContext.deleteBuffer(this._verticesBuffer);
        this._texCoordsBuffer && cc._renderContext.deleteBuffer(this._texCoordsBuffer);
        this._colorPointerBuffer && cc._renderContext.deleteBuffer(this._colorPointerBuffer);
    },
    isFastMode: function() {
        return this.fastMode;
    },
    setFastMode: function(X) {
        this.fastMode = X;
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized;
    },
    setStartingPositionInitialized: function(X) {
        this.startingPositionInitialized = X;
    },
    initWithFade: function(X, S, P, O, Z) {
        var Y = "cc.MotionStreak.initWithFade(): Invalid filename or texture";
        if (!Z)
            throw Y;
        H8m.u6P === typeof Z && (Z = cc.textureCache.addImage(Z));
        cc.Node.prototype.setPosition.call(this, cc.p(H8m.U7H, H8m.U7H));
        this.anchorY = this.anchorX = H8m.U7H;
        this.ignoreAnchor = !H8m.U7H;
        this.startingPositionInitialized = !H8m.h7H;
        this.fastMode = !H8m.U7H;
        this._minSeg = -H8m.h7H == S ? H8m.y7m(P, H8m.b7H) : S;
        this._minSeg *= this._minSeg;
        this._stroke = P;
        this._fadeDelta = H8m.q7m(H8m.h7H, X);
        X = (H8m.l7m(H8m.U7H, H8m.H8i * X)) + H8m.s7H;
        this._nuPoints = H8m.U7H;
        this._pointState = new Float32Array(X);
        this._pointVertexes = new Float32Array(H8m.X0m(H8m.s7H, X));
        this._vertices = new Float32Array(H8m.D0m(H8m.q7H, X));
        this._texCoords = new Float32Array(H8m.c0m(H8m.q7H, X));
        this._colorPointer = new Uint8Array(H8m.z0m(H8m.F7H, X));
        this._maxPoints = X;
        X = cc._renderContext;
        this._verticesBuffer = X.createBuffer();
        this._texCoordsBuffer = X.createBuffer();
        this._colorPointerBuffer = X.createBuffer();
        this._blendFunc.src = X.SRC_ALPHA;
        this._blendFunc.dst = X.ONE_MINUS_SRC_ALPHA;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        this.texture = Z;
        this.color = O;
        this.scheduleUpdate();
        X.bindBuffer(X.ARRAY_BUFFER, this._verticesBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._vertices, X.DYNAMIC_DRAW);
        X.bindBuffer(X.ARRAY_BUFFER, this._texCoordsBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._texCoords, X.DYNAMIC_DRAW);
        X.bindBuffer(X.ARRAY_BUFFER, this._colorPointerBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._colorPointer, X.DYNAMIC_DRAW);
        return !H8m.U7H;
    },
    tintWithColor: function(X) {
        this.color = X;
        for (var S = this._colorPointer, P = H8m.U7H, O = H8m.j0m(H8m.s7H, this._nuPoints); H8m.x0m(P, O); P++)
            S[H8m.o0m(H8m.q7H, P)] = X.r, S[H8m.p0m(H8m.q7H, P) + H8m.h7H] = X.g, S[H8m.Y0m(H8m.q7H, P) + H8m.s7H] = X.b;
    },
    reset: function() {
        this._nuPoints = H8m.U7H;
    },
    setPosition: function(X, S) {
        this.startingPositionInitialized = !H8m.U7H;
        void H8m.U7H === S ? (this._positionR.x = X.x, this._positionR.y = X.y) : (this._positionR.x = X, this._positionR.y = S);
    },
    getPositionX: function() {
        return this._positionR.x;
    },
    setPositionX: function(X) {
        this._positionR.x = X;
        this.startingPositionInitialized || (this.startingPositionInitialized = !H8m.U7H);
    },
    getPositionY: function() {
        return this._positionR.y;
    },
    setPositionY: function(X) {
        this._positionR.y = X;
        this.startingPositionInitialized || (this.startingPositionInitialized = !H8m.U7H);
    },
    draw: function(X) {
        H8m.T0m(H8m.h7H, this._nuPoints) || !this.texture || !this.texture.isLoaded() || (X = X || cc._renderContext, cc.NODE_DRAW_SETUP(this), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(this.texture), X.bindBuffer(X.ARRAY_BUFFER, this._verticesBuffer), X.bufferData(X.ARRAY_BUFFER, this._vertices, X.DYNAMIC_DRAW), X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, H8m.s7H, X.FLOAT, !H8m.h7H, H8m.U7H, H8m.U7H), X.bindBuffer(X.ARRAY_BUFFER, this._texCoordsBuffer), X.bufferData(X.ARRAY_BUFFER, this._texCoords, X.DYNAMIC_DRAW), X.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, H8m.s7H, X.FLOAT, !H8m.h7H, H8m.U7H, H8m.U7H), X.bindBuffer(X.ARRAY_BUFFER, this._colorPointerBuffer), X.bufferData(X.ARRAY_BUFFER, this._colorPointer, X.DYNAMIC_DRAW), X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, H8m.q7H, X.UNSIGNED_BYTE, !H8m.U7H, H8m.U7H, H8m.U7H), X.drawArrays(X.TRIANGLE_STRIP, H8m.U7H, H8m.R0m(H8m.s7H, this._nuPoints)), cc.g_NumberOfDraws++);
    },
    update: function(X) {
        if (this.startingPositionInitialized) {
            X *= this._fadeDelta;
            var S,
                P,
                O,
                Z,
                Y = H8m.U7H,
                T = this._nuPoints,
                R = this._pointState,
                E = this._pointVertexes,
                V = this._vertices,
                U = this._colorPointer;
            for (O = H8m.U7H; H8m.M0m(O, T); O++)
                R[O] -= X, H8m.V0m(H8m.U7H, R[O]) ? Y++ : (S = H8m.s0m(O, Y), H8m.U0m(H8m.U7H, Y) ? (R[S] = R[O], E[H8m.b0m(H8m.s7H, S)] = E[H8m.F0m(H8m.s7H, O)], E[H8m.k3m(H8m.s7H, S) + H8m.h7H] = E[H8m.L3m(H8m.s7H, O) + H8m.h7H], Z = H8m.i3m(H8m.s7H, O), P = H8m.S3m(H8m.s7H, S), V[H8m.P3m(H8m.s7H, P)] = V[H8m.a3m(H8m.s7H, Z)], V[H8m.O3m(H8m.s7H, P) + H8m.h7H] = V[H8m.B3m(H8m.s7H, Z) + H8m.h7H], V[H8m.Z3m(H8m.s7H, (P + H8m.h7H))] = V[H8m.J3m(H8m.s7H, (Z + H8m.h7H))], V[H8m.n3m(H8m.s7H, (P + H8m.h7H)) + H8m.h7H] = V[H8m.G3m(H8m.s7H, (Z + H8m.h7H)) + H8m.h7H], Z *= H8m.q7H, P *= H8m.q7H, U[P + H8m.U7H] = U[Z + H8m.U7H], U[P + H8m.h7H] = U[Z + H8m.h7H], U[P + H8m.s7H] = U[Z + H8m.s7H], U[P + H8m.q7H] = U[Z + H8m.q7H], U[P + H8m.b7H] = U[Z + H8m.b7H], U[P + H8m.H7H] = U[Z + H8m.H7H]) : P = H8m.W3m(H8m.F7H, S), S = H8m.v3m(H8m.s0K, R[S]), U[P + H8m.v7H] = S, U[P + H8m.y7H] = S);
            T -= Y;
            O = !H8m.U7H;
            H8m.u3m(T, this._maxPoints) ? O = !H8m.h7H : H8m.H3m(H8m.U7H, T) && (X = H8m.f3m(cc.pDistanceSQ(cc.p(E[H8m.s7H * (T - H8m.h7H)], E[H8m.s7H * (T - H8m.h7H) + H8m.h7H]), this._positionR), this._minSeg), P = H8m.I3m(H8m.h7H, T) ? !H8m.h7H : H8m.g5m(cc.pDistanceSQ(cc.p(E[H8m.s7H * (T - H8m.s7H)], E[H8m.s7H * (T - H8m.s7H) + H8m.h7H]), this._positionR), H8m.s7H * this._minSeg), X || P) && (O = !H8m.h7H);
            O && (E[H8m.K5m(H8m.s7H, T)] = this._positionR.x, E[H8m.d5m(H8m.s7H, T) + H8m.h7H] = this._positionR.y, R[T] = H8m.h7H, R = H8m.t5m(H8m.F7H, T), O = this._displayedColor, U[R] = O.r, U[R + H8m.h7H] = O.g, U[R + H8m.s7H] = O.b, U[R + H8m.q7H] = O.r, U[R + H8m.b7H] = O.g, U[R + H8m.H7H] = O.b, U[R + H8m.v7H] = H8m.s0K, U[R + H8m.y7H] = H8m.s0K, H8m.w5m(H8m.U7H, T) && this.fastMode && (H8m.e5m(H8m.h7H, T) ? cc.vertexLineToPolygon(E, this._stroke, this._vertices, T, H8m.h7H) : cc.vertexLineToPolygon(E, this._stroke, this._vertices, H8m.U7H, H8m.s7H)), T++);
            this.fastMode || cc.vertexLineToPolygon(E, this._stroke, this._vertices, H8m.U7H, T);
            if (T && H8m.Q5m(this._previousNuPoints, T)) {
                E = H8m.r5m(H8m.h7H, T);
                U = this._texCoords;
                for (O = H8m.U7H; H8m.N5m(O, T); O++)
                    U[H8m.m5m(H8m.q7H, O)] = H8m.U7H, U[H8m.A5m(H8m.q7H, O) + H8m.h7H] = H8m.E5m(E, O), U[H8m.C5m(H8m.s7H, (H8m.s7H * O + H8m.h7H))] = H8m.h7H, U[H8m.h5m(H8m.s7H, (H8m.s7H * O + H8m.h7H)) + H8m.h7H] = H8m.y5m(E, O);
                this._previousNuPoints = T;
            }
            this._nuPoints = T;
        }
    }
});
cc.MotionStreak.create = function(X, S, P, O, Z) {
    var Y = new cc.MotionStreak;
    return Y && Y.initWithFade(X, S, P, O, Z) ? Y : H8m.H6P;
};
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    getGrid: function() {
        return this.grid;
    },
    setGrid: function(X) {
        this.grid = X;
    },
    setTarget: function(X) {
        this._target = X;
    },
    addChild: function(X, S, P) {
        cc.Node.prototype.addChild.call(this, X, S, P);
        X && !this._target && (this._target = X);
    },
    visit: function() {
        if (this._visible) {
            var X = H8m.q5m(cc._renderType, cc._RENDER_TYPE_WEBGL),
                S = this.grid;
            X && S && S._active && S.beforeDraw();
            this.transform();
            var P = this._children;
            if (P && H8m.l5m(0, P.length)) {
                var O = P.length;
                this.sortAllChildren();
                for (i = 0; H8m.X6m(i, O); i++) {
                    var Z = P[i];
                    Z && Z.visit();
                }
            }
            X && S && S._active && S.afterDraw(this._target);
        }
    },
    _transformForWebGL: function() {
        var X = this._transform4x4,
            S = cc.current_stack.top,
            P = this.nodeToParentTransform(),
            O = X.mat;
        O[0] = P.a;
        O[4] = P.c;
        O[12] = P.tx;
        O[1] = P.b;
        O[5] = P.d;
        O[13] = P.ty;
        O[14] = this._vertexZ;
        cc.kmMat4Multiply(S, S, X);
        H8m.D6m(null, this._camera) || this.grid && this.grid.isActive() || (X = this._anchorPointInPoints.x, S = this._anchorPointInPoints.y, H8m.c6m(0, X) || H8m.z6m(0, S) ? (cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(X), cc.RENDER_IN_SUBPIXEL(S), 0), this._camera.locate(), cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(-X), cc.RENDER_IN_SUBPIXEL(-S), 0)) : this._camera.locate());
    }
});
w6b0K[q0K]._p = cc.NodeGrid.prototype;
H8m.K8y();
cc.defineGetterSetter(_p, H8m.I3i, H8m.H6P, _p.setTarget);
delete w6b0K[q0K]._p;
cc.NodeGrid.create = function() {
    return new cc.NodeGrid;
};
cc.v2fzero = function() {
    return {
        x: H8m.U7H,
        y: H8m.U7H
    };
};
cc.v2f = function(X, S) {
    return {
        x: X,
        y: S
    };
};
cc.v2fadd = function(X, S) {
    return cc.v2f(X.x + S.x, X.y + S.y);
};
cc.v2fsub = function(X, S) {
    return cc.v2f(H8m.j6m(X.x, S.x), H8m.x6m(X.y, S.y));
};
cc.v2fmult = function(X, S) {
    return cc.v2f(H8m.o6m(X.x, S), H8m.p6m(X.y, S));
};
cc.v2fperp = function(X) {
    return cc.v2f(-X.y, X.x);
};
cc.v2fneg = function(X) {
    return cc.v2f(-X.x, -X.y);
};
cc.v2fdot = function(X, S) {
    return H8m.Y6m(X.x, S.x) + H8m.T6m(X.y, S.y);
};
cc.v2fforangle = function(X) {
    return cc.v2f(Math.cos(X), Math.sin(X));
};
cc.v2fnormalize = function(X) {
    X = cc.pNormalize(cc.p(X.x, X.y));
    return cc.v2f(X.x, X.y);
};
cc.__v2f = function(X) {
    return cc.v2f(X.x, X.y);
};
cc.__t = function(X) {
    return {
        u: X.x,
        v: X.y
    };
};
cc.DrawNodeCanvas = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 0,
    _drawColor: null,
    _className: "DrawNodeCanvas",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._lineWidth = 1;
        this._drawColor = cc.color(255, 255, 255, 255);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    setBlendFunc: function(X) {
        this._blendFunc = X;
    },
    setLineWidth: function(X) {
        this._lineWidth = X;
    },
    getLineWidth: function() {
        return this._lineWidth;
    },
    setDrawColor: function(X) {
        this._drawColor.r = X.r;
        this._drawColor.g = X.g;
        this._drawColor.b = X.b;
        this._drawColor.a = X.a;
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a);
    },
    drawRect: function(X, S, P, O, Z) {
        O = O || this._lineWidth;
        Z = Z || this.getDrawColor();
        X = [X, cc.p(S.x, X.y), S, cc.p(X.x, S.y)];
        S = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        S.verts = X;
        S.lineWidth = O;
        S.lineColor = Z;
        S.isClosePolygon = !0;
        S.isStroke = !0;
        S.lineCap = "butt";
        if (S.fillColor = P)
            S.isFill = !0;
        this._buffer.push(S);
    },
    drawCircle: function(X, S, P, O, Z, Y, T) {
        Y = Y || this._lineWidth;
        T = T || this.getDrawColor();
        for (var R = H8m.R6m(2, Math.PI, O), E = [], V = 0; H8m.E6m(V, O); V++) {
            var U = H8m.C6m(V, R),
                k9 = H8m.h6m(S, Math.cos(U + P)) + X.x,
                U = H8m.y6m(S, Math.sin(U + P)) + X.y;
            E.push(cc.p(k9, U));
        }
        Z && E.push(cc.p(X.x, X.y));
        X = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        X.verts = E;
        X.lineWidth = Y;
        X.lineColor = T;
        X.isClosePolygon = !0;
        X.isStroke = !0;
        this._buffer.push(X);
    },
    drawQuadBezier: function(X, S, P, O, Z, Y) {
        Z = Z || this._lineWidth;
        Y = Y || this.getDrawColor();
        for (var T = [], R = 0, E = 0; H8m.q6m(E, O); E++) {
            var V = H8m.l6m(Math.pow(1 - R, 2), X.x) + H8m.X2m(2, (1 - R), R, S.x) + H8m.i2m(R, R, P.x),
                U = H8m.z2m(Math.pow(1 - R, 2), X.y) + H8m.j2m(2, (1 - R), R, S.y) + H8m.O2m(R, R, P.y);
            T.push(cc.p(V, U));
            R += H8m.p2m(1, O);
        }
        T.push(cc.p(P.x, P.y));
        X = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        X.verts = T;
        X.lineWidth = Z;
        X.lineColor = Y;
        X.isStroke = !0;
        X.lineCap = "round";
        this._buffer.push(X);
    },
    drawCubicBezier: function(X, S, P, O, Z, Y, T) {
        Y = Y || this._lineWidth;
        T = T || this.getDrawColor();
        for (var R = [], E = 0, V = 0; H8m.Y2m(V, Z); V++) {
            var U = H8m.T2m(Math.pow(1 - E, 3), X.x) + H8m.R2m(3, Math.pow(1 - E, 2), E, S.x) + H8m.W2m(3, (1 - E), E, E, P.x) + H8m.u2m(E, E, E, O.x),
                k9 = H8m.q2m(Math.pow(1 - E, 3), X.y) + H8m.l2m(3, Math.pow(1 - E, 2), E, S.y) + H8m.L9w(3, (1 - E), E, E, P.y) + H8m.S9w(E, E, E, O.y);
            R.push(cc.p(U, k9));
            E += H8m.w9w(1, Z);
        }
        R.push(cc.p(O.x, O.y));
        X = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        X.verts = R;
        X.lineWidth = Y;
        X.lineColor = T;
        X.isStroke = !0;
        X.lineCap = "round";
        this._buffer.push(X);
    },
    drawCatmullRom: function(X, S, P, O) {
        this.drawCardinalSpline(X, 0.5, S, P, O);
    },
    drawCardinalSpline: function(X, S, P, O, Z) {
        O = O || this._lineWidth;
        Z = Z || this.getDrawColor();
        for (var Y = [], T, R, E = H8m.e9w(1, X.length), V = 0; H8m.Q9w(V, P + 1); V++)
            R = H8m.r9w(V, P), H8m.N9w(1, R) ? (T = H8m.m9w(X.length, 1), R = 1) : (T = H8m.A9w(0, R / E), R = H8m.E9w((R - E * T), E)), T = cc.CardinalSplineAt(cc.getControlPointAt(X, H8m.C9w(T, 1)), cc.getControlPointAt(X, H8m.h9w(T, 0)), cc.getControlPointAt(X, T + 1), cc.getControlPointAt(X, T + 2), S, R), Y.push(T);
        X = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        X.verts = Y;
        X.lineWidth = O;
        X.lineColor = Z;
        X.isStroke = !0;
        X.lineCap = "round";
        this._buffer.push(X);
    },
    drawDot: function(X, S, P) {
        P = P || this.getDrawColor();
        var O = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        O.verts = [X];
        O.lineWidth = S;
        O.fillColor = P;
        this._buffer.push(O);
    },
    drawSegment: function(X, S, P, O) {
        P = P || this._lineWidth;
        O = O || this.getDrawColor();
        var Z = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        Z.verts = [X, S];
        Z.lineWidth = P;
        Z.lineColor = O;
        Z.isStroke = !0;
        Z.lineCap = "round";
        this._buffer.push(Z);
    },
    drawPoly_: function(X, S, P, O) {
        P = P || this._lineWidth;
        O = O || this.getDrawColor();
        var Z = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        Z.verts = X;
        Z.fillColor = S;
        Z.lineWidth = P;
        Z.lineColor = O;
        Z.isClosePolygon = !0;
        Z.isStroke = !0;
        Z.lineCap = "round";
        S && (Z.isFill = !0);
        this._buffer.push(Z);
    },
    drawPoly: function(X, S, P, O) {
        for (var Z = [], Y = 0; H8m.y9w(Y, X.length); Y++)
            Z.push(cc.p(X[Y].x, X[Y].y));
        return this.drawPoly_(Z, S, P, O);
    },
    draw: function(X) {
        X = X || cc._renderContext;
        this._blendFunc && H8m.q9w(this._blendFunc.src, cc.SRC_ALPHA) && H8m.l9w(this._blendFunc.dst, cc.ONE) && (X.globalCompositeOperation = "lighter");
        for (var S = 0; H8m.X1w(S, this._buffer.length); S++) {
            var P = this._buffer[S];
            switch (P.type) {
            case cc.DrawNode.TYPE_DOT:
                this._drawDot(X, P);
                break;
            case cc.DrawNode.TYPE_SEGMENT:
                this._drawSegment(X, P);
                break;
            case cc.DrawNode.TYPE_POLY:
                this._drawPoly(X, P);
            }
        }
    },
    _drawDot: function(X, S) {
        var P = S.fillColor,
            O = S.verts[0],
            Z = S.lineWidth,
            Y = cc.view.getScaleX(),
            T = cc.view.getScaleY();
        X.fillStyle = "rgba(" + (H8m.D1w(0, P.r)) + "," + (H8m.c1w(0, P.g)) + "," + (H8m.z1w(0, P.b)) + "," + H8m.j1w(P.a, 255) + ")";
        X.beginPath();
        X.arc(H8m.x1w(O.x, Y), -O.y * T, H8m.o1w(Z, Y), 0, H8m.p1w(2, Math.PI), !1);
        X.closePath();
        X.fill();
    },
    _drawSegment: function(X, S) {
        var P = S.lineColor,
            O = S.verts[0],
            Z = S.verts[1],
            Y = S.lineWidth,
            T = S.lineCap,
            R = cc.view.getScaleX(),
            E = cc.view.getScaleY();
        X.strokeStyle = "rgba(" + (H8m.Y1w(0, P.r)) + "," + (H8m.T1w(0, P.g)) + "," + (H8m.R1w(0, P.b)) + "," + H8m.M1w(P.a, 255) + ")";
        X.lineWidth = H8m.V1w(Y, R);
        X.beginPath();
        X.lineCap = T;
        X.moveTo(H8m.s1w(O.x, R), -O.y * E);
        X.lineTo(H8m.U1w(Z.x, R), -Z.y * E);
        X.stroke();
    },
    _drawPoly: function(X, S) {
        var P = S.verts,
            O = S.lineCap,
            Z = S.fillColor,
            Y = S.lineWidth,
            T = S.lineColor,
            R = S.isClosePolygon,
            E = S.isFill,
            V = S.isStroke;
        if (H8m.b1w(null, P)) {
            var U = P[0],
                k9 = cc.view.getScaleX(),
                L9 = cc.view.getScaleY();
            X.lineCap = O;
            Z && (X.fillStyle = "rgba(" + (H8m.F1w(0, Z.r)) + "," + (H8m.k8w(0, Z.g)) + "," + (H8m.L8w(0, Z.b)) + "," + H8m.i8w(Z.a, 255) + ")");
            Y && (X.lineWidth = H8m.S8w(Y, k9));
            T && (X.strokeStyle = "rgba(" + (H8m.P8w(0, T.r)) + "," + (H8m.a8w(0, T.g)) + "," + (H8m.O8w(0, T.b)) + "," + H8m.B8w(T.a, 255) + ")");
            X.beginPath();
            X.moveTo(H8m.Z8w(U.x, k9), -U.y * L9);
            O = 1;
            for (Z = P.length; H8m.J8w(O, Z); O++)
                X.lineTo(H8m.n8w(P[O].x, k9), -P[O].y * L9);
            R && X.closePath();
            E && X.fill();
            V && X.stroke();
        }
    },
    clear: function() {
        this._buffer.length = 0;
    }
});
cc.DrawNodeWebGL = cc.Node.extend({
    _bufferCapacity: 0,
    _buffer: null,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _blendFunc: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    getBlendFunc: function() {
        return this._blendFunc;
    },
    setBlendFunc: function(X) {
        this._blendFunc = X;
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    },
    init: function() {
        return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(512), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1;
    },
    _render: function() {
        var X = cc._renderContext;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
        X.bindBuffer(X.ARRAY_BUFFER, this._trianglesWebBuffer);
        this._dirty && (X.bufferData(X.ARRAY_BUFFER, this._trianglesArrayBuffer, X.STREAM_DRAW), this._dirty = !1);
        var S = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, S, 0);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, X.UNSIGNED_BYTE, !0, S, 8);
        X.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, X.FLOAT, !1, S, 12);
        X.drawArrays(X.TRIANGLES, 0, H8m.G8w(3, this._buffer.length));
        cc.INCREMENT_GL_DRAWS(1);
    },
    _ensureCapacity: function(X) {
        if (H8m.W8w(this._buffer.length + X, this._bufferCapacity)) {
            var S = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            this._bufferCapacity += Math.max(this._bufferCapacity, X);
            if (H8m.v8w(null, this._buffer) || H8m.u8w(0, this._buffer.length))
                this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(H8m.H8w(S, this._bufferCapacity)), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
            else {
                X = this._buffer;
                X.length = 0;
                for (var P = new ArrayBuffer(H8m.f8w(S, this._bufferCapacity)), O = 0; H8m.I8w(O, this._buffer.length); O++)
                    X[O] = new cc.V2F_C4B_T2F_Triangle(this._buffer[O].a, this._buffer[O].b, this._buffer[O].c, P, H8m.g4w(O, S));
                this._trianglesReader = new Uint8Array(P);
                this._trianglesArrayBuffer = P;
            }
        }
    },
    draw: function() {
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        this._render();
    },
    drawDot: function(X, S, P) {
        P = {
            r: H8m.K4w(0, P.r),
            g: H8m.d4w(0, P.g),
            b: H8m.t4w(0, P.b),
            a: H8m.w4w(0, P.a)
        };
        var O = {
                vertices: {
                    x: H8m.e4w(X.x, S),
                    y: H8m.Q4w(X.y, S)
                },
                colors: P,
                texCoords: {
                    u: -1,
                    v: -1
                }
            },
            Z = {
                vertices: {
                    x: X.x + S,
                    y: X.y + S
                },
                colors: P,
                texCoords: {
                    u: 1,
                    v: 1
                }
            },
            Y = {
                vertices: {
                    x: X.x + S,
                    y: H8m.r4w(X.y, S)
                },
                colors: P,
                texCoords: {
                    u: 1,
                    v: -1
                }
            };
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(O, {
            vertices: {
                x: H8m.N4w(X.x, S),
                y: X.y + S
            },
            colors: P,
            texCoords: {
                u: -1,
                v: 1
            }
        }, Z, this._trianglesArrayBuffer, H8m.m4w(this._buffer.length, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(O, Z, Y, this._trianglesArrayBuffer, H8m.A4w(this._buffer.length, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)));
        this._dirty = !0;
    },
    drawSegment: function(X, S, P, O) {
        this._ensureCapacity(18);
        O = {
            r: H8m.E4w(0, O.r),
            g: H8m.C4w(0, O.g),
            b: H8m.h4w(0, O.b),
            a: H8m.y4w(0, O.a)
        };
        var Z = cc.__v2f(X),
            Y = cc.__v2f(S);
        S = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(Y, Z)));
        X = cc.v2fperp(S);
        var T = cc.v2fmult(S, P),
            R = cc.v2fmult(X, P);
        P = cc.v2fsub(Y, cc.v2fadd(T, R));
        var E = cc.v2fadd(Y, cc.v2fsub(T, R)),
            V = cc.v2fsub(Y, T),
            Y = cc.v2fadd(Y, T),
            U = cc.v2fsub(Z, T),
            k9 = cc.v2fadd(Z, T),
            L9 = cc.v2fsub(Z, cc.v2fsub(T, R)),
            Z = cc.v2fadd(Z, cc.v2fadd(T, R)),
            T = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            R = this._trianglesArrayBuffer;
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: P,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(cc.v2fadd(S, X)))
        }, {
            vertices: E,
            colors: O,
            texCoords: cc.__t(cc.v2fsub(S, X))
        }, {
            vertices: V,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, R, H8m.q4w(this._buffer.length, T)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: Y,
            colors: O,
            texCoords: cc.__t(S)
        }, {
            vertices: E,
            colors: O,
            texCoords: cc.__t(cc.v2fsub(S, X))
        }, {
            vertices: V,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, R, H8m.l4w(this._buffer.length, T)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: Y,
            colors: O,
            texCoords: cc.__t(S)
        }, {
            vertices: U,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, {
            vertices: V,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, R, H8m.X7w(this._buffer.length, T)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: Y,
            colors: O,
            texCoords: cc.__t(S)
        }, {
            vertices: U,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, {
            vertices: k9,
            colors: O,
            texCoords: cc.__t(S)
        }, R, H8m.D7w(this._buffer.length, T)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: L9,
            colors: O,
            texCoords: cc.__t(cc.v2fsub(X, S))
        }, {
            vertices: U,
            colors: O,
            texCoords: cc.__t(cc.v2fneg(S))
        }, {
            vertices: k9,
            colors: O,
            texCoords: cc.__t(S)
        }, R, H8m.c7w(this._buffer.length, T)));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: L9,
            colors: O,
            texCoords: cc.__t(cc.v2fsub(X, S))
        }, {
            vertices: Z,
            colors: O,
            texCoords: cc.__t(cc.v2fadd(S, X))
        }, {
            vertices: k9,
            colors: O,
            texCoords: cc.__t(S)
        }, R, H8m.z7w(this._buffer.length, T)));
        this._dirty = !0;
    },
    drawPoly: function(X, S, P, O) {
        S = {
            r: H8m.j7w(0, S.r),
            g: H8m.x7w(0, S.g),
            b: H8m.o7w(0, S.b),
            a: H8m.p7w(0, S.a)
        };
        O = {
            r: H8m.Y7w(0, O.r),
            g: H8m.T7w(0, O.g),
            b: H8m.R7w(0, O.b),
            a: H8m.M7w(0, O.a)
        };
        var Z = [],
            Y,
            T,
            R,
            E,
            V = X.length;
        for (Y = 0; H8m.V7w(Y, V); Y++) {
            T = cc.__v2f(X[H8m.s7w((Y - 1 + V), V)]);
            R = cc.__v2f(X[Y]);
            E = cc.__v2f(X[H8m.U7w((Y + 1), V)]);
            var U = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(R, T)));
            R = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(E, R)));
            U = cc.v2fmult(cc.v2fadd(U, R), H8m.b7w(1, (cc.v2fdot(U, R) + 1)));
            Z[Y] = {
                offset: U,
                n: R
            };
        }
        U = H8m.F7w(0, P);
        this._ensureCapacity(H8m.k0w(3, (3 * V - 2)));
        var k9 = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            L9 = this._trianglesArrayBuffer,
            K9 = this._buffer,
            c9 = !1 == U ? 0.5 : 0;
        for (Y = 0; H8m.L0w(Y, V - 2); Y++)
            T = cc.v2fsub(cc.__v2f(X[0]), cc.v2fmult(Z[0].offset, c9)), R = cc.v2fsub(cc.__v2f(X[Y + 1]), cc.v2fmult(Z[Y + 1].offset, c9)), E = cc.v2fsub(cc.__v2f(X[Y + 2]), cc.v2fmult(Z[Y + 2].offset, c9)), K9.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: T,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: R,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: E,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, L9, H8m.i0w(K9.length, k9)));
        for (Y = 0; H8m.S0w(Y, V); Y++) {
            c9 = H8m.P0w((Y + 1), V);
            T = cc.__v2f(X[Y]);
            R = cc.__v2f(X[c9]);
            E = Z[Y].n;
            var t9 = Z[Y].offset,
                S9 = Z[c9].offset,
                c9 = U ? cc.v2fsub(T, cc.v2fmult(t9, P)) : cc.v2fsub(T, cc.v2fmult(t9, 0.5)),
                j9 = U ? cc.v2fsub(R, cc.v2fmult(S9, P)) : cc.v2fsub(R, cc.v2fmult(S9, 0.5));
            T = U ? cc.v2fadd(T, cc.v2fmult(t9, P)) : cc.v2fadd(T, cc.v2fmult(t9, 0.5));
            R = U ? cc.v2fadd(R, cc.v2fmult(S9, P)) : cc.v2fadd(R, cc.v2fmult(S9, 0.5));
            U ? (K9.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c9,
                colors: O,
                texCoords: cc.__t(cc.v2fneg(E))
            }, {
                vertices: j9,
                colors: O,
                texCoords: cc.__t(cc.v2fneg(E))
            }, {
                vertices: R,
                colors: O,
                texCoords: cc.__t(E)
            }, L9, H8m.a0w(K9.length, k9))), K9.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c9,
                colors: O,
                texCoords: cc.__t(cc.v2fneg(E))
            }, {
                vertices: T,
                colors: O,
                texCoords: cc.__t(E)
            }, {
                vertices: R,
                colors: O,
                texCoords: cc.__t(E)
            }, L9, H8m.O0w(K9.length, k9)))) : (K9.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c9,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: j9,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: R,
                colors: S,
                texCoords: cc.__t(E)
            }, L9, H8m.B0w(K9.length, k9))), K9.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c9,
                colors: S,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: T,
                colors: S,
                texCoords: cc.__t(E)
            }, {
                vertices: R,
                colors: S,
                texCoords: cc.__t(E)
            }, L9, H8m.Z0w(K9.length, k9))));
        }
        this._dirty = !0;
    },
    clear: function() {
        this._buffer.length = 0;
        this._dirty = !0;
    }
});
H8m.i8y();
cc.DrawNode.create = function() {
    var X = new cc.DrawNode;
    return X && X.init() ? X : H8m.H6P;
};
cc._DrawNodeElement = function(X, S, P, O, Z, Y, T, R, E) {
    this.type = X;
    this.verts = S || H8m.H6P;
    this.fillColor = P || H8m.H6P;
    this.lineWidth = O || 0;
    this.lineColor = Z || H8m.H6P;
    this.lineCap = Y || "butt";
    this.isClosePolygon = T || !H8m.h7H;
    this.isFill = R || !H8m.h7H;
    this.isStroke = E || !H8m.h7H;
};
H8m.c8y(H8m.U7H);
H8m.S8y(H8m.h7H);
H8m.t8y(H8m.s7H);
H8m.j8y();
cc.setProgram = function(X, S) {
    X.shaderProgram = S;
    var P = X.children;
    if (P)
        for (var O = 0; H8m.J0w(O, P.length); O++)
            cc.setProgram(P[O], S);
};
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _godhelpme: !1,
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._stencil = null;
        this.alphaThreshold = 0;
        this.inverted = !1;
    },
    init: null,
    _className: "ClippingNode",
    _initForWebGL: function(X) {
        this._stencil = X;
        this.alphaThreshold = 1;
        this.inverted = !1;
        cc.ClippingNode._init_once = !0;
        cc.ClippingNode._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), H8m.n0w(0, cc.stencilBits) && cc.log("Stencil buffer is not enabled."), cc.ClippingNode._init_once = !1);
        return !0;
    },
    _initForCanvas: function(X) {
        this._stencil = X;
        this.alphaThreshold = 1;
        this.inverted = !1;
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter();
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish();
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this);
    },
    onExit: function() {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this);
    },
    visit: null,
    _visitForWebGL: function(X) {
        var S = X || cc._renderContext;
        if (H8m.G0w(1, cc.stencilBits))
            cc.Node.prototype.visit.call(this, X);
        else if (this._stencil && this._stencil.visible)
            if (cc.ClippingNode._layer = -1, H8m.W0w(cc.ClippingNode._layer + 1, cc.stencilBits))
                cc.ClippingNode._visit_once = !0, cc.ClippingNode._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), cc.ClippingNode._visit_once = !1), cc.Node.prototype.visit.call(this, X);
            else {
                cc.ClippingNode._layer++;
                var P = H8m.v0w(1, cc.ClippingNode._layer),
                    O = H8m.u0w(P, P - 1),
                    Z = S.isEnabled(S.STENCIL_TEST),
                    Y = S.getParameter(S.STENCIL_WRITEMASK),
                    T = S.getParameter(S.STENCIL_FUNC),
                    R = S.getParameter(S.STENCIL_REF),
                    E = S.getParameter(S.STENCIL_VALUE_MASK),
                    V = S.getParameter(S.STENCIL_FAIL),
                    U = S.getParameter(S.STENCIL_PASS_DEPTH_FAIL),
                    k9 = S.getParameter(S.STENCIL_PASS_DEPTH_PASS);
                S.enable(S.STENCIL_TEST);
                S.stencilMask(P);
                var L9 = S.getParameter(S.DEPTH_WRITEMASK);
                S.depthMask(!1);
                S.stencilFunc(S.NEVER, P, P);
                S.stencilOp(this.inverted ? S.REPLACE : S.ZERO, S.KEEP, S.KEEP);
                cc._drawingUtil.drawSolidRect(cc.p(0, 0), cc.pFromSize(cc.director.getWinSize()), cc.color(255, 255, 255, 255));
                S.stencilFunc(S.NEVER, P, P);
                S.stencilOp(this.inverted ? S.ZERO : S.REPLACE, S.KEEP, S.KEEP);
                if (H8m.H0w(1, this.alphaThreshold)) {
                    var P = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                        K9 = S.getUniformLocation(P.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                    cc.glUseProgram(P.getProgram());
                    P.setUniformLocationWith1f(K9, this.alphaThreshold);
                    cc.setProgram(this._stencil, P);
                }
                cc.kmGLPushMatrix();
                this.transform();
                this._stencil.visit();
                cc.kmGLPopMatrix();
                S.depthMask(L9);
                S.stencilFunc(S.EQUAL, O, O);
                S.stencilOp(S.KEEP, S.KEEP, S.KEEP);
                cc.Node.prototype.visit.call(this, X);
                S.stencilFunc(T, R, E);
                S.stencilOp(V, U, k9);
                S.stencilMask(Y);
                Z || S.disable(S.STENCIL_TEST);
                cc.ClippingNode._layer--;
            }
        else
            this.inverted && cc.Node.prototype.visit.call(this, X);
    },
    _visitForCanvas: function(X) {
        if (this._stencil && this._stencil.visible) {
            X = X || cc._renderContext;
            if (this._cangodhelpme() || H8m.f0w(this._stencil, cc.Sprite)) {
                var S = X.canvas,
                    P = cc.ClippingNode._getSharedCache();
                P.width = S.width;
                P.height = S.height;
                P.getContext("2d").drawImage(S, 0, 0);
                X.save();
                this._super(X);
                X.globalCompositeOperation = this.inverted ? "destination-out" : "destination-in";
                this.transform(X);
                this._stencil.visit();
                X.restore();
                X.save();
                X.setTransform(1, 0, 0, 1, 0, 0);
                X.globalCompositeOperation = "destination-over";
                X.drawImage(P, 0, 0);
            } else {
                var P = this._children,
                    O;
                X.save();
                this.transform(X);
                this._stencil.visit(X);
                X.clip();
                this._cangodhelpme(!0);
                var Z = P.length;
                if (H8m.I0w(0, Z)) {
                    this.sortAllChildren();
                    for (S = 0; H8m.g3w(S, Z); S++)
                        if (O = P[S], H8m.K3w(0, O._localZOrder))
                            O.visit(X);
                        else
                            break;
                    for (this.draw(X); H8m.d3w(S, Z); S++)
                        P[S].visit(X);
                } else
                    this.draw(X);
                this._cangodhelpme(!1);
            }
            X.restore();
        } else
            this.inverted && cc.Node.prototype.visit.call(this, X);
    },
    getStencil: function() {
        return this._stencil;
    },
    setStencil: null,
    _setStencilForWebGL: function(X) {
        this._stencil = X;
    },
    _setStencilForCanvas: function(Z) {
        this._stencil = Z;
        var Y = cc.view.getScaleX(),
            T = cc.view.getScaleY(),
            R = cc._renderContext;
        !(H8m.t3w(Z, cc.Sprite)) && H8m.w3w(Z, cc.DrawNode) && (Z.draw = function() {
            for (var X = 0; H8m.e3w(X, Z._buffer.length); X++) {
                var S = Z._buffer[X].verts,
                    P = S[0];
                R.beginPath();
                R.moveTo(H8m.Q3w(P.x, Y), -P.y * T);
                for (var P = 1, O = S.length; H8m.r3w(P, O); P++)
                    R.lineTo(H8m.N3w(S[P].x, Y), -S[P].y * T);
            }
        });
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold;
    },
    setAlphaThreshold: function(X) {
        this.alphaThreshold = X;
    },
    isInverted: function() {
        return this.inverted;
    },
    setInverted: function(X) {
        this.inverted = X;
    },
    _cangodhelpme: function(X) {
        if (!0 === X || !1 === X)
            cc.ClippingNode.prototype._godhelpme = X;
        return cc.ClippingNode.prototype._godhelpme;
    }
});
w6b0K[q0K]._p = cc.ClippingNode.prototype;
H8m.m3w(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.init = _p._initForWebGL, _p.visit = _p._visitForWebGL, _p.setStencil = _p._setStencilForWebGL) : (_p.init = _p._initForCanvas, _p.visit = _p._visitForCanvas, _p.setStencil = _p._setStencilForCanvas);
cc.defineGetterSetter(_p, H8m.R7K, _p.getStencil, _p.setStencil);
delete w6b0K[q0K]._p;
H8m.w8y(H8m.H6P);
H8m.x8y(H8m.H6P);
H8m.O8y(H8m.H6P);
H8m.Q8y(H8m.H6P);
cc.ClippingNode._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = w6b0K[I0K]['createElement'](H8m.e6S));
};
cc.ClippingNode.create = function(X) {
    var S = new cc.ClippingNode;
    S.init(X);
    return S;
};
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function() {
        this._active = !1;
        this._reuseGrid = 0;
        this._texture = this._gridSize = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1;
    },
    isActive: function() {
        return this._active;
    },
    setActive: function(X) {
        this._active = X;
        if (!X) {
            X = cc.director;
            var S = X.getProjection();
            X.setProjection(S);
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid;
    },
    setReuseGrid: function(X) {
        this._reuseGrid = X;
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height);
    },
    setGridSize: function(X) {
        this._gridSize.width = parseInt(X.width);
        this._gridSize.height = parseInt(X.height);
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y);
    },
    setStep: function(X) {
        this._step.x = X.x;
        this._step.y = X.y;
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped;
    },
    setTextureFlipped: function(X) {
        H8m.A3w(this._isTextureFlipped, X) && (this._isTextureFlipped = X, this.calculateVertexPoints());
    },
    initWithSize: function(X, S, P) {
        if (!S) {
            var O = cc.director.getWinSizeInPixels(),
                Z = cc.NextPOT(O.width),
                Y = cc.NextPOT(O.height),
                T = new Uint8Array(H8m.E3w(Z, Y, 4));
            if (!T)
                return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            S = new cc.Texture2D;
            S.initWithData(T, cc.Texture2D.PIXEL_FORMAT_RGBA8888, Z, Y, O);
            if (!S)
                return cc.log("cocos2d: CCGrid: error creating texture"), !1;
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = X;
        this._texture = S;
        this._isTextureFlipped = P || !1;
        this._step.x = H8m.v3w(this._texture.width, X.width);
        this._step.y = H8m.u3w(this._texture.height, X.height);
        this._grabber = new cc.Grabber;
        if (!this._grabber)
            return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0;
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection();
        this.set2DProjection();
        this._grabber.beforeRender(this._texture);
    },
    afterDraw: function(X) {
        this._grabber.afterRender(this._texture);
        cc.director.setProjection(this._directorProjection);
        if (X.getCamera().isDirty()) {
            var S = X.getAnchorPointInPoints();
            cc.kmGLTranslatef(S.x, S.y, 0);
            X.getCamera().locate();
            cc.kmGLTranslatef(-S.x, -S.y, 0);
        }
        cc.glBindTexture2D(this._texture);
        this.blit();
    },
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.");
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.");
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.");
    },
    set2DProjection: function() {
        var X = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, X.width, X.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var S = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(S, 0, X.width, 0, X.height, -1, 1);
        cc.kmGLMultMatrix(S);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty();
    }
});
cc.GridBase.create = function(X, S, P) {
    var O = new cc.GridBase;
    return O && O.initWithSize(X, S, P) ? O : H8m.H6P;
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function() {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
    },
    vertex: function(X) {
        H8m.H3w(X.x, (0 | X.x)) && H8m.f3w(X.y, (0 | X.y)) || cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        X = H8m.I3w(0, 3 * (X.x * (this._gridSize.height + 1) + X.y));
        var S = this._vertices;
        return new cc.Vertex3F(S[X], S[X + 1], S[X + 2]);
    },
    originalVertex: function(X) {
        H8m.g5w(X.x, (0 | X.x)) && H8m.K5w(X.y, (0 | X.y)) || cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        X = H8m.d5w(0, 3 * (X.x * (this._gridSize.height + 1) + X.y));
        var S = this._originalVertices;
        return new cc.Vertex3F(S[X], S[X + 1], S[X + 2]);
    },
    setVertex: function(X, S) {
        H8m.t5w(X.x, (0 | X.x)) && H8m.w5w(X.y, (0 | X.y)) || cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var P = H8m.e5w(0, 3 * (X.x * (this._gridSize.height + 1) + X.y)),
            O = this._vertices;
        O[P] = S.x;
        O[P + 1] = S.y;
        O[P + 2] = S.z;
        this._dirty = !0;
    },
    blit: function() {
        var X = H8m.Q5w(this._gridSize.width, this._gridSize.height);
        cc.glEnableVertexAttribs(H8m.r5w(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS));
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var S = cc._renderContext,
            P = this._dirty;
        S.bindBuffer(S.ARRAY_BUFFER, this._verticesBuffer);
        P && S.bufferData(S.ARRAY_BUFFER, this._vertices, S.DYNAMIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, S.FLOAT, !1, 0, 0);
        S.bindBuffer(S.ARRAY_BUFFER, this._texCoordinateBuffer);
        P && S.bufferData(S.ARRAY_BUFFER, this._texCoordinates, S.DYNAMIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, S.FLOAT, !1, 0, 0);
        S.bindBuffer(S.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        P && S.bufferData(S.ELEMENT_ARRAY_BUFFER, this._indices, S.STATIC_DRAW);
        S.drawElements(S.TRIANGLES, H8m.N5w(6, X), S.UNSIGNED_SHORT, 0);
        P && (this._dirty = !1);
        cc.INCREMENT_GL_DRAWS(1);
    },
    reuse: function() {
        if (H8m.m5w(0, this._reuseGrid)) {
            for (var X = this._originalVertices, S = this._vertices, P = 0, O = this._vertices.length; H8m.A5w(P, O); P++)
                X[P] = S[P];
            --this._reuseGrid;
        }
    },
    calculateVertexPoints: function() {
        var X = cc._renderContext,
            S = this._texture.pixelsWidth,
            P = this._texture.pixelsHeight,
            O = this._texture.getContentSizeInPixels().height,
            Z = this._gridSize,
            Y = H8m.E5w((Z.width + 1), (Z.height + 1));
        this._vertices = new Float32Array(H8m.C5w(3, Y));
        this._texCoordinates = new Float32Array(H8m.h5w(2, Y));
        this._indices = new Uint16Array(H8m.y5w(Z.width, Z.height, 6));
        this._verticesBuffer && X.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = X.createBuffer();
        this._texCoordinateBuffer && X.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = X.createBuffer();
        this._indicesBuffer && X.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = X.createBuffer();
        for (var T, R, E = this._indices, V = this._texCoordinates, U = this._isTextureFlipped, k9 = this._vertices, Y = 0; H8m.f5w(Y, Z.width); ++Y)
            for (T = 0; H8m.I5w(T, Z.height); ++T) {
                var L9 = H8m.g6w(T, Z.width) + Y;
                R = H8m.K6w(Y, this._step.x);
                var K9 = R + this._step.x,
                    c9 = H8m.d6w(T, this._step.y),
                    t9 = c9 + this._step.y,
                    S9 = H8m.t6w(Y, (Z.height + 1)) + T,
                    j9 = H8m.w6w((Y + 1), (Z.height + 1)) + T,
                    a9 = H8m.e6w((Y + 1), (Z.height + 1)) + (T + 1),
                    o9 = H8m.Q6w(Y, (Z.height + 1)) + (T + 1);
                E[H8m.r6w(6, L9)] = S9;
                E[H8m.N6w(6, L9) + 1] = j9;
                E[H8m.m6w(6, L9) + 2] = o9;
                E[H8m.A6w(6, L9) + 3] = j9;
                E[H8m.E6w(6, L9) + 4] = a9;
                E[H8m.C6w(6, L9) + 5] = o9;
                var L9 = [H8m.h6w(3, S9), H8m.y6w(3, j9), H8m.q6w(3, a9), H8m.l6w(3, o9)],
                    T9 = [{
                        x: R,
                        y: c9,
                        z: 0
                    }, {
                        x: K9,
                        y: c9,
                        z: 0
                    }, {
                        x: K9,
                        y: t9,
                        z: 0
                    }, {
                        x: R,
                        y: t9,
                        z: 0
                    }],
                    S9 = [H8m.X2w(2, S9), H8m.D2w(2, j9), H8m.c2w(2, a9), H8m.z2w(2, o9)],
                    K9 = [cc.p(R, c9), cc.p(K9, c9), cc.p(K9, t9), cc.p(R, t9)];
                for (R = 0; H8m.j2w(4, R); ++R)
                    k9[L9[R]] = T9[R].x, k9[L9[R] + 1] = T9[R].y, k9[L9[R] + 2] = T9[R].z, V[S9[R]] = H8m.x2w(K9[R].x, S), V[S9[R] + 1] = U ? H8m.o2w((O - K9[R].y), P) : H8m.p2w(K9[R].y, P);
            }
        this._originalVertices = new Float32Array(this._vertices);
        X.bindBuffer(X.ARRAY_BUFFER, this._verticesBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._vertices, X.DYNAMIC_DRAW);
        X.bindBuffer(X.ARRAY_BUFFER, this._texCoordinateBuffer);
        X.bufferData(X.ARRAY_BUFFER, this._texCoordinates, X.DYNAMIC_DRAW);
        X.bindBuffer(X.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        X.bufferData(X.ELEMENT_ARRAY_BUFFER, this._indices, X.STATIC_DRAW);
        this._dirty = !0;
    }
});
cc.Grid3D.create = function(X, S, P) {
    var O = new cc.Grid3D;
    return O && O.initWithSize(X, S, P) ? O : H8m.H6P;
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function() {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
    },
    tile: function(X) {
        H8m.Y2w(X.x, (0 | X.x)) && H8m.T2w(X.y, (0 | X.y)) || cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        X = H8m.R2w(12, (this._gridSize.height * X.x + X.y));
        var S = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(S[X], S[X + 1], S[X + 2]), new cc.Vertex3F(S[X + 3], S[X + 4], S[X + 5]), new cc.Vertex3F(S[X + 6], S[X + 7], S[X + 8]), new cc.Vertex3F(S[X + 9], S[X + 10], S[X + 11]));
    },
    originalTile: function(X) {
        H8m.M2w(X.x, (0 | X.x)) && H8m.V2w(X.y, (0 | X.y)) || cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        X = H8m.s2w(12, (this._gridSize.height * X.x + X.y));
        var S = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(S[X], S[X + 1], S[X + 2]), new cc.Vertex3F(S[X + 3], S[X + 4], S[X + 5]), new cc.Vertex3F(S[X + 6], S[X + 7], S[X + 8]), new cc.Vertex3F(S[X + 9], S[X + 10], S[X + 11]));
    },
    setTile: function(X, S) {
        H8m.U2w(X.x, (0 | X.x)) && H8m.b2w(X.y, (0 | X.y)) || cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var P = H8m.F2w(12, (this._gridSize.height * X.x + X.y)),
            O = this._vertices;
        O[P] = S.bl.x;
        O[P + 1] = S.bl.y;
        O[P + 2] = S.bl.z;
        O[P + 3] = S.br.x;
        O[P + 4] = S.br.y;
        O[P + 5] = S.br.z;
        O[P + 6] = S.tl.x;
        O[P + 7] = S.tl.y;
        O[P + 8] = S.tl.z;
        O[P + 9] = S.tr.x;
        O[P + 10] = S.tr.y;
        O[P + 11] = S.tr.z;
        this._dirty = !0;
    },
    blit: function() {
        var X = H8m.k9z(this._gridSize.width, this._gridSize.height);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var S = cc._renderContext,
            P = this._dirty;
        cc.glEnableVertexAttribs(H8m.L9z(cc.VERTEX_ATTRIB_FLAG_POSITION, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS));
        S.bindBuffer(S.ARRAY_BUFFER, this._verticesBuffer);
        P && S.bufferData(S.ARRAY_BUFFER, this._vertices, S.DYNAMIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, S.FLOAT, !1, 0, this._vertices);
        S.bindBuffer(S.ARRAY_BUFFER, this._texCoordinateBuffer);
        P && S.bufferData(S.ARRAY_BUFFER, this._texCoordinates, S.DYNAMIC_DRAW);
        S.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, S.FLOAT, !1, 0, this._texCoordinates);
        S.bindBuffer(S.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        P && S.bufferData(S.ELEMENT_ARRAY_BUFFER, this._indices, S.STATIC_DRAW);
        S.drawElements(S.TRIANGLES, H8m.i9z(6, X), S.UNSIGNED_SHORT, 0);
        P && (this._dirty = !1);
        cc.INCREMENT_GL_DRAWS(1);
    },
    reuse: function() {
        if (H8m.S9z(0, this._reuseGrid)) {
            for (var X = this._vertices, S = this._originalVertices, P = 0; H8m.P9z(P, X.length); P++)
                S[P] = X[P];
            --this._reuseGrid;
        }
    },
    calculateVertexPoints: function() {
        var X = this._texture.pixelsWidth,
            S = this._texture.pixelsHeight,
            P = this._texture.getContentSizeInPixels().height,
            O = this._gridSize,
            Z = H8m.a9z(O.width, O.height);
        this._vertices = new Float32Array(H8m.O9z(12, Z));
        this._texCoordinates = new Float32Array(H8m.B9z(8, Z));
        this._indices = new Uint16Array(H8m.Z9z(6, Z));
        var Y = cc._renderContext;
        this._verticesBuffer && Y.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = Y.createBuffer();
        this._texCoordinateBuffer && Y.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = Y.createBuffer();
        this._indicesBuffer && Y.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = Y.createBuffer();
        var T,
            R,
            E = 0,
            V = this._step,
            U = this._vertices,
            k9 = this._texCoordinates,
            L9 = this._isTextureFlipped;
        for (T = 0; H8m.J9z(T, O.width); T++)
            for (R = 0; H8m.n9z(R, O.height); R++) {
                var K9 = H8m.G9z(T, V.x),
                    c9 = K9 + V.x,
                    t9 = H8m.W9z(R, V.y),
                    S9 = t9 + V.y;
                U[H8m.v9z(12, E)] = K9;
                U[H8m.u9z(12, E) + 1] = t9;
                U[H8m.H9z(12, E) + 2] = 0;
                U[H8m.f9z(12, E) + 3] = c9;
                U[H8m.I9z(12, E) + 4] = t9;
                U[H8m.g1z(12, E) + 5] = 0;
                U[H8m.K1z(12, E) + 6] = K9;
                U[H8m.d1z(12, E) + 7] = S9;
                U[H8m.t1z(12, E) + 8] = 0;
                U[H8m.w1z(12, E) + 9] = c9;
                U[H8m.e1z(12, E) + 10] = S9;
                U[H8m.Q1z(12, E) + 11] = 0;
                var j9 = t9,
                    a9 = S9;
                L9 && (j9 = H8m.r1z(P, t9), a9 = H8m.N1z(P, S9));
                k9[H8m.m1z(8, E)] = H8m.A1z(K9, X);
                k9[H8m.E1z(8, E) + 1] = H8m.C1z(j9, S);
                k9[H8m.h1z(8, E) + 2] = H8m.y1z(c9, X);
                k9[H8m.q1z(8, E) + 3] = H8m.l1z(j9, S);
                k9[H8m.X8z(8, E) + 4] = H8m.D8z(K9, X);
                k9[H8m.c8z(8, E) + 5] = H8m.z8z(a9, S);
                k9[H8m.j8z(8, E) + 6] = H8m.x8z(c9, X);
                k9[H8m.o8z(8, E) + 7] = H8m.p8z(a9, S);
                E++;
            }
        X = this._indices;
        for (T = 0; H8m.Y8z(T, Z); T++)
            X[H8m.T8z(6, T) + 0] = H8m.R8z(4, T) + 0, X[H8m.M8z(6, T) + 1] = H8m.V8z(4, T) + 1, X[H8m.s8z(6, T) + 2] = H8m.U8z(4, T) + 2, X[H8m.b8z(6, T) + 3] = H8m.F8z(4, T) + 1, X[H8m.k4z(6, T) + 4] = H8m.L4z(4, T) + 2, X[H8m.i4z(6, T) + 5] = H8m.S4z(4, T) + 3;
        this._originalVertices = new Float32Array(this._vertices);
        Y.bindBuffer(Y.ARRAY_BUFFER, this._verticesBuffer);
        Y.bufferData(Y.ARRAY_BUFFER, this._vertices, Y.DYNAMIC_DRAW);
        Y.bindBuffer(Y.ARRAY_BUFFER, this._texCoordinateBuffer);
        Y.bufferData(Y.ARRAY_BUFFER, this._texCoordinates, Y.DYNAMIC_DRAW);
        Y.bindBuffer(Y.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        Y.bufferData(Y.ELEMENT_ARRAY_BUFFER, this._indices, Y.DYNAMIC_DRAW);
        this._dirty = !0;
    }
});
cc.TiledGrid3D.create = function(X, S, P) {
    var O = new cc.TiledGrid3D;
    O.initWithSize(X, S, P);
    return O;
};
cc.Grabber = cc.Class.extend({
    _FBO: H8m.H6P,
    _oldFBO: H8m.H6P,
    _oldClearColor: H8m.H6P,
    _gl: H8m.H6P,
    ctor: function() {
        this._gl = cc._renderContext;
        this._oldClearColor = [H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H];
        this._oldFBO = H8m.H6P;
        this._FBO = this._gl.createFramebuffer();
    },
    grab: function(X) {
        var S = "Frame Grabber: could not attach texture to frmaebuffer",
            P = this._gl;
        this._oldFBO = P.getParameter(P.FRAMEBUFFER_BINDING);
        P.bindFramebuffer(P.FRAMEBUFFER, this._FBO);
        P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, X._webTextureObj, H8m.U7H);
        H8m.P4z(P.checkFramebufferStatus(P.FRAMEBUFFER), P.FRAMEBUFFER_COMPLETE) && cc.log(S);
        P.bindFramebuffer(P.FRAMEBUFFER, this._oldFBO);
    },
    beforeRender: function(X) {
        X = this._gl;
        this._oldFBO = X.getParameter(X.FRAMEBUFFER_BINDING);
        X.bindFramebuffer(X.FRAMEBUFFER, this._FBO);
        this._oldClearColor = X.getParameter(X.COLOR_CLEAR_VALUE);
        X.clearColor(H8m.U7H, H8m.U7H, H8m.U7H, H8m.U7H);
        X.clear(H8m.a4z(X.COLOR_BUFFER_BIT, X.DEPTH_BUFFER_BIT));
    },
    afterRender: function(X) {
        X = this._gl;
        X.bindFramebuffer(X.FRAMEBUFFER, this._oldFBO);
        X.colorMask(!H8m.U7H, !H8m.U7H, !H8m.U7H, !H8m.U7H);
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO);
    }
});
H8m.p8y();
cc.Action = cc.Class.extend({
    originalTarget: H8m.H6P,
    target: H8m.H6P,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = H8m.H6P;
        this.tag = cc.ACTION_TAG_INVALID;
    },
    copy: function() {
        return this.clone();
    },
    clone: function() {
        var X = new cc.Action;
        X.originalTarget = H8m.H6P;
        X.target = H8m.H6P;
        X.tag = this.tag;
        return X;
    },
    isDone: function() {
        return !H8m.U7H;
    },
    startWithTarget: function(X) {
        this.target = this.originalTarget = X;
    },
    stop: function() {
        this.target = H8m.H6P;
    },
    step: function(X) {
        var S = "[Action step]. override me";
        cc.log(S);
    },
    update: function(X) {
        var S = "[Action update]. override me";
        cc.log(S);
    },
    getTarget: function() {
        return this.target;
    },
    setTarget: function(X) {
        this.target = X;
    },
    getOriginalTarget: function() {
        return this.originalTarget;
    },
    setOriginalTarget: function(X) {
        this.originalTarget = X;
    },
    getTag: function() {
        return this.tag;
    },
    setTag: function(X) {
        this.tag = X;
    },
    retain: function() {},
    release: function() {}
});
cc.Action.create = function() {
    return new cc.Action;
};
cc.FiniteTimeAction = cc.Action.extend({
    _duration: H8m.U7H,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = H8m.U7H;
    },
    getDuration: function() {
        return this._duration;
    },
    setDuration: function(X) {
        this._duration = X;
    },
    reverse: function() {
        var X = "cocos2d: FiniteTimeAction#reverse: Implement me";
        cc.log(X);
        return H8m.H6P;
    },
    clone: function() {
        return new cc.FiniteTimeAction;
    }
});
cc.Speed = cc.Action.extend({
    _speed: H8m.U7H,
    _innerAction: H8m.H6P,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._speed = H8m.U7H;
        this._innerAction = H8m.H6P;
    },
    getSpeed: function() {
        return this._speed;
    },
    setSpeed: function(X) {
        this._speed = X;
    },
    initWithAction: function(X, S) {
        var P = "cc.Speed.initWithAction(): action must be non nil";
        if (!X)
            throw P;
        this._innerAction = X;
        this._speed = S;
        return !H8m.U7H;
    },
    clone: function() {
        var X = new cc.Speed;
        X.initWithAction(this._innerAction.clone(), this._speed);
        return X;
    },
    startWithTarget: function(X) {
        cc.Action.prototype.startWithTarget.call(this, X);
        this._innerAction.startWithTarget(X);
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    step: function(X) {
        this._innerAction.step(H8m.O4z(X, this._speed));
    },
    isDone: function() {
        return this._innerAction.isDone();
    },
    reverse: function() {
        return cc.Speed.create(this._innerAction.reverse(), this._speed);
    },
    setInnerAction: function(X) {
        H8m.B4z(this._innerAction, X) && (this._innerAction = X);
    },
    getInnerAction: function() {
        return this._innerAction;
    }
});
cc.Speed.create = function(X, S) {
    var P = new cc.Speed;
    return P && P.initWithAction(X, S) ? P : H8m.H6P;
};
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    _worldRect: null,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
    },
    clone: function() {
        var X = new cc.Follow,
            S = this._worldRect,
            S = new cc.Rect(S.x, S.y, S.width, S.height);
        X.initWithTarget(this._followedNode, S);
        return X;
    },
    isBoundarySet: function() {
        return this._boundarySet;
    },
    setBoudarySet: function(X) {
        this._boundarySet = X;
    },
    initWithTarget: function(X, S) {
        if (!X)
            throw "cc.Follow.initWithAction(): followedNode must be non nil";
        S = S || cc.rect(0, 0, 0, 0);
        this._followedNode = X;
        this._worldRect = S;
        this._boundarySet = !cc._rectEqualToZero(S);
        this._boundaryFullyCovered = !1;
        var P = cc.director.getWinSize();
        this._fullScreenSize = cc.p(P.width, P.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(S.x + S.width - this._fullScreenSize.x), this.rightBoundary = -S.x, this.topBoundary = -S.y, this.bottomBoundary = -(S.y + S.height - this._fullScreenSize.y), H8m.Z4z(this.rightBoundary, this.leftBoundary) && (this.rightBoundary = this.leftBoundary = H8m.J4z((this.leftBoundary + this.rightBoundary), 2)), H8m.n4z(this.topBoundary, this.bottomBoundary) && (this.topBoundary = this.bottomBoundary = H8m.G4z((this.topBoundary + this.bottomBoundary), 2)), H8m.W4z(this.topBoundary, this.bottomBoundary) && H8m.v4z(this.leftBoundary, this.rightBoundary) && (this._boundaryFullyCovered = !0));
        return !0;
    },
    step: function(X) {
        X = this._followedNode.x;
        var S = this._followedNode.y;
        X = H8m.u4z(this._halfScreenSize.x, X);
        S = H8m.H4z(this._halfScreenSize.y, S);
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(X, this.leftBoundary, this.rightBoundary), cc.clampf(S, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(X, S);
    },
    isDone: function() {
        return !this._followedNode.running;
    },
    stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this);
    }
});
cc.Follow.create = function(X, S) {
    S = S || cc.rect(0, 0, 0, 0);
    var P = new cc.Follow;
    return H8m.f4z(H8m.H6P, S) && P && P.initWithTarget(X, S) || P && P.initWithTarget(X) ? P : H8m.H6P;
};
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: H8m.U7H,
    _firstTick: !H8m.h7H,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._elapsed = H8m.U7H;
        this._firstTick = !H8m.h7H;
    },
    getElapsed: function() {
        return this._elapsed;
    },
    initWithDuration: function(X) {
        this._duration = H8m.I4z(H8m.U7H, X) ? cc.FLT_EPSILON : X;
        this._elapsed = H8m.U7H;
        return this._firstTick = !H8m.U7H;
    },
    isDone: function() {
        return H8m.g7z(this._elapsed, this._duration);
    },
    clone: function() {
        var X = new cc.ActionInterval;
        X.initWithDuration(this._duration);
        return X;
    },
    step: function(X) {
        this._firstTick ? (this._firstTick = !H8m.h7H, this._elapsed = H8m.U7H) : this._elapsed += X;
        X = H8m.K7z(this._elapsed, (H8m.M8K < this._duration ? this._duration : H8m.M8K));
        X = H8m.d7z(H8m.h7H, X) ? X : H8m.h7H;
        this.update(H8m.t7z(H8m.U7H, X) ? X : H8m.U7H);
    },
    startWithTarget: function(X) {
        cc.Action.prototype.startWithTarget.call(this, X);
        this._elapsed = H8m.U7H;
        this._firstTick = !H8m.U7H;
    },
    reverse: function() {
        var X = "cc.IntervalAction: reverse not implemented.";
        cc.log(X);
        return H8m.H6P;
    },
    setAmplitudeRate: function(X) {
        var S = "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.";
        cc.log(S);
    },
    getAmplitudeRate: function() {
        var X = "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.";
        cc.log(X);
    }
});
cc.ActionInterval.create = function(X) {
    var S = new cc.ActionInterval;
    S.initWithDuration(X);
    return S;
};
cc.Sequence = cc.ActionInterval.extend({
    _actions: H8m.H6P,
    _split: H8m.H6P,
    _last: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        this._split = H8m.H6P;
        this._last = H8m.U7H;
    },
    initWithTwoActions: function(X, S) {
        var P = "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        if (!X || !S)
            throw P;
        var O = X.getDuration() + S.getDuration();
        this.initWithDuration(O);
        this._actions[H8m.U7H] = X;
        this._actions[H8m.h7H] = S;
        return !H8m.U7H;
    },
    clone: function() {
        var X = new cc.Sequence;
        X.initWithTwoActions(this._actions[H8m.U7H].clone(), this._actions[H8m.h7H].clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._split = H8m.w7z(this._actions[H8m.U7H].getDuration(), this._duration);
        this._last = -H8m.h7H;
    },
    stop: function() {
        -H8m.h7H !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
    },
    update: function(X) {
        var S = H8m.U7H,
            P = this._split,
            O = this._actions,
            Z = this._last;
        H8m.e7z(X, P) ? (X = H8m.Q7z(H8m.U7H, P) ? H8m.r7z(X, P) : H8m.h7H, H8m.N7z(H8m.U7H, S) && H8m.m7z(H8m.h7H, Z) && (O[H8m.h7H].update(H8m.U7H), O[H8m.h7H].stop())) : (S = H8m.h7H, X = H8m.A7z(H8m.h7H, P) ? H8m.h7H : H8m.E7z((X - P), (H8m.h7H - P)), -H8m.h7H === Z && (O[H8m.U7H].startWithTarget(this.target), O[H8m.U7H].update(H8m.h7H), O[H8m.U7H].stop()), Z || (O[H8m.U7H].update(H8m.h7H), O[H8m.U7H].stop()));
        H8m.C7z(Z, S) && O[S].isDone() || (H8m.h7z(Z, S) && O[S].startWithTarget(this.target), O[S].update(X), this._last = S);
    },
    reverse: function() {
        return cc.Sequence._actionOneTwo(this._actions[H8m.h7H].reverse(), this._actions[H8m.U7H].reverse());
    },
    copy: function() {
        return this.clone();
    }
});
cc.Sequence.create = function(X) {
    var S = H8m.y7z(X, Array) ? X : arguments;
    H8m.q7z(0, S.length) && H8m.l7z(null, S[S.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
    for (var P = S[0], O = 1; H8m.X0z(O, S.length); O++)
        S[O] && (P = cc.Sequence._actionOneTwo(P, S[O]));
    return P;
};
cc.Sequence._actionOneTwo = function(X, S) {
    var P = new cc.Sequence;
    P.initWithTwoActions(X, S);
    return P;
};
cc.Repeat = cc.ActionInterval.extend({
    _times: H8m.U7H,
    _total: H8m.U7H,
    _nextDt: H8m.U7H,
    _actionInstant: !H8m.h7H,
    _innerAction: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._nextDt = this._total = this._times = H8m.U7H;
        this._actionInstant = !H8m.h7H;
        this._innerAction = H8m.H6P;
    },
    initWithAction: function(X, S) {
        var P = H8m.D0z(X.getDuration(), S);
        return this.initWithDuration(P) ? (this._times = S, this._innerAction = X, H8m.c0z(X, cc.ActionInstant) && (this._times -= H8m.h7H), this._total = H8m.U7H, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.Repeat;
        X.initWithAction(this._innerAction.clone(), this._times);
        return X;
    },
    startWithTarget: function(X) {
        this._total = H8m.U7H;
        this._nextDt = H8m.z0z(this._innerAction.getDuration(), this._duration);
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._innerAction.startWithTarget(X);
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    update: function(X) {
        var S = this._innerAction,
            P = this._duration,
            O = this._times,
            Z = this._nextDt;
        if (H8m.j0z(X, Z)) {
            for (; H8m.x0z(X, Z) && H8m.o0z(this._total, O);)
                S.update(H8m.h7H), this._total++, S.stop(), S.startWithTarget(this.target), this._nextDt = Z += H8m.p0z(S.getDuration(), P);
            H8m.Y0z(H8m.h7H, X) && H8m.T0z(this._total, O) && this._total++;
            this._actionInstant && (H8m.R0z(this._total, O) ? (S.update(H8m.h7H), S.stop()) : S.update(H8m.M0z(X, (Z - S.getDuration() / P))));
        } else
            S.update(H8m.V0z(X, O, H8m.h7H));
    },
    isDone: function() {
        return H8m.h0z(this._total, this._times);
    },
    reverse: function() {
        return cc.Repeat.create(this._innerAction.reverse(), this._times);
    },
    setInnerAction: function(X) {
        H8m.y0z(this._innerAction, X) && (this._innerAction = X);
    },
    getInnerAction: function() {
        return this._innerAction;
    }
});
cc.Repeat.create = function(X, S) {
    var P = new cc.Repeat;
    P.initWithAction(X, S);
    return P;
};
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = H8m.H6P;
    },
    initWithAction: function(X) {
        var S = "cc.RepeatForever.initWithAction(): action must be non null";
        if (!X)
            throw S;
        this._innerAction = X;
        return !H8m.U7H;
    },
    clone: function() {
        var X = new cc.RepeatForever;
        X.initWithAction(this._innerAction.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._innerAction.startWithTarget(X);
    },
    step: function(X) {
        var S = this._innerAction;
        S.step(X);
        S.isDone() && (S.startWithTarget(this.target), S.step(H8m.q0z(S.getElapsed(), S.getDuration())));
    },
    isDone: function() {
        return !H8m.h7H;
    },
    reverse: function() {
        return cc.RepeatForever.create(this._innerAction.reverse());
    },
    setInnerAction: function(X) {
        H8m.l0z(this._innerAction, X) && (this._innerAction = X);
    },
    getInnerAction: function() {
        return this._innerAction;
    }
});
cc.RepeatForever.create = function(X) {
    var S = new cc.RepeatForever;
    return S && S.initWithAction(X) ? S : H8m.H6P;
};
cc.Spawn = cc.ActionInterval.extend({
    _one: H8m.H6P,
    _two: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = H8m.H6P;
    },
    initWithTwoActions: function(X, S) {
        var P = "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        if (!X || !S)
            throw P;
        var O = !H8m.h7H,
            Z = X.getDuration(),
            Y = S.getDuration();
        this.initWithDuration(Math.max(Z, Y)) && (this._one = X, this._two = S, H8m.X3z(Z, Y) ? this._two = cc.Sequence._actionOneTwo(S, cc.DelayTime.create(H8m.D3z(Z, Y))) : H8m.c3z(Z, Y) && (this._one = cc.Sequence._actionOneTwo(X, cc.DelayTime.create(H8m.z3z(Y, Z)))), O = !H8m.U7H);
        return O;
    },
    clone: function() {
        var X = new cc.Spawn;
        X.initWithTwoActions(this._one.clone(), this._two.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._one.startWithTarget(X);
        this._two.startWithTarget(X);
    },
    stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
    },
    update: function(X) {
        this._one && this._one.update(X);
        this._two && this._two.update(X);
    },
    reverse: function() {
        return cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
    }
});
cc.Spawn.create = function(X) {
    var S = H8m.j3z(X, Array) ? X : arguments;
    H8m.x3z(0, S.length) && H8m.o3z(null, S[S.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
    for (var P = S[0], O = 1; H8m.p3z(O, S.length); O++)
        H8m.Y3z(null, S[O]) && (P = this._actionOneTwo(P, S[O]));
    return P;
};
cc.Spawn._actionOneTwo = function(X, S) {
    var P = new cc.Spawn;
    P.initWithTwoActions(X, S);
    return P;
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: H8m.U7H,
    _startAngleX: H8m.U7H,
    _diffAngleX: H8m.U7H,
    _dstAngleY: H8m.U7H,
    _startAngleY: H8m.U7H,
    _diffAngleY: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._diffAngleY = this._startAngleY = this._dstAngleY = this._diffAngleX = this._startAngleX = this._dstAngleX = H8m.U7H;
    },
    initWithDuration: function(X, S, P) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._dstAngleX = S || H8m.U7H, this._dstAngleY = P || this._dstAngleX, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.RotateTo;
        X.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        var S = H8m.T3z(X.rotationX, H8m.Z7P),
            P = H8m.R3z(this._dstAngleX, S);
        H8m.M3z(H8m.P0S, P) && (P -= H8m.Z7P);
        -H8m.P0S > P && (P += H8m.Z7P);
        this._startAngleX = S;
        this._diffAngleX = P;
        this._startAngleY = H8m.V3z(X.rotationY, H8m.Z7P);
        X = H8m.s3z(this._dstAngleY, this._startAngleY);
        H8m.U3z(H8m.P0S, X) && (X -= H8m.Z7P);
        -H8m.P0S > X && (X += H8m.Z7P);
        this._diffAngleY = X;
    },
    reverse: function() {
        var X = "cc.RotateTo.reverse(): it should be overridden in subclass.";
        cc.log(X);
    },
    update: function(X) {
        this.target && (this.target.rotationX = this._startAngleX + H8m.b3z(this._diffAngleX, X), this.target.rotationY = this._startAngleY + H8m.F3z(this._diffAngleY, X));
    }
});
cc.RotateTo.create = function(X, S, P) {
    var O = new cc.RotateTo;
    O.initWithDuration(X, S, P);
    return O;
};
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: H8m.U7H,
    _startAngleX: H8m.U7H,
    _angleY: H8m.U7H,
    _startAngleY: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startAngleY = this._angleY = this._startAngleX = this._angleX = H8m.U7H;
    },
    initWithDuration: function(X, S, P) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._angleX = S || H8m.U7H, this._angleY = P || this._angleX, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.RotateBy;
        X.initWithDuration(this._duration, this._angleX, this._angleY);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._startAngleX = X.rotationX;
        this._startAngleY = X.rotationY;
    },
    update: function(X) {
        this.target && (this.target.rotationX = this._startAngleX + H8m.k5z(this._angleX, X), this.target.rotationY = this._startAngleY + H8m.L5z(this._angleY, X));
    },
    reverse: function() {
        return cc.RotateBy.create(this._duration, -this._angleX, -this._angleY);
    }
});
cc.RotateBy.create = function(X, S, P) {
    var O = new cc.RotateBy;
    O.initWithDuration(X, S, P);
    return O;
};
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: H8m.H6P,
    _startPosition: H8m.H6P,
    _previousPosition: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(H8m.U7H, H8m.U7H);
        this._startPosition = cc.p(H8m.U7H, H8m.U7H);
        this._previousPosition = cc.p(H8m.U7H, H8m.U7H);
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._positionDelta.x = S.x, this._positionDelta.y = S.y, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.MoveBy;
        X.initWithDuration(this._duration, this._positionDelta);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        var S = X.getPositionX();
        X = X.getPositionY();
        this._previousPosition.x = S;
        this._previousPosition.y = X;
        this._startPosition.x = S;
        this._startPosition.y = X;
    },
    update: function(X) {
        if (this.target) {
            var S = H8m.i5z(this._positionDelta.x, X);
            X *= this._positionDelta.y;
            var P = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var O = this.target.getPositionX(),
                    Z = this.target.getPositionY(),
                    Y = this._previousPosition;
                P.x = P.x + O - Y.x;
                P.y = P.y + Z - Y.y;
                S += P.x;
                X += P.y;
                Y.x = S;
                Y.y = X;
                this.target.setPosition(S, X);
            } else
                this.target.setPosition(P.x + S, P.y + X);
        }
    },
    reverse: function() {
        return cc.MoveBy.create(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
    }
});
cc.MoveBy.create = function(X, S) {
    var P = new cc.MoveBy;
    P.initWithDuration(X, S);
    return P;
};
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: H8m.H6P,
    ctor: function() {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(H8m.U7H, H8m.U7H);
    },
    initWithDuration: function(X, S) {
        return cc.MoveBy.prototype.initWithDuration.call(this, X, S) ? (this._endPosition.x = S.x, this._endPosition.y = S.y, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.MoveTo;
        X.initWithDuration(this._duration, this._endPosition);
        return X;
    },
    startWithTarget: function(X) {
        cc.MoveBy.prototype.startWithTarget.call(this, X);
        this._positionDelta.x = H8m.S5z(this._endPosition.x, X.getPositionX());
        this._positionDelta.y = H8m.P5z(this._endPosition.y, X.getPositionY());
    }
});
cc.MoveTo.create = function(X, S) {
    var P = new cc.MoveTo;
    P.initWithDuration(X, S);
    return P;
};
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: H8m.U7H,
    _skewY: H8m.U7H,
    _startSkewX: H8m.U7H,
    _startSkewY: H8m.U7H,
    _endSkewX: H8m.U7H,
    _endSkewY: H8m.U7H,
    _deltaX: H8m.U7H,
    _deltaY: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._deltaY = this._deltaX = this._endSkewY = this._endSkewX = this._startSkewY = this._startSkewX = this._skewY = this._skewX = H8m.U7H;
    },
    initWithDuration: function(X, S, P) {
        var O = !H8m.h7H;
        cc.ActionInterval.prototype.initWithDuration.call(this, X) && (this._endSkewX = S, this._endSkewY = P, O = !H8m.U7H);
        return O;
    },
    clone: function() {
        var X = new cc.SkewTo;
        X.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._startSkewX = H8m.a5z(X.skewX, H8m.P0S);
        this._deltaX = H8m.O5z(this._endSkewX, this._startSkewX);
        H8m.B5z(H8m.P0S, this._deltaX) && (this._deltaX -= H8m.Z7P);
        -H8m.P0S > this._deltaX && (this._deltaX += H8m.Z7P);
        this._startSkewY = H8m.Z5z(X.skewY, H8m.Z7P);
        this._deltaY = H8m.J5z(this._endSkewY, this._startSkewY);
        H8m.n5z(H8m.P0S, this._deltaY) && (this._deltaY -= H8m.Z7P);
        -H8m.P0S > this._deltaY && (this._deltaY += H8m.Z7P);
    },
    update: function(X) {
        this.target.skewX = this._startSkewX + H8m.G5z(this._deltaX, X);
        this.target.skewY = this._startSkewY + H8m.W5z(this._deltaY, X);
    }
});
cc.SkewTo.create = function(X, S, P) {
    var O = new cc.SkewTo;
    O && O.initWithDuration(X, S, P);
    return O;
};
cc.SkewBy = cc.SkewTo.extend({
    initWithDuration: function(X, S, P) {
        var O = !H8m.h7H;
        cc.SkewTo.prototype.initWithDuration.call(this, X, S, P) && (this._skewX = S, this._skewY = P, O = !H8m.U7H);
        return O;
    },
    clone: function() {
        var X = new cc.SkewBy;
        X.initWithDuration(this._duration, this._skewX, this._skewY);
        return X;
    },
    startWithTarget: function(X) {
        cc.SkewTo.prototype.startWithTarget.call(this, X);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
    },
    reverse: function() {
        return cc.SkewBy.create(this._duration, -this._skewX, -this._skewY);
    }
});
cc.SkewBy.create = function(X, S, P) {
    var O = new cc.SkewBy;
    O && O.initWithDuration(X, S, P);
    return O;
};
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: H8m.H6P,
    _delta: H8m.H6P,
    _height: H8m.U7H,
    _jumps: H8m.U7H,
    _previousPosition: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(H8m.U7H, H8m.U7H);
        this._previousPosition = cc.p(H8m.U7H, H8m.U7H);
        this._delta = cc.p(H8m.U7H, H8m.U7H);
        this._jumps = this._height = H8m.U7H;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._delta.x = S.x, this._delta.y = S.y, this._height = P, this._jumps = O, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.JumpBy;
        X.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        var S = X.getPositionX();
        X = X.getPositionY();
        this._previousPosition.x = S;
        this._previousPosition.y = X;
        this._startPosition.x = S;
        this._startPosition.y = X;
    },
    update: function(X) {
        if (this.target) {
            var S = H8m.v5z(X, this._jumps, H8m.h7H),
                S = H8m.U5z(H8m.q7H, this._height, S, (H8m.h7H - S)),
                S = S + H8m.f5z(this._delta.y, X);
            X *= this._delta.x;
            var P = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var O = this.target.getPositionX(),
                    Z = this.target.getPositionY(),
                    Y = this._previousPosition;
                P.x = P.x + O - Y.x;
                P.y = P.y + Z - Y.y;
                X += P.x;
                S += P.y;
                Y.x = X;
                Y.y = S;
                this.target.setPosition(X, S);
            } else
                this.target.setPosition(P.x + X, P.y + S);
        }
    },
    reverse: function() {
        return cc.JumpBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
    }
});
cc.JumpBy.create = function(X, S, P, O) {
    var Z = new cc.JumpBy;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.JumpTo = cc.JumpBy.extend({
    startWithTarget: function(X) {
        cc.JumpBy.prototype.startWithTarget.call(this, X);
        this._delta.x -= this._startPosition.x;
        this._delta.y -= this._startPosition.y;
    },
    clone: function() {
        var X = new cc.JumpTo;
        X.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return X;
    }
});
cc.JumpTo.create = function(X, S, P, O) {
    var Z = new cc.JumpTo;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.bezierAt = function(X, S, P, O, Z) {
    return H8m.I5z(Math.pow(H8m.h7H - Z, H8m.v7H), X) + H8m.g6z(H8m.v7H, Z, Math.pow(H8m.h7H - Z, H8m.s7H), S) + H8m.c6z(H8m.v7H, Math.pow(Z, H8m.s7H), (H8m.h7H - Z), P) + H8m.P6z(Math.pow(Z, H8m.v7H), O);
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._config = S, !0) : !1;
    },
    clone: function() {
        for (var X = new cc.BezierBy, S = [], P = 0; H8m.a6z(P, this._config.length); P++) {
            var O = this._config[P];
            S.push(cc.p(O.x, O.y));
        }
        X.initWithDuration(this._duration, S);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        var S = X.getPositionX();
        X = X.getPositionY();
        this._previousPosition.x = S;
        this._previousPosition.y = X;
        this._startPosition.x = S;
        this._startPosition.y = X;
    },
    update: function(X) {
        if (this.target) {
            var S = this._config,
                P = S[0].y,
                O = S[1].y,
                Z = S[2].y,
                S = cc.bezierAt(0, S[0].x, S[1].x, S[2].x, X);
            X = cc.bezierAt(0, P, O, Z, X);
            P = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var O = this.target.getPositionX(),
                    Z = this.target.getPositionY(),
                    Y = this._previousPosition;
                P.x = P.x + O - Y.x;
                P.y = P.y + Z - Y.y;
                S += P.x;
                X += P.y;
                Y.x = S;
                Y.y = X;
                this.target.setPosition(S, X);
            } else
                this.target.setPosition(P.x + S, P.y + X);
        }
    },
    reverse: function() {
        var X = this._config,
            X = [cc.pAdd(X[1], cc.pNeg(X[2])), cc.pAdd(X[0], cc.pNeg(X[2])), cc.pNeg(X[2])];
        return cc.BezierBy.create(this._duration, X);
    }
});
cc.BezierBy.create = function(X, S) {
    var P = new cc.BezierBy;
    P.initWithDuration(X, S);
    return P;
};
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: H8m.H6P,
    ctor: function() {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._toConfig = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.BezierTo;
        X.initWithDuration(this._duration, this._toConfig);
        return X;
    },
    startWithTarget: function(X) {
        cc.BezierBy.prototype.startWithTarget.call(this, X);
        X = this._startPosition;
        var S = this._toConfig,
            P = this._config;
        P[H8m.U7H] = cc.pSub(S[H8m.U7H], X);
        P[H8m.h7H] = cc.pSub(S[H8m.h7H], X);
        P[H8m.s7H] = cc.pSub(S[H8m.s7H], X);
    }
});
cc.BezierTo.create = function(X, S) {
    var P = new cc.BezierTo;
    P.initWithDuration(X, S);
    return P;
};
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: H8m.h7H,
    _scaleY: H8m.h7H,
    _startScaleX: H8m.h7H,
    _startScaleY: H8m.h7H,
    _endScaleX: H8m.U7H,
    _endScaleY: H8m.U7H,
    _deltaX: H8m.U7H,
    _deltaY: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startScaleY = this._startScaleX = this._scaleY = this._scaleX = H8m.h7H;
        this._deltaY = this._deltaX = this._endScaleY = this._endScaleX = H8m.U7H;
    },
    initWithDuration: function(X, S, P) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._endScaleX = S, this._endScaleY = H8m.O6z(H8m.H6P, P) ? P : S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.ScaleTo;
        X.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._startScaleX = X.scaleX;
        this._startScaleY = X.scaleY;
        this._deltaX = H8m.B6z(this._endScaleX, this._startScaleX);
        this._deltaY = H8m.Z6z(this._endScaleY, this._startScaleY);
    },
    update: function(X) {
        this.target && (this.target.scaleX = this._startScaleX + H8m.J6z(this._deltaX, X), this.target.scaleY = this._startScaleY + H8m.n6z(this._deltaY, X));
    }
});
cc.ScaleTo.create = function(X, S, P) {
    var O = new cc.ScaleTo;
    O.initWithDuration(X, S, P);
    return O;
};
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(X) {
        cc.ScaleTo.prototype.startWithTarget.call(this, X);
        this._deltaX = H8m.G6z(this._startScaleX * this._endScaleX, this._startScaleX);
        this._deltaY = H8m.W6z(this._startScaleY * this._endScaleY, this._startScaleY);
    },
    reverse: function() {
        return cc.ScaleBy.create(this._duration, H8m.v6z(H8m.h7H, this._endScaleX), H8m.u6z(H8m.h7H, this._endScaleY));
    },
    clone: function() {
        var X = new cc.ScaleBy;
        X.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return X;
    }
});
cc.ScaleBy.create = function(X, S, P) {
    var O = new cc.ScaleBy;
    O.initWithDuration(X, S, P);
    return O;
};
cc.Blink = cc.ActionInterval.extend({
    _times: H8m.U7H,
    _originalState: !H8m.h7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._times = H8m.U7H;
        this._originalState = !H8m.h7H;
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._times = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.Blink;
        X.initWithDuration(this._duration, this._times);
        return X;
    },
    update: function(X) {
        if (this.target && !this.isDone()) {
            var S = H8m.H6z(H8m.h7H, this._times);
            this.target.visible = H8m.f6z(X % S, S / H8m.s7H);
        }
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._originalState = X.visible;
    },
    stop: function() {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
    },
    reverse: function() {
        return cc.Blink.create(this._duration, this._times);
    }
});
cc.Blink.create = function(X, S) {
    var P = new cc.Blink;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: H8m.H6P,
    _fromOpacity: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._fromOpacity = this._toOpacity = H8m.U7H;
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._toOpacity = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.FadeTo;
        X.initWithDuration(this._duration, this._toOpacity);
        return X;
    },
    update: function(X) {
        if (this.target.RGBAProtocol) {
            var S = this._fromOpacity;
            this.target.opacity = S + H8m.I6z((this._toOpacity - S), X);
        }
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this.target.RGBAProtocol && (this._fromOpacity = X.opacity);
    }
});
cc.FadeTo.create = function(X, S) {
    var P = new cc.FadeTo;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: H8m.H6P,
    reverse: function() {
        var X = new cc.FadeOut;
        X.initWithDuration(this._duration, H8m.U7H);
        return X;
    },
    clone: function() {
        var X = new cc.FadeIn;
        X.initWithDuration(this._duration, this._toOpacity);
        return X;
    },
    startWithTarget: function(X) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, X);
    }
});
cc.FadeIn.create = function(X, S) {
    H8m.g2z(H8m.H6P, S) && (S = H8m.s0K);
    var P = new cc.FadeIn;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeOut = cc.FadeTo.extend({
    reverse: function() {
        var X = new cc.FadeIn;
        X._reverseAction = this;
        X.initWithDuration(this._duration, H8m.s0K);
        return X;
    },
    clone: function() {
        var X = new cc.FadeOut;
        X.initWithDuration(this._duration, this._toOpacity);
        return X;
    }
});
cc.FadeOut.create = function(X) {
    var S = new cc.FadeOut;
    S.initWithDuration(X, H8m.U7H);
    return S;
};
cc.TintTo = cc.ActionInterval.extend({
    _to: H8m.H6P,
    _from: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(H8m.U7H, H8m.U7H, H8m.U7H);
        this._from = cc.color(H8m.U7H, H8m.U7H, H8m.U7H);
    },
    initWithDuration: function(X, S, P, O) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._to = cc.color(S, P, O), !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.TintTo,
            S = this._to;
        X.initWithDuration(this._duration, S.r, S.g, S.b);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this.target.RGBAProtocol && (this._from = this.target.color);
    },
    update: function(X) {
        var S = this._from,
            P = this._to;
        this.target.RGBAProtocol && (this.target.color = cc.color(S.r + H8m.K2z((P.r - S.r), X), S.g + H8m.d2z((P.g - S.g), X), S.b + H8m.t2z((P.b - S.b), X)));
    }
});
cc.TintTo.create = function(X, S, P, O) {
    var Z = new cc.TintTo;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: H8m.U7H,
    _deltaG: H8m.U7H,
    _deltaB: H8m.U7H,
    _fromR: H8m.U7H,
    _fromG: H8m.U7H,
    _fromB: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._fromB = this._fromG = this._fromR = this._deltaB = this._deltaG = this._deltaR = H8m.U7H;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._deltaR = S, this._deltaG = P, this._deltaB = O, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.TintBy;
        X.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        X.RGBAProtocol && (X = X.color, this._fromR = X.r, this._fromG = X.g, this._fromB = X.b);
    },
    update: function(X) {
        this.target.RGBAProtocol && (this.target.color = cc.color(this._fromR + H8m.w2z(this._deltaR, X), this._fromG + H8m.e2z(this._deltaG, X), this._fromB + H8m.Q2z(this._deltaB, X)));
    },
    reverse: function() {
        return cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
    }
});
cc.TintBy.create = function(X, S, P, O) {
    var Z = new cc.TintBy;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.DelayTime = cc.ActionInterval.extend({
    update: function(X) {},
    reverse: function() {
        return cc.DelayTime.create(this._duration);
    },
    clone: function() {
        var X = new cc.DelayTime;
        X.initWithDuration(this._duration);
        return X;
    }
});
cc.DelayTime.create = function(X) {
    var S = new cc.DelayTime;
    S.initWithDuration(X);
    return S;
};
cc.ReverseTime = cc.ActionInterval.extend({
    _other: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = H8m.H6P;
    },
    initWithAction: function(X) {
        var S = "cc.ReverseTime.initWithAction(): the action was already passed in.",
            P = "cc.ReverseTime.initWithAction(): action must be non null";
        if (!X)
            throw P;
        if (H8m.r2z(X, this._other))
            throw S;
        return cc.ActionInterval.prototype.initWithDuration.call(this, X.getDuration()) ? (this._other = X, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.ReverseTime;
        X.initWithAction(this._other.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._other.startWithTarget(X);
    },
    update: function(X) {
        this._other && this._other.update(H8m.N2z(H8m.h7H, X));
    },
    reverse: function() {
        return this._other.clone();
    },
    stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
    }
});
cc.ReverseTime.create = function(X) {
    var S = new cc.ReverseTime;
    S.initWithAction(X);
    return S;
};
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._animation = null;
        this._nextFrame = 0;
        this._origFrame = null;
        this._executedLoops = 0;
        this._splitTimes = [];
    },
    getAnimation: function() {
        return this._animation;
    },
    setAnimation: function(X) {
        this._animation = X;
    },
    initWithAnimation: function(X) {
        if (!X)
            throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var S = X.getDuration();
        if (this.initWithDuration(H8m.m2z(S, X.getLoops()))) {
            this._nextFrame = 0;
            this.setAnimation(X);
            this._origFrame = null;
            this._executedLoops = 0;
            var P = this._splitTimes,
                O = P.length = 0,
                Z = H8m.A2z(S, X.getTotalDelayUnits());
            X = X.getFrames();
            cc.arrayVerifyType(X, cc.AnimationFrame);
            for (var Y = 0; H8m.E2z(Y, X.length); Y++) {
                var T = H8m.C2z(O, Z, S),
                    O = O + X[Y].getDelayUnits();
                P.push(T);
            }
            return !0;
        }
        return !1;
    },
    clone: function() {
        var X = new cc.Animate;
        X.initWithAnimation(this._animation.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = X.displayFrame());
        this._executedLoops = this._nextFrame = 0;
    },
    update: function(X) {
        H8m.u2z(1, X) && (X *= this._animation.getLoops(), H8m.H2z((0 | X), this._executedLoops) && (this._nextFrame = 0, this._executedLoops++), X %= 1);
        for (var S = this._animation.getFrames(), P = S.length, O = this._splitTimes, Z = this._nextFrame; H8m.f2z(Z, P); Z++)
            if (H8m.I2z(O[Z], X))
                this.target.setSpriteFrame(S[Z].getSpriteFrame()), this._nextFrame = Z + 1;
            else
                break;
    },
    reverse: function() {
        var X = this._animation,
            S = X.getFrames(),
            P = [];
        cc.arrayVerifyType(S, cc.AnimationFrame);
        if (H8m.g9M(0, S.length))
            for (var O = H8m.K9M(S.length, 1); H8m.d9M(0, O); O--) {
                var Z = S[O];
                if (!Z)
                    break;
                P.push(Z.clone());
            }
        S = cc.Animation.create(P, X.getDelayPerUnit(), X.getLoops());
        S.setRestoreOriginalFrame(X.getRestoreOriginalFrame());
        return cc.Animate.create(S);
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this);
    }
});
cc.Animate.create = function(X) {
    var S = new cc.Animate;
    S.initWithAnimation(X);
    return S;
};
cc.TargetedAction = cc.ActionInterval.extend({
    _action: H8m.H6P,
    _forcedTarget: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._forcedTarget = this._action = H8m.H6P;
    },
    initWithTarget: function(X, S) {
        return this.initWithDuration(S.getDuration()) ? (this._forcedTarget = X, this._action = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.TargetedAction;
        X.initWithTarget(this._forcedTarget, this._action.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._action.startWithTarget(this._forcedTarget);
    },
    stop: function() {
        this._action.stop();
    },
    update: function(X) {
        this._action.update(X);
    },
    getForcedTarget: function() {
        return this._forcedTarget;
    },
    setForcedTarget: function(X) {
        H8m.t9M(this._forcedTarget, X) && (this._forcedTarget = X);
    }
});
cc.TargetedAction.create = function(X, S) {
    var P = new cc.TargetedAction;
    P.initWithTarget(X, S);
    return P;
};
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !H8m.U7H;
    },
    step: function(X) {
        this.update(H8m.h7H);
    },
    update: function(X) {},
    reverse: function() {
        return this.clone();
    },
    clone: function() {
        return new cc.ActionInstant;
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function(X) {
        this.target.visible = !H8m.U7H;
    },
    reverse: function() {
        return cc.Hide.create();
    },
    clone: function() {
        return new cc.Show;
    }
});
cc.Show.create = function() {
    return new cc.Show;
};
cc.Hide = cc.ActionInstant.extend({
    update: function(X) {
        this.target.visible = !H8m.h7H;
    },
    reverse: function() {
        return cc.Show.create();
    },
    clone: function() {
        return new cc.Hide;
    }
});
cc.Hide.create = function() {
    return new cc.Hide;
};
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(X) {
        this.target.visible = !this.target.visible;
    },
    reverse: function() {
        return new cc.ToggleVisibility;
    },
    clone: function() {
        return new cc.ToggleVisibility;
    }
});
cc.ToggleVisibility.create = function() {
    return new cc.ToggleVisibility;
};
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !H8m.U7H,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._isNeedCleanUp = !H8m.U7H;
    },
    update: function(X) {
        this.target.removeFromParent(this._isNeedCleanUp);
    },
    init: function(X) {
        this._isNeedCleanUp = X;
        return !H8m.U7H;
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
    }
});
cc.RemoveSelf.create = function(X) {
    H8m.w9M(H8m.H6P, X) && (X = !H8m.U7H);
    var S = new cc.RemoveSelf;
    S && S.init(X);
    return S;
};
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !H8m.h7H,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !H8m.h7H;
    },
    initWithFlipX: function(X) {
        this._flippedX = X;
        return !H8m.U7H;
    },
    update: function(X) {
        this.target.flippedX = this._flippedX;
    },
    reverse: function() {
        return cc.FlipX.create(!this._flippedX);
    },
    clone: function() {
        var X = new cc.FlipX;
        X.initWithFlipX(this._flippedX);
        return X;
    }
});
cc.FlipX.create = function(X) {
    var S = new cc.FlipX;
    return S.initWithFlipX(X) ? S : H8m.H6P;
};
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !H8m.h7H,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !H8m.h7H;
    },
    initWithFlipY: function(X) {
        this._flippedY = X;
        return !H8m.U7H;
    },
    update: function(X) {
        this.target.flippedY = this._flippedY;
    },
    reverse: function() {
        return cc.FlipY.create(!this._flippedY);
    },
    clone: function() {
        var X = new cc.FlipY;
        X.initWithFlipY(this._flippedY);
        return X;
    }
});
cc.FlipY.create = function(X) {
    var S = new cc.FlipY;
    return S.initWithFlipY(X) ? S : H8m.H6P;
};
cc.Place = cc.ActionInstant.extend({
    _x: H8m.U7H,
    _y: H8m.U7H,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = H8m.U7H;
    },
    initWithPosition: function(X, S) {
        this._x = X;
        this._y = S;
        return !H8m.U7H;
    },
    update: function(X) {
        this.target.setPosition(this._x, this._y);
    },
    clone: function() {
        var X = new cc.Place;
        X.initWithPosition(this._x, this._y);
        return X;
    }
});
cc.Place.create = function(X) {
    var S = new cc.Place;
    S.initWithPosition(X.x, X.y);
    return S;
};
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: H8m.H6P,
    _callFunc: H8m.H6P,
    _function: H8m.H6P,
    _data: H8m.H6P,
    ctor: function() {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._data = this._function = this._callFunc = this._selectorTarget = H8m.H6P;
    },
    initWithTarget: function(X, S, P) {
        this._data = P;
        this._callFunc = X;
        this._selectorTarget = S;
        return !H8m.U7H;
    },
    initWithFunction: function(X) {
        this._function = X;
        return !H8m.U7H;
    },
    execute: function() {
        H8m.e9M(H8m.H6P, this._callFunc) ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(H8m.H6P, this.target);
    },
    update: function(X) {
        this.execute();
    },
    getTargetCallback: function() {
        return this._selectorTarget;
    },
    setTargetCallback: function(X) {
        H8m.Q9M(X, this._selectorTarget) && (this._selectorTarget && (this._selectorTarget = H8m.H6P), this._selectorTarget = X);
    },
    copy: function() {
        var X = new cc.CallFunc;
        this._selectorTarget ? X.initWithTarget(this._callFunc, this._selectorTarget, this._data) : this._function && X.initWithFunction(this._function);
        return X;
    },
    clone: function() {
        var X = new cc.CallFunc;
        this._selectorTarget ? X.initWithTarget(this._callFunc, this._selectorTarget, this._data) : this._function && X.initWithFunction(this._function);
        return X;
    }
});
cc.CallFunc.create = function(X, S, P) {
    var O = new cc.CallFunc;
    if (void H8m.U7H === S) {
        if (O && O.initWithFunction(X))
            return O;
    } else if (O && O.initWithTarget(X, S, P))
        return O._callFunc = X, O;
    return H8m.H6P;
};
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: H8m.U7H,
    _centerYOrig: H8m.U7H,
    _centerZOrig: H8m.U7H,
    _eyeXOrig: H8m.U7H,
    _eyeYOrig: H8m.U7H,
    _eyeZOrig: H8m.U7H,
    _upXOrig: H8m.U7H,
    _upYOrig: H8m.U7H,
    _upZOrig: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = H8m.U7H;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        X = X.getCamera();
        var S = X.getCenter();
        this._centerXOrig = S.x;
        this._centerYOrig = S.y;
        this._centerZOrig = S.z;
        S = X.getEye();
        this._eyeXOrig = S.x;
        this._eyeYOrig = S.y;
        this._eyeZOrig = S.z;
        X = X.getUp();
        this._upXOrig = X.x;
        this._upYOrig = X.y;
        this._upZOrig = X.z;
    },
    clone: function() {
        return new cc.ActionCamera;
    },
    reverse: function() {
        return cc.ReverseTime.create(this);
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: H8m.U7H,
    _deltaRadius: H8m.U7H,
    _angleZ: H8m.U7H,
    _deltaAngleZ: H8m.U7H,
    _angleX: H8m.U7H,
    _deltaAngleX: H8m.U7H,
    _radZ: H8m.U7H,
    _radDeltaZ: H8m.U7H,
    _radX: H8m.U7H,
    _radDeltaX: H8m.U7H,
    ctor: function() {
        cc.ActionCamera.prototype.ctor.call(this);
        this._radDeltaX = this._radX = this._radDeltaZ = this._radZ = this._deltaAngleX = this._angleX = this._deltaAngleZ = this._angleZ = this._deltaRadius = this._radius = H8m.U7H;
    },
    initWithDuration: function(X, S, P, O, Z, Y, T) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._radius = S, this._deltaRadius = P, this._angleZ = O, this._deltaAngleZ = Z, this._angleX = Y, this._deltaAngleX = T, this._radDeltaZ = cc.DEGREES_TO_RADIANS(Z), this._radDeltaX = cc.DEGREES_TO_RADIANS(T), !H8m.U7H) : !H8m.h7H;
    },
    sphericalRadius: function() {
        var X,
            S;
        S = this.target.getCamera();
        var P = S.getEye();
        X = S.getCenter();
        S = H8m.r9M(P.x, X.x);
        var O = H8m.N9M(P.y, X.y);
        X = H8m.m9M(P.z, X.z);
        var P = Math.sqrt(Math.pow(S, H8m.s7H) + Math.pow(O, H8m.s7H) + Math.pow(X, H8m.s7H)),
            Z = Math.sqrt(Math.pow(S, H8m.s7H) + Math.pow(O, H8m.s7H));
        H8m.A9M(H8m.U7H, Z) && (Z = cc.FLT_EPSILON);
        H8m.E9M(H8m.U7H, P) && (P = cc.FLT_EPSILON);
        X = Math.acos(H8m.C9M(X, P));
        S = H8m.h9M(H8m.U7H, S) ? H8m.y9M(Math.PI, Math.asin(O / Z)) : Math.asin(H8m.q9M(O, Z));
        return {
            newRadius: H8m.l9M(P, cc.Camera.getZEye()),
            zenith: X,
            azimuth: S
        };
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        X = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = X.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.RADIANS_TO_DEGREES(X.zenith));
        isNaN(this._angleX) && (this._angleX = cc.RADIANS_TO_DEGREES(X.azimuth));
        this._radZ = cc.DEGREES_TO_RADIANS(this._angleZ);
        this._radX = cc.DEGREES_TO_RADIANS(this._angleX);
    },
    clone: function() {
        var X = new cc.OrbitCamera;
        X.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return X;
    },
    update: function(X) {
        var S = H8m.X1M((this._radius + this._deltaRadius * X), cc.Camera.getZEye()),
            P = this._radZ + H8m.D1M(this._radDeltaZ, X),
            O = this._radX + H8m.c1M(this._radDeltaX, X);
        X = H8m.z1M(Math.sin(P), Math.cos(O), S) + this._centerXOrig;
        O = H8m.w1M(Math.sin(P), Math.sin(O), S) + this._centerYOrig;
        S = H8m.O1M(Math.cos(P), S) + this._centerZOrig;
        this.target.getCamera().setEye(X, O, S);
    }
});
cc.OrbitCamera.create = function(X, S, P, O, Z, Y, T) {
    var R = new cc.OrbitCamera;
    return R.initWithDuration(X, S, P, O, Z, Y, T) ? R : H8m.H6P;
};
cc.ActionEase = cc.ActionInterval.extend({
    _inner: H8m.H6P,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._inner = H8m.H6P;
    },
    initWithAction: function(X) {
        var S = "cc.ActionEase.initWithAction(): action must be non nil";
        if (!X)
            throw S;
        return this.initWithDuration(X.getDuration()) ? (this._inner = X, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.ActionEase;
        X.initWithAction(this._inner.clone());
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._inner.startWithTarget(this.target);
    },
    stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this);
    },
    update: function(X) {
        this._inner.update(X);
    },
    reverse: function() {
        return cc.ActionEase.create(this._inner.reverse());
    },
    getInnerAction: function() {
        return this._inner;
    }
});
cc.ActionEase.create = function(X) {
    var S = new cc.ActionEase;
    S && S.initWithAction(X);
    return S;
};
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: H8m.U7H,
    ctor: function() {
        cc.ActionEase.prototype.ctor.call(this);
        this._rate = H8m.U7H;
    },
    setRate: function(X) {
        this._rate = X;
    },
    getRate: function() {
        return this._rate;
    },
    initWithAction: function(X, S) {
        return cc.ActionEase.prototype.initWithAction.call(this, X) ? (this._rate = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.EaseRateAction;
        X.initWithAction(this._inner.clone(), this._rate);
        return X;
    },
    reverse: function() {
        return cc.EaseRateAction.create(this._inner.reverse(), H8m.B1M(H8m.h7H, this._rate));
    }
});
cc.EaseRateAction.create = function(X, S) {
    var P = new cc.EaseRateAction;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(X) {
        this._inner.update(Math.pow(X, this._rate));
    },
    reverse: function() {
        return cc.EaseIn.create(this._inner.reverse(), H8m.Z1M(H8m.h7H, this._rate));
    },
    clone: function() {
        var X = new cc.EaseIn;
        X.initWithAction(this._inner.clone(), this._rate);
        return X;
    }
});
cc.EaseIn.create = function(X, S) {
    var P = new cc.EaseIn;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(X) {
        this._inner.update(Math.pow(X, H8m.J1M(H8m.h7H, this._rate)));
    },
    reverse: function() {
        return cc.EaseOut.create(this._inner.reverse(), H8m.n1M(H8m.h7H, this._rate));
    },
    clone: function() {
        var X = new cc.EaseOut;
        X.initWithAction(this._inner.clone(), this._rate);
        return X;
    }
});
cc.EaseOut.create = function(X, S) {
    var P = new cc.EaseOut;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(X) {
        X *= H8m.s7H;
        H8m.G1M(H8m.h7H, X) ? this._inner.update(H8m.W1M(H8m.E1S, Math.pow(X, this._rate))) : this._inner.update(H8m.v1M(H8m.h7H, H8m.E1S * Math.pow(H8m.s7H - X, this._rate)));
    },
    clone: function() {
        var X = new cc.EaseInOut;
        X.initWithAction(this._inner.clone(), this._rate);
        return X;
    },
    reverse: function() {
        return cc.EaseInOut.create(this._inner.reverse(), this._rate);
    }
});
cc.EaseInOut.create = function(X, S) {
    var P = new cc.EaseInOut;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(X) {
        this._inner.update(H8m.u1M(H8m.U7H, X) ? H8m.U7H : Math.pow(H8m.s7H, H8m.H1M(H8m.e1i, (X - H8m.h7H))));
    },
    reverse: function() {
        return cc.EaseExponentialOut.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseExponentialIn;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseExponentialIn.create = function(X) {
    var S = new cc.EaseExponentialIn;
    S && S.initWithAction(X);
    return S;
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(X) {
        this._inner.update(H8m.f1M(H8m.h7H, X) ? H8m.h7H : -Math.pow(H8m.s7H, -H8m.e1i * X) + H8m.h7H);
    },
    reverse: function() {
        return cc.EaseExponentialIn.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseExponentialOut;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseExponentialOut.create = function(X) {
    var S = new cc.EaseExponentialOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(X) {
        H8m.I1M(H8m.h7H, X) && H8m.g8M(H8m.U7H, X) && (X *= H8m.s7H, X = H8m.K8M(H8m.h7H, X) ? H8m.d8M(H8m.E1S, Math.pow(H8m.s7H, H8m.e1i * (X - H8m.h7H))) : H8m.E1S * (-Math.pow(H8m.s7H, -H8m.e1i * (H8m.t8M(X, H8m.h7H))) + H8m.s7H));
        this._inner.update(X);
    },
    reverse: function() {
        return cc.EaseExponentialInOut.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseExponentialInOut;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseExponentialInOut.create = function(X) {
    var S = new cc.EaseExponentialInOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(X) {
        X = H8m.w8M(H8m.U7H, X) || H8m.e8M(H8m.h7H, X) ? X : -H8m.h7H * Math.cos(H8m.Q8M(X, Math.PI, H8m.s7H)) + H8m.h7H;
        this._inner.update(X);
    },
    reverse: function() {
        return cc.EaseSineOut.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseSineIn;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseSineIn.create = function(X) {
    var S = new cc.EaseSineIn;
    S && S.initWithAction(X);
    return S;
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(X) {
        X = H8m.Z8M(H8m.U7H, X) || H8m.J8M(H8m.h7H, X) ? X : Math.sin(H8m.n8M(X, Math.PI, H8m.s7H));
        this._inner.update(X);
    },
    reverse: function() {
        return cc.EaseSineIn.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseSineOut;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseSineOut.create = function(X) {
    var S = new cc.EaseSineOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(X) {
        X = H8m.M8M(H8m.U7H, X) || H8m.V8M(H8m.h7H, X) ? X : -H8m.E1S * (H8m.s8M(Math.cos(Math.PI * X), H8m.h7H));
        this._inner.update(X);
    },
    clone: function() {
        var X = new cc.EaseSineInOut;
        X.initWithAction(this._inner.clone());
        return X;
    },
    reverse: function() {
        return cc.EaseSineInOut.create(this._inner.reverse());
    }
});
cc.EaseSineInOut.create = function(X) {
    var S = new cc.EaseSineInOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: H8m.H6P,
    ctor: function() {
        cc.ActionEase.prototype.ctor.call(this);
        this._period = H8m.V1S;
    },
    getPeriod: function() {
        return this._period;
    },
    setPeriod: function(X) {
        this._period = X;
    },
    initWithAction: function(X, S) {
        cc.ActionEase.prototype.initWithAction.call(this, X);
        this._period = H8m.U8M(H8m.H6P, S) ? H8m.V1S : S;
        return !H8m.U7H;
    },
    reverse: function() {
        var X = "cc.EaseElastic.reverse(): it should be overridden in subclass.";
        cc.log(X);
    },
    clone: function() {
        var X = new cc.EaseElastic;
        X.initWithAction(this._inner.clone(), this._period);
        return X;
    }
});
cc.EaseElastic.create = function(X, S) {
    var P = new cc.EaseElastic;
    return P && P.initWithAction(X, S) ? P : H8m.H6P;
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(X) {
        var S = H8m.U7H;
        H8m.b8M(H8m.U7H, X) || H8m.F8M(H8m.h7H, X) ? S = X : (S = H8m.k4M(this._period, H8m.q7H), X -= H8m.h7H, S = -Math.pow(H8m.s7H, H8m.L4M(H8m.e1i, X)) * Math.sin(H8m.i4M((X - S), Math.PI, H8m.s7H, this._period)));
        this._inner.update(S);
    },
    reverse: function() {
        return cc.EaseElasticOut.create(this._inner.reverse(), this._period);
    },
    clone: function() {
        var X = new cc.EaseElasticIn;
        X.initWithAction(this._inner.clone(), this._period);
        return X;
    }
});
cc.EaseElasticIn.create = function(X, S) {
    var P = new cc.EaseElasticIn;
    return P && P.initWithAction(X, S) ? P : H8m.H6P;
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(X) {
        var S = H8m.U7H;
        H8m.t4M(H8m.U7H, X) || H8m.w4M(H8m.h7H, X) ? S = X : (S = H8m.e4M(this._period, H8m.q7H), S = Math.pow(H8m.s7H, -H8m.e1i * X) * Math.sin(H8m.Q4M((X - S), Math.PI, H8m.s7H, this._period)) + H8m.h7H);
        this._inner.update(S);
    },
    reverse: function() {
        return cc.EaseElasticIn.create(this._inner.reverse(), this._period);
    },
    clone: function() {
        var X = new cc.EaseElasticOut;
        X.initWithAction(this._inner.clone(), this._period);
        return X;
    }
});
cc.EaseElasticOut.create = function(X, S) {
    var P = new cc.EaseElasticOut;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(X) {
        var S = H8m.U7H,
            S = this._period;
        if (H8m.Y4M(H8m.U7H, X) || H8m.T4M(H8m.h7H, X))
            S = X;
        else {
            S || (S = this._period = H8m.R4M(H8m.V1S, H8m.m4i));
            var P = H8m.M4M(S, H8m.q7H);
            X = H8m.V4M(H8m.s7H * X, H8m.h7H);
            S = H8m.s4M(H8m.U7H, X) ? -H8m.E1S * Math.pow(H8m.s7H, H8m.U4M(H8m.e1i, X)) * Math.sin(H8m.b4M((X - P), Math.PI, H8m.s7H, S)) : Math.pow(H8m.s7H, -H8m.e1i * X) * Math.sin(H8m.I4M((X - P), Math.PI, H8m.s7H, S)) * H8m.E1S + H8m.h7H;
        }
        this._inner.update(S);
    },
    reverse: function() {
        return cc.EaseElasticInOut.create(this._inner.reverse(), this._period);
    },
    clone: function() {
        var X = new cc.EaseElasticInOut;
        X.initWithAction(this._inner.clone(), this._period);
        return X;
    }
});
cc.EaseElasticInOut.create = function(X, S) {
    var P = new cc.EaseElasticInOut;
    P && P.initWithAction(X, S);
    return P;
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(X) {
        var S = 0.984375,
            P = 2.625,
            O = 0.9375,
            Z = 2.25,
            Y = 0.75,
            T = 7.5625,
            R = 2.75;
        if (H8m.D7M(X, H8m.h7H / R))
            return H8m.c7M(T, X, X);
        if (H8m.t7M(X, H8m.s7H / R))
            return X -= H8m.w7M(H8m.m4i, R), H8m.e7M(T, X, X) + Y;
        if (H8m.B7M(X, H8m.B5P / R))
            return X -= H8m.Z7M(Z, R), H8m.J7M(T, X, X) + O;
        X -= H8m.R7M(P, R);
        return H8m.M7M(T, X, X) + S;
    },
    clone: function() {
        var X = new cc.EaseBounce;
        X.initWithAction(this._inner.clone());
        return X;
    },
    reverse: function() {
        return cc.EaseBounce.create(this._inner.reverse());
    }
});
cc.EaseBounce.create = function(X) {
    var S = new cc.EaseBounce;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(X) {
        X = H8m.C7M(H8m.h7H, this.bounceTime(H8m.h7H - X));
        this._inner.update(X);
    },
    reverse: function() {
        return cc.EaseBounceOut.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseBounceIn;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseBounceIn.create = function(X) {
    var S = new cc.EaseBounceIn;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(X) {
        X = this.bounceTime(X);
        this._inner.update(X);
    },
    reverse: function() {
        return cc.EaseBounceIn.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseBounceOut;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseBounceOut.create = function(X) {
    var S = new cc.EaseBounceOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(X) {
        var S = H8m.U7H,
            S = H8m.h7M(H8m.E1S, X) ? H8m.y7M(H8m.E1S, (H8m.h7H - this.bounceTime(H8m.h7H - H8m.s7H * X))) : H8m.q7M(H8m.E1S, this.bounceTime(H8m.s7H * X - H8m.h7H)) + H8m.E1S;
        this._inner.update(S);
    },
    clone: function() {
        var X = new cc.EaseBounceInOut;
        X.initWithAction(this._inner.clone());
        return X;
    },
    reverse: function() {
        return cc.EaseBounceInOut.create(this._inner.reverse());
    }
});
cc.EaseBounceInOut.create = function(X) {
    var S = new cc.EaseBounceInOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(X) {
        this._inner.update(H8m.l7M(H8m.U7H, X) || H8m.X0M(H8m.h7H, X) ? X : H8m.D0M(X, X, (H8m.Z0S * X - H8m.d4i)));
    },
    reverse: function() {
        return cc.EaseBackOut.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseBackIn;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseBackIn.create = function(X) {
    var S = new cc.EaseBackIn;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(X) {
        X -= H8m.h7H;
        this._inner.update(H8m.d0M(X, X, (H8m.Z0S * X + H8m.d4i)) + H8m.h7H);
    },
    reverse: function() {
        return cc.EaseBackIn.create(this._inner.reverse());
    },
    clone: function() {
        var X = new cc.EaseBackOut;
        X.initWithAction(this._inner.clone());
        return X;
    }
});
cc.EaseBackOut.create = function(X) {
    var S = new cc.EaseBackOut;
    S && S.initWithAction(X);
    return S;
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(X) {
        var S = 2.5949095,
            P = 3.5949095;
        X *= H8m.s7H;
        H8m.P0M(H8m.h7H, X) ? this._inner.update(H8m.a0M(X, X, (P * X - S), H8m.s7H)) : (X -= H8m.s7H, this._inner.update(H8m.Q0M(X, X, (P * X + S), H8m.s7H) + H8m.h7H));
    },
    clone: function() {
        var X = new cc.EaseBackInOut;
        X.initWithAction(this._inner.clone());
        return X;
    },
    reverse: function() {
        return cc.EaseBackInOut.create(this._inner.reverse());
    }
});
cc.EaseBackInOut.create = function(X) {
    var S = new cc.EaseBackInOut;
    S && S.initWithAction(X);
    return S;
};
cc.CardinalSplineAt = function(X, S, P, O, Z, Y) {
    var T = H8m.Y0M(Y, Y),
        R = H8m.T0M(T, Y),
        E = H8m.R0M((H8m.h7H - Z), H8m.s7H);
    Z = E * (-R + H8m.s7H * T - Y);
    var V = E * (-R + T) + (H8m.M0M(H8m.s7H * R, H8m.v7H * T, H8m.h7H));
    Y = H8m.C0M(E, (R - H8m.s7H * T + Y)) + (-H8m.s7H * R + H8m.h0M(H8m.v7H, T));
    T = H8m.y0M(E, (R - T));
    return cc.p(H8m.q0M(X.x, Z) + H8m.l0M(S.x, V) + H8m.X3M(P.x, Y) + H8m.D3M(O.x, T), H8m.c3M(X.y, Z) + H8m.z3M(S.y, V) + H8m.j3M(P.y, Y) + H8m.x3M(O.y, T));
};
cc.reverseControlPoints = function(X) {
    for (var S = [], P = H8m.o3M(X.length, 1); H8m.p3M(0, P); P--)
        S.push(cc.p(X[P].x, X[P].y));
    return S;
};
cc.copyControlPoints = function(X) {
    for (var S = [], P = 0; H8m.Y3M(P, X.length); P++)
        S.push(cc.p(X[P].x, X[P].y));
    return S;
};
cc.getControlPointAt = function(X, S) {
    var P = Math.min(H8m.T3M(X.length, 1), Math.max(S, 0));
    return X[P];
};
cc.reverseControlPointsInline = function(X) {
    for (var S = X.length, P = H8m.R3M(0, S / 2), O = 0; H8m.M3M(O, P); ++O) {
        var Z = X[O];
        X[O] = X[H8m.V3M(S, O, 1)];
        X[H8m.h3M(S, O, 1)] = Z;
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        this._tension = this._deltaT = 0;
        this._accumulatedDiff = this._previousPosition = null;
    },
    initWithDuration: function(X, S, P) {
        if (!S || H8m.H3M(0, S.length))
            throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this.setPoints(S), this._tension = P, !0) : !1;
    },
    clone: function() {
        var X = new cc.CardinalSplineTo;
        X.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._deltaT = H8m.f3M(1, (this._points.length - 1));
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0);
    },
    update: function(X) {
        var S,
            P = this._points;
        if (H8m.I3M(1, X))
            S = H8m.g5M(P.length, 1), X = 1;
        else {
            var O = this._deltaT;
            S = H8m.K5M(0, X / O);
            X = H8m.d5M((X - O * S), O);
        }
        S = cc.CardinalSplineAt(cc.getControlPointAt(P, H8m.t5M(S, 1)), cc.getControlPointAt(P, H8m.w5M(S, 0)), cc.getControlPointAt(P, S + 1), cc.getControlPointAt(P, S + 2), this._tension, X);
        cc.ENABLE_STACKABLE_ACTIONS && (P = H8m.e5M(this.target.getPositionX(), this._previousPosition.x), X = H8m.Q5M(this.target.getPositionY(), this._previousPosition.y), H8m.r5M(0, P) || H8m.N5M(0, X)) && (O = this._accumulatedDiff, P = O.x + P, X = O.y + X, O.x = P, O.y = X, S.x += P, S.y += X);
        this.updatePosition(S);
    },
    reverse: function() {
        var X = cc.reverseControlPoints(this._points);
        return cc.CardinalSplineTo.create(this._duration, X, this._tension);
    },
    updatePosition: function(X) {
        this.target.setPosition(X);
        this._previousPosition = X;
    },
    getPoints: function() {
        return this._points;
    },
    setPoints: function(X) {
        this._points = X;
    }
});
cc.CardinalSplineTo.create = function(X, S, P) {
    var O = new cc.CardinalSplineTo;
    return O.initWithDuration(X, S, P) ? O : H8m.H6P;
};
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function() {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
    },
    startWithTarget: function(X) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, X);
        this._startPosition.x = X.getPositionX();
        this._startPosition.y = X.getPositionY();
    },
    reverse: function() {
        for (var X = this._points.slice(), S, P = X[0], O = 1; H8m.m5M(O, X.length); ++O)
            S = X[O], X[O] = cc.pSub(S, P), P = S;
        X = cc.reverseControlPoints(X);
        P = X[H8m.A5M(X.length, 1)];
        X.pop();
        P.x = -P.x;
        P.y = -P.y;
        X.unshift(P);
        for (O = 1; H8m.E5M(O, X.length); ++O)
            S = X[O], S.x = -S.x, S.y = -S.y, S.x += P.x, S.y += P.y, P = X[O] = S;
        return cc.CardinalSplineBy.create(this._duration, X, this._tension);
    },
    updatePosition: function(X) {
        var S = this._startPosition,
            P = X.x + S.x;
        X = X.y + S.y;
        this._previousPosition.x = P;
        this._previousPosition.y = X;
        this.target.setPosition(P, X);
    },
    clone: function() {
        var X = new cc.CardinalSplineBy;
        X.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return X;
    }
});
cc.CardinalSplineBy.create = function(X, S, P) {
    var O = new cc.CardinalSplineBy;
    return O.initWithDuration(X, S, P) ? O : H8m.H6P;
};
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    initWithDuration: function(X, S) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, X, S, H8m.E1S);
    },
    clone: function() {
        var X = new cc.CatmullRomTo;
        X.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return X;
    }
});
cc.CatmullRomTo.create = function(X, S) {
    var P = new cc.CatmullRomTo;
    return P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    initWithDuration: function(X, S) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, X, S, H8m.E1S);
    },
    clone: function() {
        var X = new cc.CatmullRomBy;
        X.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return X;
    }
});
cc.CatmullRomBy.create = function(X, S) {
    var P = new cc.CatmullRomBy;
    return P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(X, S) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        this.delta = this.to = this.from = 0;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this.key = S, this.to = O, this.from = P, !0) : !1;
    },
    startWithTarget: function(X) {
        if (!X || !X.updateTweenAction)
            throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this.delta = H8m.C5M(this.to, this.from);
    },
    update: function(X) {
        this.target.updateTweenAction(H8m.h5M(this.to, this.delta * (1 - X)), this.key);
    },
    reverse: function() {
        return cc.ActionTween.create(this.duration, this.key, this.to, this.from);
    },
    clone: function() {
        var X = new cc.ActionTween;
        X.initWithDuration(this._duration, this.key, this.from, this.to);
        return X;
    }
});
cc.ActionTween.create = function(X, S, P, O) {
    var Z = new cc.ActionTween;
    return Z.initWithDuration(X, S, P, O) ? Z : H8m.H6P;
};
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._gridSize = cc.size(0, 0);
    },
    clone: function() {
        var X = new cc.GridAction,
            S = this._gridSize;
        X.initWithDuration(this._duration, cc.size(S.width, S.height));
        return X;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        var S = this.getGrid(),
            P = this.target;
        (X = P.grid) && H8m.y5M(0, X.getReuseGrid()) ? (S = X.getGridSize(), X.isActive() && H8m.q5M(S.width, this._gridSize.width) && H8m.l5M(S.height, this._gridSize.height) && X.reuse()) : (X && X.isActive() && X.setActive(!1), P.grid = S, P.grid.setActive(!0));
    },
    reverse: function() {
        return cc.ReverseTime.create(this);
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._gridSize.width = S.width, this._gridSize.height = S.height, !0) : !1;
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.");
    }
});
cc.GridAction.create = function(X, S) {
    var P = new cc.GridAction;
    P.initWithDuration(X, S);
    return P;
};
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return cc.Grid3D.create(this._gridSize);
    },
    vertex: function(X) {
        return this.target.grid.vertex(X);
    },
    originalVertex: function(X) {
        return this.target.grid.originalVertex(X);
    },
    setVertex: function(X, S) {
        this.target.grid.setVertex(X, S);
    }
});
cc.Grid3DAction.create = function(X, S) {
    var P = new cc.Grid3DAction;
    P.initWithDuration(X, S);
    return P;
};
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(X) {
        return this.target.grid.tile(X);
    },
    originalTile: function(X) {
        return this.target.grid.originalTile(X);
    },
    setTile: function(X, S) {
        this.target.grid.setTile(X, S);
    },
    getGrid: function() {
        return cc.TiledGrid3D.create(this._gridSize);
    }
});
cc.TiledGrid3DAction.create = function(X, S) {
    var P = new cc.TiledGrid3DAction;
    P.initWithDuration(X, S);
    return P;
};
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(X) {
        cc.ActionInstant.prototype.startWithTarget.call(this, X);
        (X = this.target.grid) && X.isActive() && X.setActive(!H8m.h7H);
    }
});
cc.StopGrid.create = function() {
    return new cc.StopGrid;
};
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: H8m.H6P,
    initWithTimes: function(X) {
        this._times = X;
        return !H8m.U7H;
    },
    startWithTarget: function(X) {
        cc.ActionInstant.prototype.startWithTarget.call(this, X);
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times);
    }
});
cc.ReuseGrid.create = function(X) {
    return new cc.ReuseGrid;
};
cc.rand = function() {
    var X = 16777215;
    return H8m.X6M(X, Math.random());
};
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._waves = P, this._amplitude = O, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        for (var S = this._gridSize, P = this._amplitude, O = cc.p(0, 0), Z = this._amplitudeRate, Y = this._waves, T = 0; H8m.D6M(T, S.width + 1); ++T)
            for (var R = 0; H8m.c6M(R, S.height + 1); ++R) {
                O.x = T;
                O.y = R;
                var E = this.originalVertex(O);
                E.z += H8m.z6M(Math.sin(Math.PI * X * Y * 2 + 0.01 * (E.y + E.x)), P, Z);
                this.setVertex(O, E);
            }
    }
});
cc.Waves3D.create = function(X, S, P, O) {
    var Z = new cc.Waves3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.FlipX3D = cc.Grid3DAction.extend({
    initWithDuration: function(X) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, cc.size(1, 1));
    },
    initWithSize: function(X, S) {
        return H8m.w6M(1, X.width) || H8m.e6M(1, X.height) ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, S, X);
    },
    update: function(X) {
        var S = H8m.Q6M(Math.PI, X);
        X = Math.sin(S);
        var P = Math.cos(H8m.r6M(S, 2)),
            S = new cc.Vertex3F,
            O = cc.p(0, 0);
        O.x = O.y = 1;
        var Z = this.originalVertex(O);
        O.x = O.y = 0;
        var O = this.originalVertex(O),
            Y = Z.x,
            T = O.x,
            R,
            E;
        H8m.N6M(Y, T) ? (Z = cc.p(0, 0), O = cc.p(0, 1), R = cc.p(1, 0), E = cc.p(1, 1)) : (R = cc.p(0, 0), E = cc.p(0, 1), Z = cc.p(1, 0), O = cc.p(1, 1), Y = T);
        S.x = H8m.m6M(Y, Y * P);
        S.z = Math.abs(parseFloat(H8m.A6M(Y, X, 4)));
        X = this.originalVertex(Z);
        X.x = S.x;
        X.z += S.z;
        this.setVertex(Z, X);
        X = this.originalVertex(O);
        X.x = S.x;
        X.z += S.z;
        this.setVertex(O, X);
        X = this.originalVertex(R);
        X.x -= S.x;
        X.z -= S.z;
        this.setVertex(R, X);
        X = this.originalVertex(E);
        X.x -= S.x;
        X.z -= S.z;
        this.setVertex(E, X);
    }
});
cc.FlipX3D.create = function(X) {
    var S = new cc.FlipX3D;
    S.initWithDuration(X);
    return S;
};
cc.FlipY3D = cc.FlipX3D.extend({
    update: function(X) {
        var S = H8m.W6M(Math.PI, X);
        X = Math.sin(S);
        var P = Math.cos(H8m.v6M(S, H8m.s7H)),
            S = new cc.Vertex3F,
            O = cc.p(H8m.U7H, H8m.U7H);
        O.x = O.y = H8m.h7H;
        var Z = this.originalVertex(O);
        O.x = O.y = H8m.U7H;
        var O = this.originalVertex(O),
            Y = Z.y,
            T = O.y,
            R,
            E;
        H8m.u6M(Y, T) ? (Z = cc.p(H8m.U7H, H8m.U7H), O = cc.p(H8m.U7H, H8m.h7H), R = cc.p(H8m.h7H, H8m.U7H), E = cc.p(H8m.h7H, H8m.h7H)) : (O = cc.p(H8m.U7H, H8m.U7H), Z = cc.p(H8m.U7H, H8m.h7H), E = cc.p(H8m.h7H, H8m.U7H), R = cc.p(H8m.h7H, H8m.h7H), Y = T);
        S.y = H8m.H6M(Y, Y * P);
        S.z = Math.abs(H8m.f6M(parseFloat(Y * X), H8m.q7H));
        X = this.originalVertex(Z);
        X.y = S.y;
        X.z += S.z;
        this.setVertex(Z, X);
        X = this.originalVertex(O);
        X.y -= S.y;
        X.z -= S.z;
        this.setVertex(O, X);
        X = this.originalVertex(R);
        X.y = S.y;
        X.z += S.z;
        this.setVertex(R, X);
        X = this.originalVertex(E);
        X.y -= S.y;
        X.z -= S.z;
        this.setVertex(E, X);
    }
});
cc.FlipY3D.create = function(X) {
    var S = new cc.FlipY3D;
    S.initWithDuration(X);
    return S;
};
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._lensEffect = this._radius = 0;
        this._dirty = this._concave = !1;
    },
    getLensEffect: function() {
        return this._lensEffect;
    },
    setLensEffect: function(X) {
        this._lensEffect = X;
    },
    setConcave: function(X) {
        this._concave = X;
    },
    getPosition: function() {
        return this._position;
    },
    setPosition: function(X) {
        cc.pointEqualToPoint(X, this._position) || (this._position.x = X.x, this._position.y = X.y, this._dirty = !0);
    },
    initWithDuration: function(X, S, P, O) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this.setPosition(P), this._radius = O, this._lensEffect = 0.7, this._dirty = !0) : !1;
    },
    update: function(X) {
        if (this._dirty) {
            X = this._gridSize.width;
            for (var S = this._gridSize.height, P = this._radius, O = this._lensEffect, Z = cc.p(0, 0), Y = cc.p(0, 0), T, R, E, V = 0; H8m.I6M(V, X + 1); ++V)
                for (var U = 0; H8m.g2M(U, S + 1); ++U)
                    Z.x = V, Z.y = U, T = this.originalVertex(Z), Y.x = H8m.K2M(this._position.x, T.x), Y.y = H8m.d2M(this._position.y, T.y), R = cc.pLength(Y), H8m.t2M(R, P) && (R = H8m.w2M(P, R), R /= P, H8m.e2M(0, R) && (R = 0.001), R = H8m.Q2M(Math.log(R), O), E = H8m.r2M(Math.exp(R), P), R = cc.pLength(Y), H8m.N2M(0, R) && (Y.x /= R, Y.y /= R, Y.x *= E, Y.y *= E, T.z += H8m.m2M(cc.pLength(Y), O))), this.setVertex(Z, T);
            this._dirty = !1;
        }
    }
});
cc.Lens3D.create = function(X, S, P, O) {
    var Z = new cc.Lens3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: null,
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._amplitudeRate = this._amplitude = this._waves = this._radius = 0;
    },
    getPosition: function() {
        return this._position;
    },
    setPosition: function(X) {
        this._position.x = X.x;
        this._position.y = X.y;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O, Z, Y) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this.setPosition(P), this._radius = O, this._waves = Z, this._amplitude = Y, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        for (var S = this._gridSize.width, P = this._gridSize.height, O = cc.p(0, 0), Z = this._radius, Y = this._waves, T = this._amplitude, R = this._amplitudeRate, E, V, U = cc.p(0, 0), k9 = 0; H8m.A2M(k9, S + 1); ++k9)
            for (var L9 = 0; H8m.E2M(L9, P + 1); ++L9) {
                O.x = k9;
                O.y = L9;
                E = this.originalVertex(O);
                U.x = H8m.C2M(this._position.x, E.x);
                U.y = H8m.h2M(this._position.y, E.y);
                V = cc.pLength(U);
                if (H8m.y2M(V, Z)) {
                    V = H8m.q2M(Z, V);
                    var K9 = Math.pow(H8m.l2M(V, Z), 2);
                    E.z += H8m.X9u(Math.sin(X * Math.PI * Y * 2 + 0.1 * V), T, R, K9);
                }
                this.setVertex(O, E);
            }
    }
});
cc.Ripple3D.create = function(X, S, P, O, Z, Y) {
    var T = new cc.Ripple3D;
    T.initWithDuration(X, S, P, O, Z, Y);
    return T;
};
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: null,
    _shakeZ: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._shakeZ = !1;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._randRange = P, this._shakeZ = O, !0) : !1;
    },
    update: function(X) {
        X = this._gridSize.width;
        for (var S = this._gridSize.height, P = this._randRange, O = this._shakeZ, Z = cc.p(0, 0), Y, T = 0; H8m.i9u(T, X + 1); ++T)
            for (var R = 0; H8m.S9u(R, S + 1); ++R)
                Z.x = T, Z.y = R, Y = this.originalVertex(Z), Y.x += H8m.P9u(cc.rand() % (2 * P), P), Y.y += H8m.a9u(cc.rand() % (2 * P), P), O && (Y.z += H8m.O9u(cc.rand() % (2 * P), P)), this.setVertex(Z, Y);
    }
});
cc.Shaky3D.create = function(X, S, P, O) {
    var Z = new cc.Shaky3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.Liquid = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._waves = P, this._amplitude = O, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        for (var S = this._gridSize.width, P = this._gridSize.height, O = cc.p(0, 0), Z = this._waves, Y = this._amplitude, T = this._amplitudeRate, R, E = 1; H8m.B9u(E, S); ++E)
            for (var V = 1; H8m.Z9u(V, P); ++V)
                O.x = E, O.y = V, R = this.originalVertex(O), R.x += H8m.J9u(Math.sin(X * Math.PI * Z * 2 + 0.01 * R.x), Y, T), R.y += H8m.R9u(Math.sin(X * Math.PI * Z * 2 + 0.01 * R.y), Y, T), this.setVertex(O, R);
    }
});
cc.Liquid.create = function(X, S, P, O) {
    var Z = new cc.Liquid;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.Waves = cc.Grid3DAction.extend({
    _waves: null,
    _amplitude: null,
    _amplitudeRate: null,
    _vertical: null,
    _horizontal: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0;
        this._horizontal = this._vertical = !1;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O, Z, Y) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._waves = P, this._amplitude = O, this._amplitudeRate = 1, this._horizontal = Z, this._vertical = Y, !0) : !1;
    },
    update: function(X) {
        for (var S = this._gridSize.width, P = this._gridSize.height, O = cc.p(0, 0), Z = this._vertical, Y = this._horizontal, T = this._waves, R = this._amplitude, E = this._amplitudeRate, V, U = 0; H8m.E9u(U, S + 1); ++U)
            for (var k9 = 0; H8m.C9u(k9, P + 1); ++k9)
                O.x = U, O.y = k9, V = this.originalVertex(O), Z && (V.x += H8m.h9u(Math.sin(X * Math.PI * T * 2 + 0.01 * V.y), R, E)), Y && (V.y += H8m.H9u(Math.sin(X * Math.PI * T * 2 + 0.01 * V.x), R, E)), this.setVertex(O, V);
    }
});
cc.Waves.create = function(X, S, P, O, Z, Y) {
    var T = new cc.Waves;
    T.initWithDuration(X, S, P, O, Z, Y);
    return T;
};
cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: null,
    _amplitude: null,
    _amplitudeRate: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this._amplitudeRate = this._amplitude = this._twirls = 0;
    },
    getPosition: function() {
        return this._position;
    },
    setPosition: function(X) {
        this._position.x = X.x;
        this._position.y = X.y;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O, Z) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, X, S) ? (this.setPosition(P), this._twirls = O, this._amplitude = Z, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        for (var S = this._position, P = this._gridSize.width, O = this._gridSize.height, Z = cc.p(0, 0), Y = H8m.F9u(0.1, this._amplitude, this._amplitudeRate), T = this._twirls, R, E, V, U = cc.p(0, 0), k9 = 0; H8m.X1u(k9, P + 1); ++k9)
            for (var L9 = 0; H8m.D1u(L9, O + 1); ++L9)
                Z.x = k9, Z.y = L9, R = this.originalVertex(Z), U.x = H8m.c1u(k9, P / 2), U.y = H8m.z1u(L9, O / 2), E = H8m.j1u(cc.pLength(U), Math.cos(Math.PI / 2 + X * Math.PI * T * 2), Y), V = H8m.e1u(Math.sin(E), (R.y - S.y)) + H8m.Q1u(Math.cos(E), (R.x - S.x)), E = H8m.r1u(Math.cos(E) * (R.y - S.y), Math.sin(E) * (R.x - S.x)), R.x = S.x + V, R.y = S.y + E, this.setVertex(Z, R);
    }
});
cc.Twirl.create = function(X, S, P, O, Z) {
    var Y = new cc.Twirl;
    Y.initWithDuration(X, S, P, O, Z);
    return Y;
};
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._shakeZ = !1;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._randRange = P, this._shakeZ = O, !0) : !1;
    },
    update: function(X) {
        X = this._gridSize;
        for (var S = this._randRange, P = cc.p(0, 0), O = 0; H8m.N1u(O, X.width); ++O)
            for (var Z = 0; H8m.m1u(Z, X.height); ++Z) {
                P.x = O;
                P.y = Z;
                var Y = this.originalTile(P);
                Y.bl.x += H8m.A1u(cc.rand() % (2 * S), S);
                Y.br.x += H8m.E1u(cc.rand() % (2 * S), S);
                Y.tl.x += H8m.C1u(cc.rand() % (2 * S), S);
                Y.tr.x += H8m.h1u(cc.rand() % (2 * S), S);
                Y.bl.y += H8m.y1u(cc.rand() % (2 * S), S);
                Y.br.y += H8m.q1u(cc.rand() % (2 * S), S);
                Y.tl.y += H8m.l1u(cc.rand() % (2 * S), S);
                Y.tr.y += H8m.X8u(cc.rand() % (2 * S), S);
                this._shakeZ && (Y.bl.z += H8m.D8u(cc.rand() % (2 * S), S), Y.br.z += H8m.c8u(cc.rand() % (2 * S), S), Y.tl.z += H8m.z8u(cc.rand() % (2 * S), S), Y.tr.z += H8m.j8u(cc.rand() % (2 * S), S));
                this.setTile(P, Y);
            }
    }
});
cc.ShakyTiles3D.create = function(X, S, P, O) {
    var Z = new cc.ShakyTiles3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._randRange = 0;
        this._once = this._shakeZ = !1;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._once = !1, this._randRange = P, this._shatterZ = O, !0) : !1;
    },
    update: function(X) {
        if (!1 === this._once) {
            X = this._gridSize;
            for (var S = this._randRange, P, O = cc.p(0, 0), Z = 0; H8m.x8u(Z, X.width); ++Z)
                for (var Y = 0; H8m.o8u(Y, X.height); ++Y)
                    O.x = Z, O.y = Y, P = this.originalTile(O), P.bl.x += H8m.p8u(cc.rand() % (2 * S), S), P.br.x += H8m.Y8u(cc.rand() % (2 * S), S), P.tl.x += H8m.T8u(cc.rand() % (2 * S), S), P.tr.x += H8m.R8u(cc.rand() % (2 * S), S), P.bl.y += H8m.M8u(cc.rand() % (2 * S), S), P.br.y += H8m.V8u(cc.rand() % (2 * S), S), P.tl.y += H8m.s8u(cc.rand() % (2 * S), S), P.tr.y += H8m.U8u(cc.rand() % (2 * S), S), this._shatterZ && (P.bl.z += H8m.b8u(cc.rand() % (2 * S), S), P.br.z += H8m.F8u(cc.rand() % (2 * S), S), P.tl.z += H8m.k4u(cc.rand() % (2 * S), S), P.tr.z += H8m.L4u(cc.rand() % (2 * S), S)), this.setTile(O, P);
            this._once = !0;
        }
    }
});
cc.ShatteredTiles3D.create = function(X, S, P, O) {
    var Z = new cc.ShatteredTiles3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.Tile = function(X, S, P) {
    this.position = X || cc.p(H8m.U7H, H8m.U7H);
    this.startPosition = S || cc.p(H8m.U7H, H8m.U7H);
    this.delta = P || cc.p(H8m.U7H, H8m.U7H);
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._tiles = [];
        this._tilesCount = this._seed = 0;
    },
    initWithDuration: function(X, S, P) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._seed = P, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1;
    },
    shuffle: function(X, S) {
        for (var P = H8m.i4u(S, 1); H8m.S4u(0, P); P--) {
            var O = H8m.P4u(0, cc.rand() % (P + 1)),
                Z = X[P];
            X[P] = X[O];
            X[O] = Z;
        }
    },
    getDelta: function(X) {
        var S = this._gridSize,
            P = H8m.a4u(X.width, S.height) + X.height;
        return cc.size(H8m.O4u(this._tilesOrder[P] / S.height, X.width), H8m.B4u(this._tilesOrder[P] % S.height, X.height));
    },
    placeTile: function(X, S) {
        var P = this.originalTile(X),
            O = this.target.grid.getStep(),
            Z = S.position;
        P.bl.x += H8m.Z4u(Z.x, O.x);
        P.bl.y += H8m.J4u(Z.y, O.y);
        P.br.x += H8m.n4u(Z.x, O.x);
        P.br.y += H8m.G4u(Z.y, O.y);
        P.tl.x += H8m.W4u(Z.x, O.x);
        P.tl.y += H8m.v4u(Z.y, O.y);
        P.tr.x += H8m.u4u(Z.x, O.x);
        P.tr.y += H8m.H4u(Z.y, O.y);
        this.setTile(X, P);
    },
    startWithTarget: function(X) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, X);
        X = this._gridSize;
        this._tilesCount = H8m.f4u(X.width, X.height);
        for (var S = this._tilesOrder, P = S.length = 0; H8m.I4u(P, this._tilesCount); ++P)
            S[P] = P;
        this.shuffle(S, this._tilesCount);
        for (var S = this._tiles, P = S.length = 0, O = cc.size(0, 0), Z = 0; H8m.g7u(Z, X.width); ++Z)
            for (var Y = 0; H8m.K7u(Y, X.height); ++Y)
                S[P] = new cc.Tile, S[P].position = cc.p(Z, Y), S[P].startPosition = cc.p(Z, Y), O.width = Z, O.height = Y, S[P].delta = this.getDelta(O), ++P;
    },
    update: function(X) {
        for (var S = 0, P = this._gridSize, O = this._tiles, Z, Y = cc.p(0, 0), T = 0; H8m.d7u(T, P.width); ++T)
            for (var R = 0; H8m.t7u(R, P.height); ++R)
                Y.x = T, Y.y = R, Z = O[S], Z.position.x = H8m.w7u(Z.delta.width, X), Z.position.y = H8m.e7u(Z.delta.height, X), this.placeTile(Y, Z), ++S;
    }
});
cc.ShuffleTiles.create = function(X, S, P) {
    var O = new cc.ShuffleTiles;
    O.initWithDuration(X, S, P);
    return O;
};
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(X, S) {
        var P = H8m.Q7u(this._gridSize.width, S),
            O = H8m.r7u(this._gridSize.height, S);
        return H8m.N7u(0, P + O) ? 1 : Math.pow(H8m.m7u((X.width + X.height), (P + O)), 6);
    },
    turnOnTile: function(X) {
        this.setTile(X, this.originalTile(X));
    },
    turnOffTile: function(X) {
        this.setTile(X, new cc.Quad3);
    },
    transformTile: function(X, S) {
        var P = this.originalTile(X),
            O = this.target.grid.getStep();
        P.bl.x += H8m.A7u(O.x, 2, (1 - S));
        P.bl.y += H8m.W7u(O.y, 2, (1 - S));
        P.br.x -= H8m.s7u(O.x, 2, (1 - S));
        P.br.y += H8m.y7u(O.y, 2, (1 - S));
        P.tl.x += H8m.f7u(O.x, 2, (1 - S));
        P.tl.y -= H8m.k0u(O.y, 2, (1 - S));
        P.tr.x -= H8m.D0u(O.x, 2, (1 - S));
        P.tr.y -= H8m.d0u(O.y, 2, (1 - S));
        this.setTile(X, P);
    },
    update: function(X) {
        for (var S = this._gridSize, P = cc.p(0, 0), O = cc.size(0, 0), Z, Y = 0; H8m.P0u(Y, S.width); ++Y)
            for (var T = 0; H8m.a0u(T, S.height); ++T)
                P.x = Y, P.y = T, O.width = Y, O.height = T, Z = this.testFunc(O, X), H8m.O0u(0, Z) ? this.turnOffTile(P) : H8m.B0u(1, Z) ? this.transformTile(P, Z) : this.turnOnTile(P);
    }
});
cc.FadeOutTRTiles.create = function(X, S) {
    var P = new cc.FadeOutTRTiles;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(X, S) {
        return H8m.Z0u(0, X.width + X.height) ? 1 : Math.pow(H8m.J0u((this._gridSize.width * (1 - S) + this._gridSize.height * (1 - S)), (X.width + X.height)), 6);
    }
});
cc.FadeOutBLTiles.create = function(X, S) {
    var P = new cc.FadeOutBLTiles;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(X, S) {
        var P = H8m.n0u(this._gridSize.height, S);
        return H8m.G0u(0, P) ? 1 : Math.pow(H8m.W0u(X.height, P), 6);
    },
    transformTile: function(X, S) {
        var P = this.originalTile(X),
            O = this.target.grid.getStep();
        P.bl.y += H8m.v0u(O.y, 2, (1 - S));
        P.br.y += H8m.U0u(O.y, 2, (1 - S));
        P.tl.y -= H8m.q0u(O.y, 2, (1 - S));
        P.tr.y -= H8m.I0u(O.y, 2, (1 - S));
        this.setTile(X, P);
    }
});
cc.FadeOutUpTiles.create = function(X, S) {
    var P = new cc.FadeOutUpTiles;
    P.initWithDuration(X, S);
    return P;
};
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(X, S) {
        return H8m.L3u(0, X.height) ? 1 : Math.pow(H8m.i3u(this._gridSize.height, (1 - S), X.height), 6);
    }
});
cc.FadeOutDownTiles.create = function(X, S) {
    var P = new cc.FadeOutDownTiles;
    P.initWithDuration(X, S);
    return P;
};
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._seed = null;
        this._tilesCount = 0;
    },
    initWithDuration: function(X, S, P) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._seed = P, this._tilesOrder.length = 0, !0) : !1;
    },
    shuffle: function(X, S) {
        for (var P = H8m.z3u(S, 1); H8m.j3u(0, P); P--) {
            var O = H8m.x3u(0, cc.rand() % (P + 1)),
                Z = X[P];
            X[P] = X[O];
            X[O] = Z;
        }
    },
    turnOnTile: function(X) {
        this.setTile(X, this.originalTile(X));
    },
    turnOffTile: function(X) {
        this.setTile(X, new cc.Quad3);
    },
    startWithTarget: function(X) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, X);
        this._tilesCount = H8m.o3u(this._gridSize.width, this._gridSize.height);
        X = this._tilesOrder;
        for (var S = X.length = 0; H8m.p3u(S, this._tilesCount); ++S)
            X[S] = S;
        this.shuffle(X, this._tilesCount);
    },
    update: function(X) {
        X = H8m.Y3u(0, X * this._tilesCount);
        for (var S = this._gridSize, P, O = cc.p(0, 0), Z = this._tilesOrder, Y = 0; H8m.T3u(Y, this._tilesCount); Y++)
            P = Z[Y], O.x = H8m.R3u(0, P / S.height), O.y = H8m.M3u(P, (0 | S.height)), H8m.V3u(Y, X) ? this.turnOffTile(O) : this.turnOnTile(O);
    }
});
cc.TurnOffTiles.create = function(X, S, P) {
    P = P || H8m.U7H;
    var O = new cc.TurnOffTiles;
    O.initWithDuration(X, S, P);
    return O;
};
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._waves = 0;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._waves = P, this._amplitude = O, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        for (var S = this._gridSize, P = this._waves, O = this._amplitude, Z = this._amplitudeRate, Y = cc.p(0, 0), T, R = 0; H8m.s3u(R, S.width); R++)
            for (var E = 0; H8m.U3u(E, S.height); E++)
                Y.x = R, Y.y = E, T = this.originalTile(Y), T.bl.z = H8m.b3u(Math.sin(X * Math.PI * P * 2 + 0.01 * (T.bl.y + T.bl.x)), O, Z), T.br.z = T.bl.z, T.tl.z = T.bl.z, T.tr.z = T.bl.z, this.setTile(Y, T);
    }
});
cc.WavesTiles3D.create = function(X, S, P, O) {
    var Z = new cc.WavesTiles3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._amplitudeRate = this._amplitude = this._jumps = 0;
    },
    getAmplitude: function() {
        return this._amplitude;
    },
    setAmplitude: function(X) {
        this._amplitude = X;
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate;
    },
    setAmplitudeRate: function(X) {
        this._amplitudeRate = X;
    },
    initWithDuration: function(X, S, P, O) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, S) ? (this._jumps = P, this._amplitude = O, this._amplitudeRate = 1, !0) : !1;
    },
    update: function(X) {
        var S = H8m.l3u(Math.sin(Math.PI * X * this._jumps * 2), this._amplitude, this._amplitudeRate);
        X = H8m.g5u(Math.sin(Math.PI * (X * this._jumps * 2 + 1)), this._amplitude, this._amplitudeRate);
        for (var P = this._gridSize, O = this.target.grid, Z, Y = cc.p(0, 0), T = 0; H8m.i5u(T, P.width); T++)
            for (var R = 0; H8m.S5u(R, P.height); R++)
                Y.x = T, Y.y = R, Z = O.originalTile(Y), H8m.P5u(0, (T + R) % 2) ? (Z.bl.z += S, Z.br.z += S, Z.tl.z += S, Z.tr.z += S) : (Z.bl.z += X, Z.br.z += X, Z.tl.z += X, Z.tr.z += X), O.setTile(Y, Z);
    }
});
cc.JumpTiles3D.create = function(X, S, P, O) {
    var Z = new cc.JumpTiles3D;
    Z.initWithDuration(X, S, P, O);
    return Z;
};
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._rows = 0;
        this._winSize = null;
    },
    initWithDuration: function(X, S) {
        this._rows = S;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, cc.size(1, S));
    },
    update: function(X) {
        for (var S = this._gridSize, P = this._winSize.width, O, Z, Y = cc.p(0, 0), T = 0; H8m.a5u(T, S.height); ++T)
            Y.y = T, O = this.originalTile(Y), Z = 1, H8m.O5u(0, T % 2) && (Z = -1), O.bl.x += H8m.B5u(Z, P, X), O.br.x += H8m.Y5u(Z, P, X), O.tl.x += H8m.m5u(Z, P, X), O.tr.x += H8m.G5u(Z, P, X), this.setTile(Y, O);
    },
    startWithTarget: function(X) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, X);
        this._winSize = cc.director.getWinSizeInPixels();
    }
});
cc.SplitRows.create = function(X, S) {
    var P = new cc.SplitRows;
    P.initWithDuration(X, S);
    return P;
};
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function() {
        cc.GridAction.prototype.ctor.call(this);
        this._cols = 0;
        this._winSize = null;
    },
    initWithDuration: function(X, S) {
        this._cols = S;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, X, cc.size(S, 1));
    },
    update: function(X) {
        for (var S = this._gridSize.width, P = this._winSize.height, O, Z, Y = cc.p(0, 0), T = 0; H8m.V5u(T, S); ++T)
            Y.x = T, O = this.originalTile(Y), Z = 1, H8m.s5u(0, T % 2) && (Z = -1), O.bl.y += H8m.U5u(Z, P, X), O.br.y += H8m.q5u(Z, P, X), O.tl.y += H8m.I5u(Z, P, X), O.tr.y += H8m.L6u(Z, P, X), this.setTile(Y, O);
    },
    startWithTarget: function(X) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, X);
        this._winSize = cc.director.getWinSizeInPixels();
    }
});
cc.SplitCols.create = function(X, S) {
    var P = new cc.SplitCols;
    P.initWithDuration(X, S);
    return P;
};
cc.PageTurn3D = cc.Grid3DAction.extend({
    update: function(X) {
        var S = Math.max(0, H8m.c6u(X, 0.25)),
            S = -100 - S * S * 500;
        X = -Math.PI / 2 * Math.sqrt(X);
        var P = +Math.PI / 2 + X;
        X = Math.sin(P);
        for (var P = Math.cos(P), O = this._gridSize, Z = cc.p(0, 0), Y = 0; H8m.z6u(Y, O.width); ++Y)
            for (var T = 0; H8m.j6u(T, O.height); ++T) {
                Z.x = Y;
                Z.y = T;
                var R = this.originalVertex(Z),
                    E = Math.sqrt(H8m.x6u(R.x, R.x) + H8m.o6u((R.y - S), (R.y - S))),
                    V = H8m.p6u(E, X),
                    U = H8m.Y6u(Math.asin(R.x / E), X),
                    k9 = Math.cos(U);
                R.x = H8m.T6u(U, Math.PI) ? H8m.R6u(V, Math.sin(U)) : 0;
                R.y = E + S - H8m.M6u(V, (1 - k9), X);
                R.z = H8m.C6u(V, (1 - k9), P, 7);
                H8m.U6u(0.5, R.z) && (R.z = 0.5);
                this.setVertex(Z, R);
            }
    }
});
cc.PageTurn3D.create = function(X, S) {
    var P = new cc.PageTurn3D;
    P.initWithDuration(X, S);
    return P;
};
H8m.r8y(H8m.U7H);
H8m.Y8y(H8m.h7H);
H8m.J8y(H8m.q7H);
H8m.m8y(H8m.r8i);
cc.ProgressTimer = cc.NodeRGBA.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y);
    },
    setMidpoint: function(X) {
        this._midPoint = cc.pClamp(X, cc.p(0, 0), cc.p(1, 1));
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y);
    },
    setBarChangeRate: function(X) {
        this._barChangeRate = cc.pClamp(X, cc.p(0, 0), cc.p(1, 1));
    },
    getType: function() {
        return this._type;
    },
    getPercentage: function() {
        return this._percentage;
    },
    getSprite: function() {
        return this._sprite;
    },
    setPercentage: function(X) {
        H8m.b6u(this._percentage, X) && (this._percentage = cc.clampf(X, 0, 100), this._updateProgress());
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !1;
    },
    isReverseDirection: function() {
        return this._reverseDirection;
    },
    _boundaryTexCoord: function(X) {
        if (H8m.F6u(X, cc.PROGRESS_TEXTURE_COORDS_COUNT)) {
            var S = cc.PROGRESS_TEXTURE_COORDS;
            return this._reverseDirection ? cc.p(H8m.k2u(S >> 7 - (X << 1), 1), H8m.L2u(S >> 7 - ((X << 1) + 1), 1)) : cc.p(H8m.i2u(S >> (X << 1) + 1, 1), H8m.S2u(S >> (X << 1), 1));
        }
        return cc.p(0, 0);
    },
    _origin: null,
    _startAngle: 270,
    _endAngle: 270,
    _radius: 0,
    _counterClockWise: !1,
    _barRect: null,
    _vertexDataCount: 0,
    _vertexData: null,
    _vertexArrayBuffer: null,
    _vertexWebGLBuffer: null,
    _vertexDataDirty: !1,
    ctor: null,
    _ctorForCanvas: function() {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._origin = cc.p(0, 0);
        this._endAngle = this._startAngle = 270;
        this._radius = 0;
        this._counterClockWise = !1;
        this._barRect = cc.rect(0, 0, 0, 0);
    },
    _ctorForWebGL: function() {
        cc.NodeRGBA.prototype.ctor.call(this);
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this._vertexDataCount = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataDirty = !1;
    },
    setColor: function(X) {
        this._sprite.color = X;
        this._updateColor();
    },
    setOpacity: function(X) {
        this._sprite.opacity = X;
        this._updateColor();
    },
    getColor: function() {
        return this._sprite.color;
    },
    getOpacity: function() {
        return this._sprite.opacity;
    },
    setReverseProgress: null,
    _setReverseProgressForCanvas: function(X) {
        H8m.P2u(this._reverseDirection, X) && (this._reverseDirection = X);
    },
    _setReverseProgressForWebGL: function(X) {
        H8m.a2u(this._reverseDirection, X) && (this._reverseDirection = X, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
    },
    setSprite: null,
    _setSpriteForCanvas: function(X) {
        H8m.O2u(this._sprite, X) && (this._sprite = X, this.width = this._sprite.width, this.height = this._sprite.height);
    },
    _setSpriteForWebGL: function(X) {
        X && H8m.B2u(this._sprite, X) && (this._sprite = X, this.width = X.width, this.height = X.height, this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0));
    },
    setType: null,
    _setTypeForCanvas: function(X) {
        H8m.Z2u(X, this._type) && (this._type = X);
    },
    _setTypeForWebGL: function(X) {
        H8m.J2u(X, this._type) && (this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0), this._type = X);
    },
    setReverseDirection: null,
    _setReverseDirectionForCanvas: function(X) {
        H8m.n2u(this._reverseDirection, X) && (this._reverseDirection = X);
    },
    _setReverseDirectionForWebGL: function(X) {
        H8m.G2u(this._reverseDirection, X) && (this._reverseDirection = X, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
    },
    _textureCoordFromAlphaPoint: function(X) {
        var S = this._sprite;
        if (!S)
            return {
                u: 0,
                v: 0
            };
        var P = S.quad,
            O = cc.p(P.bl.texCoords.u, P.bl.texCoords.v),
            P = cc.p(P.tr.texCoords.u, P.tr.texCoords.v);
        S.textureRectRotated && (S = X.x, X.x = X.y, X.y = S);
        return {
            u: H8m.W2u(O.x, (1 - X.x)) + H8m.v2u(P.x, X.x),
            v: H8m.u2u(O.y, (1 - X.y)) + H8m.H2u(P.y, X.y)
        };
    },
    _vertexFromAlphaPoint: function(X) {
        if (!this._sprite)
            return {
                x: 0,
                y: 0
            };
        var S = this._sprite.quad,
            P = cc.p(S.bl.vertices.x, S.bl.vertices.y),
            S = cc.p(S.tr.vertices.x, S.tr.vertices.y);
        return {
            x: H8m.f2u(P.x, (1 - X.x)) + H8m.I2u(S.x, X.x),
            y: H8m.g9b(P.y, (1 - X.y)) + H8m.K9b(S.y, X.y)
        };
    },
    initWithSprite: null,
    _initWithSpriteForCanvas: function(X) {
        this.percentage = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = X;
        return !0;
    },
    _initWithSpriteForWebGL: function(X) {
        this.percentage = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataCount = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = X;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0;
    },
    draw: null,
    _drawForCanvas: function(X) {
        X = X || cc._renderContext;
        var S = this._sprite;
        S._isLighterMode && (X.globalCompositeOperation = "lighter");
        var P = cc.view.getScaleX(),
            O = cc.view.getScaleY();
        X.globalAlpha = H8m.d9b(S._displayedOpacity, 255);
        var Z = S._rect,
            Y = S._contentSize,
            T = S._offsetPosition,
            R = S._drawSize_Canvas,
            E = H8m.t9b(0, T.x),
            V = -T.y - Z.height,
            U = S._textureRect_Canvas;
        R.width = H8m.w9b(Z.width, P);
        R.height = H8m.e9b(Z.height, O);
        X.save();
        S._flippedX && (E = -T.x - Z.width, X.scale(-1, 1));
        S._flippedY && (V = T.y, X.scale(1, -1));
        E *= P;
        V *= O;
        H8m.Q9b(this._type, cc.PROGRESS_TIMER_TYPE_BAR) ? (Z = this._barRect, X.beginPath(), X.rect(H8m.r9b(Z.x, P), H8m.N9b(Z.y, O), H8m.m9b(Z.width, P), H8m.A9b(Z.height, O)), X.clip(), X.closePath()) : H8m.E9b(this._type, cc.PROGRESS_TIMER_TYPE_RADIAL) && (Z = H8m.C9b(this._origin.x, P), T = H8m.h9b(this._origin.y, O), X.beginPath(), X.arc(Z, T, H8m.y9b(this._radius, O), H8m.q9b(Math.PI, 180, this._startAngle), H8m.I9b(Math.PI, 180, this._endAngle), this._counterClockWise), X.lineTo(Z, T), X.clip(), X.closePath());
        S._texture && U.validRect ? (P = S._texture.getHtmlElementObj(), this._colorized ? X.drawImage(P, 0, 0, U.width, U.height, E, V, R.width, R.height) : X.drawImage(P, U.x, U.y, U.width, U.height, E, V, R.width, R.height)) : H8m.L1b(0, Y.width) && (R = this.color, X.fillStyle = "rgba(" + R.r + "," + R.g + "," + R.b + ",1)", X.fillRect(E, V, H8m.i1b(Y.width, P), H8m.S1b(Y.height, O)));
        X.restore();
        cc.INCREMENT_GL_DRAWS(1);
    },
    _drawForWebGL: function(X) {
        X = X || cc._renderContext;
        if (this._vertexData && this._sprite) {
            cc.NODE_DRAW_SETUP(this);
            var S = this._sprite.getBlendFunc();
            cc.glBlendFunc(S.src, S.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(this._sprite.texture);
            X.bindBuffer(X.ARRAY_BUFFER, this._vertexWebGLBuffer);
            this._vertexDataDirty && (X.bufferData(X.ARRAY_BUFFER, this._vertexArrayBuffer, X.DYNAMIC_DRAW), this._vertexDataDirty = !1);
            S = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, X.FLOAT, !1, S, 0);
            X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, X.UNSIGNED_BYTE, !0, S, 8);
            X.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, X.FLOAT, !1, S, 12);
            H8m.P1b(this._type, cc.PROGRESS_TIMER_TYPE_RADIAL) ? X.drawArrays(X.TRIANGLE_FAN, 0, this._vertexDataCount) : H8m.a1b(this._type, cc.PROGRESS_TIMER_TYPE_BAR) && (this._reverseDirection ? (X.drawArrays(X.TRIANGLE_STRIP, 0, H8m.O1b(this._vertexDataCount, 2)), X.drawArrays(X.TRIANGLE_STRIP, 4, H8m.B1b(this._vertexDataCount, 2)), cc.g_NumberOfDraws++) : X.drawArrays(X.TRIANGLE_STRIP, 0, this._vertexDataCount));
            cc.g_NumberOfDraws++;
        }
    },
    _updateRadial: function() {
        if (this._sprite) {
            var X,
                S = this._midPoint;
            X = H8m.Z1b(this._percentage, 100);
            var P = H8m.J1b(2, cc.PI, (this._reverseDirection ? X : 1 - X)),
                O = cc.p(S.x, 1),
                Z = cc.pRotateByAngle(O, S, P),
                P = 0;
            if (H8m.R1b(0, X))
                Z = O, P = 0;
            else if (H8m.M1b(1, X))
                Z = O, P = 4;
            else {
                var Y = cc.FLT_MAX,
                    T = cc.PROGRESS_TEXTURE_COORDS_COUNT;
                for (X = 0; H8m.V1b(X, T); ++X) {
                    var R = H8m.s1b((X + (T - 1)), T),
                        E = this._boundaryTexCoord(H8m.U1b(X, T)),
                        R = this._boundaryTexCoord(R);
                    H8m.b1b(0, X) ? R = cc.pLerp(E, R, H8m.F1b(1, S.x)) : H8m.k8b(4, X) && (E = cc.pLerp(E, R, H8m.L8b(1, S.x)));
                    var V = cc.p(0, 0);
                    cc.pLineIntersect(E, R, S, Z, V) && (H8m.i8b(0, X) && H8m.S8b(4, X) || H8m.P8b(0, V.x) && H8m.a8b(1, V.x)) && H8m.O8b(0, V.y) && H8m.B8b(V.y, Y) && (Y = V.y, P = X);
                }
                Z = cc.pAdd(S, cc.pMult(cc.pSub(Z, S), Y));
            }
            Y = !0;
            H8m.Z8b(this._vertexDataCount, P + 3) && (Y = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
            if (!this._vertexData) {
                T = this._vertexDataCount = P + 3;
                E = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(H8m.J8b(T, E));
                R = [];
                for (X = 0; H8m.n8b(X, T); X++)
                    R[X] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, H8m.G8b(X, E));
                this._vertexData = R;
                if (!this._vertexData) {
                    cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                    return;
                }
            }
            this._updateColor();
            T = this._vertexData;
            if (!Y)
                for (T[0].texCoords = this._textureCoordFromAlphaPoint(S), T[0].vertices = this._vertexFromAlphaPoint(S), T[1].texCoords = this._textureCoordFromAlphaPoint(O), T[1].vertices = this._vertexFromAlphaPoint(O), X = 0; H8m.W8b(X, P); X++)
                    S = this._boundaryTexCoord(X), T[X + 2].texCoords = this._textureCoordFromAlphaPoint(S), T[X + 2].vertices = this._vertexFromAlphaPoint(S);
            T[H8m.v8b(this._vertexDataCount, 1)].texCoords = this._textureCoordFromAlphaPoint(Z);
            T[H8m.u8b(this._vertexDataCount, 1)].vertices = this._vertexFromAlphaPoint(Z);
        }
    },
    _updateBar: function() {
        if (this._sprite) {
            var X,
                S = H8m.H8b(this._percentage, 100),
                P = this._barChangeRate,
                P = cc.pMult(cc.p(H8m.f8b(1, P.x, S * P.x), H8m.k4b(1, P.y, S * P.y)), 0.5),
                S = cc.pSub(this._midPoint, P),
                P = cc.pAdd(this._midPoint, P);
            H8m.D4b(0, S.x) && (P.x += -S.x, S.x = 0);
            H8m.c4b(1, P.x) && (S.x -= H8m.z4b(P.x, 1), P.x = 1);
            H8m.j4b(0, S.y) && (P.y += -S.y, S.y = 0);
            H8m.x4b(1, P.y) && (S.y -= H8m.o4b(P.y, 1), P.y = 1);
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var O = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(H8m.p4b(8, O));
                    var Z = [];
                    for (X = 0; H8m.Y4b(8, X); X++)
                        Z[X] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, H8m.T4b(X, O));
                    Z[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
                    Z[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                    Z[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                    Z[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                    Z[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                    Z[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                    Z[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                    Z[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                    this._vertexData = Z;
                }
                X = this._vertexData;
                X[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(S.x, P.y));
                X[2].vertices = this._vertexFromAlphaPoint(cc.p(S.x, P.y));
                X[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(S.x, S.y));
                X[3].vertices = this._vertexFromAlphaPoint(cc.p(S.x, S.y));
                X[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(P.x, P.y));
                X[4].vertices = this._vertexFromAlphaPoint(cc.p(P.x, P.y));
                X[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(P.x, S.y));
                X[5].vertices = this._vertexFromAlphaPoint(cc.p(P.x, S.y));
            } else {
                if (!this._vertexData)
                    for (this._vertexDataCount = 4, O = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer = new ArrayBuffer(H8m.R4b(4, O)), this._vertexData = [], X = 0; H8m.M4b(4, X); X++)
                        this._vertexData[X] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, H8m.V4b(X, O));
                X = this._vertexData;
                X[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(S.x, P.y));
                X[0].vertices = this._vertexFromAlphaPoint(cc.p(S.x, P.y));
                X[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(S.x, S.y));
                X[1].vertices = this._vertexFromAlphaPoint(cc.p(S.x, S.y));
                X[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(P.x, P.y));
                X[2].vertices = this._vertexFromAlphaPoint(cc.p(P.x, P.y));
                X[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(P.x, S.y));
                X[3].vertices = this._vertexFromAlphaPoint(cc.p(P.x, S.y));
            }
            this._updateColor();
        }
    },
    _updateColor: function() {
        if (this._sprite && this._vertexData) {
            for (var X = this._sprite.quad.tl.colors, S = this._vertexData, P = 0, O = this._vertexDataCount; H8m.s4b(P, O); ++P)
                S[P].colors = X;
            this._vertexDataDirty = !0;
        }
    },
    _updateProgress: null,
    _updateProgressForCanvas: function() {
        var X = this._sprite,
            S = X.width,
            P = X.height,
            O = this._midPoint;
        if (H8m.U4b(this._type, cc.PROGRESS_TIMER_TYPE_RADIAL)) {
            this._radius = Math.round(Math.sqrt(H8m.b4b(S, S) + H8m.F4b(P, P)));
            var Z,
                Y = !1,
                T = this._origin;
            T.x = H8m.k7b(S, O.x);
            T.y = -P * O.y;
            this._reverseDirection ? (Z = 270, O = H8m.L7b(270, 3.6 * this._percentage)) : (O = -90, Z = -90 + 3.6 * this._percentage);
            X._flippedX && (T.x -= H8m.i7b(2, S, this._midPoint.x), O = -O - 180, Z = -Z - 180, Y = !Y);
            X._flippedY && (T.y += H8m.z7b(2, P, this._midPoint.y), Y = !Y, O = -O, Z = -Z);
            this._startAngle = O;
            this._endAngle = Z;
            this._counterClockWise = Y;
        } else {
            Z = this._barChangeRate;
            T = H8m.w7b(this._percentage, 100);
            Y = this._barRect;
            Z = cc.size(H8m.e7b(S, (1 - Z.x)), H8m.Q7b(P, (1 - Z.y)));
            var T = cc.size(H8m.r7b((S - Z.width), T), H8m.N7b((P - Z.height), T)),
                T = cc.size(Z.width + T.width, Z.height + T.height),
                R = cc.p(H8m.m7b(S, O.x), H8m.A7b(P, O.y));
            Z = H8m.E7b(R.x, T.width / 2);
            H8m.C7b(0.5, O.x) && H8m.h7b(T.width / 2, S - R.x) && (Z = H8m.y7b(S, T.width));
            S = H8m.q7b(R.y, T.height / 2);
            H8m.l7b(0.5, O.y) && H8m.X0b(T.height / 2, P - R.y) && (S = H8m.D0b(P, T.height));
            Y.x = 0;
            P = 1;
            X._flippedX && (Y.x -= T.width, P = -1);
            H8m.c0b(0, Z) && (Y.x += H8m.z0b(Z, P));
            Y.y = 0;
            P = 1;
            X._flippedY && (Y.y += T.height, P = -1);
            H8m.j0b(0, S) && (Y.y -= H8m.x0b(S, P));
            Y.width = T.width;
            Y.height = -T.height;
        }
    },
    _updateProgressForWebGL: function() {
        var X = this._type;
        H8m.o0b(X, cc.PROGRESS_TIMER_TYPE_RADIAL) ? this._updateRadial() : H8m.p0b(X, cc.PROGRESS_TIMER_TYPE_BAR) && this._updateBar();
        this._vertexDataDirty = !0;
    }
});
w6b0K[q0K]._p = cc.ProgressTimer.prototype;
H8m.Y0b(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.ctor = _p._ctorForWebGL, _p.setReverseProgress = _p._setReverseProgressForWebGL, _p.setSprite = _p._setSpriteForWebGL, _p.setType = _p._setTypeForWebGL, _p.setReverseDirection = _p._setReverseDirectionForWebGL, _p.initWithSprite = _p._initWithSpriteForWebGL, _p.draw = _p._drawForWebGL, _p._updateProgress = _p._updateProgressForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setReverseProgress = _p._setReverseProgressForCanvas, _p.setSprite = _p._setSpriteForCanvas, _p.setType = _p._setTypeForCanvas, _p.setReverseDirection = _p._setReverseDirectionForCanvas, _p.initWithSprite = _p._initWithSpriteForCanvas, _p.draw = _p._drawForCanvas, _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas);
cc.defineGetterSetter(_p, H8m.K8S, _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, H8m.c1S, _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, H8m.M1P, _p.getType, _p.setType);
cc.defineGetterSetter(_p, H8m.q2S, _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, H8m.P3P, _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, H8m.Y2S, _p.isReverseDirection, _p.setReverseDirection);
delete w6b0K[q0K]._p;
cc.ProgressTimer.create = function(X) {
    var S = new cc.ProgressTimer;
    return S.initWithSprite(X) ? S : H8m.H6P;
};
cc.ProgressTo = cc.ActionInterval.extend({
    _to: H8m.U7H,
    _from: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = H8m.U7H;
    },
    initWithDuration: function(X, S) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._to = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.ProgressTo;
        X.initWithDuration(this._duration, this._to);
        return X;
    },
    reverse: function() {
        var X = "cc.ProgressTo.reverse(): reverse hasn't been supported.";
        cc.log(X);
        return H8m.H6P;
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
        this._from = X.percentage;
        H8m.T0b(H8m.J7i, this._from) && (this._from = H8m.U7H);
    },
    update: function(X) {
        H8m.R0b(this.target, cc.ProgressTimer) && (this.target.percentage = this._from + H8m.M0b((this._to - this._from), X));
    }
});
cc.ProgressTo.create = function(X, S) {
    var P = new cc.ProgressTo;
    P.initWithDuration(X, S);
    return P;
};
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: H8m.U7H,
    _from: H8m.U7H,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = H8m.U7H;
    },
    initWithDuration: function(X, S, P) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, X) ? (this._to = P, this._from = S, !H8m.U7H) : !H8m.h7H;
    },
    clone: function() {
        var X = new cc.ProgressFromTo;
        X.initWithDuration(this._duration, this._from, this._to);
        return X;
    },
    reverse: function() {
        return cc.ProgressFromTo.create(this._duration, this._to, this._from);
    },
    startWithTarget: function(X) {
        cc.ActionInterval.prototype.startWithTarget.call(this, X);
    },
    update: function(X) {
        H8m.V0b(this.target, cc.ProgressTimer) && (this.target.percentage = this._from + H8m.s0b((this._to - this._from), X));
    }
});
cc.ProgressFromTo.create = function(X, S, P) {
    var O = new cc.ProgressFromTo;
    O.initWithDuration(X, S, P);
    return O;
};
H8m.R8y(H8m.R1P);
cc.TransitionEaseScene = cc.Class.extend({
    easeActionWithAction: function() {}
});
H8m.G8y(H8m.U7H);
H8m.E8y(H8m.h7H);
H8m.V8y(H8m.U7H);
H8m.v8y(H8m.h7H);
cc.TransitionScene = cc.Scene.extend({
    _inScene: H8m.H6P,
    _outScene: H8m.H6P,
    _duration: H8m.H6P,
    _isInSceneOnTop: !H8m.h7H,
    _isSendCleanupToScene: !H8m.h7H,
    _className: H8m.J9P,
    _setNewScene: function(X) {
        this.unschedule(this._setNewScene);
        X = cc.director;
        this._isSendCleanupToScene = X.isSendCleanupToScene();
        X.runScene(this._inScene);
        cc.eventManager.setEnabled(!H8m.U7H);
        this._outScene.visible = !H8m.U7H;
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !H8m.U7H;
    },
    draw: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!H8m.h7H);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter();
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!H8m.U7H);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish();
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup();
    },
    initWithDuration: function(X, S) {
        var P = "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene",
            O = "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (!S)
            throw O;
        if (this.init()) {
            this._duration = X;
            this.attr({
                x: H8m.U7H,
                y: H8m.U7H,
                anchorX: H8m.U7H,
                anchorY: H8m.U7H
            });
            this._inScene = S;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = cc.Scene.create(), this._outScene.init());
            if (H8m.U0b(this._inScene, this._outScene))
                throw P;
            this._sceneOrder();
            return !H8m.U7H;
        }
        return !H8m.h7H;
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        H8m.b0b(cc._renderType, cc._RENDER_TYPE_WEBGL) && this._inScene.getCamera().restore();
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        H8m.F0b(cc._renderType, cc._RENDER_TYPE_WEBGL) && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, H8m.U7H);
    },
    hideOutShowIn: function() {
        this._inScene.visible = !H8m.U7H;
        this._outScene.visible = !H8m.h7H;
    }
});
cc.TransitionScene.create = function(X, S) {
    var P = new cc.TransitionScene;
    return H8m.k3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: H8m.U7H,
    initWithDuration: function(X, S, P) {
        cc.TransitionScene.prototype.initWithDuration.call(this, X, S) && (this._orientation = P);
        return !H8m.U7H;
    }
});
cc.TransitionSceneOriented.create = function(X, S, P) {
    var O = new cc.TransitionSceneOriented;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    onEnter: function() {
        var X = (28. <= (0x91, 12.23E2) ? (1.98E2, 720) : (14., 0x18B) < (0x1E9, 7.80E1) ? (143.5E1, 5.34E2) : (0x1B, 127));
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 0.5,
            anchorY: 0.5
        });
        var S = cc.Sequence.create(cc.Spawn.create(cc.ScaleBy.create(H8m.L3b(this._duration, H8m.s7H), H8m.x8i), cc.RotateBy.create(H8m.i3b(this._duration, H8m.s7H), X)), cc.DelayTime.create(H8m.S3b(this._duration, H8m.s7H)));
        this._outScene.runAction(S);
        this._inScene.runAction(cc.Sequence.create(S.reverse(), cc.CallFunc.create(this.finish, this)));
    }
});
cc.TransitionRotoZoom.create = function(X, S) {
    var P = new cc.TransitionRotoZoom;
    return H8m.P3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.director.getWinSize();
        this._inScene.attr({
            scale: 0.5,
            x: X.width,
            y: 0,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var S = cc.JumpBy.create(H8m.a3b(this._duration, 4), cc.p(-X.width, 0), H8m.O3b(X.width, 4), 2),
            P = cc.ScaleTo.create(H8m.B3b(this._duration, 4), 1),
            X = cc.ScaleTo.create(H8m.Z3b(this._duration, 4), 0.5),
            X = cc.Sequence.create(X, S),
            S = cc.Sequence.create(S, P),
            P = cc.DelayTime.create(H8m.J3b(this._duration, 2));
        this._outScene.runAction(X);
        this._inScene.runAction(cc.Sequence.create(P, S, cc.CallFunc.create(this.finish, this)));
    }
});
cc.TransitionJumpZoom.create = function(X, S) {
    var P = new cc.TransitionJumpZoom;
    return H8m.n3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var X = this.action();
        this._inScene.runAction(cc.Sequence.create(this.easeActionWithAction(X), cc.CallFunc.create(this.finish, this)));
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0);
    },
    action: function() {
        return cc.MoveTo.create(this._duration, cc.p(H8m.U7H, H8m.U7H));
    },
    easeActionWithAction: function(X) {
        return cc.EaseOut.create(X, H8m.s7H);
    }
});
cc.TransitionMoveInL.create = function(X, S) {
    var P = new cc.TransitionMoveInL;
    return H8m.G3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0);
    }
});
cc.TransitionMoveInR.create = function(X, S) {
    var P = new cc.TransitionMoveInR;
    return H8m.W3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height);
    }
});
cc.TransitionMoveInT.create = function(X, S) {
    var P = new cc.TransitionMoveInT;
    return H8m.v3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height);
    }
});
cc.TransitionMoveInB.create = function(X, S) {
    var P = new cc.TransitionMoveInB;
    return H8m.u3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
H8m.h8y(H8m.E1S);
cc.TransitionSlideInL = cc.TransitionScene.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !1;
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var X = this.action(),
            S = this.action(),
            X = this.easeActionWithAction(X),
            S = cc.Sequence.create(this.easeActionWithAction(S), cc.CallFunc.create(this.finish, this));
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0);
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(H8m.H3b(cc.director.getWinSize().width, cc.ADJUST_FACTOR), 0));
    },
    easeActionWithAction: function(X) {
        return cc.EaseOut.create(X, 2);
    }
});
cc.TransitionSlideInL.create = function(X, S) {
    var P = new cc.TransitionSlideInL;
    return H8m.f3b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !0;
    },
    initScenes: function() {
        this._inScene.setPosition(H8m.I3b(cc.director.getWinSize().width, cc.ADJUST_FACTOR), 0);
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(-(H8m.g5b(cc.director.getWinSize().width, cc.ADJUST_FACTOR)), 0));
    }
});
cc.TransitionSlideInR.create = function(X, S) {
    var P = new cc.TransitionSlideInR;
    return H8m.K5b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !1;
    },
    initScenes: function() {
        this._inScene.setPosition(0, H8m.d5b(cc.director.getWinSize().height, cc.ADJUST_FACTOR));
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(0, -(H8m.t5b(cc.director.getWinSize().height, cc.ADJUST_FACTOR))));
    }
});
cc.TransitionSlideInB.create = function(X, S) {
    var P = new cc.TransitionSlideInB;
    return H8m.w5b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !0;
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(H8m.e5b(cc.director.getWinSize().height, cc.ADJUST_FACTOR)));
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(0, H8m.Q5b(cc.director.getWinSize().height, cc.ADJUST_FACTOR)));
    }
});
cc.TransitionSlideInT.create = function(X, S) {
    var P = new cc.TransitionSlideInT;
    return H8m.r5b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: H8m.N5b(2, 3),
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: H8m.m5b(1, 3),
            anchorY: 0.5
        });
        var X = cc.ScaleTo.create(this._duration, H8m.z0H),
            S = cc.ScaleTo.create(this._duration, H8m.h7H);
        this._inScene.runAction(this.easeActionWithAction(S));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(X), cc.CallFunc.create(this.finish, this)));
    },
    easeActionWithAction: function(X) {
        return cc.EaseOut.create(X, H8m.s7H);
    }
});
cc.TransitionShrinkGrow.create = function(X, S) {
    var P = new cc.TransitionShrinkGrow;
    return H8m.A5b(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.E5b(this._orientation, cc.TRANSITION_ORIENTATION_RIGHT_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.C5b(this._duration, H8m.s7H)), cc.Show.create(), cc.OrbitCamera.create(H8m.h5b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, H8m.U7H, H8m.U7H), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.OrbitCamera.create(H8m.y5b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.U7H, H8m.U7H), cc.Hide.create(), cc.DelayTime.create(H8m.q5b(this._duration, H8m.s7H)));
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionFlipX.create = function(X, S, P) {
    H8m.l5b(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var O = new cc.TransitionFlipX;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.X6b(this._orientation, cc.TRANSITION_ORIENTATION_UP_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.D6b(this._duration, H8m.s7H)), cc.Show.create(), cc.OrbitCamera.create(H8m.c6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, H8m.h7i, H8m.U7H), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.OrbitCamera.create(H8m.z6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.h7i, H8m.U7H), cc.Hide.create(), cc.DelayTime.create(H8m.j6b(this._duration, H8m.s7H)));
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionFlipY.create = function(X, S, P) {
    H8m.x6b(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_UP_OVER);
    var O = new cc.TransitionFlipY;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.o6b(this._orientation, cc.TRANSITION_ORIENTATION_RIGHT_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.p6b(this._duration, H8m.s7H)), cc.Show.create(), cc.OrbitCamera.create(H8m.Y6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, -H8m.k4i, H8m.U7H), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.OrbitCamera.create(H8m.T6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.k4i, H8m.U7H), cc.Hide.create(), cc.DelayTime.create(H8m.R6b(this._duration, H8m.s7H)));
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionFlipAngular.create = function(X, S, P) {
    H8m.M6b(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var O = new cc.TransitionFlipAngular;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.V6b(this._orientation, cc.TRANSITION_ORIENTATION_RIGHT_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.s6b(this._duration, H8m.s7H)), cc.Spawn.create(cc.OrbitCamera.create(H8m.U6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, H8m.U7H, H8m.U7H), cc.ScaleTo.create(H8m.b6b(this._duration, H8m.s7H), H8m.h7H), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(H8m.F6b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.U7H, H8m.U7H), cc.ScaleTo.create(H8m.k2b(this._duration, H8m.s7H), H8m.E1S)), cc.Hide.create(), cc.DelayTime.create(H8m.L2b(this._duration, H8m.s7H)));
        this._inScene.scale = 0.5;
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionZoomFlipX.create = function(X, S, P) {
    H8m.i2b(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var O = new cc.TransitionZoomFlipX;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.S2b(this._orientation, cc.TRANSITION_ORIENTATION_UP_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.P2b(this._duration, H8m.s7H)), cc.Spawn.create(cc.OrbitCamera.create(H8m.a2b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, H8m.h7i, H8m.U7H), cc.ScaleTo.create(H8m.O2b(this._duration, H8m.s7H), H8m.h7H), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(H8m.B2b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.h7i, H8m.U7H), cc.ScaleTo.create(H8m.Z2b(this._duration, H8m.s7H), H8m.E1S)), cc.Hide.create(), cc.DelayTime.create(H8m.J2b(this._duration, H8m.s7H)));
        this._inScene.scale = 0.5;
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionZoomFlipY.create = function(X, S, P) {
    H8m.n2b(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_UP_OVER);
    var O = new cc.TransitionZoomFlipY;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X,
            S;
        this._inScene.visible = !H8m.h7H;
        var P;
        H8m.G2b(this._orientation, cc.TRANSITION_ORIENTATION_RIGHT_OVER) ? (X = H8m.h7i, P = H8m.g4K, S = H8m.h7i) : (X = -H8m.h7i, P = H8m.h7i, S = -H8m.h7i);
        X = cc.Sequence.create(cc.DelayTime.create(H8m.W2b(this._duration, H8m.s7H)), cc.Spawn.create(cc.OrbitCamera.create(H8m.v2b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, P, X, -H8m.k4i, H8m.U7H), cc.ScaleTo.create(H8m.u2b(this._duration, H8m.s7H), H8m.h7H), cc.Show.create()), cc.Show.create(), cc.CallFunc.create(this.finish, this));
        S = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(H8m.H2b(this._duration, H8m.s7H), H8m.h7H, H8m.U7H, H8m.U7H, S, H8m.k4i, H8m.U7H), cc.ScaleTo.create(H8m.f2b(this._duration, H8m.s7H), H8m.E1S)), cc.Hide.create(), cc.DelayTime.create(H8m.I2b(this._duration, H8m.s7H)));
        this._inScene.scale = 0.5;
        this._inScene.runAction(X);
        this._outScene.runAction(S);
    }
});
cc.TransitionZoomFlipAngular.create = function(X, S, P) {
    H8m.g98(H8m.H6P, P) && (P = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
    var O = new cc.TransitionZoomFlipAngular;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: H8m.H6P,
    ctor: function() {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color();
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.LayerColor.create(this._color);
        this._inScene.visible = !H8m.h7H;
        this.addChild(X, H8m.s7H, cc.SCENE_FADE);
        var X = this.getChildByTag(cc.SCENE_FADE),
            S = cc.Sequence.create(cc.FadeIn.create(H8m.K98(this._duration, H8m.s7H)), cc.CallFunc.create(this.hideOutShowIn, this), cc.FadeOut.create(H8m.d98(this._duration, H8m.s7H)), cc.CallFunc.create(this.finish, this));
        X.runAction(S);
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !H8m.h7H);
    },
    initWithDuration: function(X, S, P) {
        P = P || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, X, S) && (this._color.r = P.r, this._color.g = P.g, this._color.b = P.b, this._color.a = H8m.U7H);
        return !H8m.U7H;
    }
});
cc.TransitionFade.create = function(X, S, P) {
    var O = new cc.TransitionFade;
    O.initWithDuration(X, S, P);
    return O;
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.color(0, 0, 0, 0),
            S = cc.director.getWinSize(),
            X = cc.LayerColor.create(X),
            P = cc.RenderTexture.create(S.width, S.height);
        if (H8m.t98(null, P)) {
            P.sprite.anchorX = 0.5;
            P.sprite.anchorY = 0.5;
            P.attr({
                x: H8m.w98(S.width, 2),
                y: H8m.e98(S.height, 2),
                anchorX: 0.5,
                anchorY: 0.5
            });
            P.begin();
            this._inScene.visit();
            P.end();
            var O = cc.RenderTexture.create(S.width, S.height);
            O.setPosition(H8m.Q98(S.width, 2), H8m.r98(S.height, 2));
            O.sprite.anchorX = O.anchorX = 0.5;
            O.sprite.anchorY = O.anchorY = 0.5;
            O.begin();
            this._outScene.visit();
            O.end();
            P.sprite.setBlendFunc(cc.ONE, cc.ONE);
            O.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            X.addChild(P);
            X.addChild(O);
            P.sprite.opacity = 255;
            O.sprite.opacity = 255;
            S = cc.Sequence.create(cc.FadeTo.create(this._duration, 0), cc.CallFunc.create(this.hideOutShowIn, this), cc.CallFunc.create(this.finish, this));
            O.sprite.runAction(S);
            this.addChild(X, 2, cc.SCENE_FADE);
        }
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1);
        cc.TransitionScene.prototype.onExit.call(this);
    },
    draw: function() {}
});
cc.TransitionCrossFade.create = function(X, S) {
    var P = new cc.TransitionCrossFade;
    P.initWithDuration(X, S);
    return P;
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !1;
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.director.getWinSize(),
            X = cc.TurnOffTiles.create(this._duration, cc.size(H8m.N98(0, X.width / X.height * 12), 12)),
            X = this.easeActionWithAction(X);
        this._outScene.runAction(cc.Sequence.create(X, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()));
    },
    easeActionWithAction: function(X) {
        return X;
    }
});
cc.TransitionTurnOffTiles.create = function(X, S) {
    var P = new cc.TransitionTurnOffTiles;
    return H8m.m98(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.visible = !H8m.h7H;
        var X = this.action(),
            X = cc.Sequence.create(X, cc.CallFunc.create(this.hideOutShowIn, this), X.reverse());
        this.runAction(cc.Sequence.create(this.easeActionWithAction(X), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()));
    },
    easeActionWithAction: function(X) {
        return cc.EaseInOut.create(X, H8m.v7H);
    },
    action: function() {
        return cc.SplitCols.create(H8m.A98(this._duration, H8m.s7H), H8m.v7H);
    }
});
cc.TransitionSplitCols.create = function(X, S) {
    var P = new cc.TransitionSplitCols;
    return H8m.E98(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    action: function() {
        return cc.SplitRows.create(H8m.C98(this._duration, H8m.s7H), H8m.v7H);
    }
});
cc.TransitionSplitRows.create = function(X, S) {
    var P = new cc.TransitionSplitRows;
    return H8m.h98(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _sceneOrder: function() {
        this._isInSceneOnTop = !1;
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.director.getWinSize(),
            X = this.actionWithSize(cc.size(H8m.y98(0, X.width / X.height * 12), 12));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(X), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()));
    },
    easeActionWithAction: function(X) {
        return X;
    },
    actionWithSize: function(X) {
        return cc.FadeOutTRTiles.create(this._duration, X);
    }
});
cc.TransitionFadeTR.create = function(X, S) {
    var P = new cc.TransitionFadeTR;
    return H8m.q98(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    actionWithSize: function(X) {
        return cc.FadeOutBLTiles.create(this._duration, X);
    }
});
cc.TransitionFadeBL.create = function(X, S) {
    var P = new cc.TransitionFadeBL;
    return H8m.l98(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    actionWithSize: function(X) {
        return cc.FadeOutUpTiles.create(this._duration, X);
    }
});
cc.TransitionFadeUp.create = function(X, S) {
    var P = new cc.TransitionFadeUp;
    return H8m.X18(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    actionWithSize: function(X) {
        return cc.FadeOutDownTiles.create(this._duration, X);
    }
});
cc.TransitionFadeDown.create = function(X, S) {
    var P = new cc.TransitionFadeDown;
    return H8m.D18(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
H8m.U8y(H8m.x3i);
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    _setAttrs: function(X, S, P) {
        X.attr({
            x: S,
            y: P,
            anchorX: 0.5,
            anchorY: 0.5
        });
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var X = cc.director.getWinSize(),
            S = cc.RenderTexture.create(X.width, X.height);
        S.sprite.anchorX = 0.5;
        S.sprite.anchorY = 0.5;
        this._setAttrs(S, H8m.c18(X.width, 2), H8m.z18(X.height, 2));
        S.clear(0, 0, 0, 1);
        S.begin();
        this._sceneToBeModified.visit();
        S.end();
        H8m.j18(this._sceneToBeModified, this._outScene) && this.hideOutShowIn();
        X = this._progressTimerNodeWithRenderTexture(S);
        S = cc.Sequence.create(cc.ProgressFromTo.create(this._duration, this._from, this._to), cc.CallFunc.create(this.finish, this));
        X.runAction(S);
        this.addChild(X, 2, cc.SCENE_RADIAL);
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this);
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._outScene;
        this._from = 100;
        this._to = 0;
    },
    _progressTimerNodeWithRenderTexture: function(X) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null;
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1;
    }
});
cc.TransitionProgress.create = function(X, S) {
    var P = new cc.TransitionProgress;
    return H8m.x18(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        var S = cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.o18(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        X.reverseDir = !H8m.h7H;
        X.percentage = H8m.J7i;
        this._setAttrs(X, H8m.p18(S.width, 2), H8m.Y18(S.height, 2));
        return X;
    }
});
cc.TransitionProgressRadialCCW.create = function(X, S) {
    var P = new cc.TransitionProgressRadialCCW;
    return H8m.T18(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        var S = cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.R18(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        X.reverseDir = !H8m.U7H;
        X.percentage = H8m.J7i;
        this._setAttrs(X, H8m.M18(S.width, 2), H8m.V18(S.height, 2));
        return X;
    }
});
cc.TransitionProgressRadialCW.create = function(X, S) {
    var P = new cc.TransitionProgressRadialCW;
    return H8m.s18(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        var S = cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.U18(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_BAR;
        X.midPoint = cc.p(H8m.h7H, H8m.U7H);
        X.barChangeRate = cc.p(H8m.h7H, H8m.U7H);
        X.percentage = H8m.J7i;
        this._setAttrs(X, H8m.b18(S.width, 2), H8m.F18(S.height, 2));
        return X;
    }
});
cc.TransitionProgressHorizontal.create = function(X, S) {
    var P = new cc.TransitionProgressHorizontal;
    return H8m.k88(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        var S = cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.L88(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_BAR;
        X.midPoint = cc.p(H8m.U7H, H8m.U7H);
        X.barChangeRate = cc.p(H8m.U7H, H8m.h7H);
        X.percentage = H8m.J7i;
        this._setAttrs(X, H8m.i88(S.width, 2), H8m.S88(S.height, 2));
        return X;
    }
});
cc.TransitionProgressVertical.create = function(X, S) {
    var P = new cc.TransitionProgressVertical;
    return H8m.P88(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        var S = cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.a88(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_BAR;
        X.midPoint = cc.p(H8m.E1S, H8m.E1S);
        X.barChangeRate = cc.p(H8m.h7H, H8m.h7H);
        X.percentage = H8m.U7H;
        this._setAttrs(X, H8m.O88(S.width, 2), H8m.B88(S.height, 2));
        return X;
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !H8m.h7H;
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene;
        this._from = H8m.U7H;
        this._to = H8m.J7i;
    }
});
cc.TransitionProgressInOut.create = function(X, S) {
    var P = new cc.TransitionProgressInOut;
    return H8m.Z88(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    _progressTimerNodeWithRenderTexture: function(X) {
        cc.director.getWinSize();
        X = cc.ProgressTimer.create(X.sprite);
        H8m.J88(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.sprite.flippedY = !H8m.U7H);
        X.type = cc.PROGRESS_TIMER_TYPE_BAR;
        X.midPoint = cc.p(H8m.E1S, H8m.E1S);
        X.barChangeRate = cc.p(H8m.h7H, H8m.h7H);
        X.percentage = H8m.J7i;
        this._setAttrs(X, H8m.n88(winSize.width, 2), H8m.G88(winSize.height, 2));
        return X;
    }
});
cc.TransitionProgressOutIn.create = function(X, S) {
    var P = new cc.TransitionProgressOutIn;
    return H8m.W88(H8m.H6P, P) && P.initWithDuration(X, S) ? P : H8m.H6P;
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    _back: !H8m.U7H,
    _className: H8m.H0H,
    initWithDuration: function(X, S, P) {
        this._back = P;
        cc.TransitionScene.prototype.initWithDuration.call(this, X, S);
        return !H8m.U7H;
    },
    actionWithSize: function(X) {
        return this._back ? cc.ReverseTime.create(cc.PageTurn3D.create(this._duration, X)) : cc.PageTurn3D.create(this._duration, X);
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var X = cc.director.getWinSize(),
            S;
        H8m.v88(X.width, X.height) ? (X = 16, S = 12) : (X = 12, S = 16);
        X = this.actionWithSize(cc.size(X, S));
        this._back ? (this._inScene.visible = !H8m.h7H, this._inScene.runAction(cc.Sequence.create(cc.Show.create(), X, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))) : this._outScene.runAction(cc.Sequence.create(X, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()));
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back;
    }
});
cc.TransitionPageTurn.create = function(X, S, P) {
    var O = new cc.TransitionPageTurn;
    O.initWithDuration(X, S, P);
    return O;
};
cc.Codec = {
    name: H8m.c9K
};
cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
};
cc.unzipBase64 = function() {
    var X = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [X]);
};
cc.unzipBase64AsArray = function(X, S) {
    S = S || 1;
    var P = this.unzipBase64(X),
        O = [],
        Z,
        Y,
        T;
    Z = 0;
    for (T = H8m.u88(P.length, S); H8m.H88(Z, T); Z++)
        for (O[Z] = 0, Y = H8m.f88(S, 1); H8m.I88(0, Y); --Y)
            O[Z] += H8m.g48(P.charCodeAt(Z * S + Y), 8 * Y);
    return O;
};
cc.unzipAsArray = function(X, S) {
    S = S || 1;
    var P = this.unzip(X),
        O = [],
        Z,
        Y,
        T;
    Z = 0;
    for (T = H8m.K48(P.length, S); H8m.d48(Z, T); Z++)
        for (O[Z] = 0, Y = H8m.t48(S, 1); H8m.w48(0, Y); --Y)
            O[Z] += H8m.e48(P.charCodeAt(Z * S + Y), 8 * Y);
    return O;
};
cc.StringToArray = function(X) {
    X = X.split(",");
    var S = [],
        P;
    for (P = 0; H8m.Q48(P, X.length); P++)
        S.push(parseInt(X[P]));
    return S;
};
cc.Codec.Base64 = {
    name: H8m.M3i
};
H8m.H8y(H8m.d6i);
cc.Codec.Base64.decode = function(X) {
    var S = [],
        P,
        O,
        Z,
        Y,
        T,
        R = 0;
    for (X = X.replace(/[^A-Za-z0-9\+\/\=]/g, ""); H8m.r48(R, X.length);)
        P = this._keyStr.indexOf(X.charAt(R++)), O = this._keyStr.indexOf(X.charAt(R++)), Y = this._keyStr.indexOf(X.charAt(R++)), T = this._keyStr.indexOf(X.charAt(R++)), P = H8m.N48(P << 2, O >> 4), O = H8m.m48((O & 15) << 4, Y >> 2), Z = H8m.A48((Y & 3) << 6, T), S.push(String.fromCharCode(P)), H8m.E48(64, Y) && S.push(String.fromCharCode(O)), H8m.C48(64, T) && S.push(String.fromCharCode(Z));
    return S = S.join("");
};
cc.Codec.Base64.decodeAsArray = function(X, S) {
    var P = this.decode(X),
        O = [],
        Z,
        Y,
        T;
    Z = 0;
    for (T = H8m.h48(P.length, S); H8m.y48(Z, T); Z++)
        for (O[Z] = 0, Y = H8m.q48(S, 1); H8m.l48(0, Y); --Y)
            O[Z] += H8m.X78(P.charCodeAt(Z * S + Y), 8 * Y);
    return O;
};
cc.uint8ArrayToUint32Array = function(X) {
    if (H8m.D78(0, X.length % 4))
        return null;
    for (var S = H8m.c78(X.length, 4), P = w6b0K[q0K].Uint32Array ? new Uint32Array(S) : [], O = 0; H8m.z78(O, S); O++) {
        var Z = H8m.j78(4, O);
        P[O] = X[Z] + H8m.x78(256, X[Z + 1]) + H8m.o78(65536, X[Z + 2]) + H8m.p78(16777216, X[Z + 3]);
    }
    return P;
};
cc.Codec.GZip = function(X) {
    this.data = X;
    this.debug = !H8m.h7H;
    this.gpflags = void H8m.U7H;
    this.files = H8m.U7H;
    this.unzipped = [];
    this.buf32k = Array(H8m.I5P);
    this.bIdx = H8m.U7H;
    this.modeZIP = !H8m.h7H;
    this.bytepos = H8m.U7H;
    this.bb = H8m.h7H;
    this.bits = H8m.U7H;
    this.nameBuf = [];
    this.fileout = void H8m.U7H;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(H8m.J9i);
    this.treepos = H8m.U7H;
    this.Places = H8m.H6P;
    this.len = H8m.U7H;
    this.fpos = Array(H8m.v9i);
    this.fpos[H8m.U7H] = H8m.U7H;
    this.fmax = this.flens = void H8m.U7H;
};
cc.Codec.GZip.gunzip = function(X) {
    return (new cc.Codec.GZip(X)).gunzip()[H8m.U7H][H8m.U7H];
};
cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = H8m.U7H;
    this.jump = H8m.H6P;
    this.jumppos = -H8m.h7H;
};
H8m.q8y(H8m.h8K);
H8m.F8y(H8m.v0K);
H8m.I8y();
H8m.k4y();
H8m.X4y();
H8m.g4y();
H8m.L4y();
H8m.D4y();
cc.Codec.GZip.prototype.gunzip = function() {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped;
};
cc.Codec.GZip.prototype.readByte = function() {
    this.bits += 8;
    return H8m.Y78(this.bytepos, this.data.length) ? this.data.charCodeAt(this.bytepos++) : -1;
};
cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = H8m.h7H;
};
cc.Codec.GZip.prototype.readBit = function() {
    var X;
    this.bits++;
    X = H8m.T78(this.bb, H8m.h7H);
    this.bb >>= H8m.h7H;
    H8m.R78(H8m.U7H, this.bb) && (this.bb = this.readByte(), X = H8m.M78(this.bb, H8m.h7H), this.bb = H8m.V78(this.bb >> H8m.h7H, H8m.g3S));
    return X;
};
cc.Codec.GZip.prototype.readBits = function(X) {
    for (var S = H8m.U7H, P = X; P--;)
        S = H8m.s78(S << H8m.h7H, this.readBit());
    X && (S = H8m.U78(cc.Codec.GZip.bitReverse[S], H8m.F7H - X));
    return S;
};
cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = H8m.U7H;
};
cc.Codec.GZip.prototype.addBuffer = function(X) {
    this.buf32k[this.bIdx++] = X;
    this.outputArr.push(String.fromCharCode(X));
    H8m.b78(H8m.I5P, this.bIdx) && (this.bIdx = H8m.U7H);
};
cc.Codec.GZip.prototype.IsPat = function() {
    for (;;) {
        if (H8m.F78(this.fpos[this.len], this.fmax))
            return -H8m.h7H;
        if (H8m.k08(this.flens[this.fpos[this.len]], this.len))
            return this.fpos[this.len]++;
        this.fpos[this.len]++;
    }
};
cc.Codec.GZip.prototype.Rec = function() {
    var X = this.Places[this.treepos],
        S;
    if (H8m.L08(H8m.v9i, this.len))
        return -H8m.h7H;
    this.treepos++;
    this.len++;
    S = this.IsPat();
    if (H8m.i08(H8m.U7H, S))
        X.b0 = S;
    else if (X.b0 = H8m.I5P, this.Rec())
        return -H8m.h7H;
    S = this.IsPat();
    if (H8m.S08(H8m.U7H, S))
        X.b1 = S, X.jump = H8m.H6P;
    else if (X.b1 = H8m.I5P, X.jump = this.Places[this.treepos], X.jumppos = this.treepos, this.Rec())
        return -H8m.h7H;
    this.len--;
    return H8m.U7H;
};
cc.Codec.GZip.prototype.CreateTree = function(X, S, P, O) {
    this.Places = X;
    this.treepos = H8m.U7H;
    this.flens = P;
    this.fmax = S;
    for (X = H8m.U7H; H8m.P08(H8m.v9i, X); X++)
        this.fpos[X] = H8m.U7H;
    this.len = H8m.U7H;
    return this.Rec() ? -H8m.h7H : H8m.U7H;
};
cc.Codec.GZip.prototype.DecodeValue = function(X) {
    for (var S, P, O = H8m.U7H, Z = X[O];;)
        if (S = this.readBit()) {
            if (!(H8m.a08(Z.b1, H8m.I5P)))
                return Z.b1;
            Z = Z.jump;
            S = X.length;
            for (P = H8m.U7H; H8m.O08(P, S); P++)
                if (H8m.B08(X[P], Z)) {
                    O = P;
                    break;
                }
        } else {
            if (!(H8m.Z08(Z.b0, H8m.I5P)))
                return Z.b0;
            O++;
            Z = X[O];
        }
    return -H8m.h7H;
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
    var X,
        S,
        P,
        O,
        Z;
    do if (X = this.readBit(), P = this.readBits(2), H8m.J08(0, P))
        for (this.byteAlign(), P = this.readByte(), P |= H8m.n08(this.readByte(), 8), S = this.readByte(), S |= H8m.G08(this.readByte(), 8), (P ^ ~S) & 65535 && w6b0K[I0K]['write']("BlockLen checksum mismatch\n"); P--;)
            S = this.readByte(), this.addBuffer(S);
    else if (H8m.W08(1, P))
        for (;;)
            if (P = H8m.v08(cc.Codec.GZip.bitReverse[this.readBits(7)], 1), H8m.u08(23, P) ? (P = H8m.H08(P << 1, this.readBit()), H8m.f08(199, P) ? (P -= 128, P = H8m.I08(P << 1, this.readBit())) : (P -= 48, H8m.g38(143, P) && (P += 136))) : P += 256, H8m.K38(256, P))
                this.addBuffer(P);
            else if (H8m.d38(256, P))
                break;
            else {
                var Y;
                P -= 257;
                Z = this.readBits(cc.Codec.GZip.cplext[P]) + cc.Codec.GZip.cplens[P];
                P = H8m.t38(cc.Codec.GZip.bitReverse[this.readBits(5)], 3);
                H8m.w38(8, cc.Codec.GZip.cpdext[P]) ? (Y = this.readBits(8), Y |= H8m.e38(this.readBits(cc.Codec.GZip.cpdext[P] - 8), 8)) : Y = this.readBits(cc.Codec.GZip.cpdext[P]);
                Y += cc.Codec.GZip.cpdist[P];
                for (P = 0; H8m.Q38(P, Z); P++)
                    S = this.buf32k[H8m.r38(this.bIdx - Y, 32767)], this.addBuffer(S);
            }
    else if (H8m.N38(2, P)) {
        var T = Array(320);
        S = 257 + this.readBits(5);
        Y = 1 + this.readBits(5);
        O = 4 + this.readBits(4);
        for (P = 0; H8m.m38(19, P); P++)
            T[P] = 0;
        for (P = 0; H8m.A38(P, O); P++)
            T[cc.Codec.GZip.border[P]] = this.readBits(3);
        Z = this.distanceTree.length;
        for (O = 0; H8m.E38(O, Z); O++)
            this.distanceTree[O] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, T, 0))
            return this.flushBuffer(), 1;
        Z = S + Y;
        O = 0;
        for (var R = -1; H8m.C38(O, Z);)
            if (R++, P = this.DecodeValue(this.distanceTree), H8m.h38(16, P))
                T[O++] = P;
            else if (H8m.y38(16, P)) {
                var E;
                P = 3 + this.readBits(2);
                if (H8m.q38(O + P, Z))
                    return this.flushBuffer(), 1;
                for (E = O ? T[H8m.l38(O, 1)] : 0; P--;)
                    T[O++] = E;
            } else {
                P = H8m.X58(17, P) ? 3 + this.readBits(3) : 11 + this.readBits(7);
                if (H8m.D58(O + P, Z))
                    return this.flushBuffer(), 1;
                for (; P--;)
                    T[O++] = 0;
            }
        Z = this.literalTree.length;
        for (O = 0; H8m.c58(O, Z); O++)
            this.literalTree[O] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, S, T, 0))
            return this.flushBuffer(), 1;
        Z = this.literalTree.length;
        for (O = 0; H8m.z58(O, Z); O++)
            this.distanceTree[O] = new cc.Codec.GZip.HufNode;
        P = [];
        for (O = S; H8m.j58(O, T.length); O++)
            P[H8m.x58(O, S)] = T[O];
        if (this.CreateTree(this.distanceTree, Y, P, 0))
            return this.flushBuffer(), 1;
        for (;;)
            if (P = this.DecodeValue(this.literalTree), H8m.o58(256, P)) {
                P -= 256;
                if (H8m.p58(0, P))
                    break;
                P--;
                Z = this.readBits(cc.Codec.GZip.cplext[P]) + cc.Codec.GZip.cplens[P];
                P = this.DecodeValue(this.distanceTree);
                H8m.Y58(8, cc.Codec.GZip.cpdext[P]) ? (Y = this.readBits(8), Y |= H8m.T58(this.readBits(cc.Codec.GZip.cpdext[P] - 8), 8)) : Y = this.readBits(cc.Codec.GZip.cpdext[P]);
                for (Y += cc.Codec.GZip.cpdist[P]; Z--;)
                    S = this.buf32k[H8m.R58(this.bIdx - Y, 32767)], this.addBuffer(S);
            } else
                this.addBuffer(P);
    }
    while (!X);
    this.flushBuffer();
    this.byteAlign();
    return 0;
};
cc.Codec.GZip.prototype.unzipFile = function(X) {
    var S;
    this.gunzip();
    for (S = 0; H8m.M58(S, this.unzipped.length); S++)
        if (H8m.V58(this.unzipped[S][1], X))
            return this.unzipped[S][0];
};
cc.Codec.GZip.prototype.nextFile = function() {
    var X = "file",
        S = "geonext.gxt";
    this.outputArr = [];
    this.modeZIP = !H8m.h7H;
    var P = [];
    P[H8m.U7H] = this.readByte();
    P[H8m.h7H] = this.readByte();
    H8m.s58(H8m.B3S, P[H8m.U7H]) && H8m.U58(H8m.V0P, P[H8m.h7H]) && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(H8m.u4S), S], this.files++);
    H8m.b58(H8m.m9i, P[H8m.U7H]) && H8m.F58(H8m.E3S, P[H8m.h7H]) && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(H8m.u4S), X], this.files++);
    if (H8m.k68(H8m.u1i, P[H8m.U7H]) && H8m.L68(H8m.r8i, P[H8m.h7H]) && (this.modeZIP = !H8m.U7H, P[H8m.s7H] = this.readByte(), P[H8m.v7H] = this.readByte(), H8m.i68(H8m.v7H, P[H8m.s7H]) && H8m.S68(H8m.q7H, P[H8m.v7H]))) {
        P[H8m.U7H] = this.readByte();
        P[H8m.h7H] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= H8m.P68(this.readByte(), H8m.F7H);
        P = this.readByte();
        P |= H8m.a68(this.readByte(), H8m.F7H);
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var O = this.readByte(),
            O = H8m.O68(O, this.readByte() << H8m.F7H),
            Z = this.readByte(),
            Z = H8m.B68(Z, this.readByte() << H8m.F7H),
            Y = H8m.U7H;
        for (this.nameBuf = []; O--;) {
            var T = this.readByte();
            H8m.Z68(H8m.K0P == T, H8m.J7K == T) ? Y = H8m.U7H : H8m.J68(Y, cc.Codec.GZip.NAMEMAX - H8m.h7H) && (this.nameBuf[Y++] = String.fromCharCode(T));
        }
        this.fileout || (this.fileout = this.nameBuf);
        for (var Y = H8m.U7H; H8m.n68(Y, Z);)
            this.readByte(), Y++;
        H8m.G68(H8m.F7H, P) && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(H8m.u4S), this.nameBuf.join(H8m.u4S)], this.files++);
        this.skipdir();
    }
};
cc.Codec.GZip.prototype.skipdir = function() {
    var X = "7",
        S = [],
        P;
    H8m.W68(this.gpflags, H8m.F7H) && (S[H8m.U7H] = this.readByte(), S[H8m.h7H] = this.readByte(), S[H8m.s7H] = this.readByte(), S[H8m.v7H] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    S[H8m.U7H] = this.readByte();
    if (H8m.v68(H8m.F7H, S[H8m.U7H]))
        return H8m.U7H;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (H8m.u68(this.gpflags, H8m.q7H))
        for (S[H8m.U7H] = this.readByte(), S[H8m.s7H] = this.readByte(), this.len = S[H8m.U7H] + H8m.H68(H8m.v0K, S[H8m.h7H]), S = H8m.U7H; H8m.f68(S, this.len); S++)
            this.readByte();
    if (H8m.I68(this.gpflags, H8m.F7H))
        for (S = H8m.U7H, this.nameBuf = []; P = this.readByte();) {
            if (H8m.g28(X, P) || H8m.K28(H8m.J7K, P))
                S = H8m.U7H;
            H8m.d28(S, cc.Codec.GZip.NAMEMAX - H8m.h7H) && (this.nameBuf[S++] = P);
        }
    if (H8m.t28(this.gpflags, H8m.U9i))
        for (; this.readByte();)
            ;
    H8m.w28(this.gpflags, H8m.s7H) && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile();
};
(function() {
    var y4 = function() {
            y9 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
        },
        F4 = function() {
            N9 = [];
        };
    function b8(X) {
        this.buffer = new (Z9 ? Uint16Array : Array)(H8m.j9p(2, X));
        this.length = 0;
    }
    function B4(S) {
        var P = function(X) {
                R = X;
            },
            O = function(X) {
                T = X;
            };
        if ("string" === typeof S) {
            var Z = function(X) {
                    T = X;
                },
                Y = function() {
                    S[T] = H8m.h28((S[T].charCodeAt(0) & 255), 0);
                };
            S = S.split("");
            var T,
                R;
            Z(0);
            for (R = S.length; H8m.y28(T, R); T++)
                Y();
        }
        O(1);
        P(0);
        for (var E = S.length, V, U = 0; H8m.q28(0, E);) {
            var k9 = function() {
                V = H8m.l28(1024, E) ? 1024 : E;
            };
            k9();
            E -= V;
            do T += S[U++], R += T;
            while (--V);
            T %= 65521;
            R %= 65521;
        }
        return H8m.X9p((R << 16 | T), 0);
    }
    function C4(K9) {
        function c9(S, P, O) {
            var Z = function(X) {
                    O[L9++] = X;
                },
                Y = function(X) {
                    O[L9++] = X;
                },
                T = function(X) {
                    O[L9++] = X;
                },
                R = function(X) {
                    U = X;
                },
                E = function(X) {
                    U = X;
                },
                V,
                U,
                k9,
                L9;
            for (L9 = 0; H8m.f8j(L9, S);)
                switch (V = h8(this, P), V) {
                case 16:
                    for (k9 = 3 + D8(this, 2); k9--;)
                        T(U);
                    break;
                case 17:
                    for (k9 = 3 + D8(this, 3); k9--;)
                        Z(0);
                    E(0);
                    break;
                case 18:
                    for (k9 = 11 + D8(this, 7); k9--;)
                        Y(0);
                    R(0);
                    break;
                default:
                    U = O[L9++] = V;
                }
            return O;
        }
        var t9 = D8(K9, 5) + 257,
            S9 = D8(K9, 5) + 1,
            j9 = D8(K9, 4) + 4,
            a9 = new (Z9 ? Uint8Array : Array)(e4.length),
            o9;
        for (o9 = 0; H8m.I8j(o9, j9); ++o9)
            a9[e4[o9]] = D8(K9, 3);
        j9 = R8(a9);
        a9 = new (Z9 ? Uint8Array : Array)(t9);
        o9 = new (Z9 ? Uint8Array : Array)(S9);
        K9.o(R8(c9.call(K9, t9, j9, a9)), R8(c9.call(K9, S9, j9, o9)));
    }
    var u4 = function() {
            N9 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
        },
        s4 = function() {
            N9 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
        };
    function D8(S, P) {
        var O = function() {
                S.g = H8m.S8j(T, P);
            },
            Z = function(X) {
                S.c = X;
            },
            Y = function() {
                S.e = H8m.i8j(R, P);
            };
        for (var T = S.g, R = S.e, E = S.input, V = S.c, U; H8m.P8j(R, P);)
            U = E[V++], H8m.a8j(U, e1) && b9(Error("input buffer is broken")), T |= H8m.O8j(U, R), R += 8;
        O();
        Y();
        Z(V);
        return H8m.B8j(T, (1 << P) - 1);
    }
    var W4 = function(X) {
        y9[N9] = X;
    };
    function M4(X, S) {
        this.length = X;
        this.G = S;
    }
    var z7 = function() {
        y9 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    };
    function P7() {
        var X = C8;
        switch (S1) {
        case H8m.k1p(3, X):
            return [257, H8m.L1p(X, 3), 0];
        case H8m.i1p(4, X):
            return [258, H8m.S1p(X, 4), 0];
        case H8m.P1p(5, X):
            return [259, H8m.a1p(X, 5), 0];
        case H8m.O1p(6, X):
            return [260, H8m.B1p(X, 6), 0];
        case H8m.Z1p(7, X):
            return [261, H8m.J1p(X, 7), 0];
        case H8m.n1p(8, X):
            return [262, H8m.G1p(X, 8), 0];
        case H8m.W1p(9, X):
            return [263, H8m.v1p(X, 9), 0];
        case H8m.u1p(10, X):
            return [264, H8m.H1p(X, 10), 0];
        case H8m.f1p(12, X):
            return [265, H8m.I1p(X, 11), 1];
        case H8m.g8p(14, X):
            return [266, H8m.K8p(X, 13), 1];
        case H8m.d8p(16, X):
            return [267, H8m.t8p(X, 15), 1];
        case H8m.w8p(18, X):
            return [268, H8m.e8p(X, 17), 1];
        case H8m.Q8p(22, X):
            return [269, H8m.r8p(X, 19), 2];
        case H8m.N8p(26, X):
            return [270, H8m.m8p(X, 23), 2];
        case H8m.A8p(30, X):
            return [271, H8m.E8p(X, 27), 2];
        case H8m.C8p(34, X):
            return [272, H8m.h8p(X, 31), 2];
        case H8m.y8p(42, X):
            return [273, H8m.q8p(X, 35), 3];
        case H8m.l8p(50, X):
            return [274, H8m.X4p(X, 43), 3];
        case H8m.D4p(58, X):
            return [275, H8m.c4p(X, 51), 3];
        case H8m.z4p(66, X):
            return [276, H8m.j4p(X, 59), 3];
        case H8m.x4p(82, X):
            return [277, H8m.o4p(X, 67), 4];
        case H8m.p4p(98, X):
            return [278, H8m.Y4p(X, 83), 4];
        case H8m.T4p(114, X):
            return [279, H8m.R4p(X, 99), 4];
        case H8m.M4p(130, X):
            return [280, H8m.V4p(X, 115), 4];
        case H8m.s4p(162, X):
            return [281, H8m.U4p(X, 131), 5];
        case H8m.b4p(194, X):
            return [282, H8m.F4p(X, 163), 5];
        case H8m.k7p(226, X):
            return [283, H8m.L7p(X, 195), 5];
        case H8m.i7p(257, X):
            return [284, H8m.S7p(X, 227), 5];
        case H8m.P7p(258, X):
            return [285, H8m.a7p(X, 258), 0];
        default:
            b9("invalid length: " + X);
        }
    }
    var w7 = function() {
            y9[N9] = H8m.e28(143, N9) ? 8 : H8m.Q28(255, N9) ? 9 : H8m.r28(279, N9) ? 7 : 8;
        },
        x7 = function() {
            N9[X1] = H8m.N28(143, X1) ? 8 : H8m.m28(255, X1) ? 9 : H8m.A28(279, X1) ? 7 : 8;
        },
        i7 = function(X) {
            N9 = X;
        },
        d7 = function() {
            y9 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        };
    function h8(S, P) {
        var O = function(X) {
                U = X[H8m.G8j(E, (1 << K9) - 1)];
            },
            Z = function() {
                L9 = H8m.n8j(U, 16);
            },
            Y = function() {
                S.g = H8m.J8j(E, L9);
            },
            T = function(X) {
                S.c = X;
            },
            R = function() {
                S.e = H8m.Z8j(V, L9);
            };
        for (var E = S.g, V = S.e, U = S.input, k9 = S.c, L9 = P[0], K9 = P[1], c9; H8m.W8j(V, K9);)
            c9 = U[k9++], H8m.v8j(c9, e1) && b9(Error("input buffer is broken")), E |= H8m.u8j(c9, V), V += 8;
        O(L9);
        Z();
        Y();
        R();
        T(k9);
        return H8m.H8j(U, 65535);
    }
    function N8(X, S) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = Z9 ? new Uint8Array(X) : X;
        this.s = !1;
        this.m = u8;
        this.B = !1;
        if (S || !(S = {}))
            S.index && (this.c = S.index), S.bufferSize && (this.l = S.bufferSize), S.bufferType && (this.m = S.bufferType), S.resize && (this.B = S.resize);
        switch (this.m) {
        case l8:
            this.b = 32768;
            this.a = new (Z9 ? Uint8Array : Array)(32768 + this.l + 258);
            break;
        case u8:
            this.b = 0;
            this.a = new (Z9 ? Uint8Array : Array)(this.l);
            this.f = this.J;
            this.t = this.H;
            this.o = this.I;
            break;
        default:
            b9(Error("invalid inflate mode"));
        }
    }
    function j4(P, O) {
        var Z = function(X) {
                A9[s9] = X;
            },
            Y = function(X) {
                a9[0] = X[0];
            },
            T = function(X) {
                a9 = X;
            };
        function R(X) {
            var S = F9[X][M9[X]];
            H8m.h2p(S, T9) ? (R(X + 1), R(X + 1)) : --A9[S];
            ++M9[X];
        }
        var E = function(X) {
                a9 = X;
            },
            V = function(X) {
                S9[a9] = X;
            },
            U = function(X) {
                j9 = X;
            },
            k9 = function(X) {
                a9[H8m.C2p(O, 1)] = X;
            },
            L9 = function(X) {
                S9[c9[a9].index] = X[a9];
            },
            K9 = function(X) {
                M9[s9] = X;
            },
            c9 = P.length,
            t9 = new b8(572),
            S9 = new (Z9 ? Uint8Array : Array)(c9),
            j9,
            a9,
            o9;
        if (!Z9)
            for (a9 = 0; H8m.y2p(a9, c9); a9++)
                V(0);
        for (a9 = 0; H8m.q2p(a9, c9); ++a9)
            H8m.l2p(0, P[a9]) && t9.push(a9, P[a9]);
        c9 = Array(H8m.X9j(t9.length, 2));
        j9 = new (Z9 ? Uint32Array : Array)(H8m.D9j(t9.length, 2));
        if (H8m.c9j(1, c9.length))
            return S9[t9.pop().index] = 1, S9;
        E(0);
        for (o9 = H8m.z9j(t9.length, 2); H8m.j9j(a9, o9); ++a9)
            c9[a9] = t9.pop(), j9[a9] = c9[a9].value;
        var T9 = j9.length;
        a9 = new (Z9 ? Uint16Array : Array)(O);
        var t9 = new (Z9 ? Uint8Array : Array)(O),
            A9 = new (Z9 ? Uint8Array : Array)(T9);
        o9 = Array(O);
        var F9 = Array(O),
            M9 = Array(O),
            s9 = H8m.x9j((1 << O), T9),
            C9 = H8m.o9j(1, O - 1),
            n9,
            t1,
            o1;
        k9(T9);
        for (n9 = 0; H8m.p9j(n9, O); ++n9)
            H8m.Y9j(s9, C9) ? t9[n9] = 0 : (t9[n9] = 1, s9 -= C9), s9 <<= 1, a9[H8m.T9j(O, 2, n9)] = (H8m.A9j(a9[O - 1 - n9] / 2, 0)) + T9;
        Y(t9);
        o9[0] = Array(a9[0]);
        F9[0] = Array(a9[0]);
        for (n9 = 1; H8m.E9j(n9, O); ++n9)
            H8m.C9j(a9[n9], 2 * a9[n9 - 1] + t9[n9]) && (a9[n9] = H8m.h9j(2, a9[n9 - 1]) + t9[n9]), o9[n9] = Array(a9[n9]), F9[n9] = Array(a9[n9]);
        for (s9 = 0; H8m.y9j(s9, T9); ++s9)
            Z(O);
        for (C9 = 0; H8m.q9j(C9, a9[O - 1]); ++C9)
            o9[H8m.l9j(O, 1)][C9] = j9[C9], F9[H8m.X1j(O, 1)][C9] = C9;
        for (s9 = 0; H8m.D1j(s9, O); ++s9)
            K9(0);
        H8m.c1j(1, t9[O - 1]) && (--A9[0], ++M9[H8m.z1j(O, 1)]);
        for (n9 = H8m.j1j(O, 2); H8m.x1j(0, n9); --n9) {
            var a1 = function(X) {
                    o1 = X[n9 + 1];
                },
                j1 = function(X) {
                    M9[n9] = X;
                };
            t1 = s9 = 0;
            a1(M9);
            for (C9 = 0; H8m.o1j(C9, a9[n9]); C9++)
                t1 = o9[n9 + 1][o1] + o9[n9 + 1][o1 + 1], H8m.p1j(t1, j9[s9]) ? (o9[n9][C9] = t1, F9[n9][C9] = T9, o1 += 2) : (o9[n9][C9] = j9[s9], F9[n9][C9] = s9, ++s9);
            j1(0);
            H8m.Y1j(1, t9[n9]) && R(n9);
        }
        U(A9);
        T(0);
        for (o9 = c9.length; H8m.T1j(a9, o9); ++a9)
            L9(j9);
        return S9;
    }
    var D7 = function(X) {
        N9[X1] = X;
    };
    function b9(X) {
        throw X;
    }
    var K7 = function(X) {
            X1 = X;
        },
        g7 = function() {
            y9 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        };
    function R8(S) {
        var P = function(X) {
                k9 = X;
            },
            O = function(X) {
                U = X;
            },
            Z = function() {
                E = H8m.x9p(1, T);
            },
            Y = S.length,
            T = 0,
            R = Number.POSITIVE_INFINITY,
            E,
            V,
            U,
            k9,
            L9,
            K9,
            c9,
            t9,
            S9;
        for (t9 = 0; H8m.o9p(t9, Y); ++t9)
            H8m.p9p(S[t9], T) && (T = S[t9]), H8m.Y9p(S[t9], R) && (R = S[t9]);
        Z();
        V = new (Z9 ? Uint32Array : Array)(E);
        O(1);
        P(0);
        for (L9 = 2; H8m.T9p(U, T);) {
            for (t9 = 0; H8m.R9p(t9, Y); ++t9)
                if (H8m.M9p(S[t9], U)) {
                    var j9 = function(X) {
                            c9 = X;
                        },
                        a9 = function(X) {
                            K9 = X;
                        },
                        o9 = function() {
                            V[S9] = H8m.V9p(U << 16, t9);
                        };
                    a9(0);
                    j9(k9);
                    for (S9 = 0; H8m.s9p(S9, U); ++S9)
                        K9 = H8m.U9p(K9 << 1, c9 & 1), c9 >>= 1;
                    for (S9 = K9; H8m.b9p(S9, E); S9 += L9)
                        o9();
                    ++k9;
                }
            ++U;
            k9 <<= 1;
            L9 <<= 1;
        }
        return [V, T, R];
    }
    var L7 = function(X) {
        N9 = X;
    };
    function P4(X, S) {
        var P,
            O;
        this.input = X;
        this.c = 0;
        if (S || !(S = {}))
            S.index && (this.c = S.index), S.verify && (this.M = S.verify);
        P = X[this.c++];
        O = X[this.c++];
        switch (H8m.g4j(P, 15)) {
        case V8:
            this.method = V8;
            break;
        default:
            b9(Error("unsupported compression method"));
        }
        H8m.K4j(0, ((P << 8) + O) % 31) && b9(Error("invalid fcheck flag:" + H8m.d4j(((P << 8) + O), 31)));
        H8m.t4j(O, 32) && b9(Error("fdict flag is not supported"));
        this.A = new N8(X, {
            index: this.c,
            bufferSize: S.bufferSize,
            bufferType: S.bufferType,
            resize: S.resize
        });
    }
    var G7 = function(X) {
            X1 = X;
        },
        R7 = function() {
            y9 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
        },
        m7 = function(X) {
            y9.BLOCK = X.D;
        };
    function W8(X, S) {
        this.index = "number" === typeof S ? S : 0;
        this.i = 0;
        this.buffer = H8m.D9p(X, (Z9 ? Uint8Array : Array)) ? X : new (Z9 ? Uint8Array : Array)(32768);
        H8m.c9p(2 * this.buffer.length, this.index) && b9(Error("invalid index"));
        H8m.z9p(this.buffer.length, this.index) && this.f();
    }
    function r4(X, S) {
        this.h = q8;
        this.w = 0;
        this.input = X;
        this.b = 0;
        S && (S.lazy && (this.w = S.lazy), "number" === typeof S.compressionType && (this.h = S.compressionType), S.outputBuffer && (this.a = Z9 && H8m.F9p(S.outputBuffer, Array) ? new Uint8Array(S.outputBuffer) : S.outputBuffer), "number" === typeof S.outputIndex && (this.b = S.outputIndex));
        this.a || (this.a = new (Z9 ? Uint8Array : Array)(32768));
    }
    var J7 = function() {
        N9 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    };
    function p4(e9, R1) {
        var m8 = function(X) {
                e9.L = X;
            },
            g8 = function(X) {
                Y8[256] = X;
            },
            t8 = function(X) {
                L1 = X;
            };
        function B1(S, P) {
            var O = function() {
                    u9 = [17, H8m.g0p(B9, 385), 7];
                },
                Z = function() {
                    u9 = [8, H8m.m0p(B9, 17), 3];
                },
                Y = function(X) {
                    B9 = X;
                },
                T = function() {
                    u9 = [26, H8m.J7p(B9, 8193), 12];
                },
                R = function() {
                    u9 = [5, H8m.C0p(B9, 7), 1];
                },
                E = function() {
                    u9 = [11, H8m.Q0p(B9, 49), 4];
                },
                V = function() {
                    u9 = [23, H8m.W7p(B9, 3073), 10];
                },
                U = function() {
                    u9 = [1, H8m.l0p(B9, 2), 0];
                },
                k9 = function() {
                    u9 = [0, H8m.X3p(B9, 1), 0];
                },
                L9 = function() {
                    u9 = [18, H8m.I7p(B9, 513), 8];
                },
                K9 = function() {
                    u9 = [21, H8m.u7p(B9, 1537), 9];
                },
                c9 = function() {
                    l1[O8++] = H8m.c3p(o8 >> 16, 255);
                },
                t9 = function() {
                    u9 = [14, H8m.t0p(B9, 129), 6];
                },
                S9 = function() {
                    u9 = [13, H8m.w0p(B9, 97), 5];
                },
                j9 = function() {
                    u9 = [4, H8m.h0p(B9, 5), 1];
                },
                a9 = function() {
                    u9 = [10, H8m.r0p(B9, 33), 4];
                },
                o9 = function() {
                    Q4 = S.length + P - 1;
                },
                T9 = function(X) {
                    l1[O8++] = X[0];
                },
                A9 = function() {
                    u9 = [2, H8m.q0p(B9, 3), 0];
                },
                F9 = function(X) {
                    l1[O8++] = X[1];
                },
                M9 = function() {
                    l1[O8++] = H8m.D3p(o8, 24);
                },
                s9 = function(X) {
                    l1[O8++] = X[2];
                },
                C9 = function() {
                    u9 = [3, H8m.y0p(B9, 4), 0];
                },
                n9 = function() {
                    u9 = [16, H8m.K0p(B9, 257), 7];
                },
                t1 = function() {
                    u9 = [9, H8m.N0p(B9, 25), 3];
                },
                o1 = function(X) {
                    o8 = X[S.length];
                },
                a1 = function() {
                    u9 = [20, H8m.H7p(B9, 1025), 9];
                },
                j1 = function(X) {
                    n8[E8++] = X[B9];
                },
                T1 = function() {
                    u9 = [6, H8m.E0p(B9, 9), 2];
                },
                e8 = function() {
                    u9 = [29, H8m.O7p(B9, 24577), 13];
                },
                y1 = function(X) {
                    o8 = X;
                },
                s8 = function() {
                    u9 = [22, H8m.v7p(B9, 2049), 10];
                },
                I8 = function() {
                    u9 = [15, H8m.d0p(B9, 193), 6];
                },
                L4 = function() {
                    u9 = [7, H8m.A0p(B9, 13), 2];
                },
                g4 = function() {
                    u9 = [19, H8m.f7p(B9, 769), 8];
                },
                X4 = function() {
                    u9 = [25, H8m.n7p(B9, 6145), 11];
                },
                k4 = function() {
                    l1[O8++] = H8m.z3p(o8, 65535);
                },
                c4 = function() {
                    u9 = [12, H8m.e0p(B9, 65), 5];
                },
                i4 = function(X) {
                    Q8 = X;
                },
                K4 = function() {
                    u9 = [28, H8m.B7p(B9, 16385), 13];
                },
                D4 = function() {
                    u9 = [24, H8m.G7p(B9, 4097), 11];
                },
                d4 = function() {
                    u9 = [27, H8m.Z7p(B9, 12289), 12];
                },
                B9 = S.G,
                l1 = [],
                O8 = 0,
                o8;
            o1(J4);
            k4();
            c9();
            M9();
            var u9;
            switch (S1) {
            case H8m.j3p(1, B9):
                k9();
                break;
            case H8m.x3p(2, B9):
                U();
                break;
            case H8m.o3p(3, B9):
                A9();
                break;
            case H8m.p3p(4, B9):
                C9();
                break;
            case H8m.Y3p(6, B9):
                j9();
                break;
            case H8m.T3p(8, B9):
                R();
                break;
            case H8m.R3p(12, B9):
                T1();
                break;
            case H8m.M3p(16, B9):
                L4();
                break;
            case H8m.V3p(24, B9):
                Z();
                break;
            case H8m.s3p(32, B9):
                t1();
                break;
            case H8m.U3p(48, B9):
                a9();
                break;
            case H8m.b3p(64, B9):
                E();
                break;
            case H8m.F3p(96, B9):
                c4();
                break;
            case H8m.k5p(128, B9):
                S9();
                break;
            case H8m.L5p(192, B9):
                t9();
                break;
            case H8m.i5p(256, B9):
                I8();
                break;
            case H8m.S5p(384, B9):
                n9();
                break;
            case H8m.P5p(512, B9):
                O();
                break;
            case H8m.a5p(768, B9):
                L9();
                break;
            case H8m.O5p(1024, B9):
                g4();
                break;
            case H8m.B5p(1536, B9):
                a1();
                break;
            case H8m.Z5p(2048, B9):
                K9();
                break;
            case H8m.J5p(3072, B9):
                s8();
                break;
            case H8m.n5p(4096, B9):
                V();
                break;
            case H8m.G5p(6144, B9):
                D4();
                break;
            case H8m.W5p(8192, B9):
                X4();
                break;
            case H8m.v5p(12288, B9):
                T();
                break;
            case H8m.u5p(16384, B9):
                d4();
                break;
            case H8m.H5p(24576, B9):
                K4();
                break;
            case H8m.f5p(32768, B9):
                e8();
                break;
            default:
                b9("invalid distance");
            }
            y1(u9);
            T9(o8);
            F9(o8);
            s9(o8);
            Y(0);
            for (O8 = l1.length; H8m.I5p(B9, O8); ++B9)
                j1(l1);
            Y8[l1[0]]++;
            z4[l1[3]]++;
            o9();
            i4(null);
        }
        var a8 = function(X) {
                n8[E8++] = X;
            },
            K1 = function(X) {
                e9.K = X;
            },
            L1,
            M1,
            I9,
            Z1,
            j8,
            S4 = {},
            Q8,
            n8 = Z9 ? new Uint16Array(H8m.g6p(2, R1.length)) : [],
            E8 = 0,
            Q4 = 0,
            Y8 = new (Z9 ? Uint32Array : Array)(286),
            z4 = new (Z9 ? Uint32Array : Array)(30),
            G4 = e9.w,
            B8;
        if (!Z9) {
            var n4 = function(X) {
                    z4[I9++] = X;
                },
                R4 = function(X) {
                    Y8[I9++] = X;
                };
            for (I9 = 0; H8m.K6p(285, I9);)
                R4(0);
            for (I9 = 0; H8m.d6p(29, I9);)
                n4(0);
        }
        g8(1);
        t8(0);
        for (M1 = R1.length; H8m.t6p(L1, M1); ++L1) {
            var T4 = function() {
                    j8 = H8m.w6p(j8 << 8, R1[L1 + I9]);
                },
                m4 = function(X) {
                    I9 = X[j8];
                };
            I9 = j8 = 0;
            for (Z1 = 3; H8m.e6p(I9, Z1) && H8m.Q6p(L1 + I9, M1); ++I9)
                T4();
            H8m.r6p(S4[j8], e1) && (S4[j8] = []);
            m4(S4);
            if (!(H8m.N6p(0, Q4--))) {
                for (; H8m.m6p(0, I9.length) && H8m.A6p(32768, L1 - I9[0]);)
                    I9.shift();
                if (H8m.E6p(L1 + 3, M1)) {
                    var A4 = function(X) {
                        I9 = X;
                    };
                    Q8 && B1(Q8, -1);
                    A4(0);
                    for (Z1 = H8m.C6p(M1, L1); H8m.h6p(I9, Z1); ++I9)
                        B8 = R1[L1 + I9], n8[E8++] = B8, ++Y8[B8];
                    break;
                }
                if (H8m.y6p(0, I9.length)) {
                    j8 = Z1 = e1;
                    var M8 = 0,
                        N1 = e1,
                        H8 = e1,
                        t4 = N1 = e1,
                        I4 = R1.length,
                        H8 = 0,
                        t4 = I9.length;
                    a:
                    for (; H8m.q6p(H8, t4); H8++) {
                        var X7 = function(X) {
                                Z1 = X[H8m.l6p(t4, H8, 1)];
                            },
                            k7 = function(X) {
                                N1 = X;
                            };
                        X7(I9);
                        k7(3);
                        if (H8m.g2p(3, M8)) {
                            var b4 = function(X) {
                                N1 = X;
                            };
                            for (N1 = M8; H8m.K2p(3, N1); N1--)
                                if (H8m.d2p(R1[Z1 + N1 - 1], R1[L1 + N1 - 1]))
                                    continue a;
                            b4(M8);
                        }
                        for (; H8m.t2p(258, N1) && H8m.w2p(L1 + N1, I4) && H8m.e2p(R1[Z1 + N1], R1[L1 + N1]);)
                            ++N1;
                        H8m.Q2p(N1, M8) && (j8 = Z1, M8 = N1);
                        if (H8m.r2p(258, N1))
                            break;
                    }
                    Z1 = new M4(M8, H8m.N2p(L1, j8));
                    Q8 ? H8m.m2p(Q8.length, Z1.length) ? (B8 = R1[H8m.A2p(L1, 1)], n8[E8++] = B8, ++Y8[B8], B1(Z1, 0)) : B1(Q8, -1) : H8m.E2p(Z1.length, G4) ? Q8 = Z1 : B1(Z1, 0);
                } else
                    Q8 ? B1(Q8, -1) : (B8 = R1[L1], n8[E8++] = B8, ++Y8[B8]);
            }
            I9.push(L1);
        }
        a8(256);
        Y8[256]++;
        m8(Y8);
        K1(z4);
        return Z9 ? n8.subarray(0, E8) : n8;
    }
    var Y7 = function() {
        N9 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    };
    function a4(S) {
        var P = function(X) {
                U = X;
            },
            O = function(X) {
                U = X;
            },
            Z = function(X) {
                U = X;
            },
            Y = function() {
                R[S[U]] = (H8m.R1j(R[S[U]], 0)) + 1;
            },
            T = new (Z9 ? Uint16Array : Array)(S.length),
            R = [],
            E = [],
            V = 0,
            U,
            k9,
            L9;
        O(0);
        for (k9 = S.length; H8m.M1j(U, k9); U++)
            Y();
        Z(1);
        for (k9 = 16; H8m.V1j(U, k9); U++)
            E[U] = V, V += H8m.s1j(R[U], 0), H8m.U1j(V, 1 << U) && b9("overcommitted"), V <<= 1;
        H8m.b1j(65536, V) && b9("undercommitted");
        P(0);
        for (k9 = S.length; H8m.F1j(U, k9); U++)
            for (V = E[S[U]], E[S[U]] += 1, R = T[U] = 0, L9 = S[U]; H8m.k8j(R, L9); R++)
                T[U] = H8m.L8j(T[U] << 1, V & 1), V >>>= 1;
        return T;
    }
    function w4(S, P) {
        var O = function(X) {
            Z[Y] = X[Y];
        };
        this.input = S;
        this.a = new (Z9 ? Uint8Array : Array)(32768);
        this.h = Z8.j;
        var Z = {},
            Y;
        !P && (P = {}) || "number" !== typeof P.compressionType || (this.h = P.compressionType);
        for (Y in P)
            O(P);
        Z.outputBuffer = this.a;
        this.z = new r4(this.input, Z);
    }
    var r7 = function(X) {
        y9.ADAPTIVE = X.C;
    };
    function p8(X, S) {
        var P = X.split("."),
            O = O7;
        H8m.E28(P[0], O) || !O.execScript || O.execScript("var " + P[0]);
        for (var Z; P.length && (Z = P.shift());)
            P.length || H8m.C28(S, e1) ? O = O[Z] ? O[Z] : O[Z] = {} : O[Z] = S;
    }
    var B7 = function() {
            N9 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        },
        e1 = void 0,
        S1 = !0,
        O7 = this,
        Z9 = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    W8.prototype.f = function() {
        var X = this.buffer,
            S,
            P = X.length,
            O = new (Z9 ? Uint8Array : Array)(H8m.w4j(P, 1));
        if (Z9)
            O.set(X);
        else
            for (S = 0; H8m.e4j(S, P); ++S)
                O[S] = X[S];
        return this.buffer = O;
    };
    W8.prototype.d = function(X, S, P) {
        var O = this.buffer,
            Z = this.index,
            Y = this.i,
            T = O[Z];
        P && H8m.Q4j(1, S) && (X = H8m.r4j(8, S) ? H8m.N4j((A8[X & 255] << 24 | A8[X >>> 8 & 255] << 16 | A8[X >>> 16 & 255] << 8 | A8[X >>> 24 & 255]), 32 - S) : H8m.m4j(A8[X], 8 - S));
        if (H8m.A4j(8, S + Y))
            T = H8m.E4j(T << S, X), Y += S;
        else
            for (P = 0; H8m.C4j(P, S); ++P)
                T = H8m.h4j(T << 1, X >> S - P - 1 & 1), 8 === ++Y && (Y = 0, O[Z++] = A8[T], T = 0, H8m.y4j(Z, O.length) && (O = this.f()));
        O[Z] = T;
        this.buffer = O;
        this.i = Y;
        this.index = Z;
    };
    W8.prototype.finish = function() {
        var X = this.buffer,
            S = this.index,
            P;
        H8m.q4j(0, this.i) && (X[S] <<= H8m.l4j(8, this.i), X[S] = A8[X[S]], S++);
        Z9 ? P = X.subarray(0, S) : (X.length = S, P = X);
        return P;
    };
    var y9 = new (Z9 ? Uint8Array : Array)(256),
        N9;
    for (N9 = 0; H8m.X7j(256, N9); ++N9) {
        var E7 = function() {
            y9[N9] = H8m.D7j((G8 << Z4 & 255), 0);
        };
        for (var X1 = N9, G8 = X1, Z4 = 7, X1 = H8m.c7j(X1, 1); X1; X1 >>>= 1)
            G8 <<= 1, G8 |= H8m.z7j(X1, 1), --Z4;
        E7();
    }
    var A8 = y9,
        y9 = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    Z9 && new Uint32Array(y9);
    b8.prototype.getParent = function(X) {
        return H8m.j7j(2, ((X - 2) / 4 | 0));
    };
    b8.prototype.push = function(X, S) {
        var P,
            O,
            Z = this.buffer,
            Y;
        P = this.length;
        Z[this.length++] = S;
        for (Z[this.length++] = X; H8m.x7j(0, P);)
            if (O = this.getParent(P), H8m.o7j(Z[P], Z[O]))
                Y = Z[P], Z[P] = Z[O], Z[O] = Y, Y = Z[P + 1], Z[P + 1] = Z[O + 1], Z[O + 1] = Y, P = O;
            else
                break;
        return this.length;
    };
    b8.prototype.pop = function() {
        var X,
            S,
            P = this.buffer,
            O,
            Z,
            Y;
        S = P[0];
        X = P[1];
        this.length -= 2;
        P[0] = P[this.length];
        P[1] = P[this.length + 1];
        for (Y = 0;;) {
            Z = H8m.p7j(2, Y) + 2;
            if (H8m.Y7j(Z, this.length))
                break;
            H8m.T7j(Z + 2, this.length) && H8m.R7j(P[Z + 2], P[Z]) && (Z += 2);
            if (H8m.M7j(P[Z], P[Y]))
                O = P[Y], P[Y] = P[Z], P[Z] = O, O = P[Y + 1], P[Y + 1] = P[Z + 1], P[Z + 1] = O;
            else
                break;
            Y = Z;
        }
        return {
            index: X,
            value: S,
            length: this.length
        };
    };
    var q8 = 2,
        y9 = {
            NONE: 0,
            r: 1,
            j: q8,
            N: 3
        },
        v8 = [];
    for (N9 = 0; H8m.V7j(288, N9); N9++)
        switch (S1) {
        case H8m.s7j(143, N9):
            v8.push([N9 + 48, 8]);
            break;
        case H8m.U7j(255, N9):
            v8.push([H8m.b7j(N9, 144, 400), 9]);
            break;
        case H8m.l7j(279, N9):
            v8.push([H8m.X0j(N9, 256, 0), 7]);
            break;
        case H8m.K0j(287, N9):
            v8.push([H8m.d0j(N9, 280, 192), 8]);
            break;
        default:
            b9("invalid literal: " + N9);
        }
    r4.prototype.n = function() {
        var X,
            S,
            P,
            O,
            Z = this.input;
        switch (this.h) {
        case 0:
            P = 0;
            for (O = Z.length; H8m.P0j(P, O);) {
                S = Z9 ? Z.subarray(P, P + 65535) : Z.slice(P, P + 65535);
                P += S.length;
                var Y = H8m.a0j(P, O),
                    T = e1,
                    R = T = e1,
                    R = T = e1,
                    E = this.a,
                    V = this.b;
                if (Z9) {
                    for (E = new Uint8Array(this.a.buffer); H8m.O0j(E.length, V + S.length + 5);)
                        E = new Uint8Array(H8m.B0j(E.length, 1));
                    E.set(this.a);
                }
                T = Y ? 1 : 0;
                E[V++] = H8m.Z0j(T, 0);
                T = S.length;
                R = ~T + 65536 & 65535;
                E[V++] = H8m.J0j(T, 255);
                E[V++] = H8m.n0j(T >>> 8, 255);
                E[V++] = H8m.G0j(R, 255);
                E[V++] = H8m.W0j(R >>> 8, 255);
                if (Z9)
                    E.set(S, V), V += S.length, E = E.subarray(0, V);
                else {
                    T = 0;
                    for (R = S.length; H8m.v0j(T, R); ++T)
                        E[V++] = S[T];
                    E.length = V;
                }
                this.b = V;
                this.a = E;
            }
            break;
        case 1:
            P = new W8(new Uint8Array(this.a.buffer), this.b);
            P.d(1, 1, S1);
            P.d(1, 2, S1);
            Z = p4(this, Z);
            S = 0;
            for (Y = Z.length; H8m.u0j(S, Y); S++)
                if (O = Z[S], W8.prototype.d.apply(P, v8[O]), H8m.H0j(256, O))
                    P.d(Z[++S], Z[++S], S1), P.d(Z[++S], 5), P.d(Z[++S], Z[++S], S1);
                else if (H8m.f0j(256, O))
                    break;
            this.a = P.finish();
            this.b = this.a.length;
            break;
        case q8:
            O = new W8(new Uint8Array(this.a), this.b);
            var U,
                k9,
                L9,
                K9 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                c9,
                t9,
                T = Array(19),
                S9,
                E = q8;
            O.d(1, 1, S1);
            O.d(E, 2, S1);
            Z = p4(this, Z);
            R = j4(this.L, 15);
            c9 = a4(R);
            E = j4(this.K, 7);
            V = a4(E);
            for (U = 286; H8m.I0j(257, U) && H8m.g3j(0, R[U - 1]); U--)
                ;
            for (k9 = 30; H8m.K3j(1, k9) && H8m.d3j(0, E[k9 - 1]); k9--)
                ;
            var j9 = U,
                a9 = k9;
            X = new (Z9 ? Uint32Array : Array)(j9 + a9);
            var o9 = new (Z9 ? Uint32Array : Array)(316),
                T9,
                A9;
            t9 = new (Z9 ? Uint8Array : Array)(19);
            for (S9 = L9 = 0; H8m.t3j(S9, j9); S9++)
                X[L9++] = R[S9];
            for (S9 = 0; H8m.w3j(S9, a9); S9++)
                X[L9++] = E[S9];
            if (!Z9)
                for (S9 = 0, a9 = t9.length; H8m.e3j(S9, a9); ++S9)
                    t9[S9] = 0;
            S9 = T9 = 0;
            for (a9 = X.length; H8m.Q3j(S9, a9); S9 += L9) {
                for (L9 = 1; H8m.r3j(S9 + L9, a9) && H8m.N3j(X[S9 + L9], X[S9]); ++L9)
                    ;
                j9 = L9;
                if (H8m.m3j(0, X[S9]))
                    if (H8m.A3j(3, j9))
                        for (; H8m.E3j(0, j9--);)
                            o9[T9++] = 0, t9[0]++;
                    else
                        for (; H8m.C3j(0, j9);)
                            A9 = H8m.h3j(138, j9) ? j9 : 138, H8m.y3j(A9, j9 - 3) && H8m.q3j(A9, j9) && (A9 = H8m.l3j(j9, 3)), H8m.X5j(10, A9) ? (o9[T9++] = 17, o9[T9++] = H8m.D5j(A9, 3), t9[17]++) : (o9[T9++] = 18, o9[T9++] = H8m.c5j(A9, 11), t9[18]++), j9 -= A9;
                else if (o9[T9++] = X[S9], t9[X[S9]]++, j9--, H8m.z5j(3, j9))
                    for (; H8m.j5j(0, j9--);)
                        o9[T9++] = X[S9], t9[X[S9]]++;
                else
                    for (; H8m.x5j(0, j9);)
                        A9 = H8m.o5j(6, j9) ? j9 : 6, H8m.p5j(A9, j9 - 3) && H8m.Y5j(A9, j9) && (A9 = H8m.T5j(j9, 3)), o9[T9++] = 16, o9[T9++] = H8m.R5j(A9, 3), t9[16]++, j9 -= A9;
            }
            X = Z9 ? o9.subarray(0, T9) : o9.slice(0, T9);
            t9 = j4(t9, 7);
            for (S9 = 0; H8m.M5j(19, S9); S9++)
                T[S9] = t9[K9[S9]];
            for (L9 = 19; H8m.V5j(4, L9) && H8m.s5j(0, T[L9 - 1]); L9--)
                ;
            K9 = a4(t9);
            O.d(H8m.U5j(U, 257), 5, S1);
            O.d(H8m.b5j(k9, 1), 5, S1);
            O.d(H8m.F5j(L9, 4), 4, S1);
            for (S9 = 0; H8m.k6j(S9, L9); S9++)
                O.d(T[S9], 3, S1);
            S9 = 0;
            for (T = X.length; H8m.L6j(S9, T); S9++)
                if (S = X[S9], O.d(K9[S], t9[S], S1), H8m.i6j(16, S)) {
                    S9++;
                    switch (S) {
                    case 16:
                        Y = 2;
                        break;
                    case 17:
                        Y = 3;
                        break;
                    case 18:
                        Y = 7;
                        break;
                    default:
                        b9("invalid code: " + S);
                    }
                    O.d(X[S9], Y, S1);
                }
            Y = [c9, R];
            V = [V, E];
            S = Y[0];
            Y = Y[1];
            E = V[0];
            c9 = V[1];
            V = 0;
            for (T = Z.length; H8m.S6j(V, T); ++V)
                if (P = Z[V], O.d(S[P], Y[P], S1), H8m.P6j(256, P))
                    O.d(Z[++V], Z[++V], S1), R = Z[++V], O.d(E[R], c9[R], S1), O.d(Z[++V], Z[++V], S1);
                else if (H8m.a6j(256, P))
                    break;
            this.a = O.finish();
            this.b = this.a.length;
            break;
        default:
            b9("invalid compression type");
        }
        return this.a;
    };
    F4();
    var C8;
    for (C8 = 3; H8m.O6j(258, C8); C8++)
        X1 = P7(), N9[C8] = H8m.B6j(X1[2] << 24, X1[1] << 16, X1[0]);
    var J4 = Z9 ? new Uint32Array(N9) : N9,
        Z8 = y9;
    w4.prototype.n = function() {
        var X,
            S,
            P,
            O,
            Z = 0;
        O = this.a;
        X = V8;
        switch (X) {
        case V8:
            S = H8m.Y6j(Math.LOG2E * Math.log(32768), 8);
            break;
        default:
            b9(Error("invalid compression method"));
        }
        S = H8m.T6j(S << 4, X);
        O[Z++] = S;
        switch (X) {
        case V8:
            switch (this.h) {
            case Z8.NONE:
                P = 0;
                break;
            case Z8.r:
                P = 1;
                break;
            case Z8.j:
                P = 2;
                break;
            default:
                b9(Error("unsupported compression type"));
            }
            break;
        default:
            b9(Error("invalid compression method"));
        }
        X = H8m.R6j(P << 6, 0);
        O[Z++] = H8m.M6j(X, 31 - (256 * S + X) % 31);
        X = B4(this.input);
        this.z.b = Z;
        O = this.z.n();
        Z = O.length;
        Z9 && (O = new Uint8Array(O.buffer), H8m.V6j(O.length, Z + 4) && (this.a = new Uint8Array(O.length + 4), this.a.set(O), O = this.a), O = O.subarray(0, Z + 4));
        O[Z++] = H8m.s6j(X >> 24, 255);
        O[Z++] = H8m.U6j(X >> 16, 255);
        O[Z++] = H8m.b6j(X >> 8, 255);
        O[Z++] = H8m.F6j(X, 255);
        return O;
    };
    p8("Zlib.Deflate", w4);
    p8("Zlib.Deflate.compress", function(X, S) {
        return (new w4(X, S)).n();
    });
    p8("Zlib.Deflate.CompressionType", Z8);
    p8("Zlib.Deflate.CompressionType.NONE", Z8.NONE);
    p8("Zlib.Deflate.CompressionType.FIXED", Z8.r);
    p8("Zlib.Deflate.CompressionType.DYNAMIC", Z8.j);
    var l8 = 0,
        u8 = 1,
        y9 = {
            D: l8,
            C: u8
        };
    N8.prototype.p = function() {
        for (; !this.s;) {
            var X = D8(this, 3);
            H8m.k2j(X, 1) && (this.s = S1);
            X >>>= 1;
            switch (X) {
            case 0:
                var X = this.input,
                    S = this.c,
                    P = this.a,
                    O = this.b,
                    Z = e1,
                    Y = e1,
                    T = e1,
                    R = P.length,
                    Z = e1;
                this.e = this.g = 0;
                Z = X[S++];
                H8m.L2j(Z, e1) && b9(Error("invalid uncompressed block header: LEN (first byte)"));
                Y = Z;
                Z = X[S++];
                H8m.i2j(Z, e1) && b9(Error("invalid uncompressed block header: LEN (second byte)"));
                Y |= H8m.S2j(Z, 8);
                Z = X[S++];
                H8m.P2j(Z, e1) && b9(Error("invalid uncompressed block header: NLEN (first byte)"));
                T = Z;
                Z = X[S++];
                H8m.a2j(Z, e1) && b9(Error("invalid uncompressed block header: NLEN (second byte)"));
                T |= H8m.O2j(Z, 8);
                Y === ~T && b9(Error("invalid uncompressed block header: length verify"));
                H8m.B2j(S + Y, X.length) && b9(Error("input buffer is broken"));
                switch (this.m) {
                case l8:
                    for (; H8m.Z2j(O + Y, P.length);) {
                        Z = H8m.J2j(R, O);
                        Y -= Z;
                        if (Z9)
                            P.set(X.subarray(S, S + Z), O), O += Z, S += Z;
                        else
                            for (; Z--;)
                                P[O++] = X[S++];
                        this.b = O;
                        P = this.f();
                        O = this.b;
                    }
                    break;
                case u8:
                    for (; H8m.n2j(O + Y, P.length);)
                        P = this.f({
                            v: 2
                        });
                    break;
                default:
                    b9(Error("invalid inflate mode"));
                }
                if (Z9)
                    P.set(X.subarray(S, S + Y), O), O += Y, S += Y;
                else
                    for (; Y--;)
                        P[O++] = X[S++];
                this.c = S;
                this.b = O;
                this.a = P;
                break;
            case 1:
                this.o(N4, Y4);
                break;
            case 2:
                C4(this);
                break;
            default:
                b9(Error("unknown BTYPE: " + X));
            }
        }
        return this.t();
    };
    B7();
    var e4 = Z9 ? new Uint16Array(N9) : N9;
    s4();
    var O4 = Z9 ? new Uint16Array(N9) : N9;
    u4();
    var U8 = Z9 ? new Uint8Array(N9) : N9;
    Y7();
    var o4 = Z9 ? new Uint16Array(N9) : N9;
    J7();
    var y8 = Z9 ? new Uint8Array(N9) : N9;
    N9 = new (Z9 ? Uint8Array : Array)(288);
    K7(0);
    for (G8 = N9.length; H8m.G2j(X1, G8); ++X1)
        x7();
    var N4 = R8(N9);
    N9 = new (Z9 ? Uint8Array : Array)(30);
    G7(0);
    for (G8 = N9.length; H8m.W2j(X1, G8); ++X1)
        D7(5);
    var Y4 = R8(N9);
    N8.prototype.o = function(X, S) {
        var P = this.a,
            O = this.b;
        this.u = X;
        for (var Z = H8m.v2j(P.length, 258), Y, T, R; H8m.u2j(256, (Y = h8(this, X)));)
            if (H8m.H2j(256, Y))
                H8m.f2j(O, Z) && (this.b = O, P = this.f(), O = this.b), P[O++] = Y;
            else
                for (Y -= 257, R = O4[Y], H8m.I2j(0, U8[Y]) && (R += D8(this, U8[Y])), Y = h8(this, S), T = o4[Y], H8m.g9l(0, y8[Y]) && (T += D8(this, y8[Y])), H8m.K9l(O, Z) && (this.b = O, P = this.f(), O = this.b); R--;)
                    P[O] = P[H8m.d9l(O++, T)];
        for (; H8m.t9l(8, this.e);)
            this.e -= 8, this.c--;
        this.b = O;
    };
    N8.prototype.I = function(X, S) {
        var P = this.a,
            O = this.b;
        this.u = X;
        for (var Z = P.length, Y, T, R; H8m.w9l(256, (Y = h8(this, X)));)
            if (H8m.e9l(256, Y))
                H8m.Q9l(O, Z) && (P = this.f(), Z = P.length), P[O++] = Y;
            else
                for (Y -= 257, R = O4[Y], H8m.r9l(0, U8[Y]) && (R += D8(this, U8[Y])), Y = h8(this, S), T = o4[Y], H8m.N9l(0, y8[Y]) && (T += D8(this, y8[Y])), H8m.m9l(O + R, Z) && (P = this.f(), Z = P.length); R--;)
                    P[O] = P[H8m.A9l(O++, T)];
        for (; H8m.E9l(8, this.e);)
            this.e -= 8, this.c--;
        this.b = O;
    };
    N8.prototype.f = function() {
        var X = new (Z9 ? Uint8Array : Array)(H8m.C9l(this.b, 32768)),
            S = H8m.h9l(this.b, 32768),
            P,
            O,
            Z = this.a;
        if (Z9)
            X.set(Z.subarray(32768, X.length));
        else
            for (P = 0, O = X.length; H8m.y9l(P, O); ++P)
                X[P] = Z[P + 32768];
        this.k.push(X);
        this.q += X.length;
        if (Z9)
            Z.set(Z.subarray(S, S + 32768));
        else
            for (P = 0; H8m.q9l(32768, P); ++P)
                Z[P] = Z[S + P];
        this.b = 32768;
        return Z;
    };
    N8.prototype.J = function(X) {
        var S,
            P = H8m.l9l(this.input.length / this.c + 1, 0),
            O,
            Z,
            Y,
            T = this.input,
            R = this.a;
        X && ("number" === typeof X.v && (P = X.v), "number" === typeof X.F && (P += X.F));
        H8m.X1l(2, P) ? (O = H8m.D1l((T.length - this.c), this.u[2]), Y = H8m.c1l(O / 2 * 258, 0), Z = H8m.z1l(Y, R.length) ? R.length + Y : H8m.j1l(R.length, 1)) : Z = H8m.x1l(R.length, P);
        Z9 ? (S = new Uint8Array(Z), S.set(R)) : S = R;
        return this.a = S;
    };
    N8.prototype.t = function() {
        var X = 0,
            S = this.a,
            P = this.k,
            O,
            Z = new (Z9 ? Uint8Array : Array)(this.q + (H8m.o1l(this.b, 32768))),
            Y,
            T,
            R,
            E;
        if (H8m.p1l(0, P.length))
            return Z9 ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        Y = 0;
        for (T = P.length; H8m.Y1l(Y, T); ++Y)
            for (O = P[Y], R = 0, E = O.length; H8m.T1l(R, E); ++R)
                Z[X++] = O[R];
        Y = 32768;
        for (T = this.b; H8m.R1l(Y, T); ++Y)
            Z[X++] = S[Y];
        this.k = [];
        return this.buffer = Z;
    };
    N8.prototype.H = function() {
        var X,
            S = this.b;
        Z9 ? this.B ? (X = new Uint8Array(S), X.set(this.a.subarray(0, S))) : X = this.a.subarray(0, S) : (H8m.M1l(this.a.length, S) && (this.a.length = S), X = this.a);
        return this.buffer = X;
    };
    P4.prototype.p = function() {
        var X = this.input,
            S,
            P;
        S = this.A.p();
        this.c = this.A.c;
        this.M && (P = H8m.V1l((X[this.c++] << 24 | X[this.c++] << 16 | X[this.c++] << 8 | X[this.c++]), 0), H8m.s1l(P, B4(S)) && b9(Error("invalid adler-32 checksum")));
        return S;
    };
    p8("Zlib.Inflate", P4);
    p8("Zlib.Inflate.BufferType", y9);
    r7(y9);
    m7(y9);
    p8("Zlib.Inflate.prototype.decompress", P4.prototype.p);
    d7();
    Z9 && new Uint16Array(y9);
    y4();
    Z9 && new Uint16Array(y9);
    z7();
    Z9 && new Uint8Array(y9);
    R7();
    Z9 && new Uint16Array(y9);
    g7();
    Z9 && new Uint8Array(y9);
    y9 = new (Z9 ? Uint8Array : Array)(288);
    L7(0);
    for (X1 = y9.length; H8m.U1l(N9, X1); ++N9)
        w7();
    R8(y9);
    y9 = new (Z9 ? Uint8Array : Array)(30);
    i7(0);
    for (X1 = y9.length; H8m.b1l(N9, X1); ++N9)
        W4(5);
    R8(y9);
    var V8 = 8;
}).call(this);
H8m.Z3y(window);
_p = _p.Zlib = _p.Zlib;
H8m.N3y(_p);
H8m.T3y(_p);
H8m.n3y(_p);
H8m.A3y(_p);
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
delete w6b0K[q0K]._p;
cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var X,
            S,
            P,
            O;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (P = null;;) {
            X = this.readUInt32();
            O = a = void 0;
            O = [];
            for (a = 0; H8m.F1l(4, a); ++a)
                O.push(String.fromCharCode(this.data[this.pos++]));
            a = O.join("");
            switch (a) {
            case "IHDR":
                this.width = this.readUInt32();
                this.height = this.readUInt32();
                this.bits = this.data[this.pos++];
                this.colorType = this.data[this.pos++];
                this.compressionMethod = this.data[this.pos++];
                this.filterMethod = this.data[this.pos++];
                this.interlaceMethod = this.data[this.pos++];
                break;
            case "acTL":
                this.animation = {
                    numFrames: this.readUInt32(),
                    numPlays: this.readUInt32() || Infinity,
                    frames: []
                };
                break;
            case "PLTE":
                this.palette = this.read(X);
                break;
            case "fcTL":
                P && this.animation.frames.push(P);
                this.pos += 4;
                P = {
                    width: this.readUInt32(),
                    height: this.readUInt32(),
                    xOffset: this.readUInt32(),
                    yOffset: this.readUInt32()
                };
                a = this.readUInt16();
                X = this.readUInt16() || 100;
                P.delay = H8m.k8l(1E3, a, X);
                P.disposeOp = this.data[this.pos++];
                P.blendOp = this.data[this.pos++];
                P.data = [];
                break;
            case "IDAT":
            case "fdAT":
                H8m.D8l("fdAT", a) && (this.pos += 4, X -= 4);
                a = (H8m.c8l(null, P) ? P.data : void 0) || this.imgData;
                for (O = 0; H8m.z8l(0, X) ? H8m.j8l(O, X) : H8m.x8l(O, X); H8m.o8l(0, X) ? ++O : --O)
                    a.push(this.data[this.pos++]);
                break;
            case "tRNS":
                this.transparency = {};
                switch (this.colorType) {
                case 3:
                    this.transparency.indexed = this.read(X);
                    X = H8m.p8l(255, this.transparency.indexed.length);
                    if (H8m.Y8l(0, X))
                        for (a = 0; H8m.T8l(0, X) ? H8m.R8l(a, X) : H8m.M8l(a, X); H8m.V8l(0, X) ? ++a : --a)
                            this.transparency.indexed.push(255);
                    break;
                case 0:
                    this.transparency.grayscale = this.read(X)[0];
                    break;
                case 2:
                    this.transparency.rgb = this.read(X);
                }
                break;
            case "tEXt":
                O = this.read(X);
                X = O.indexOf(0);
                a = String.fromCharCode.apply(String, O.slice(0, X));
                this.text[a] = String.fromCharCode.apply(String, O.slice(X + 1));
                break;
            case "IEND":
                P && this.animation.frames.push(P);
                a:
                {
                    switch (this.colorType) {
                    case 0:
                    case 3:
                    case 4:
                        P = 1;
                        break a;
                    case 2:
                    case 6:
                        P = 3;
                        break a;
                    }
                    P = void 0;
                }this.colors = P;
                this.hasAlphaChannel = H8m.s8l(4, (S = this.colorType)) || H8m.U8l(6, S);
                S = this.colors + (this.hasAlphaChannel ? 1 : 0);
                this.pixelBitlength = H8m.b8l(this.bits, S);
                a:
                {
                    switch (this.colors) {
                    case 1:
                        S = "DeviceGray";
                        break a;
                    case 3:
                        S = "DeviceRGB";
                        break a;
                    }
                    S = void 0;
                }this.colorSpace = S;
                H8m.F8l(Uint8Array, Array) && (this.imgData = new Uint8Array(this.imgData));
                return;
            default:
                this.pos += X;
            }
            this.pos += 4;
            if (H8m.k4l(this.pos, this.data.length))
                throw Error("Incomplete or corrupt PNG file");
        }
    },
    read: function(X) {
        var S,
            P;
        P = [];
        for (S = 0; H8m.L4l(0, X) ? H8m.i4l(S, X) : H8m.S4l(S, X); H8m.P4l(0, X) ? ++S : --S)
            P.push(this.data[this.pos++]);
        return P;
    },
    readUInt32: function() {
        var X,
            S,
            P,
            O;
        X = H8m.a4l(this.data[this.pos++], 24);
        S = H8m.O4l(this.data[this.pos++], 16);
        P = H8m.B4l(this.data[this.pos++], 8);
        O = this.data[this.pos++];
        return H8m.Z4l(X, S, P, O);
    },
    readUInt16: function() {
        var X,
            S;
        X = H8m.m4l(this.data[this.pos++], 8);
        S = this.data[this.pos++];
        return H8m.A4l(X, S);
    },
    decodePixels: function(X) {
        var S,
            P,
            O,
            Z,
            Y,
            T,
            R,
            E,
            V,
            U,
            k9,
            L9,
            K9,
            c9,
            t9;
        H8m.E4l(null, X) && (X = this.imgData);
        if (H8m.C4l(0, X.length))
            return new Uint8Array(0);
        X = (new Zlib.Inflate(X, {
            index: 0,
            verify: !1
        })).decompress();
        E = H8m.h4l(this.pixelBitlength, 8);
        L9 = H8m.y4l(E, this.width);
        V = new Uint8Array(H8m.q4l(L9, this.height));
        T = X.length;
        for (P = U = k9 = 0; H8m.l4l(U, T);) {
            switch (X[U++]) {
            case 0:
                for (S = 0; H8m.X7l(S, L9); S += 1)
                    V[P++] = X[U++];
                break;
            case 1:
                for (Z = K9 = 0; H8m.D7l(K9, L9); Z = K9 += 1)
                    S = X[U++], Y = H8m.c7l(Z, E) ? 0 : V[H8m.z7l(P, E)], V[P++] = H8m.j7l((S + Y), 256);
                break;
            case 2:
                for (Z = Y = 0; H8m.x7l(Y, L9); Z = Y += 1)
                    S = X[U++], O = H8m.o7l((Z - Z % E), E), K9 = k9 && V[H8m.p7l((k9 - 1), L9) + H8m.Y7l(O, E) + H8m.T7l(Z, E)], V[P++] = H8m.R7l((K9 + S), 256);
                break;
            case 3:
                for (Z = t9 = 0; H8m.M7l(t9, L9); Z = t9 += 1)
                    S = X[U++], O = H8m.V7l((Z - Z % E), E), Y = H8m.s7l(Z, E) ? 0 : V[H8m.U7l(P, E)], K9 = k9 && V[H8m.b7l((k9 - 1), L9) + H8m.F7l(O, E) + H8m.k0l(Z, E)], V[P++] = H8m.L0l((S + Math.floor((Y + K9) / 2)), 256);
                break;
            case 4:
                for (Z = t9 = 0; H8m.i0l(t9, L9); Z = t9 += 1)
                    S = X[U++], O = H8m.S0l((Z - Z % E), E), Y = H8m.P0l(Z, E) ? 0 : V[H8m.a0l(P, E)], H8m.O0l(0, k9) ? K9 = c9 = 0 : (K9 = V[H8m.B0l((k9 - 1), L9) + H8m.Z0l(O, E) + H8m.J0l(Z, E)], c9 = O && V[H8m.n0l((k9 - 1), L9) + H8m.G0l((O - 1), E) + H8m.W0l(Z, E)]), R = Y + K9 - c9, Z = Math.abs(H8m.v0l(R, Y)), O = Math.abs(H8m.u0l(R, K9)), R = Math.abs(H8m.H0l(R, c9)), Y = H8m.f0l(Z, O) && H8m.I0l(Z, R) ? Y : H8m.g3l(O, R) ? K9 : c9, V[P++] = H8m.K3l((S + Y), 256);
                break;
            default:
                throw Error("Invalid filter algorithm: " + X[H8m.d3l(U, 1)]);
            }
            k9++;
        }
        return V;
    },
    copyToImageData: function(X, S) {
        var P,
            O,
            Z,
            Y,
            T,
            R,
            E,
            V;
        O = this.colors;
        V = null;
        P = this.hasAlphaChannel;
        this.palette.length && (V = H8m.t3l(null, (Z = this._decodedPalette)) ? Z : this._decodedPalette = this.decodePalette(), O = 4, P = !0);
        Z = X.data || X;
        E = Z.length;
        T = V || S;
        Y = R = 0;
        if (H8m.w3l(1, O))
            for (; H8m.e3l(Y, E);)
                O = V ? H8m.Q3l(4, S[Y / 4]) : R, R = T[O++], Z[Y++] = R, Z[Y++] = R, Z[Y++] = R, Z[Y++] = P ? T[O++] : 255, R = O;
        else
            for (; H8m.r3l(Y, E);)
                O = V ? H8m.N3l(4, S[Y / 4]) : R, Z[Y++] = T[O++], Z[Y++] = T[O++], Z[Y++] = T[O++], Z[Y++] = P ? T[O++] : 255, R = O;
    },
    decodePalette: function() {
        var X,
            S,
            P,
            O,
            Z,
            Y,
            T,
            R,
            E;
        P = this.palette;
        Y = this.transparency.indexed || [];
        Z = new Uint8Array((Y.length || 0) + P.length);
        S = T = X = O = 0;
        for (R = P.length; H8m.m3l(T, R); S = T += 3)
            Z[O++] = P[S], Z[O++] = P[S + 1], Z[O++] = P[S + 2], Z[O++] = H8m.A3l(null, (E = Y[X++])) ? E : 255;
        return Z;
    },
    render: function(X) {
        var S;
        X.width = this.width;
        X.height = this.height;
        X = X.getContext("2d");
        S = X.createImageData(this.width, this.height);
        this.copyToImageData(S, this.decodePixels());
        return X.putImageData(S, 0, 0);
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(X) {
        return this._tiffData[X];
    },
    getUint16: function(X) {
        return this._littleEndian ? H8m.E3l(this._tiffData[X + 1] << 8, this._tiffData[X]) : H8m.C3l(this._tiffData[X] << 8, this._tiffData[X + 1]);
    },
    getUint32: function(X) {
        var S = this._tiffData;
        return this._littleEndian ? H8m.h3l(S[X + 3] << 24, S[X + 2] << 16, S[X + 1] << 8, S[X]) : H8m.b3l(S[X] << 24, S[X + 1] << 16, S[X + 2] << 8, S[X + 3]);
    },
    checkLittleEndian: function() {
        var X = this.getUint16(0);
        if (H8m.I3l(18761, X))
            this.littleEndian = !0;
        else if (H8m.g5l(19789, X))
            this.littleEndian = !1;
        else
            throw console.log(X), TypeError("Invalid byte order value.");
        return this.littleEndian;
    },
    hasTowel: function() {
        if (H8m.K5l(42, this.getUint16(2)))
            throw RangeError("You forgot your towel!");
        return !0;
    },
    getFieldTypeName: function(X) {
        var S = this.fieldTypeNames;
        return H8m.d5l(X, S) ? S[X] : null;
    },
    getFieldTagName: function(X) {
        var S = this.fieldTagNames;
        if (H8m.t5l(X, S))
            return S[X];
        console.log("Unknown Field Tag:", X);
        return "Tag" + X;
    },
    getFieldTypeLength: function(X) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(X) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(X) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(X) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(X) ? 8 : null;
    },
    getFieldValues: function(O, Z, Y, T) {
        O = [];
        var R = this.getFieldTypeLength(Z);
        if (H8m.w5l(4, R * Y))
            !1 === this.littleEndian ? O.push(H8m.e5l(T, 8 * (4 - R))) : O.push(T);
        else
            for (var E = 0; H8m.Q5l(E, Y); E++) {
                var V = H8m.r5l(R, E);
                H8m.N5l(8, R) ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(Z) ? (O.push(this.getUint32(T + V)), O.push(this.getUint32(T + V + 4))) : cc.log("Can't handle this field type or size") : O.push(this.getBytes(R, T + V));
            }
        H8m.m5l("ASCII", Z) && O.forEach(function(X, S, P) {
            P[S] = String.fromCharCode(X);
        });
        return O;
    },
    getBytes: function(X, S) {
        if (H8m.A5l(0, X))
            cc.log("No bytes requested");
        else {
            if (H8m.E5l(1, X))
                return this.getUint8(S);
            if (H8m.C5l(2, X))
                return this.getUint16(S);
            if (H8m.h5l(3, X))
                return H8m.y5l(this.getUint32(S), 8);
            if (H8m.q5l(4, X))
                return this.getUint32(S);
            cc.log("Too many bytes requested");
        }
    },
    getBits: function(X, S, P) {
        P = P || 0;
        S += Math.floor(H8m.l5l(P, 8));
        var O = P + X;
        X = H8m.X6l(32, X);
        var Z,
            Y;
        H8m.D6l(0, O) ? console.log("No bits requested") : H8m.c6l(8, O) ? (Z = 24 + P, Y = this.getUint8(S)) : H8m.z6l(16, O) ? (Z = 16 + P, Y = this.getUint16(S)) : H8m.j6l(32, O) ? (Z = P, Y = this.getUint32(S)) : console.log("Too many bits requested");
        return {
            bits: H8m.x6l(Y, Z, X),
            byteOffset: S + Math.floor(H8m.Q6l(O, 8)),
            bitOffset: H8m.r6l(O, 8)
        };
    },
    parseFileDirectory: function(X) {
        var S = this.getUint16(X),
            P = [];
        X += 2;
        for (var O = 0; H8m.N6l(O, S); X += 12, O++) {
            var Z = this.getUint16(X),
                Y = this.getUint16(X + 2),
                T = this.getUint32(X + 4),
                R = this.getUint32(X + 8),
                Z = this.getFieldTagName(Z),
                Y = this.getFieldTypeName(Y),
                T = this.getFieldValues(Z, Y, T, R);
            P[Z] = {
                type: Y,
                values: T
            };
        }
        this._fileDirectories.push(P);
        S = this.getUint32(X);
        H8m.m6l(0, S) && this.parseFileDirectory(S);
    },
    clampColorSample: function(X, S) {
        var P = Math.pow(2, H8m.A6l(8, S));
        return Math.floor(H8m.E6l(X, P) + (H8m.C6l(P, 1)));
    },
    parseTIFF: function(O, Z) {
        Z = Z || w6b0K[I0K]['createElement']("canvas");
        this._tiffData = O;
        this.canvas = Z;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var Y = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(Y);
            var T = this._fileDirectories[0],
                Y = T.ImageWidth.values[0],
                R = T.ImageLength.values[0];
            this.canvas.width = Y;
            this.canvas.height = R;
            var E = [],
                V = T.Compression ? T.Compression.values[0] : 1,
                U = T.SamplesPerPixel.values[0],
                k9 = [],
                L9 = 0,
                K9 = !1;
            T.BitsPerSample.values.forEach(function(X, S, P) {
                k9[S] = {
                    bitsPerSample: X,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                };
                H8m.h6l(0, X % 8) && (k9[S].hasBytesPerSample = !0, k9[S].bytesPerSample = H8m.y6l(X, 8));
                L9 += X;
            }, this);
            if (H8m.q6l(0, L9 % 8))
                var K9 = !0,
                    c9 = H8m.l6l(L9, 8);
            var t9 = T.StripOffsets.values,
                S9 = t9.length;
            if (T.StripByteCounts)
                var j9 = T.StripByteCounts.values;
            else if (cc.log("Missing StripByteCounts!"), H8m.X2l(1, S9))
                j9 = [Math.ceil(H8m.D2l(Y, R, L9, 8))];
            else
                throw Error("Cannot recover from missing StripByteCounts");
            for (var a9 = 0; H8m.S2l(a9, S9); a9++) {
                var o9 = t9[a9];
                E[a9] = [];
                for (var T9 = j9[a9], A9 = 0, F9 = 0, M9 = 1, s9 = !0, C9 = [], n9 = 0, t1 = 0, o1 = 0; H8m.P2l(A9, T9); A9 += M9)
                    switch (V) {
                    case 1:
                        M9 = 0;
                        for (C9 = []; H8m.a2l(M9, U); M9++)
                            if (k9[M9].hasBytesPerSample)
                                C9.push(this.getBytes(k9[M9].bytesPerSample, o9 + A9 + H8m.O2l(k9[M9].bytesPerSample, M9)));
                            else {
                                var a1 = this.getBits(k9[M9].bitsPerSample, o9 + A9, F9);
                                C9.push(a1.bits);
                                A9 = H8m.B2l(a1.byteOffset, o9);
                                F9 = a1.bitOffset;
                                throw RangeError("Cannot handle sub-byte bits per sample");
                            }
                        E[a9].push(C9);
                        if (K9)
                            M9 = c9;
                        else
                            throw M9 = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        break;
                    case 32773:
                        if (s9) {
                            var s9 = !1,
                                j1 = 1,
                                T1 = 1,
                                M9 = this.getInt8(o9 + A9);
                            H8m.Z2l(0, M9) && H8m.J2l(127, M9) ? j1 = M9 + 1 : -127 <= M9 && -1 >= M9 ? T1 = -M9 + 1 : s9 = !0;
                        } else {
                            for (var e8 = this.getUint8(o9 + A9), M9 = 0; H8m.n2l(M9, T1); M9++) {
                                if (k9[t1].hasBytesPerSample)
                                    o1 = H8m.G2l(o1 << 8 * n9, e8), n9++, H8m.W2l(n9, k9[t1].bytesPerSample) && (C9.push(o1), o1 = n9 = 0, t1++);
                                else
                                    throw RangeError("Cannot handle sub-byte bits per sample");
                                H8m.v2l(t1, U) && (E[a9].push(C9), C9 = [], t1 = 0);
                            }
                            j1--;
                            H8m.u2l(0, j1) && (s9 = !0);
                        }
                        M9 = 1;
                    }
            }
            if (Z.getContext) {
                c9 = this.canvas.getContext("2d");
                c9.fillStyle = "rgba(255, 255, 255, 0)";
                a9 = T.RowsPerStrip ? T.RowsPerStrip.values[0] : R;
                o9 = E.length;
                R %= a9;
                R = H8m.H2l(0, R) ? a9 : R;
                A9 = a9;
                V = 0;
                C9 = T.PhotometricInterpretation.values[0];
                j1 = [];
                T1 = 0;
                T.ExtraSamples && (j1 = T.ExtraSamples.values, T1 = j1.length);
                if (T.ColorMap)
                    var a1 = T.ColorMap.values,
                        y1 = Math.pow(2, k9[0].bitsPerSample);
                for (a9 = 0; H8m.f2l(a9, o9); a9++) {
                    H8m.I2l(a9 + 1, o9) && (A9 = R);
                    T = E[a9].length;
                    V *= a9;
                    for (K9 = U = 0; H8m.g91(U, A9), H8m.K91(K9, T); U++)
                        for (t9 = 0; H8m.d91(t9, Y); t9++, K9++) {
                            j9 = E[a9][K9];
                            s9 = F9 = T9 = 0;
                            S9 = 1;
                            if (H8m.t91(0, T1))
                                for (T9 = 0; H8m.w91(T9, T1); T9++)
                                    if (H8m.e91(1, j1[T9]) || H8m.Q91(2, j1[T9])) {
                                        S9 = H8m.r91(j9[3 + T9], 256);
                                        break;
                                    }
                            switch (C9) {
                            case 0:
                                if (k9[0].hasBytesPerSample)
                                    var s8 = Math.pow(16, H8m.N91(2, k9[0].bytesPerSample));
                                j9.forEach(function(X, S, P) {
                                    P[S] = H8m.m91(s8, X);
                                });
                            case 1:
                                T9 = F9 = s9 = this.clampColorSample(j9[0], k9[0].bitsPerSample);
                                break;
                            case 2:
                                T9 = this.clampColorSample(j9[0], k9[0].bitsPerSample);
                                F9 = this.clampColorSample(j9[1], k9[1].bitsPerSample);
                                s9 = this.clampColorSample(j9[2], k9[2].bitsPerSample);
                                break;
                            case 3:
                                if (void 0 === a1)
                                    throw Error("Palette image missing color map");
                                j9 = j9[0];
                                T9 = this.clampColorSample(a1[j9], 16);
                                F9 = this.clampColorSample(a1[y1 + j9], 16);
                                s9 = this.clampColorSample(a1[H8m.A91(2, y1) + j9], 16);
                                break;
                            default:
                                throw RangeError("Unknown Photometric Interpretation:", C9);
                            }
                            c9.fillStyle = "rgba(" + T9 + ", " + F9 + ", " + s9 + ", " + S9 + ")";
                            c9.fillRect(t9, V + U, 1, 1);
                        }
                    V = A9;
                }
            }
            return this.canvas;
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
H8m.M3y(H8m.U7H);
H8m.W3y(H8m.h7H);
H8m.C3y(H8m.U7H);
H8m.s3y(H8m.h7H);
H8m.u3y();
H8m.U3y();
H8m.y3y();
H8m.H3y(H8m.U7H);
H8m.q3y(H8m.h7H);
H8m.F3y(H8m.U7H);
H8m.I3y(H8m.h7H);
H8m.X5y(H8m.s7H);
cc.Particle = function(X, S, P, O, Z, Y, T, R, E, V, U, k9) {
    this.pos = X ? X : cc.p(H8m.U7H, H8m.U7H);
    this.startPos = S ? S : cc.p(H8m.U7H, H8m.U7H);
    this.color = P ? P : {
        r: H8m.U7H,
        g: H8m.U7H,
        b: H8m.U7H,
        a: H8m.s0K
    };
    this.deltaColor = O ? O : {
        r: H8m.U7H,
        g: H8m.U7H,
        b: H8m.U7H,
        a: H8m.s0K
    };
    this.size = Z || H8m.U7H;
    this.deltaSize = Y || H8m.U7H;
    this.rotation = T || H8m.U7H;
    this.deltaRotation = R || H8m.U7H;
    this.timeToLive = E || H8m.U7H;
    this.atlasIndex = V || H8m.U7H;
    this.modeA = U ? U : new cc.Particle.ModeA;
    this.modeB = k9 ? k9 : new cc.Particle.ModeB;
    this.isChangeColor = !H8m.h7H;
    this.drawPos = cc.p(H8m.U7H, H8m.U7H);
};
cc.Particle.ModeA = function(X, S, P) {
    this.dir = X ? X : cc.p(H8m.U7H, H8m.U7H);
    this.radialAccel = S || H8m.U7H;
    this.tangentialAccel = P || H8m.U7H;
};
cc.Particle.ModeB = function(X, S, P, O) {
    this.angle = X || H8m.U7H;
    this.degreesPerSecond = S || H8m.U7H;
    this.radius = P || H8m.U7H;
    this.deltaRadius = O || H8m.U7H;
};
H8m.L5y();
cc.ParticleSystem = cc.Node.extend({
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _className: "ParticleSystem",
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    drawMode: cc.PARTICLE_SHAPE_MODE,
    shapeType: cc.PARTICLE_BALL_SHAPE,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: cc.PARTICLE_TYPE_FREE,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _quads: null,
    _indices: null,
    _buffersVBO: null,
    _pointRect: null,
    _textureLoaded: null,
    _quadsArrayBuffer: null,
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.PARTICLE_MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0, 0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = !1;
        this._allocatedParticles = 0;
        this.drawMode = cc.PARTICLE_SHAPE_MODE;
        this.shapeType = cc.PARTICLE_BALL_SHAPE;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.PARTICLE_TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._textureLoaded = !0;
        H8m.E91(cc._renderType, cc._RENDER_TYPE_WEBGL) && (this._quadsArrayBuffer = null);
    },
    initIndices: function() {
        for (var X = this._indices, S = 0, P = this._totalParticles; H8m.C91(S, P); ++S) {
            var O = H8m.h91(6, S),
                Z = H8m.y91(4, S);
            X[O + 0] = Z + 0;
            X[O + 1] = Z + 1;
            X[O + 2] = Z + 2;
            X[O + 5] = Z + 1;
            X[O + 4] = Z + 2;
            X[O + 3] = Z + 3;
        }
    },
    initTexCoordsWithRect: function(X) {
        var S = cc.CONTENT_SCALE_FACTOR(),
            P = cc.rect(H8m.q91(X.x, S), H8m.l91(X.y, S), H8m.X11(X.width, S), H8m.D11(X.height, S)),
            O = X.width,
            Z = X.height;
        this._texture && (O = this._texture.pixelsWidth, Z = this._texture.pixelsHeight);
        if (H8m.c11(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (X = H8m.z11((2 * P.x + 1), (2 * O)), S = H8m.j11((2 * P.y + 1), (2 * Z)), O = X + H8m.x11((2 * P.width - 2), (2 * O)), P = S + H8m.o11((2 * P.height - 2), (2 * Z))) : (X = H8m.p11(P.x, O), S = H8m.Y11(P.y, Z), O = X + H8m.T11(P.width, O), P = S + H8m.R11(P.height, Z));
            var Z = P,
                P = S,
                S = Z,
                Y = 0,
                T = 0;
            this._batchNode ? (Z = this._batchNode.textureAtlas.quads, Y = this.atlasIndex, T = this.atlasIndex + this._totalParticles) : (Z = this._quads, Y = 0, T = this._totalParticles);
            for (; H8m.M11(Y, T); Y++) {
                Z[Y] || (Z[Y] = cc.V3F_C4B_T2F_QuadZero());
                var R = Z[Y];
                R.bl.texCoords.u = X;
                R.bl.texCoords.v = S;
                R.br.texCoords.u = O;
                R.br.texCoords.v = S;
                R.tl.texCoords.u = X;
                R.tl.texCoords.v = P;
                R.tr.texCoords.u = O;
                R.tr.texCoords.v = P;
            }
        }
    },
    getBatchNode: function() {
        return this._batchNode;
    },
    setBatchNode: function(X) {
        if (H8m.V11(this._batchNode, X)) {
            var S = this._batchNode;
            if (this._batchNode = X)
                for (var P = this._particles, O = 0; H8m.s11(O, this._totalParticles); O++)
                    P[O].atlasIndex = O;
            X ? S || (this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(), this.setTexture(S.getTexture()), this._setupVBO());
        }
    },
    getAtlasIndex: function() {
        return this.atlasIndex;
    },
    setAtlasIndex: function(X) {
        this.atlasIndex = X;
    },
    getDrawMode: function() {
        return this.drawMode;
    },
    setDrawMode: function(X) {
        this.drawMode = X;
    },
    getShapeType: function() {
        return this.shapeType;
    },
    setShapeType: function(X) {
        this.shapeType = X;
    },
    isActive: function() {
        return this._isActive;
    },
    getParticleCount: function() {
        return this.particleCount;
    },
    setParticleCount: function(X) {
        this.particleCount = X;
    },
    getDuration: function() {
        return this.duration;
    },
    setDuration: function(X) {
        this.duration = X;
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        };
    },
    setSourcePosition: function(X) {
        this._sourcePosition = X;
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        };
    },
    setPosVar: function(X) {
        this._posVar = X;
    },
    getLife: function() {
        return this.life;
    },
    setLife: function(X) {
        this.life = X;
    },
    getLifeVar: function() {
        return this.lifeVar;
    },
    setLifeVar: function(X) {
        this.lifeVar = X;
    },
    getAngle: function() {
        return this.angle;
    },
    setAngle: function(X) {
        this.angle = X;
    },
    getAngleVar: function() {
        return this.angleVar;
    },
    setAngleVar: function(X) {
        this.angleVar = X;
    },
    getGravity: function() {
        H8m.U11(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var X = this.modeA.gravity;
        return cc.p(X.x, X.y);
    },
    setGravity: function(X) {
        H8m.b11(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = X;
    },
    getSpeed: function() {
        H8m.l11(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed;
    },
    setSpeed: function(X) {
        H8m.X81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = X;
    },
    getSpeedVar: function() {
        H8m.D81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar;
    },
    setSpeedVar: function(X) {
        H8m.c81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = X;
    },
    getTangentialAccel: function() {
        H8m.z81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel;
    },
    setTangentialAccel: function(X) {
        H8m.j81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = X;
    },
    getTangentialAccelVar: function() {
        H8m.x81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar;
    },
    setTangentialAccelVar: function(X) {
        H8m.o81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = X;
    },
    getRadialAccel: function() {
        H8m.p81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel;
    },
    setRadialAccel: function(X) {
        H8m.Y81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = X;
    },
    getRadialAccelVar: function() {
        H8m.T81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar;
    },
    setRadialAccelVar: function(X) {
        H8m.R81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = X;
    },
    getRotationIsDir: function() {
        H8m.M81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir;
    },
    setRotationIsDir: function(X) {
        H8m.V81(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = X;
    },
    getStartRadius: function() {
        H8m.s81(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius;
    },
    setStartRadius: function(X) {
        H8m.U81(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = X;
    },
    getStartRadiusVar: function() {
        H8m.b81(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar;
    },
    setStartRadiusVar: function(X) {
        H8m.F81(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = X;
    },
    getEndRadius: function() {
        H8m.k41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius;
    },
    setEndRadius: function(X) {
        H8m.L41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = X;
    },
    getEndRadiusVar: function() {
        H8m.i41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar;
    },
    setEndRadiusVar: function(X) {
        H8m.S41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = X;
    },
    getRotatePerSecond: function() {
        H8m.P41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond;
    },
    setRotatePerSecond: function(X) {
        H8m.a41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = X;
    },
    getRotatePerSecondVar: function() {
        H8m.O41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar;
    },
    setRotatePerSecondVar: function(X) {
        H8m.B41(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = X;
    },
    setScale: function(X, S) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this, X, S);
    },
    setRotation: function(X) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this, X);
    },
    setScaleX: function(X) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, X);
    },
    setScaleY: function(X) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, X);
    },
    getStartSize: function() {
        return this.startSize;
    },
    setStartSize: function(X) {
        this.startSize = X;
    },
    getStartSizeVar: function() {
        return this.startSizeVar;
    },
    setStartSizeVar: function(X) {
        this.startSizeVar = X;
    },
    getEndSize: function() {
        return this.endSize;
    },
    setEndSize: function(X) {
        this.endSize = X;
    },
    getEndSizeVar: function() {
        return this.endSizeVar;
    },
    setEndSizeVar: function(X) {
        this.endSizeVar = X;
    },
    getStartColor: function() {
        return this._startColor;
    },
    setStartColor: function(X) {
        this._startColor = cc.color(X);
    },
    getStartColorVar: function() {
        return this._startColorVar;
    },
    setStartColorVar: function(X) {
        this._startColorVar = cc.color(X);
    },
    getEndColor: function() {
        return this._endColor;
    },
    setEndColor: function(X) {
        this._endColor = cc.color(X);
    },
    getEndColorVar: function() {
        return this._endColorVar;
    },
    setEndColorVar: function(X) {
        this._endColorVar = cc.color(X);
    },
    getStartSpin: function() {
        return this.startSpin;
    },
    setStartSpin: function(X) {
        this.startSpin = X;
    },
    getStartSpinVar: function() {
        return this.startSpinVar;
    },
    setStartSpinVar: function(X) {
        this.startSpinVar = X;
    },
    getEndSpin: function() {
        return this.endSpin;
    },
    setEndSpin: function(X) {
        this.endSpin = X;
    },
    getEndSpinVar: function() {
        return this.endSpinVar;
    },
    setEndSpinVar: function(X) {
        this.endSpinVar = X;
    },
    getEmissionRate: function() {
        return this.emissionRate;
    },
    setEmissionRate: function(X) {
        this.emissionRate = X;
    },
    getTotalParticles: function() {
        return this._totalParticles;
    },
    setTotalParticles: function(X) {
        if (H8m.Z41(cc._renderType, cc._RENDER_TYPE_CANVAS))
            this._totalParticles = H8m.J41(200, X) ? X : 200;
        else {
            if (H8m.n41(X, this._allocatedParticles)) {
                var S = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(H8m.G41(6, X));
                var P = new ArrayBuffer(H8m.W41(X, S)),
                    O = this._particles;
                O.length = 0;
                for (var Z = this._quads, Y = Z.length = 0; H8m.v41(Y, X); Y++)
                    O[Y] = new cc.Particle, Z[Y] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, P, H8m.u41(Y, S));
                this._totalParticles = this._allocatedParticles = X;
                if (this._batchNode)
                    for (S = 0; H8m.H41(S, X); S++)
                        O[S].atlasIndex = S;
                this._quadsArrayBuffer = P;
                this.initIndices();
                this._setupVBO();
                this._texture && this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height));
            } else
                this._totalParticles = X;
            this.resetSystem();
        }
    },
    getTexture: function() {
        return this._texture;
    },
    setTexture: function(S) {
        S.isLoaded() ? this.setTextureWithRect(S, cc.rect(0, 0, S.width, S.height)) : (this._textureLoaded = !1, S.addLoadedEventListener(function(X) {
            this._textureLoaded = !0;
            this.setTextureWithRect(X, cc.rect(0, 0, X.width, X.height));
        }, this));
    },
    getBlendFunc: function() {
        return this._blendFunc;
    },
    setBlendFunc: function(X, S) {
        if (void 0 === S)
            H8m.f41(this._blendFunc, X) && (this._blendFunc = X, this._updateBlendFunc());
        else if (H8m.I41(this._blendFunc.src, X) || H8m.g71(this._blendFunc.dst, S))
            this._blendFunc = {
                src: X,
                dst: S
            }, this._updateBlendFunc();
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
    },
    setOpacityModifyRGB: function(X) {
        this._opacityModifyRGB = X;
    },
    isBlendAdditive: function() {
        return H8m.K71(this._blendFunc.src, cc.SRC_ALPHA) && H8m.d71(this._blendFunc.dst, cc.ONE) || H8m.t71(this._blendFunc.src, cc.ONE) && H8m.w71(this._blendFunc.dst, cc.ONE);
    },
    setBlendAdditive: function(X) {
        var S = this._blendFunc;
        X ? (S.src = cc.SRC_ALPHA, S.dst = cc.ONE) : H8m.e71(cc._renderType, cc._RENDER_TYPE_WEBGL) ? this._texture && !this._texture.hasPremultipliedAlpha() ? (S.src = cc.SRC_ALPHA, S.dst = cc.ONE_MINUS_SRC_ALPHA) : (S.src = cc.BLEND_SRC, S.dst = cc.BLEND_DST) : (S.src = cc.BLEND_SRC, S.dst = cc.BLEND_DST);
    },
    getPositionType: function() {
        return this.positionType;
    },
    setPositionType: function(X) {
        this.positionType = X;
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish;
    },
    setAutoRemoveOnFinish: function(X) {
        this.autoRemoveOnFinish = X;
    },
    getEmitterMode: function() {
        return this.emitterMode;
    },
    setEmitterMode: function(X) {
        this.emitterMode = X;
    },
    init: function() {
        return this.initWithTotalParticles(150);
    },
    initWithFile: function(X) {
        this._plistFile = X;
        X = cc.loader.getRes(X);
        return X ? this.initWithDictionary(X, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1);
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height);
    },
    initWithDictionary: function(X, S) {
        var P = !1,
            O = null,
            O = this._valueForKey,
            Z = parseInt(O("maxParticles", X));
        if (this.initWithTotalParticles(Z)) {
            this.angle = parseFloat(O("angle", X));
            this.angleVar = parseFloat(O("angleVariance", X));
            this.duration = parseFloat(O("duration", X));
            this._blendFunc.src = parseInt(O("blendFuncSource", X));
            this._blendFunc.dst = parseInt(O("blendFuncDestination", X));
            P = this._startColor;
            P.r = H8m.Q71(255, parseFloat(O("startColorRed", X)));
            P.g = H8m.r71(255, parseFloat(O("startColorGreen", X)));
            P.b = H8m.N71(255, parseFloat(O("startColorBlue", X)));
            P.a = H8m.m71(255, parseFloat(O("startColorAlpha", X)));
            P = this._startColorVar;
            P.r = H8m.A71(255, parseFloat(O("startColorVarianceRed", X)));
            P.g = H8m.E71(255, parseFloat(O("startColorVarianceGreen", X)));
            P.b = H8m.C71(255, parseFloat(O("startColorVarianceBlue", X)));
            P.a = H8m.h71(255, parseFloat(O("startColorVarianceAlpha", X)));
            P = this._endColor;
            P.r = H8m.y71(255, parseFloat(O("finishColorRed", X)));
            P.g = H8m.q71(255, parseFloat(O("finishColorGreen", X)));
            P.b = H8m.l71(255, parseFloat(O("finishColorBlue", X)));
            P.a = H8m.X01(255, parseFloat(O("finishColorAlpha", X)));
            P = this._endColorVar;
            P.r = H8m.D01(255, parseFloat(O("finishColorVarianceRed", X)));
            P.g = H8m.c01(255, parseFloat(O("finishColorVarianceGreen", X)));
            P.b = H8m.z01(255, parseFloat(O("finishColorVarianceBlue", X)));
            P.a = H8m.j01(255, parseFloat(O("finishColorVarianceAlpha", X)));
            this.startSize = parseFloat(O("startParticleSize", X));
            this.startSizeVar = parseFloat(O("startParticleSizeVariance", X));
            this.endSize = parseFloat(O("finishParticleSize", X));
            this.endSizeVar = parseFloat(O("finishParticleSizeVariance", X));
            this.setPosition(parseFloat(O("sourcePositionx", X)), parseFloat(O("sourcePositiony", X)));
            this._posVar.x = parseFloat(O("sourcePositionVariancex", X));
            this._posVar.y = parseFloat(O("sourcePositionVariancey", X));
            this.startSpin = parseFloat(O("rotationStart", X));
            this.startSpinVar = parseFloat(O("rotationStartVariance", X));
            this.endSpin = parseFloat(O("rotationEnd", X));
            this.endSpinVar = parseFloat(O("rotationEndVariance", X));
            this.emitterMode = parseInt(O("emitterType", X));
            if (H8m.x01(this.emitterMode, cc.PARTICLE_MODE_GRAVITY))
                P = this.modeA, P.gravity.x = parseFloat(O("gravityx", X)), P.gravity.y = parseFloat(O("gravityy", X)), P.speed = parseFloat(O("speed", X)), P.speedVar = parseFloat(O("speedVariance", X)), Z = O("radialAcceleration", X), P.radialAccel = Z ? parseFloat(Z) : 0, Z = O("radialAccelVariance", X), P.radialAccelVar = Z ? parseFloat(Z) : 0, Z = O("tangentialAcceleration", X), P.tangentialAccel = Z ? parseFloat(Z) : 0, Z = O("tangentialAccelVariance", X), P.tangentialAccelVar = Z ? parseFloat(Z) : 0, Z = O("rotationIsDir", X).toLowerCase(), P.rotationIsDir = H8m.o01(null, Z) && (H8m.p01("true", Z) || H8m.Y01("1", Z));
            else if (H8m.T01(this.emitterMode, cc.PARTICLE_MODE_RADIUS))
                P = this.modeB, P.startRadius = parseFloat(O("maxRadius", X)), P.startRadiusVar = parseFloat(O("maxRadiusVariance", X)), P.endRadius = parseFloat(O("minRadius", X)), P.endRadiusVar = 0, P.rotatePerSecond = parseFloat(O("rotatePerSecond", X)), P.rotatePerSecondVar = parseFloat(O("rotatePerSecondVariance", X));
            else
                return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(O("particleLifespan", X));
            this.lifeVar = parseFloat(O("particleLifespanVariance", X));
            this.emissionRate = H8m.R01(this._totalParticles, this.life);
            if (!this._batchNode)
                if (this._opacityModifyRGB = !1, P = O("textureFileName", X), P = cc.path.changeBasename(this._plistFile, P), Z = cc.textureCache.textureForKey(P))
                    this.setTexture(Z);
                else if ((O = O("textureImageData", X)) && H8m.M01(0, O.length)) {
                    Z = cc.textureCache.addImage(P);
                    if (!Z)
                        return !1;
                    this.setTexture(Z);
                } else {
                    O = cc.unzipBase64AsArray(O, 1);
                    if (!O)
                        return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                    Z = cc.getImageFormatByData(O);
                    if (H8m.V01(Z, cc.FMT_TIFF) && H8m.s01(Z, cc.FMT_PNG))
                        return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                    var Y = w6b0K[I0K]['createElement']("canvas");
                    H8m.U01(Z, cc.FMT_PNG) ? (new cc.PNGReader(O)).render(Y) : cc.tiffReader.parseTIFF(O, Y);
                    cc.textureCache.cacheImage(P, Y);
                    (O = cc.textureCache.textureForKey(P)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                    this.setTexture(O);
                }
            P = !0;
        }
        return P;
    },
    initWithTotalParticles: function(X) {
        this._totalParticles = X;
        var S,
            P = this._particles;
        for (S = P.length = 0; H8m.b01(S, X); S++)
            P[S] = new cc.Particle;
        if (!P)
            return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = X;
        if (this._batchNode)
            for (S = 0; H8m.F01(S, this._totalParticles); S++)
                P[S].atlasIndex = S;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.PARTICLE_TYPE_FREE;
        this.emitterMode = cc.PARTICLE_MODE_GRAVITY;
        this._transformSystemDirty = this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        if (H8m.k31(cc._renderType, cc._RENDER_TYPE_WEBGL)) {
            if (!this._allocMemory())
                return !1;
            this.initIndices();
            this._setupVBO();
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        }
        return !0;
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate();
    },
    addParticle: function() {
        if (this.isFull())
            return !1;
        var X,
            S = this._particles;
        H8m.L31(cc._renderType, cc._RENDER_TYPE_CANVAS) ? H8m.i31(this.particleCount, S.length) ? X = S[this.particleCount] : (X = new cc.Particle, S.push(X)) : X = S[this.particleCount];
        this.initParticle(X);
        ++this.particleCount;
        return !0;
    },
    initParticle: function(X) {
        var S = cc.RANDOM_MINUS1_1;
        X.timeToLive = this.life + H8m.S31(this.lifeVar, S());
        X.timeToLive = Math.max(0, X.timeToLive);
        X.pos.x = this._sourcePosition.x + H8m.P31(this._posVar.x, S());
        X.pos.y = this._sourcePosition.y + H8m.a31(this._posVar.y, S());
        var P,
            O;
        P = this._startColor;
        var Z = this._startColorVar,
            Y = this._endColor;
        O = this._endColorVar;
        H8m.O31(cc._renderType, cc._RENDER_TYPE_CANVAS) ? (P = cc.color(cc.clampf(P.r + H8m.B31(Z.r, S()), 0, 255), cc.clampf(P.g + H8m.Z31(Z.g, S()), 0, 255), cc.clampf(P.b + H8m.J31(Z.b, S()), 0, 255), cc.clampf(P.a + H8m.n31(Z.a, S()), 0, 255)), O = cc.color(cc.clampf(Y.r + H8m.G31(O.r, S()), 0, 255), cc.clampf(Y.g + H8m.W31(O.g, S()), 0, 255), cc.clampf(Y.b + H8m.v31(O.b, S()), 0, 255), cc.clampf(Y.a + H8m.u31(O.a, S()), 0, 255))) : (P = {
            r: cc.clampf(P.r + H8m.H31(Z.r, S()), 0, 255),
            g: cc.clampf(P.g + H8m.f31(Z.g, S()), 0, 255),
            b: cc.clampf(P.b + H8m.I31(Z.b, S()), 0, 255),
            a: cc.clampf(P.a + H8m.g51(Z.a, S()), 0, 255)
        }, O = {
            r: cc.clampf(Y.r + H8m.K51(O.r, S()), 0, 255),
            g: cc.clampf(Y.g + H8m.d51(O.g, S()), 0, 255),
            b: cc.clampf(Y.b + H8m.t51(O.b, S()), 0, 255),
            a: cc.clampf(Y.a + H8m.w51(O.a, S()), 0, 255)
        });
        X.color = P;
        Z = X.deltaColor;
        Y = X.timeToLive;
        Z.r = H8m.e51((O.r - P.r), Y);
        Z.g = H8m.Q51((O.g - P.g), Y);
        Z.b = H8m.r51((O.b - P.b), Y);
        Z.a = H8m.N51((O.a - P.a), Y);
        P = this.startSize + H8m.m51(this.startSizeVar, S());
        P = Math.max(0, P);
        X.size = P;
        H8m.A51(this.endSize, cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE) ? X.deltaSize = 0 : (O = this.endSize + H8m.E51(this.endSizeVar, S()), O = Math.max(0, O), X.deltaSize = H8m.C51((O - P), Y));
        P = this.startSpin + H8m.h51(this.startSpinVar, S());
        O = this.endSpin + H8m.y51(this.endSpinVar, S());
        X.rotation = P;
        X.deltaRotation = H8m.q51((O - P), Y);
        H8m.l51(this.positionType, cc.PARTICLE_TYPE_FREE) ? X.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : H8m.X61(this.positionType, cc.PARTICLE_TYPE_RELATIVE) && (X.startPos.x = this._position.x, X.startPos.y = this._position.y);
        P = cc.DEGREES_TO_RADIANS(this.angle + H8m.D61(this.angleVar, S()));
        if (H8m.c61(this.emitterMode, cc.PARTICLE_MODE_GRAVITY))
            Y = this.modeA, O = X.modeA, Z = Y.speed + H8m.z61(Y.speedVar, S()), O.dir.x = Math.cos(P), O.dir.y = Math.sin(P), cc.pMultIn(O.dir, Z), O.radialAccel = Y.radialAccel + H8m.j61(Y.radialAccelVar, S()), O.tangentialAccel = Y.tangentialAccel + H8m.x61(Y.tangentialAccelVar, S()), Y.rotationIsDir && (X.rotation = -cc.RADIANS_TO_DEGREES(cc.pToAngle(O.dir)));
        else {
            O = this.modeB;
            X = X.modeB;
            var Z = O.startRadius + H8m.o61(O.startRadiusVar, S()),
                T = O.endRadius + H8m.p61(O.endRadiusVar, S());
            X.radius = Z;
            X.deltaRadius = H8m.Y61(O.endRadius, cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS) ? 0 : H8m.T61((T - Z), Y);
            X.angle = P;
            X.degreesPerSecond = cc.DEGREES_TO_RADIANS(O.rotatePerSecond + H8m.R61(O.rotatePerSecondVar, S()));
        }
    },
    stopSystem: function() {
        this._isActive = !1;
        this._elapsed = this.duration;
        this._emitCounter = 0;
    },
    resetSystem: function() {
        this._isActive = !0;
        this._elapsed = 0;
        var X = this._particles;
        for (this._particleIdx = 0; H8m.M61(this._particleIdx, this.particleCount); ++this._particleIdx)
            X[this._particleIdx].timeToLive = 0;
    },
    isFull: function() {
        return H8m.V61(this.particleCount, this._totalParticles);
    },
    updateQuadWithParticle: function(X, S) {
        var P = null;
        this._batchNode ? (P = this._batchNode.textureAtlas.quads[this.atlasIndex + X.atlasIndex], this._batchNode.textureAtlas.dirty = !0) : P = this._quads[this._particleIdx];
        var O,
            Z,
            Y,
            T;
        this._opacityModifyRGB ? (O = H8m.s61(0, X.color.r * X.color.a / 255), Z = H8m.U61(0, X.color.g * X.color.a / 255), Y = H8m.b61(0, X.color.b * X.color.a / 255)) : (O = H8m.F61(0, X.color.r), Z = H8m.k21(0, X.color.g), Y = H8m.L21(0, X.color.b));
        T = H8m.i21(0, X.color.a);
        var R = P.bl.colors;
        R.r = O;
        R.g = Z;
        R.b = Y;
        R.a = T;
        R = P.br.colors;
        R.r = O;
        R.g = Z;
        R.b = Y;
        R.a = T;
        R = P.tl.colors;
        R.r = O;
        R.g = Z;
        R.b = Y;
        R.a = T;
        R = P.tr.colors;
        R.r = O;
        R.g = Z;
        R.b = Y;
        R.a = T;
        O = H8m.S21(X.size, 2);
        if (X.rotation) {
            Z = -O;
            Y = -O;
            T = S.x;
            var R = S.y,
                E = -cc.DEGREES_TO_RADIANS(X.rotation),
                V = Math.cos(E),
                E = Math.sin(E);
            P.bl.vertices.x = H8m.P21(Z * V, Y * E, T);
            P.bl.vertices.y = H8m.x21(Z, E) + H8m.o21(Y, V) + R;
            P.br.vertices.x = H8m.p21(O * V, Y * E, T);
            P.br.vertices.y = H8m.N21(O, E) + H8m.m21(Y, V) + R;
            P.tl.vertices.x = H8m.A21(Z * V, O * E, T);
            P.tl.vertices.y = H8m.W21(Z, E) + H8m.v21(O, V) + R;
            P.tr.vertices.x = H8m.u21(O * V, O * E, T);
            P.tr.vertices.y = H8m.b21(O, E) + H8m.F21(O, V) + R;
        } else
            P.bl.vertices.x = H8m.k9d(S.x, O), P.bl.vertices.y = H8m.L9d(S.y, O), P.br.vertices.x = S.x + O, P.br.vertices.y = H8m.i9d(S.y, O), P.tl.vertices.x = H8m.S9d(S.x, O), P.tl.vertices.y = S.y + O, P.tr.vertices.x = S.x + O, P.tr.vertices.y = S.y + O;
    },
    postStep: function() {
        if (H8m.P9d(cc._renderType, cc._RENDER_TYPE_WEBGL)) {
            var X = cc._renderContext;
            X.bindBuffer(X.ARRAY_BUFFER, this._buffersVBO[0]);
            X.bufferData(X.ARRAY_BUFFER, this._quadsArrayBuffer, X.DYNAMIC_DRAW);
        }
    },
    update: function(X) {
        if (this._isActive && this.emissionRate) {
            var S = H8m.a9d(1, this.emissionRate);
            H8m.O9d(this.particleCount, this._totalParticles) && (this._emitCounter += X);
            for (; H8m.B9d(this.particleCount, this._totalParticles) && H8m.Z9d(this._emitCounter, S);)
                this.addParticle(), this._emitCounter -= S;
            this._elapsed += X;
            -1 != this.duration && H8m.J9d(this.duration, this._elapsed) && this.stopSystem();
        }
        this._particleIdx = 0;
        S = cc.Particle.TemporaryPoints[0];
        H8m.n9d(this.positionType, cc.PARTICLE_TYPE_FREE) ? cc.pIn(S, this.convertToWorldSpace(this._pointZeroForParticle)) : H8m.G9d(this.positionType, cc.PARTICLE_TYPE_RELATIVE) && (S.x = this._position.x, S.y = this._position.y);
        if (this._visible) {
            for (var P = cc.Particle.TemporaryPoints[1], O = cc.Particle.TemporaryPoints[2], Z = cc.Particle.TemporaryPoints[3], Y = this._particles; H8m.W9d(this._particleIdx, this.particleCount);) {
                cc.pZeroIn(P);
                cc.pZeroIn(O);
                cc.pZeroIn(Z);
                var T = Y[this._particleIdx];
                T.timeToLive -= X;
                if (H8m.v9d(0, T.timeToLive)) {
                    if (H8m.u9d(this.emitterMode, cc.PARTICLE_MODE_GRAVITY)) {
                        var R = Z,
                            E = P,
                            V = O;
                        T.pos.x || T.pos.y ? (cc.pIn(E, T.pos), cc.pNormalizeIn(E)) : cc.pZeroIn(E);
                        cc.pIn(V, E);
                        cc.pMultIn(E, T.modeA.radialAccel);
                        var U = V.x;
                        V.x = -V.y;
                        V.y = U;
                        cc.pMultIn(V, T.modeA.tangentialAccel);
                        cc.pIn(R, E);
                        cc.pAddIn(R, V);
                        cc.pAddIn(R, this.modeA.gravity);
                        cc.pMultIn(R, X);
                        cc.pAddIn(T.modeA.dir, R);
                        cc.pIn(R, T.modeA.dir);
                        cc.pMultIn(R, X);
                        cc.pAddIn(T.pos, R);
                    } else
                        R = T.modeB, R.angle += H8m.H9d(R.degreesPerSecond, X), R.radius += H8m.f9d(R.deltaRadius, X), T.pos.x = -Math.cos(R.angle) * R.radius, T.pos.y = -Math.sin(R.angle) * R.radius;
                    this._dontTint || (T.color.r += H8m.I9d(T.deltaColor.r, X), T.color.g += H8m.g1d(T.deltaColor.g, X), T.color.b += H8m.K1d(T.deltaColor.b, X), T.color.a += H8m.d1d(T.deltaColor.a, X), T.isChangeColor = !0);
                    T.size += H8m.t1d(T.deltaSize, X);
                    T.size = Math.max(0, T.size);
                    T.rotation += H8m.w1d(T.deltaRotation, X);
                    R = P;
                    H8m.e1d(this.positionType, cc.PARTICLE_TYPE_FREE) || H8m.Q1d(this.positionType, cc.PARTICLE_TYPE_RELATIVE) ? (E = O, cc.pIn(E, S), cc.pSubIn(E, T.startPos), cc.pIn(R, T.pos), cc.pSubIn(R, E)) : cc.pIn(R, T.pos);
                    this._batchNode && (R.x += this._position.x, R.y += this._position.y);
                    H8m.r1d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? this.updateQuadWithParticle(T, R) : cc.pIn(T.drawPos, R);
                    ++this._particleIdx;
                } else if (T = T.atlasIndex, H8m.N1d(this._particleIdx, this.particleCount - 1) && (R = Y[this._particleIdx], Y[this._particleIdx] = Y[H8m.m1d(this.particleCount, 1)], Y[H8m.A1d(this.particleCount, 1)] = R), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + T), Y[H8m.E1d(this.particleCount, 1)].atlasIndex = T), --this.particleCount, H8m.C1d(0, this.particleCount) && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return;
                }
            }
            this._transformSystemDirty = !1;
        }
        this._batchNode || this.postStep();
    },
    updateWithNoTime: function() {
        this.update(0);
    },
    _valueForKey: function(X, S) {
        if (S) {
            var P = S[X];
            return H8m.h1d(null, P) ? P : "";
        }
        return "";
    },
    _updateBlendFunc: function() {
        if (this._batchNode)
            cc.log("Can't change blending functions when the particle is being batched");
        else {
            var X = this._texture;
            if (X && H8m.y1d(X, cc.Texture2D)) {
                this._opacityModifyRGB = !1;
                var S = this._blendFunc;
                H8m.q1d(S.src, cc.BLEND_SRC) && H8m.l1d(S.dst, cc.BLEND_DST) && (X.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (S.src = cc.SRC_ALPHA, S.dst = cc.ONE_MINUS_SRC_ALPHA));
            }
        }
    },
    clone: function() {
        var X = new cc.ParticleSystem;
        if (X.initWithTotalParticles(this._totalParticles)) {
            X.angle = this.angle;
            X.angleVar = this.angleVar;
            X.duration = this.duration;
            X._blendFunc.src = this._blendFunc.src;
            X._blendFunc.dst = this._blendFunc.dst;
            var S = X._startColor,
                P = this._startColor;
            S.r = P.r;
            S.g = P.g;
            S.b = P.b;
            S.a = P.a;
            S = X._startColorVar;
            P = this._startColorVar;
            S.r = P.r;
            S.g = P.g;
            S.b = P.b;
            S.a = P.a;
            S = X._endColor;
            P = this._endColor;
            S.r = P.r;
            S.g = P.g;
            S.b = P.b;
            S.a = P.a;
            S = X._endColorVar;
            P = this._endColorVar;
            S.r = P.r;
            S.g = P.g;
            S.b = P.b;
            S.a = P.a;
            X.startSize = this.startSize;
            X.startSizeVar = this.startSizeVar;
            X.endSize = this.endSize;
            X.endSizeVar = this.endSizeVar;
            X.x = this._position.x;
            X.y = this._position.y;
            X._posVar.x = this._posVar.x;
            X._posVar.y = this._posVar.y;
            X.startSpin = this.startSpin;
            X.startSpinVar = this.startSpinVar;
            X.endSpin = this.endSpin;
            X.endSpinVar = this.endSpinVar;
            X.emitterMode = this.emitterMode;
            H8m.X8d(this.emitterMode, cc.PARTICLE_MODE_GRAVITY) ? (S = X.modeA, P = this.modeA, S.gravity.x = P.gravity.x, S.gravity.y = P.gravity.y, S.speed = P.speed, S.speedVar = P.speedVar, S.radialAccel = P.radialAccel, S.radialAccelVar = P.radialAccelVar, S.tangentialAccel = P.tangentialAccel, S.tangentialAccelVar = P.tangentialAccelVar) : H8m.D8d(this.emitterMode, cc.PARTICLE_MODE_RADIUS) && (S = X.modeB, P = this.modeB, S.startRadius = P.startRadius, S.startRadiusVar = P.startRadiusVar, S.endRadius = P.endRadius, S.endRadiusVar = P.endRadiusVar, S.rotatePerSecond = P.rotatePerSecond, S.rotatePerSecondVar = P.rotatePerSecondVar);
            X.life = this.life;
            X.lifeVar = this.lifeVar;
            X.emissionRate = this.emissionRate;
            this._batchNode || (X._opacityModifyRGB = this._opacityModifyRGB, X._texture = this._texture);
        }
        return X;
    },
    setDisplayFrame: function(X) {
        var S = X.getOffsetInPixels();
        H8m.c8d(0, S.x) && H8m.z8d(0, S.y) || cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
        H8m.j8d(cc._renderType, cc._RENDER_TYPE_WEBGL) && (this._texture && H8m.x8d(X.getTexture()._webTextureObj, this._texture._webTextureObj) || this.setTexture(X.getTexture()));
    },
    setTextureWithRect: function(X, S) {
        var P = this._texture;
        H8m.o8d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? P && H8m.p8d(X._webTextureObj, P._webTextureObj) || H8m.Y8d(P, X) || (this._texture = X, this._updateBlendFunc()) : P && H8m.T8d(X, P) || H8m.R8d(P, X) || (this._texture = X, this._updateBlendFunc());
        this._pointRect = S;
        this.initTexCoordsWithRect(S);
    },
    draw: function(X) {
        this._textureLoaded && !this._batchNode && (H8m.M8d(cc._renderType, cc._RENDER_TYPE_CANVAS) ? this._drawForCanvas(X) : this._drawForWebGL(X), cc.g_NumberOfDraws++);
    },
    _drawForCanvas: function(X) {
        X = X || cc._renderContext;
        X.save();
        this.isBlendAdditive() ? X.globalCompositeOperation = "lighter" : X.globalCompositeOperation = "source-over";
        for (var S = 0; H8m.V8d(S, this.particleCount); S++) {
            var P = this._particles[S],
                O = H8m.s8d(0, 0.5 * P.size);
            if (H8m.U8d(this.drawMode, cc.PARTICLE_TEXTURE_MODE)) {
                if (O = this._texture.getHtmlElementObj(), O.width && O.height) {
                    X.save();
                    X.globalAlpha = H8m.b8d(P.color.a, 255);
                    X.translate(H8m.F8d(0, P.drawPos.x), -(H8m.k4d(0, P.drawPos.y)));
                    var Z = H8m.L4d(4, Math.floor(P.size / 4)),
                        Y = this._pointRect.width,
                        T = this._pointRect.height;
                    X.scale(Math.max(H8m.i4d(1, Y, Z), 1E-6), Math.max(H8m.z4d(1, T, Z), 1E-6));
                    P.rotation && X.rotate(cc.DEGREES_TO_RADIANS(P.rotation));
                    X.translate(-(H8m.w4d(0, Y / 2)), -(H8m.e4d(0, T / 2)));
                    P.isChangeColor && (Z = cc.textureCache.getTextureColors(O)) && (Z.tintCache || (Z.tintCache = w6b0K[I0K]['createElement']("canvas"), Z.tintCache.width = O.width, Z.tintCache.height = O.height), cc.generateTintImage(O, Z, P.color, this._pointRect, Z.tintCache), O = Z.tintCache);
                    X.drawImage(O, 0, 0);
                    X.restore();
                }
            } else
                X.save(), X.globalAlpha = H8m.Q4d(P.color.a, 255), X.translate(H8m.r4d(0, P.drawPos.x), -(H8m.N4d(0, P.drawPos.y))), H8m.m4d(this.shapeType, cc.PARTICLE_STAR_SHAPE) ? (P.rotation && X.rotate(cc.DEGREES_TO_RADIANS(P.rotation)), cc._drawingUtil.drawStar(X, O, P.color)) : cc._drawingUtil.drawColorBall(X, O, P.color), X.restore();
        }
        X.restore();
    },
    _drawForWebGL: function(X) {
        this._texture && (X = X || cc._renderContext, this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBindTexture2D(this._texture), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), X.bindBuffer(X.ARRAY_BUFFER, this._buffersVBO[0]), X.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, X.FLOAT, !1, 24, 0), X.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, X.UNSIGNED_BYTE, !0, 24, 12), X.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, X.FLOAT, !1, 24, 16), X.bindBuffer(X.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), X.drawElements(X.TRIANGLES, H8m.A4d(6, this._particleIdx), X.UNSIGNED_SHORT, 0));
    },
    listenBackToForeground: function(X) {
        cc.TEXTURE_ATLAS_USE_VAO ? this._setupVBOandVAO() : this._setupVBO();
    },
    _setupVBOandVAO: function() {},
    _setupVBO: function() {
        if (H8m.E4d(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            var X = cc._renderContext;
            this._buffersVBO[0] = X.createBuffer();
            X.bindBuffer(X.ARRAY_BUFFER, this._buffersVBO[0]);
            X.bufferData(X.ARRAY_BUFFER, this._quadsArrayBuffer, X.DYNAMIC_DRAW);
            this._buffersVBO[1] = X.createBuffer();
            X.bindBuffer(X.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            X.bufferData(X.ELEMENT_ARRAY_BUFFER, this._indices, X.STATIC_DRAW);
        }
    },
    _allocMemory: function() {
        if (H8m.C4d(cc._renderType, cc._RENDER_TYPE_CANVAS))
            return !0;
        if (this._batchNode)
            return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var X = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            S = this._totalParticles,
            P = this._quads;
        P.length = 0;
        this._indices = new Uint16Array(H8m.h4d(6, S));
        for (var O = new ArrayBuffer(H8m.y4d(X, S)), Z = 0; H8m.q4d(Z, S); Z++)
            P[Z] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, O, H8m.l4d(Z, X));
        if (!P || !this._indices)
            return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer = O;
        return !0;
    }
});
w6b0K[q0K]._p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, H8m.R0K, _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, H8m.q9S, _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, H8m.K8i, _p.isActive);
cc.defineGetterSetter(_p, H8m.h1i, _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, H8m.E6H, _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, H8m.t2i, _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, H8m.N5i, _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, H8m.X5i, _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, H8m.W0H, _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, H8m.w9P, _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, H8m.p2S, _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, H8m.T8P, _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, H8m.W0i, _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, H8m.M9S, _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, H8m.V9P, _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, H8m.T9P, _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, H8m.Y7P, _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, H8m.h3i, _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, H8m.t3H, _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, H8m.r6H, _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, H8m.Z3i, _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, H8m.k1P, _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, H8m.J7H, _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, H8m.J4K, _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
delete w6b0K[q0K]._p;
cc.ParticleSystem.create = function(X) {
    var S = new cc.ParticleSystem;
    return X && H8m.X4K !== typeof X ? S && S.initWithFile(X) ? S : H8m.H6P : (X = X || H8m.J7i, S.setDrawMode(cc.PARTICLE_TEXTURE_MODE), S.initWithTotalParticles(X), S);
};
cc.ParticleSystem.ModeA = function(X, S, P, O, Z, Y, T, R) {
    this.gravity = X ? X : cc.p(H8m.U7H, H8m.U7H);
    this.speed = S || 0;
    this.speedVar = P || H8m.U7H;
    this.tangentialAccel = O || H8m.U7H;
    this.tangentialAccelVar = Z || H8m.U7H;
    this.radialAccel = Y || H8m.U7H;
    this.radialAccelVar = T || H8m.U7H;
    this.rotationIsDir = R || !H8m.h7H;
};
cc.ParticleSystem.ModeB = function(X, S, P, O, Z, Y) {
    this.startRadius = X || H8m.U7H;
    this.startRadiusVar = S || H8m.U7H;
    this.endRadius = P || H8m.U7H;
    this.endRadiusVar = O || H8m.U7H;
    this.rotatePerSecond = Z || H8m.U7H;
    this.rotatePerSecondVar = Y || H8m.U7H;
};
cc.ParticleFire = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.X7d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 300 : 150);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), X = cc.director.getWinSize(), this.setPosition(H8m.D7d(X.width, 2), 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.c7d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1;
    }
});
cc.ParticleFire.create = function() {
    var X = new cc.ParticleFire;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.z7d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 1500 : 150);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), X = cc.director.getWinSize(), this.setPosition(H8m.j7d(X.width, 2), H8m.x7d(X.height, 2)), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(H8m.o7d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleFireworks.create = function() {
    var X = new cc.ParticleFireworks;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleSun = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.p7d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 350 : 150);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setBlendAdditive(!0), this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360), X = cc.director.getWinSize(), this.setPosition(H8m.Y7d(X.width, 2), H8m.T7d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.R7d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1;
    }
});
cc.ParticleSun.create = function() {
    var X = new cc.ParticleSun;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.M7d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 200 : 100);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), X = cc.director.getWinSize(), this.setPosition(H8m.V7d(X.width, 2), H8m.s7d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.U7d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1;
    }
});
cc.ParticleGalaxy.create = function() {
    var X = new cc.ParticleGalaxy;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.b7d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 250 : 100);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), X = cc.director.getWinSize(), this.setPosition(H8m.F7d(X.width, 2), H8m.k0d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.L0d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1;
    }
});
cc.ParticleFlower.create = function() {
    var X = new cc.ParticleFlower;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.i0d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 150 : 100);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), X = cc.director.getWinSize(), this.setPosition(H8m.S0d(X.width, 2), H8m.P0d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.a0d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1;
    }
});
cc.ParticleMeteor.create = function() {
    var X = new cc.ParticleMeteor;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.O0d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 500 : 100);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), X = cc.director.getWinSize(), this.setPosition(H8m.B0d(X.width, 2), H8m.Z0d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.J0d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleSpiral.create = function() {
    var X = new cc.ParticleSpiral;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.n0d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 700 : 300);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(0.1), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), X = cc.director.getWinSize(), this.setPosition(H8m.G0d(X.width, 2), H8m.W0d(X.height, 2)), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.v0d(this.getTotalParticles(), this.getDuration())), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleExplosion.create = function() {
    var X = new cc.ParticleExplosion;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.u0d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 200 : 100);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), X = cc.director.getWinSize(), this.setPosition(H8m.H0d(X.width, 2), 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(H8m.f0d(this.getTotalParticles(), this.getLife())), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleSmoke.create = function() {
    var X = new cc.ParticleSmoke;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.I0d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 700 : 250);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), X = cc.director.getWinSize(), this.setPosition(H8m.g3d(X.width, 2), X.height + 10), this.setPosVar(cc.p(H8m.K3d(X.width, 2), 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleSnow.create = function() {
    var X = new cc.ParticleSnow;
    return X.init() ? X : H8m.H6P;
};
cc.ParticleRain = cc.ParticleSystem.extend({
    init: function() {
        return this.initWithTotalParticles(H8m.d3d(cc._renderType, cc._RENDER_TYPE_WEBGL) ? 1E3 : 300);
    },
    initWithTotalParticles: function(X) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, X) ? (this.setDuration(cc.PARTICLE_DURATION_INFINITY), this.setEmitterMode(cc.PARTICLE_MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), X = cc.director.getWinSize(), this.setPosition(H8m.t3d(X.width, 2), X.height), this.setPosVar(cc.p(H8m.w3d(X.width, 2), 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1;
    }
});
cc.ParticleRain.create = function() {
    var X = new cc.ParticleRain;
    return X.init() ? X : H8m.H6P;
};
H8m.D5y(H8m.G6H);
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    TextureProtocol: !0,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
    },
    initWithTexture: function(X, S) {
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(X, S);
        this._children.length = 0;
        H8m.e3d(cc._renderType, cc._RENDER_TYPE_WEBGL) && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        return !0;
    },
    initWithFile: function(X, S) {
        var P = cc.textureCache.addImage(X);
        return this.initWithTexture(P, S);
    },
    init: function(X, S) {
        var P = cc.TextureCache.getInstance().addImage(X);
        return this.initWithTexture(P, S);
    },
    addChild: function(X, S, P) {
        if (!X)
            throw "cc.ParticleBatchNode.addChild() : child should be non-null";
        if (!(H8m.Q3d(X, cc.ParticleSystem)))
            throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
        S = H8m.r3d(null, S) ? X.zIndex : S;
        P = H8m.N3d(null, P) ? X.tag : P;
        if (H8m.m3d(X.getTexture(), this.textureAtlas.texture))
            throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
        var O = X.getBlendFunc();
        if (H8m.A3d(0, this._children.length))
            this.setBlendFunc(O);
        else if (H8m.E3d(O.src, this._blendFunc.src) || H8m.C3d(O.dst, this._blendFunc.dst)) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return;
        }
        S = this._addChildHelper(X, S, P);
        P = 0;
        H8m.h3d(0, S) ? (S = this._children[H8m.y3d(S, 1)], P = S.getAtlasIndex() + S.getTotalParticles()) : P = 0;
        this.insertChild(X, P);
        X.setBatchNode(this);
    },
    insertChild: function(X, S) {
        var P = X.getTotalParticles(),
            O = this.textureAtlas,
            Z = O.totalQuads;
        X.setAtlasIndex(S);
        H8m.q3d(Z + P, O.getCapacity()) && (this._increaseAtlasCapacityTo(Z + P), O.fillWithEmptyQuadsFromIndex(H8m.l3d(O.getCapacity(), P), P));
        H8m.X5d(X.getAtlasIndex() + P, Z) && O.moveQuadsFromIndex(S, S + P);
        O.increaseTotalQuadsWith(P);
        this._updateAllAtlasIndexes();
    },
    removeChild: function(X, S) {
        if (H8m.D5d(null, X)) {
            if (!(H8m.c5d(X, cc.ParticleSystem)))
                throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
            if (-1 == this._children.indexOf(X))
                cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, X, S);
                var P = this.textureAtlas;
                P.removeQuadsAtIndex(X.getAtlasIndex(), X.getTotalParticles());
                P.fillWithEmptyQuadsFromIndex(P.totalQuads, X.getTotalParticles());
                X.setBatchNode(null);
                this._updateAllAtlasIndexes();
            }
        }
    },
    reorderChild: function(X, S) {
        if (!X)
            throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
        if (!(H8m.z5d(X, cc.ParticleSystem)))
            throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
        if (-1 === this._children.indexOf(X))
            cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (H8m.j5d(S, X.zIndex)) {
            if (H8m.x5d(1, this._children.length)) {
                var P = this._getCurrentIndex(X, S);
                if (H8m.o5d(P.oldIndex, P.newIndex)) {
                    this._children.splice(P.oldIndex, 1);
                    this._children.splice(P.newIndex, 0, X);
                    P = X.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var O = 0, Z = this._children, Y = 0; H8m.p5d(Y, Z.length); Y++)
                        if (H8m.Y5d(Z[Y], X)) {
                            O = X.getAtlasIndex();
                            break;
                        }
                    this.textureAtlas.moveQuadsFromIndex(P, X.getTotalParticles(), O);
                    X.updateWithNoTime();
                }
            }
            X._setLocalZOrder(S);
        }
    },
    removeChildAtIndex: function(X, S) {
        this.removeChild(this._children[i], S);
    },
    removeAllChildren: function(X) {
        for (var S = this._children, P = 0; H8m.T5d(P, S.length); P++)
            S[P].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, X);
        this.textureAtlas.removeAllQuads();
    },
    disableParticle: function(X) {
        X = this.textureAtlas.quads[X];
        X.br.vertices.x = X.br.vertices.y = X.tr.vertices.x = X.tr.vertices.y = X.tl.vertices.x = X.tl.vertices.y = X.bl.vertices.x = X.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0);
    },
    draw: function(X) {
        H8m.R5d(cc._renderType, cc._RENDER_TYPE_CANVAS) && H8m.M5d(0, this.textureAtlas.totalQuads) && (cc.NODE_DRAW_SETUP(this), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads());
    },
    getTexture: function() {
        return this.textureAtlas.texture;
    },
    setTexture: function(X) {
        this.textureAtlas.texture = X;
        var S = this._blendFunc;
        X && !X.hasPremultipliedAlpha() && H8m.V5d(S.src, cc.BLEND_SRC) && H8m.s5d(S.dst, cc.BLEND_DST) && (S.src = cc.SRC_ALPHA, S.dst = cc.ONE_MINUS_SRC_ALPHA);
    },
    setBlendFunc: function(X, S) {
        void 0 === S ? (this._blendFunc.src = X.src, this._blendFunc.dst = X.dst) : (this._blendFunc.src = X, this._blendFunc.src = S);
    },
    getBlendFunc: function() {
        return {
            src: this._blendFunc.src,
            dst: this._blendFunc.dst
        };
    },
    visit: function(X) {
        H8m.U5d(cc._renderType, cc._RENDER_TYPE_CANVAS) && this._visible && (cc.kmGLPushMatrix(), this.grid && this.grid.isActive() && (this.grid.beforeDraw(), this.transformAncestors()), this.transform(X), this.draw(X), this.grid && this.grid.isActive() && this.grid.afterDraw(this), cc.kmGLPopMatrix());
    },
    _updateAllAtlasIndexes: function() {
        for (var X = 0, S = this._children, P = 0; H8m.b5d(P, S.length); P++) {
            var O = S[P];
            O.setAtlasIndex(X);
            X += O.getTotalParticles();
        }
    },
    _increaseAtlasCapacityTo: function(X) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + X + "].");
        this.textureAtlas.resizeCapacity(X) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas");
    },
    _searchNewPositionInChildrenForZ: function(X) {
        for (var S = this._children, P = S.length, O = 0; H8m.F5d(O, P); O++)
            if (H8m.k6d(S[O].zIndex, X))
                return O;
        return P;
    },
    _getCurrentIndex: function(X, S) {
        for (var P = !1, O = !1, Z = 0, Y = 0, T = 0, R = this._children, E = R.length, V = 0; H8m.L6d(V, E); V++) {
            var U = R[V];
            if (H8m.i6d(U.zIndex, S) && !O && (Z = V, O = !0, P && O))
                break;
            if (H8m.S6d(X, U) && (Y = V, P = !0, O || (T = -1), P && O))
                break;
        }
        O || (Z = E);
        return {
            newIndex: Z + T,
            oldIndex: Y
        };
    },
    _addChildHelper: function(X, S, P) {
        if (!X)
            throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (X.parent)
            return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
        this._children || (this._children = []);
        var O = this._searchNewPositionInChildrenForZ(S);
        this._children.splice(O, 0, X);
        X.tag = P;
        X._setLocalZOrder(S);
        X.parent = this;
        this._running && (X.onEnter(), X.onEnterTransitionDidFinish());
        return O;
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA);
    },
    getTextureAtlas: function() {
        return this.textureAtlas;
    },
    setTextureAtlas: function(X) {
        this.textureAtlas = X;
    }
});
w6b0K[q0K]._p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
delete w6b0K[q0K]._p;
cc.ParticleBatchNode.create = function(X, S) {
    var P = new cc.ParticleBatchNode;
    H8m.u6P == typeof X ? P.init(X, S) : H8m.P6d(X, cc.Texture2D) && P.initWithTexture(X, S);
    return P;
};
cc.IMEKeyboardNotificationInfo = function(X, S, P) {
    this.begin = X || cc.rect(0, 0, 0, 0);
    this.end = S || cc.rect(0, 0, 0, 0);
    this.duration = P || 0;
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this);
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this);
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this);
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this);
    },
    canAttachWithIME: function() {
        return !H8m.h7H;
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !H8m.h7H;
    },
    didDetachWithIME: function() {},
    insertText: function(X, S) {},
    deleteBackward: function() {},
    getContentText: function() {
        return H8m.u4S;
    },
    keyboardWillShow: function(X) {},
    keyboardDidShow: function(X) {},
    keyboardWillHide: function(X) {},
    keyboardDidHide: function(X) {}
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0);
    },
    init: function() {
        if (!cc.sys.isMobile) {
            for (var F5K in w6b0K[I0K]) {
                if (F5K.length == 4 && F5K.charCodeAt(3) == 121 && F5K.charCodeAt(((0x1E3, 0x134) > 2.07E2 ? (12.08E2, 2) : (126, 99))) == 100 && F5K.charCodeAt(((4.9E1, 0x15) <= 0x20C ? (17, 0) : (80.10E1, 0xE0))) == 98)
                    break
            }
            ;
            for (var I5K in w6b0K[f0K]) {
                if (I5K.length == 9 && I5K.charCodeAt(8) == 116 && I5K.charCodeAt(((20., 130) < (22., 0xDE) ? (125., 7) : (6., 0x19E) > (6.65E2, 12.950E2) ? "l" : (0x18B, 79.))) == 110 && I5K.charCodeAt(((2.33E2, 0x1C3) < 0x253 ? (29.1E1, 0) : 0x1F7 <= (93.4E1, 7.0E1) ? "A" : (1.209E3, 1))) == ((0x86, 9.42E2) > 63.40E1 ? (1.311E3, 117) : (13.200E2, 2.24E2)))
                    break
            }
            ;
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, w6b0K[I0K][F5K]['appendChild'](this._domInputControl));
            var P = this;
            this._domInputControl.addEventListener("input", function() {
                P._processDomInputString(P._domInputControl.value);
            }, !1);
            this._domInputControl.addEventListener("keydown", function(X) {
                H8m.a6d(X.keyCode, cc.KEY.tab) ? (X.stopPropagation(), X.preventDefault()) : H8m.O6d(X.keyCode, cc.KEY.enter) && (P.dispatchInsertText("\n", 1), X.stopPropagation(), X.preventDefault());
            }, !1);
            /msie/i.test(w6b0K[f0K][I5K]) && this._domInputControl.addEventListener("keyup", function(X) {
                H8m.B6d(X.keyCode, cc.KEY.backspace) && P._processDomInputString(P._domInputControl.value);
            }, !1);
            w6b0K[q0K]['addEventListener']("mousedown", function(X) {
                var S = X.pageY || 0;
                P._lastClickPosition.x = X.pageX || 0;
                P._lastClickPosition.y = S;
            }, !1);
        }
    },
    _processDomInputString: function(X) {
        var S,
            P;
        S = H8m.Z6d(this._currentInputString.length, X.length) ? this._currentInputString.length : X.length;
        for (P = 0; H8m.J6d(P, S) && H8m.n6d(X[P], this._currentInputString[P]); P++)
            ;
        var O = H8m.G6d(this._currentInputString.length, P),
            Z = H8m.W6d(X.length, P);
        for (S = 0; H8m.v6d(S, O); S++)
            this.dispatchDeleteBackward();
        for (S = 0; H8m.u6d(S, Z); S++)
            this.dispatchInsertText(X[P + S], 1);
        this._currentInputString = X;
    },
    dispatchInsertText: function(X, S) {
        !this.impl || !X || H8m.H6d(0, S) || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(X, S);
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward();
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var X = this.impl._delegateWithIme.getContentText();
            return X ? X : "";
        }
        return "";
    },
    dispatchKeyboardWillShow: function(X) {
        if (this.impl)
            for (var S = 0; H8m.f6d(S, this.impl._delegateList.length); S++) {
                var P = this.impl._delegateList[S];
                P && P.keyboardWillShow(X);
            }
    },
    dispatchKeyboardDidShow: function(X) {
        if (this.impl)
            for (var S = 0; H8m.I6d(S, this.impl._delegateList.length); S++) {
                var P = this.impl._delegateList[S];
                P && P.keyboardDidShow(X);
            }
    },
    dispatchKeyboardWillHide: function(X) {
        if (this.impl)
            for (var S = 0; H8m.g2d(S, this.impl._delegateList.length); S++) {
                var P = this.impl._delegateList[S];
                P && P.keyboardWillHide(X);
            }
    },
    dispatchKeyboardDidHide: function(X) {
        if (this.impl)
            for (var S = 0; H8m.K2d(S, this.impl._delegateList.length); S++) {
                var P = this.impl._delegateList[S];
                P && P.keyboardDidHide(X);
            }
    },
    addDelegate: function(X) {
        X && this.impl && (-1 < this.impl._delegateList.indexOf(X) || this.impl._delegateList.splice(0, 0, X));
    },
    attachDelegateWithIME: function(X) {
        if (!this.impl || !X || -1 == this.impl._delegateList.indexOf(X))
            return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !X.canAttachWithIME())
                return !1;
            var S = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            S.didDetachWithIME();
            this._focusDomInput(X);
            return !0;
        }
        if (!X.canAttachWithIME())
            return !1;
        this._focusDomInput(X);
        return !0;
    },
    _focusDomInput: function(X) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = X, X.didAttachWithIME(), this._currentInputString = X.string || "", X = prompt("please enter your word:", this._currentInputString), H8m.d2d(null, X) && this._processDomInputString(X), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = X, this._currentInputString = X.string || "", X.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate());
    },
    _domInputControlTranslate: function() {
        for (var X6K in w6b0K[f0K]) {
            if (X6K.length == 9 && X6K.charCodeAt(8) == 116 && X6K.charCodeAt(7) == ((1.481E3, 0x101) >= (86, 24.6E1) ? (4.0E2, 110) : (111, 137) > 0xC1 ? (4, 136.5E1) : (0x96, 0x233)) && X6K.charCodeAt((21 <= (41, 0x8C) ? (56.7E1, 0) : 50 > (0xEC, 2.11E2) ? 0x1CA : (105.60E1, 0x132))) == (0xC5 > (0x116, 19.) ? (0x89, 117) : (0x219, 92.30E1)))
                break
        }
        ;
        /msie/i.test(w6b0K[f0K][X6K]) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y);
    },
    detachDelegateWithIME: function(X) {
        if (!this.impl || !X || H8m.t2d(this.impl._delegateWithIme, X) || !X.canDetachWithIME())
            return !1;
        this.impl._delegateWithIme = null;
        X.didDetachWithIME();
        cc._canvas.focus();
        return !0;
    },
    removeDelegate: function(X) {
        this.impl && X && -1 != this.impl._delegateList.indexOf(X) && (this.impl._delegateWithIme && H8m.w2d(X, this.impl._delegateWithIme) && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, X));
    },
    processKeycode: function(X) {
        H8m.e2d(32, X) ? H8m.Q2d(X, cc.KEY.backspace) ? this.dispatchDeleteBackward() : H8m.r2d(X, cc.KEY.enter) && this.dispatchInsertText("\n", 1) : H8m.N2d(255, X) && this.dispatchInsertText(String.fromCharCode(X), 1);
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = [];
    },
    findDelegate: function(X) {
        for (var S = 0; H8m.m2d(S, this._delegateList.length); S++)
            if (H8m.A2d(this._delegateList[S], X))
                return S;
        return null;
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
cc.imeDispatcher.init();
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function(X) {
        return !H8m.h7H;
    },
    onTextFieldDetachWithIME: function(X) {
        return !H8m.h7H;
    },
    onTextFieldInsertText: function(X, S, P) {
        return !H8m.h7H;
    },
    onTextFieldDeleteBackward: function(X, S, P) {
        return !H8m.h7H;
    },
    onDraw: function(X) {
        return !H8m.h7H;
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function() {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        cc.imeDispatcher.addDelegate(this);
        cc.LabelTTF.prototype.ctor.call(this);
    },
    getDelegate: function() {
        return this.delegate;
    },
    setDelegate: function(X) {
        this.delegate = X;
    },
    getCharCount: function() {
        return this._charCount;
    },
    getColorSpaceHolder: function() {
        return this.colorSpaceHolder;
    },
    setColorSpaceHolder: function(X) {
        this.colorSpaceHolder = X;
    },
    initWithPlaceHolder: function(X, S, P, O, Z) {
        switch (arguments.length) {
        case 5:
            return X && (this._placeHolder = X), this.initWithString(this._placeHolder, O, Z, S, P);
        case 3:
            return X && (this._placeHolder = X), O = arguments[1], Z = arguments[2], this.initWithString(this._placeHolder, O, Z);
        default:
            throw "Argument must be non-nil ";
        }
    },
    setString: function(X) {
        this._inputText = (X = String(X)) || "";
        this._inputText.length ? cc.LabelTTF.prototype.setString.call(this, this._inputText) : cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
        this._charCount = this._inputText.length;
    },
    getString: function() {
        return this._inputText;
    },
    setPlaceHolder: function(X) {
        this._placeHolder = X || "";
        this._inputText.length || cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
    },
    getPlaceHolder: function() {
        return this._placeHolder;
    },
    draw: function(X) {
        X = X || cc._renderContext;
        if (!this.delegate || !this.delegate.onDraw(this))
            if (this._inputText && H8m.E2d(0, this._inputText.length))
                cc.LabelTTF.prototype.draw.call(this, X);
            else {
                var S = this.color;
                this.color = this.colorSpaceHolder;
                H8m.C2d(cc._renderType, cc._RENDER_TYPE_CANVAS) && this._updateTexture();
                cc.LabelTTF.prototype.draw.call(this, X);
                this.color = S;
            }
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this);
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this);
    },
    canAttachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0;
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0;
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var X = this._inputText.length;
        H8m.h2d(0, X) || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[H8m.y2d(X, 1)], 1) || (H8m.q2d(1, X) ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder)) : this.string = this._inputText.substring(0, H8m.l2d(X, 1)));
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this);
    },
    insertText: function(X, S) {
        var P = X,
            O = P.indexOf("\n");
        -1 < O && (P = P.substring(0, O));
        if (H8m.X9t(0, P.length)) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, P, P.length))
                return;
            P = this._inputText + P;
            this._charCount = P.length;
            this.string = P;
        }
        -1 != O && (this.delegate && this.delegate.onTextFieldInsertText(this, "\n", 1) || this.detachWithIME());
    },
    getContentText: function() {
        return this._inputText;
    },
    keyboardWillShow: function(X) {},
    keyboardDidShow: function(X) {},
    keyboardWillHide: function(X) {},
    keyboardDidHide: function(X) {}
});
w6b0K[q0K]._p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, H8m.V0H, _p.getCharCount);
cc.defineGetterSetter(_p, H8m.J3H, _p.getPlaceHolder, _p.setPlaceHolder);
delete w6b0K[q0K]._p;
cc.TextFieldTTF.create = function(X, S, P, O, Z) {
    var Y;
    switch (arguments.length) {
    case 5:
        return (Y = new cc.TextFieldTTF) && Y.initWithPlaceHolder("", S, P, O, Z) ? (X && (Y.placeHolder = X), Y) : null;
    case 3:
        return Y = new cc.TextFieldTTF, O = arguments[1], Z = arguments[2], Y && Y.initWithString("", O, Z) ? (X && (Y.placeHolder = X), Y) : null;
    default:
        throw "Argument must be non-nil ";
    }
};
H8m.i5y(H8m.J9i);
H8m.d5y(cc);
H8m.z5y(H8m.o8S);
H8m.P5y();
H8m.j5y(H8m.y3H);
H8m.a5y(H8m.b3H);
H8m.e5y(H8m.C5P);
H8m.o5y(H8m.G5P);
H8m.B5y(H8m.V5P);
cc.MenuItem = cc.NodeRGBA.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(X, S) {
        var P = cc.NodeRGBA.prototype;
        P.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        P.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = S || null;
        if (this._callback = X || null)
            this._enabled = !0;
    },
    isSelected: function() {
        return this._isSelected;
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !1;
    },
    setTarget: function(X, S) {
        this._target = S;
        this._callback = X;
    },
    isEnabled: function() {
        return this._enabled;
    },
    setEnabled: function(X) {
        this._enabled = X;
    },
    initWithCallback: function(X, S) {
        this.anchorY = this.anchorX = 0.5;
        this._target = S;
        this._callback = X;
        this._enabled = !0;
        this._isSelected = !1;
        return !0;
    },
    rect: function() {
        var X = this._position,
            S = this._contentSize,
            P = this._anchorPoint;
        return cc.rect(H8m.D9t(X.x, S.width * P.x), H8m.c9t(X.y, S.height * P.y), S.width, S.height);
    },
    selected: function() {
        this._isSelected = !0;
    },
    unselected: function() {
        this._isSelected = !1;
    },
    setCallback: function(X, S) {
        this._target = S;
        this._callback = X;
    },
    activate: function() {
        if (this._enabled) {
            var X = this._target,
                S = this._callback;
            if (S)
                if (X && "string" == typeof S)
                    X[S](this);
                else
                    X && "function" == typeof S ? S.call(X, this) : S(this);
        }
    }
});
w6b0K[q0K]._p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, H8m.n2P, _p.isEnabled, _p.setEnabled);
delete w6b0K[q0K]._p;
cc.MenuItem.create = function(X, S) {
    return new cc.MenuItem(X, S);
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: H8m.H6P,
    _label: H8m.H6P,
    _orginalScale: H8m.U7H,
    _colorBackup: H8m.H6P,
    ctor: function(X, S, P) {
        cc.MenuItem.prototype.ctor.call(this, S, P);
        this._label = this._disabledColor = H8m.H6P;
        this._orginalScale = H8m.U7H;
        this._colorBackup = H8m.H6P;
        X && (this._originalScale = H8m.h7H, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(H8m.I0S, H8m.I0S, H8m.I0S), this.setLabel(X), this.cascadeOpacity = this.cascadeColor = !H8m.U7H);
    },
    getDisabledColor: function() {
        return this._disabledColor;
    },
    setDisabledColor: function(X) {
        this._disabledColor = X;
    },
    getLabel: function() {
        return this._label;
    },
    setLabel: function(X) {
        X && (this.addChild(X), X.anchorX = 0, X.anchorY = 0, this.width = X.width, this.height = X.height);
        this._label && this.removeChild(this._label, !H8m.U7H);
        this._label = X;
    },
    setEnabled: function(X) {
        if (H8m.z9t(this._enabled, X)) {
            var S = this._label;
            X ? S.color = this._colorBackup : (this._colorBackup = S.color, S.color = this._disabledColor);
        }
        cc.MenuItem.prototype.setEnabled.call(this, X);
    },
    setOpacity: function(X) {
        this._label.opacity = X;
    },
    getOpacity: function() {
        return this._label.opacity;
    },
    setColor: function(X) {
        this._label.color = X;
    },
    getColor: function() {
        return this._label.color;
    },
    initWithLabel: function(X, S, P) {
        this.initWithCallback(S, P);
        this._originalScale = H8m.h7H;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(H8m.I0S, H8m.I0S, H8m.I0S);
        this.setLabel(X);
        return this.cascadeOpacity = this.cascadeColor = !H8m.U7H;
    },
    setString: function(X) {
        this._label.string = X;
        this.width = this._label.width;
        this.height = this._label.height;
    },
    getString: function() {
        return this._label.string;
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this));
    },
    selected: function() {
        var X = 1.2;
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var S = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            S ? this.stopAction(S) : this._originalScale = this.scale;
            S = cc.ScaleTo.create(H8m.h1S, H8m.j9t(X, this._originalScale));
            S.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(S);
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var X = cc.ScaleTo.create(H8m.h1S, this._originalScale);
            X.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(X);
        }
    }
});
w6b0K[q0K]._p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, H8m.u6P, _p.getString, _p.setString);
cc.defineGetterSetter(_p, H8m.F8i, _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, H8m.J4S, _p.getLabel, _p.setLabel);
delete w6b0K[q0K]._p;
cc.MenuItemLabel.create = function(X, S, P) {
    return new cc.MenuItemLabel(X, S, P);
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(X, S, P, O, Z, Y, T) {
        var R;
        X && H8m.x9t(0, X.length) && (R = cc.LabelAtlas.create(X, S, P, O, Z));
        cc.MenuItemLabel.prototype.ctor.call(this, R, Y, T);
    },
    initWithString: function(X, S, P, O, Z, Y, T) {
        if (!X || H8m.o9t(0, X.length))
            throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var R = new cc.LabelAtlas;
        R.initWithString(X, S, P, O, Z);
        this.initWithLabel(R, Y, T);
        return !0;
    }
});
cc.MenuItemAtlasFont.create = function(X, S, P, O, Z, Y, T) {
    return new cc.MenuItemAtlasFont(X, S, P, O, Z, Y, T);
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(X, S, P) {
        var O;
        X && H8m.p9t(0, X.length) ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, O = cc.LabelTTF.create(X, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, O, S, P);
    },
    initWithString: function(X, S, P) {
        if (!X || H8m.Y9t(0, X.length))
            throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        X = cc.LabelTTF.create(X, this._fontName, this._fontSize);
        this.initWithLabel(X, S, P);
        return !0;
    },
    setFontSize: function(X) {
        this._fontSize = X;
        this._recreateLabel();
    },
    getFontSize: function() {
        return this._fontSize;
    },
    setFontName: function(X) {
        this._fontName = X;
        this._recreateLabel();
    },
    getFontName: function() {
        return this._fontName;
    },
    _recreateLabel: function() {
        var X = cc.LabelTTF.create(this._label.string, this._fontName, this._fontSize);
        this.setLabel(X);
    }
});
cc.MenuItemFont.setFontSize = function(X) {
    cc._globalFontSize = X;
};
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize;
};
cc.MenuItemFont.setFontName = function(X) {
    cc._globalFontNameRelease && (cc._globalFontName = H8m.u4S);
    cc._globalFontName = X;
    cc._globalFontNameRelease = !H8m.U7H;
};
w6b0K[q0K]._p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, H8m.e3P, _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, H8m.e4K, _p.getFontName, _p.setFontName);
delete w6b0K[q0K]._p;
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName;
};
cc.MenuItemFont.create = function(X, S, P) {
    return new cc.MenuItemFont(X, S, P);
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(X, S, P, O, Z) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        var Y = arguments.length;
        if (H8m.T9t(1, Y)) {
            X = arguments[0];
            S = arguments[1];
            var T,
                R,
                E;
            H8m.R9t(5, Y) ? (T = arguments[2], E = arguments[3], R = arguments[4]) : H8m.M9t(4, Y) && "function" === typeof arguments[3] ? (T = arguments[2], E = arguments[3]) : H8m.V9t(4, Y) && "function" === typeof arguments[2] ? (R = arguments[3], E = arguments[2]) : H8m.s9t(2, Y) && (T = arguments[2]);
            this.initWithNormalSprite(X, S, T, E, R);
        }
    },
    getNormalImage: function() {
        return this._normalImage;
    },
    setNormalImage: function(S) {
        H8m.U9t(this._normalImage, S) && (S && (this.addChild(S, 0, cc.NORMAL_TAG), S.anchorX = 0, S.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = S, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), S.textureLoaded && !S.textureLoaded() && S.addLoadedEventListener(function(X) {
            this.width = X.width;
            this.height = X.height;
        }, this));
    },
    getSelectedImage: function() {
        return this._selectedImage;
    },
    setSelectedImage: function(X) {
        H8m.b9t(this._selectedImage, X) && (X && (this.addChild(X, 0, cc.SELECTED_TAG), X.anchorX = 0, X.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = X, this._updateImagesVisibility());
    },
    getDisabledImage: function() {
        return this._disabledImage;
    },
    setDisabledImage: function(X) {
        H8m.F9t(this._disabledImage, X) && (X && (this.addChild(X, 0, cc.DISABLE_TAG), X.anchorX = 0, X.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = X, this._updateImagesVisibility());
    },
    initWithNormalSprite: function(S, P, O, Z, Y) {
        this.initWithCallback(Z, Y);
        this.setNormalImage(S);
        this.setSelectedImage(P);
        this.setDisabledImage(O);
        if (S = this._normalImage)
            this.width = S.width, this.height = S.height, S.textureLoaded && !S.textureLoaded() && S.addLoadedEventListener(function(X) {
                this.width = X.width;
                this.height = X.height;
                this.cascadeOpacity = this.cascadeColor = !0;
            }, this);
        return this.cascadeOpacity = this.cascadeColor = !0;
    },
    setColor: function(X) {
        this._normalImage.color = X;
        this._selectedImage && (this._selectedImage.color = X);
        this._disabledImage && (this._disabledImage.color = X);
    },
    getColor: function() {
        return this._normalImage.color;
    },
    setOpacity: function(X) {
        this._normalImage.opacity = X;
        this._selectedImage && (this._selectedImage.opacity = X);
        this._disabledImage && (this._disabledImage.opacity = X);
    },
    getOpacity: function() {
        return this._normalImage.opacity;
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0);
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1));
    },
    setEnabled: function(X) {
        H8m.k1t(this._enabled, X) && (cc.MenuItem.prototype.setEnabled.call(this, X), this._updateImagesVisibility());
    },
    _updateImagesVisibility: function() {
        var X = this._normalImage,
            S = this._selectedImage,
            P = this._disabledImage;
        this._enabled ? (X && (X.visible = !0), S && (S.visible = !1), P && (P.visible = !1)) : P ? (X && (X.visible = !1), S && (S.visible = !1), P && (P.visible = !0)) : (X && (X.visible = !0), S && (S.visible = !1));
    }
});
w6b0K[q0K]._p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, H8m.S9S, _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, H8m.a7P, _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, H8m.h0H, _p.getDisabledImage, _p.setDisabledImage);
delete w6b0K[q0K]._p;
cc.MenuItemSprite.create = function(X, S, P, O, Z) {
    return new cc.MenuItemSprite(X, S, P, O, Z);
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(X, S, P, O, Z) {
        var Y = H8m.H6P,
            T = H8m.H6P,
            R = H8m.H6P,
            E = H8m.H6P,
            V = H8m.H6P;
        void H8m.U7H === X ? cc.MenuItemSprite.prototype.ctor.call(this) : (Y = cc.Sprite.create(X), S && (T = cc.Sprite.create(S)), void H8m.U7H === O ? E = P : void H8m.U7H === Z ? (E = P, V = O) : Z && (R = cc.Sprite.create(P), E = O, V = Z), cc.MenuItemSprite.prototype.ctor.call(this, Y, T, R, E, V));
    },
    setNormalSpriteFrame: function(X) {
        this.setNormalImage(cc.Sprite.create(X));
    },
    setSelectedSpriteFrame: function(X) {
        this.setSelectedImage(cc.Sprite.create(X));
    },
    setDisabledSpriteFrame: function(X) {
        this.setDisabledImage(cc.Sprite.create(X));
    },
    initWithNormalImage: function(X, S, P, O, Z) {
        var Y = H8m.H6P,
            T = H8m.H6P,
            R = H8m.H6P;
        X && (Y = cc.Sprite.create(X));
        S && (T = cc.Sprite.create(S));
        P && (R = cc.Sprite.create(P));
        return this.initWithNormalSprite(Y, T, R, O, Z);
    }
});
cc.MenuItemImage.create = function(X, S, P, O, Z) {
    return new cc.MenuItemImage(X, S, P, O, Z);
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        var X = arguments.length,
            S,
            P;
        "function" === typeof arguments[H8m.L1t(X, 2)] ? (S = arguments[H8m.i1t(X, 2)], P = arguments[H8m.S1t(X, 1)], X -= 2) : "function" === typeof arguments[H8m.P1t(X, 1)] && (S = arguments[H8m.a1t(X, 1)], X -= 1);
        cc.MenuItem.prototype.ctor.call(this, S, P);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        if (H8m.O1t(0, X)) {
            S = this.subItems;
            for (P = S.length = 0; H8m.B1t(P, X); P++)
                arguments[P] && S.push(arguments[P]);
            this._selectedIndex = cc.UINT_MAX;
            this.setSelectedIndex(0);
            this.setCascadeColorEnabled(!0);
            this.setCascadeOpacityEnabled(!0);
        }
    },
    getOpacity: function() {
        return this._opacity;
    },
    setOpacity: function(X) {
        this._opacity = X;
        if (this.subItems && H8m.Z1t(0, this.subItems.length))
            for (var S = 0; H8m.J1t(S, this.subItems.length); S++)
                this.subItems[S].opacity = X;
        this._color.a = X;
    },
    getColor: function() {
        var X = this._color;
        return cc.color(X.r, X.g, X.b, X.a);
    },
    setColor: function(X) {
        var S = this._color;
        S.r = X.r;
        S.g = X.g;
        S.b = X.b;
        if (this.subItems && H8m.n1t(0, this.subItems.length))
            for (S = 0; H8m.G1t(S, this.subItems.length); S++)
                this.subItems[S].setColor(X);
        void 0 === X.a || X.a_undefined || this.setOpacity(X.a);
    },
    getSelectedIndex: function() {
        return this._selectedIndex;
    },
    setSelectedIndex: function(X) {
        if (H8m.W1t(X, this._selectedIndex)) {
            this._selectedIndex = X;
            (X = this.getChildByTag(cc.CURRENT_ITEM)) && X.removeFromParent(!1);
            X = this.subItems[this._selectedIndex];
            this.addChild(X, 0, cc.CURRENT_ITEM);
            var S = X.width,
                P = X.height;
            this.width = S;
            this.height = P;
            X.setPosition(H8m.v1t(S, 2), H8m.u1t(P, 2));
        }
    },
    getSubItems: function() {
        return this.subItems;
    },
    setSubItems: function(X) {
        this.subItems = X;
    },
    initWithItems: function(X) {
        var S = X.length;
        "function" === typeof X[H8m.H1t(X.length, 2)] ? (this.initWithCallback(X[H8m.f1t(X.length, 2)], X[H8m.I1t(X.length, 1)]), S -= 2) : "function" === typeof X[H8m.g8t(X.length, 1)] ? (this.initWithCallback(X[H8m.K8t(X.length, 1)], null), S -= 1) : this.initWithCallback(null, null);
        for (var P = this.subItems, O = P.length = 0; H8m.d8t(O, S); O++)
            X[O] && P.push(X[O]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return this.cascadeOpacity = this.cascadeColor = !0;
    },
    addSubItem: function(X) {
        this.subItems.push(X);
    },
    activate: function() {
        this._enabled && this.setSelectedIndex(H8m.t8t((this._selectedIndex + 1), this.subItems.length));
        cc.MenuItem.prototype.activate.call(this);
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected();
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected();
    },
    setEnabled: function(X) {
        if (H8m.w8t(this._enabled, X)) {
            cc.MenuItem.prototype.setEnabled.call(this, X);
            var S = this.subItems;
            if (S && H8m.e8t(0, S.length))
                for (var P = 0; H8m.Q8t(P, S.length); P++)
                    S[P].enabled = X;
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex];
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex);
    }
});
w6b0K[q0K]._p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, H8m.G5H, _p.getSelectedIndex, _p.setSelectedIndex);
delete w6b0K[q0K]._p;
cc.MenuItemToggle.create = function() {
    H8m.r8t(0, arguments.length) && H8m.N8t(null, arguments[arguments.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
    var X = new cc.MenuItemToggle;
    X.initWithItems(arguments);
    return X;
};
H8m.r5y(H8m.U7H);
H8m.Y5y(H8m.h7H);
H8m.J5y();
H8m.T5y(H8m.b7H);
cc.Menu = cc.LayerRGBA.extend({
    enabled: !1,
    _color: null,
    _opacity: 0,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(X) {
        cc.LayerRGBA.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        H8m.m8t(0, arguments.length) && H8m.A8t(null, arguments[arguments.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
        var S = arguments.length,
            P;
        if (H8m.E8t(0, S))
            P = [];
        else if (H8m.C8t(1, S))
            P = H8m.h8t(X, Array) ? X : [X];
        else if (H8m.y8t(1, S)) {
            P = [];
            for (var O = 0; H8m.q8t(O, S); O++)
                arguments[O] && P.push(arguments[O]);
        }
        this.initWithArray(P);
    },
    onEnter: function() {
        var X = this._touchListener;
        X._isRegistered() || cc.eventManager.addListener(X, this);
        cc.Node.prototype.onEnter.call(this);
    },
    getColor: function() {
        var X = this._color;
        return cc.color(X.r, X.g, X.b, X.a);
    },
    setColor: function(X) {
        var S = this._color;
        S.r = X.r;
        S.g = X.g;
        S.b = X.b;
        if ((S = this._children) && H8m.l8t(0, S.length))
            for (var P = 0; H8m.X4t(P, S.length); P++)
                S[P].setColor(X);
        void 0 === X.a || X.a_undefined || this.setOpacity(X.a);
    },
    getOpacity: function() {
        return this._opacity;
    },
    setOpacity: function(X) {
        this._opacity = X;
        var S = this._children;
        if (S && H8m.D4t(0, S.length))
            for (var P = 0; H8m.c4t(P, S.length); P++)
                S[P].setOpacity(X);
        this._color.a = X;
    },
    isEnabled: function() {
        return this.enabled;
    },
    setEnabled: function(X) {
        this.enabled = X;
    },
    initWithItems: function(X) {
        var S = [];
        if (X)
            for (var P = 0; H8m.z4t(P, X.length); P++)
                X[P] && S.push(X[P]);
        return this.initWithArray(S);
    },
    initWithArray: function(X) {
        if (cc.LayerRGBA.prototype.init.call(this)) {
            this.enabled = !0;
            var S = cc.winSize;
            this.setPosition(H8m.j4t(S.width, 2), H8m.x4t(S.height, 2));
            this.setContentSize(S);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (X)
                for (S = 0; H8m.o4t(S, X.length); S++)
                    this.addChild(X[S], S);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0;
        }
        return !1;
    },
    addChild: function(X, S, P) {
        if (!(H8m.p4t(X, cc.MenuItem)))
            throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, X, S, P);
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsVerticallyWithPadding: function(X) {
        var S = -X,
            P = this._children,
            O,
            Z,
            Y,
            T;
        if (P && H8m.Y4t(0, P.length)) {
            Z = 0;
            for (O = P.length; H8m.T4t(Z, O); Z++)
                S += H8m.R4t(P[Z].height, P[Z].scaleY) + X;
            var R = H8m.M4t(S, 2);
            Z = 0;
            for (O = P.length; H8m.V4t(Z, O); Z++)
                T = P[Z], Y = T.height, S = T.scaleY, T.setPosition(0, H8m.s4t(R, Y * S / 2)), R -= H8m.U4t(Y, S) + X;
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsHorizontallyWithPadding: function(X) {
        var S = -X,
            P = this._children,
            O,
            Z,
            Y,
            T;
        if (P && H8m.b4t(0, P.length)) {
            O = 0;
            for (Z = P.length; H8m.F4t(O, Z); O++)
                S += H8m.k7t(P[O].width, P[O].scaleX) + X;
            var R = -S / 2;
            O = 0;
            for (Z = P.length; H8m.L7t(O, Z); O++)
                T = P[O], S = T.scaleX, Y = P[O].width, T.setPosition(R + H8m.i7t(Y, S, 2), 0), R += H8m.z7t(Y, S) + X;
        }
    },
    alignItemsInColumns: function() {
        H8m.j7t(0, arguments.length) && H8m.x7t(null, arguments[arguments.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
        for (var X = [], S = 0; H8m.o7t(S, arguments.length); S++)
            X.push(arguments[S]);
        var P = -5,
            O = 0,
            Z = 0,
            Y = 0,
            T,
            R,
            E,
            V = this._children;
        if (V && H8m.p7t(0, V.length))
            for (S = 0, E = V.length; H8m.Y7t(S, E); S++)
                H8m.T7t(O, X.length) || !(T = X[O]) || (R = V[S].height, Z = H8m.R7t(Z, R) || isNaN(R) ? Z : R, ++Y, H8m.M7t(Y, T) && (P += Z + 5, Z = Y = 0, ++O));
        var U = cc.director.getWinSize(),
            k9 = T = Z = O = 0,
            L9 = 0,
            P = H8m.V7t(P, 2);
        if (V && H8m.s7t(0, V.length))
            for (S = 0, E = V.length; H8m.U7t(S, E); S++) {
                var K9 = V[S];
                H8m.b7t(0, T) && (T = X[O], L9 = k9 = H8m.F7t(U.width, (1 + T)));
                R = K9._getHeight();
                Z = H8m.k0t(Z, R) || isNaN(R) ? Z : R;
                K9.setPosition(H8m.L0t(L9, U.width / 2), H8m.i0t(P, R / 2));
                L9 += k9;
                ++Y;
                H8m.S0t(Y, T) && (P -= Z + 5, Z = T = Y = 0, ++O);
            }
    },
    alignItemsInRows: function() {
        H8m.P0t(0, arguments.length) && H8m.a0t(null, arguments[arguments.length - 1]) && cc.log("parameters should not be ending with null in Javascript");
        var X = [],
            S;
        for (S = 0; H8m.O0t(S, arguments.length); S++)
            X.push(arguments[S]);
        var P = [],
            O = [],
            Z = -10,
            Y = -5,
            T = 0,
            R = 0,
            E = 0,
            V,
            U,
            k9,
            L9,
            K9 = this._children;
        if (K9 && H8m.B0t(0, K9.length))
            for (S = 0, k9 = K9.length; H8m.Z0t(S, k9); S++)
                (U = K9[S], H8m.J0t(T, X.length) || !(V = X[T])) || (L9 = U.width, R = H8m.n0t(R, L9) || isNaN(L9) ? R : L9, Y += U.height + 5, ++E, H8m.G0t(E, V) && (P.push(R), O.push(Y), Z += R + 10, R = E = 0, Y = -5, ++T));
        Y = cc.director.getWinSize();
        V = R = T = 0;
        var Z = -Z / 2,
            c9 = 0;
        if (K9 && H8m.W0t(0, K9.length))
            for (S = 0, k9 = K9.length; H8m.v0t(S, k9); S++)
                U = K9[S], H8m.u0t(0, V) && (V = X[T], c9 = O[T]), L9 = U._getWidth(), R = H8m.H0t(R, L9) || isNaN(L9) ? R : L9, U.setPosition(Z + H8m.f0t(P[T], 2), H8m.I0t(c9, Y.height / 2)), c9 -= U.height + 10, ++E, H8m.g3t(E, V) && (Z += R + 5, R = V = E = 0, ++T);
    },
    removeChild: function(X, S) {
        H8m.K3t(null, X) && (H8m.d3t(X, cc.MenuItem) ? (H8m.t3t(this._selectedItem, X) && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, X, S)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"));
    },
    _onTouchBegan: function(X, S) {
        var P = S.getCurrentTarget();
        if (H8m.w3t(P._state, cc.MENU_STATE_WAITING) || !P._visible || !P.enabled)
            return !1;
        for (var O = P.parent; H8m.e3t(null, O); O = O.parent)
            if (!O.isVisible())
                return !1;
        P._selectedItem = P._itemForTouch(X);
        return P._selectedItem ? (P._state = cc.MENU_STATE_TRACKING_TOUCH, P._selectedItem.selected(), !0) : !1;
    },
    _onTouchEnded: function(X, S) {
        var P = S.getCurrentTarget();
        H8m.Q3t(P._state, cc.MENU_STATE_TRACKING_TOUCH) ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (P._selectedItem && (P._selectedItem.unselected(), P._selectedItem.activate()), P._state = cc.MENU_STATE_WAITING);
    },
    _onTouchCancelled: function(X, S) {
        var P = S.getCurrentTarget();
        H8m.r3t(P._state, cc.MENU_STATE_TRACKING_TOUCH) ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && P._selectedItem.unselected(), P._state = cc.MENU_STATE_WAITING);
    },
    _onTouchMoved: function(X, S) {
        var P = S.getCurrentTarget();
        if (H8m.N3t(P._state, cc.MENU_STATE_TRACKING_TOUCH))
            cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var O = P._itemForTouch(X);
            H8m.m3t(O, P._selectedItem) && (P._selectedItem && P._selectedItem.unselected(), P._selectedItem = O, P._selectedItem && P._selectedItem.selected());
        }
    },
    onExit: function() {
        H8m.A3t(this._state, cc.MENU_STATE_TRACKING_TOUCH) && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this);
    },
    setOpacityModifyRGB: function(X) {},
    isOpacityModifyRGB: function() {
        return !1;
    },
    _itemForTouch: function(X) {
        X = X.getLocation();
        var S = this._children,
            P;
        if (S && H8m.E3t(0, S.length))
            for (var O = 0; H8m.C3t(O, S.length); O++)
                if (P = S[O], P.isVisible() && P.isEnabled()) {
                    var Z = P.convertToNodeSpace(X),
                        Y = P.rect();
                    Y.x = 0;
                    Y.y = 0;
                    if (cc.rectContainsPoint(Y, Z))
                        return P;
                }
        return null;
    }
});
w6b0K[q0K]._p = cc.Menu.prototype;
delete w6b0K[q0K]._p;
cc.Menu.create = function(X) {
    var S = arguments.length;
    H8m.h3t(0, S) && H8m.y3t(null, arguments[S - 1]) && cc.log("parameters should not be ending with null in Javascript");
    return H8m.q3t(0, S) ? new cc.Menu : H8m.l3t(1, S) ? new cc.Menu(X) : new cc.Menu(Array.prototype.slice.call(arguments, 0));
};
H8m.n5y(H8m.U7H);
H8m.A5y(H8m.h7H);
H8m.M5y(H8m.s7H);
H8m.W5y(H8m.v7H);
H8m.C5y(H8m.q7H);
H8m.s5y(H8m.b7H);
cc.ImageTGA = function(X, S, P, O, Z, Y, T) {
    this.status = X || H8m.U7H;
    this.type = S || H8m.U7H;
    this.pixelDepth = P || H8m.U7H;
    this.width = O || 0;
    this.height = Z || 0;
    this.imageData = Y || [];
    this.flipped = T || H8m.U7H;
};
cc.tgaLoadHeader = function(X, S, P) {
    var O = H8m.s7H;
    if (H8m.X5t(O + H8m.h7H, S))
        return !H8m.h7H;
    X = new cc.BinaryStreamReader(X);
    X.setOffset(O);
    P.type = X.readByte();
    O += H8m.e1i;
    if (H8m.D5t(O + H8m.q7H + H8m.h7H, S))
        return !H8m.h7H;
    X.setOffset(O);
    P.width = X.readUnsignedShort();
    P.height = X.readUnsignedInteger();
    P.pixelDepth = X.readByte();
    if (H8m.c5t(O + H8m.b7H + H8m.h7H, S))
        return !H8m.h7H;
    S = X.readByte();
    P.flipped = H8m.U7H;
    H8m.z5t(S, H8m.J9i) && (P.flipped = H8m.h7H);
    return !H8m.U7H;
};
cc.tgaLoadImageData = function(X, S, P) {
    var O,
        Z;
    O = H8m.j5t(H8m.U7H, P.pixelDepth / H8m.s7H);
    Z = H8m.x5t(P.height, P.width, O);
    if (H8m.Q5t(H8m.s9i + Z, S))
        return !H8m.h7H;
    P.imageData = cc.__getSubArray(X, H8m.s9i, H8m.s9i + Z);
    if (H8m.r5t(H8m.v7H, O))
        for (X = H8m.U7H; H8m.N5t(X, Z); X += O)
            S = P.imageData[X], P.imageData[X] = P.imageData[X + H8m.s7H], P.imageData[X + H8m.s7H] = S;
    return !H8m.U7H;
};
cc.tgaRGBtogreyscale = function(X) {
    var S,
        P;
    if (H8m.m5t(8, X.pixelDepth)) {
        var O = H8m.A5t(X.pixelDepth, 8),
            Z = new Uint8Array(H8m.E5t(X.height, X.width));
        if (H8m.C5t(null, Z)) {
            for (P = S = 0; H8m.h5t(P, X.width * X.height); S += O, P++)
                Z[P] = H8m.y5t(0.3, X.imageData[S]) + H8m.q5t(0.59, X.imageData[S + 1]) + H8m.l5t(0.11, X.imageData[S + 2]);
            X.pixelDepth = 8;
            X.type = 3;
            X.imageData = Z;
        }
    }
};
cc.tgaDestroy = function(X) {
    X && (X.imageData = H8m.H6P);
};
cc.tgaLoadRLEImageData = function(X, S, P) {
    var O,
        Z,
        Y,
        T = H8m.U7H,
        R = H8m.U7H,
        E = H8m.U7H,
        V = [],
        U = H8m.U7H,
        k9 = H8m.s9i;
    O = H8m.X6t(P.pixelDepth, H8m.F7H);
    Z = H8m.D6t(P.height, P.width);
    for (Y = H8m.U7H; H8m.c6t(Y, Z); Y++) {
        if (H8m.z6t(H8m.U7H, U))
            U--, R = H8m.j6t(H8m.U7H, E);
        else {
            if (H8m.x6t(k9 + H8m.h7H, S))
                break;
            U = X[k9];
            k9 += H8m.h7H;
            (E = H8m.o6t(U, H8m.g3S)) && (U -= H8m.g3S);
            R = H8m.U7H;
        }
        if (!R) {
            if (H8m.p6t(k9 + O, S))
                break;
            V = cc.__getSubArray(X, k9, k9 + O);
            k9 += O;
            H8m.Y6t(H8m.v7H, O) && (R = V[H8m.U7H], V[H8m.U7H] = V[H8m.s7H], V[H8m.s7H] = R);
        }
        for (R = H8m.U7H; H8m.T6t(R, O); R++)
            P.imageData[T + R] = V[R];
        T += O;
    }
    return !H8m.U7H;
};
cc.tgaFlipImage = function(X) {
    for (var S = H8m.R6t(X.pixelDepth, 8, X.width), P = 0; H8m.E6t(P, X.height / 2); P++) {
        var O = cc.__getSubArray(X.imageData, H8m.C6t(P, S), H8m.h6t(P, S) + S);
        cc.__setDataToArray(cc.__getSubArray(X.imageData, H8m.y6t((X.height - (P + 1)), S), S), X.imageData, H8m.q6t(P, S));
        cc.__setDataToArray(O, X.imageData, H8m.l6t((X.height - (P + 1)), S));
    }
    X.flipped = 0;
};
cc.__getSubArray = function(X, S, P) {
    return H8m.X2t(X, Array) ? X.slice(S, P) : X.subarray(S, P);
};
cc.__setDataToArray = function(X, S, P) {
    for (var O = 0; H8m.D2t(O, X.length); O++)
        S[P + O] = X[O];
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(X) {
        this._binaryData = X;
    },
    setBinaryData: function(X) {
        this._binaryData = X;
        this._offset = 0;
    },
    getBinaryData: function() {
        return this._binaryData;
    },
    _checkSize: function(X) {
        if (!(H8m.c2t(this._offset + Math.ceil(X / 8), this._data.length)))
            throw Error("Index out of bound");
    },
    _decodeFloat: function(X, S) {
        var P = X + S + 1,
            O = H8m.z2t(P, 3);
        this._checkSize(P);
        var P = H8m.j2t(Math.pow(2, S - 1), 1),
            Z = this._readBits(X + S, 1, O),
            Y = this._readBits(X, S, O),
            T = 0,
            R = 2,
            E = 0;
        do for (var V = this._readByte(++E, O), U = H8m.x2t(X, 8) || 8, k9 = H8m.o2t(1, U); k9 >>= 1;)
            H8m.p2t(V, k9) && (T += H8m.Y2t(1, R)), R *= 2;
        while (X -= U);
        this._offset += O;
        return H8m.T2t(Y, (P << 1) + 1) ? T ? NaN : Z ? -Infinity : Infinity : (1 + -2 * Z) * (Y || T ? Y ? H8m.R2t(Math.pow(2, Y - P), (1 + T)) : Math.pow(2, -P + 1) * T : 0);
    },
    _readByte: function(X, S) {
        return this._data[this._offset + S - X - 1];
    },
    _decodeInt: function(X, S) {
        var P = this._readBits(0, X, H8m.M2t(X, 8)),
            O = Math.pow(2, X);
        this._offset += H8m.V2t(X, 8);
        return S && H8m.s2t(P, O / 2) ? H8m.U2t(P, O) : P;
    },
    _shl: function(X, S) {
        for (++S; --S; X = H8m.b2t(1073741824, ((X %= 2147483648) & 1073741824)) ? H8m.F2t(2, X) : H8m.k9G(2, (X - 1073741824)) + 2147483648)
            ;
        return X;
    },
    _readBits: function(X, S, P) {
        var O = H8m.L9G((X + S), 8),
            Z = H8m.i9G(X, 8),
            Y = H8m.S9G(P, (X >> 3), 1);
        X = P + (-(X + S) >> 3);
        var T = H8m.j9G(Y, X);
        S = H8m.x9G(this._readByte(Y, P) >> Z, (1 << (T ? 8 - Z : S)) - 1);
        for (T && O && (S += H8m.o9G((this._readByte(X++, P) & (1 << O) - 1), (T-- << 3) - Z)); T;)
            S += this._shl(this._readByte(X++, P), H8m.p9G((T-- << 3), Z));
        return S;
    },
    readInteger: function() {
        return this._decodeInt(32, !0);
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1);
    },
    readSingle: function() {
        return this._decodeFloat(23, 8);
    },
    readShort: function() {
        return this._decodeInt(16, !0);
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1);
    },
    readByte: function() {
        var X = this._data[this._offset];
        this._offset += 1;
        return X;
    },
    readData: function(X, S) {
        return H8m.Y9G(this._binaryData, Array) ? this._binaryData.slice(X, S) : this._binaryData.subarray(X, S);
    },
    setOffset: function(X) {
        this._offset = X;
    },
    getOffset: function() {
        return this._offset;
    }
});
H8m.u5y(H8m.U7H);
H8m.y5y(H8m.h7H);
H8m.b5y(H8m.s7H);
cc.TMXTiledMap = cc.NodeRGBA.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height);
    },
    setMapSize: function(X) {
        this._mapSize.width = X.width;
        this._mapSize.height = X.height;
    },
    _getMapWidth: function() {
        return this._mapSize.width;
    },
    _setMapWidth: function(X) {
        this._mapSize.width = X;
    },
    _getMapHeight: function() {
        return this._mapSize.height;
    },
    _setMapHeight: function(X) {
        this._mapSize.height = X;
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height);
    },
    setTileSize: function(X) {
        this._tileSize.width = X.width;
        this._tileSize.height = X.height;
    },
    _getTileWidth: function() {
        return this._tileSize.width;
    },
    _setTileWidth: function(X) {
        this._tileSize.width = X;
    },
    _getTileHeight: function() {
        return this._tileSize.height;
    },
    _setTileHeight: function(X) {
        this._tileSize.height = X;
    },
    getMapOrientation: function() {
        return this.mapOrientation;
    },
    setMapOrientation: function(X) {
        this.mapOrientation = X;
    },
    getObjectGroups: function() {
        return this.objectGroups;
    },
    setObjectGroups: function(X) {
        this.objectGroups = X;
    },
    getProperties: function() {
        return this.properties;
    },
    setProperties: function(X) {
        this.properties = X;
    },
    initWithTMXFile: function(X) {
        if (!X || H8m.T9G(0, X.length))
            throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        this.height = this.width = 0;
        X = cc.TMXMapInfo.create(X);
        if (!X)
            return !1;
        var S = X.getTilesets();
        S && H8m.R9G(0, S.length) || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(X);
        return !0;
    },
    initWithXML: function(X, S) {
        this.height = this.width = 0;
        var P = cc.TMXMapInfo.create(X, S),
            O = P.getTilesets();
        O && H8m.M9G(0, O.length) || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(P);
        return !0;
    },
    _buildWithMapInfo: function(X) {
        this._mapSize = X.getMapSize();
        this._tileSize = X.getTileSize();
        this.mapOrientation = X.orientation;
        this.objectGroups = X.getObjectGroups();
        this.properties = X.properties;
        this._tileProperties = X.getTileProperties();
        var S = 0,
            P = X.getLayers();
        if (P)
            for (var O = null, Z = 0, Y = P.length; H8m.V9G(Z, Y); Z++)
                (O = P[Z]) && O.visible && (O = this._parseLayer(O, X), this.addChild(O, S, S), this.width = Math.max(this.width, O.width), this.height = Math.max(this.height, O.height), S++);
    },
    allLayers: function() {
        for (var X = [], S = this._children, P = 0, O = S.length; H8m.s9G(P, O); P++) {
            var Z = S[P];
            Z && H8m.U9G(Z, cc.TMXLayer) && X.push(Z);
        }
        return X;
    },
    getLayer: function(X) {
        if (!X || H8m.b9G(0, X.length))
            throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var S = this._children, P = 0; H8m.F9G(P, S.length); P++) {
            var O = S[P];
            if (O && H8m.k1G(O.layerName, X))
                return O;
        }
        return null;
    },
    getObjectGroup: function(X) {
        if (!X || H8m.L1G(0, X.length))
            throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var S = 0; H8m.i1G(S, this.objectGroups.length); S++) {
                var P = this.objectGroups[S];
                if (P && H8m.S1G(P.groupName, X))
                    return P;
            }
        return null;
    },
    getProperty: function(X) {
        return this.properties[X.toString()];
    },
    propertiesForGID: function(X) {
        return this._tileProperties[X];
    },
    _parseLayer: function(X, S) {
        var P = this._tilesetForLayer(X, S),
            P = cc.TMXLayer.create(P, X, S);
        X.ownTiles = !1;
        P.setupTiles();
        return P;
    },
    _tilesetForLayer: function(X, S) {
        var P = X._layerSize,
            O = S.getTilesets();
        if (O)
            for (var Z = H8m.P1G(O.length, 1); H8m.a1G(0, Z); Z--) {
                var Y = O[Z];
                if (Y)
                    for (var T = 0; H8m.O1G(T, P.height); T++)
                        for (var R = 0; H8m.B1G(R, P.width); R++) {
                            var E = X._tiles[R + H8m.Z1G(P.width, T)];
                            if (H8m.J1G(0, E) && H8m.n1G((E & cc.TMX_TILE_FLIPPED_MASK) >>> 0, Y.firstGid))
                                return Y;
                        }
            }
        cc.log("cocos2d: Warning: TMX Layer " + X.name + " has no tiles");
        return null;
    }
});
w6b0K[q0K]._p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, H8m.j1P, _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, H8m.a1i, _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, H8m.J5P, _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, H8m.i8S, _p._getTileHeight, _p._setTileHeight);
delete w6b0K[q0K]._p;
cc.TMXTiledMap.create = function(X, S) {
    var P = new cc.TMXTiledMap;
    if (S) {
        if (P.initWithXML(X, S))
            return P;
    } else if (P.initWithTMXFile(X))
        return P;
    return H8m.H6P;
};
H8m.f5y(H8m.h7H);
H8m.l5y(H8m.s7H);
H8m.k6y(H8m.q7H);
H8m.g6y(H8m.F7H);
H8m.D6y(H8m.U7H);
H8m.i6y(H8m.h7H);
H8m.d6y(H8m.s7H);
H8m.z6y(H8m.v7H);
H8m.P6y(H8m.q7H);
H8m.w6y(H8m.b7H);
H8m.x6y(H8m.u3P);
H8m.O6y(H8m.S9K);
H8m.Q6y(H8m.s6H);
H8m.p6y();
H8m.r6y();
cc.TMXLayerInfo = cc.Class.extend({
    properties: H8m.H6P,
    name: H8m.u4S,
    _layerSize: H8m.H6P,
    _tiles: H8m.H6P,
    visible: H8m.H6P,
    _opacity: H8m.H6P,
    ownTiles: !H8m.U7H,
    _minGID: H8m.U5P,
    _maxGID: H8m.U7H,
    offset: H8m.H6P,
    ctor: function() {
        this.properties = [];
        this.name = H8m.u4S;
        this._layerSize = H8m.H6P;
        this._tiles = [];
        this.visible = !H8m.U7H;
        this._opacity = H8m.U7H;
        this.ownTiles = !H8m.U7H;
        this._minGID = H8m.U5P;
        this._maxGID = H8m.U7H;
        this.offset = cc.p(H8m.U7H, H8m.U7H);
    },
    getProperties: function() {
        return this.properties;
    },
    setProperties: function(X) {
        this.properties = X;
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0);
    },
    rectForGID: function(X) {
        var S = cc.rect(0, 0, 0, 0);
        S.width = this._tileSize.width;
        S.height = this._tileSize.height;
        X &= cc.TMX_TILE_FLIPPED_MASK;
        X -= parseInt(this.firstGid, 10);
        var P = parseInt(H8m.G1G((this.imageSize.width - 2 * this.margin + this.spacing), (this._tileSize.width + this.spacing)), 10);
        S.x = parseInt(H8m.W1G(X, P, (this._tileSize.width + this.spacing)) + this.margin, 10);
        S.y = parseInt(H8m.s1G(parseInt(X / P, 10), (this._tileSize.height + this.spacing)) + this.margin, 10);
        return S;
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function() {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties = {};
        this._currentFirstGID = 0;
    },
    getOrientation: function() {
        return this.orientation;
    },
    setOrientation: function(X) {
        this.orientation = X;
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height);
    },
    setMapSize: function(X) {
        this._mapSize.width = X.width;
        this._mapSize.height = X.height;
    },
    _getMapWidth: function() {
        return this._mapSize.width;
    },
    _setMapWidth: function(X) {
        this._mapSize.width = X;
    },
    _getMapHeight: function() {
        return this._mapSize.height;
    },
    _setMapHeight: function(X) {
        this._mapSize.height = X;
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height);
    },
    setTileSize: function(X) {
        this._tileSize.width = X.width;
        this._tileSize.height = X.height;
    },
    _getTileWidth: function() {
        return this._tileSize.width;
    },
    _setTileWidth: function(X) {
        this._tileSize.width = X;
    },
    _getTileHeight: function() {
        return this._tileSize.height;
    },
    _setTileHeight: function(X) {
        this._tileSize.height = X;
    },
    getLayers: function() {
        return this._layers;
    },
    setLayers: function(X) {
        this._layers.push(X);
    },
    getTilesets: function() {
        return this._tilesets;
    },
    setTilesets: function(X) {
        this._tilesets.push(X);
    },
    getObjectGroups: function() {
        return this._objectGroups;
    },
    setObjectGroups: function(X) {
        this._objectGroups.push(X);
    },
    getParentElement: function() {
        return this.parentElement;
    },
    setParentElement: function(X) {
        this.parentElement = X;
    },
    getParentGID: function() {
        return this.parentGID;
    },
    setParentGID: function(X) {
        this.parentGID = X;
    },
    getLayerAttribs: function() {
        return this.layerAttrs;
    },
    setLayerAttribs: function(X) {
        this.layerAttrs = X;
    },
    getStoringCharacters: function() {
        return this.storingCharacters;
    },
    setStoringCharacters: function(X) {
        this.storingCharacters = X;
    },
    getProperties: function() {
        return this.properties;
    },
    setProperties: function(X) {
        this.properties = X;
    },
    initWithTMXFile: function(X) {
        this._internalInit(X, null);
        return this.parseXMLFile(X);
    },
    initWithXML: function(X, S) {
        this._internalInit(null, S);
        return this.parseXMLString(X);
    },
    parseXMLFile: function(X, S) {
        var P = (S = S || !1) ? X : cc.loader.getRes(X);
        if (!P)
            throw "Please load the resource first : " + X;
        var O,
            Z,
            P = this._parseXML(P).documentElement;
        O = P.getAttribute("version");
        Z = P.getAttribute("orientation");
        if (H8m.U1G("map", P.nodeName) && (H8m.b1G("1.0", O) && H8m.F1G(null, O) && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + O), H8m.k8G("orthogonal", Z) ? this.orientation = cc.TMX_ORIENTATION_ORTHO : H8m.L8G("isometric", Z) ? this.orientation = cc.TMX_ORIENTATION_ISO : H8m.i8G("hexagonal", Z) ? this.orientation = cc.TMX_ORIENTATION_HEX : H8m.S8G(null, Z) && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + Z), O = cc.size(0, 0), O.width = parseFloat(P.getAttribute("width")), O.height = parseFloat(P.getAttribute("height")), this.setMapSize(O), O = cc.size(0, 0), O.width = parseFloat(P.getAttribute("tilewidth")), O.height = parseFloat(P.getAttribute("tileheight")), this.setTileSize(O), Z = P.querySelectorAll("map \x3e properties \x3e  property"))) {
            var Y = {};
            for (O = 0; H8m.P8G(O, Z.length); O++)
                Y[Z[O].getAttribute("name")] = Z[O].getAttribute("value");
            this.properties = Y;
        }
        Z = P.getElementsByTagName("tileset");
        H8m.a8G("map", P.nodeName) && (Z = [], Z.push(P));
        for (O = 0; H8m.O8G(O, Z.length); O++) {
            var T = Z[O];
            if (Y = T.getAttribute("source"))
                Y = S ? cc.path.join(this._resources, Y) : cc.path.changeBasename(X, Y), this.parseXMLFile(Y);
            else {
                Y = new cc.TMXTilesetInfo;
                Y.name = T.getAttribute("name") || "";
                Y.firstGid = parseInt(T.getAttribute("firstgid")) || 0;
                Y.spacing = parseInt(T.getAttribute("spacing")) || 0;
                Y.margin = parseInt(T.getAttribute("margin")) || 0;
                var R = cc.size(0, 0);
                R.width = parseFloat(T.getAttribute("tilewidth"));
                R.height = parseFloat(T.getAttribute("tileheight"));
                Y._tileSize = R;
                T = T.getElementsByTagName("image")[0].getAttribute("source");
                R = -1;
                this.tmxFileName && (R = this.tmxFileName.lastIndexOf("/"));
                -1 !== R ? (R = this.tmxFileName.substr(0, R + 1), Y.sourceImage = R + T) : Y.sourceImage = this._resources + (this._resources ? "/" : "") + T;
                this.setTilesets(Y);
            }
        }
        if (Y = P.querySelectorAll("tile"))
            for (O = 0; H8m.B8G(O, Y.length); O++)
                if (Z = Y[O], this.parentGID = parseInt(this._tilesets[0].firstGid) + parseInt(Z.getAttribute("id") || 0), T = Z.querySelectorAll("properties \x3e property")) {
                    R = {};
                    for (Z = 0; H8m.Z8G(Z, T.length); Z++) {
                        var E = T[Z].getAttribute("name");
                        R[E] = T[Z].getAttribute("value");
                    }
                    this._tileProperties[this.parentGID] = R;
                }
        if (Y = P.getElementsByTagName("layer"))
            for (O = 0; H8m.J8G(O, Y.length); O++) {
                R = Y[O];
                E = R.getElementsByTagName("data")[0];
                T = new cc.TMXLayerInfo;
                T.name = R.getAttribute("name");
                Z = cc.size(0, 0);
                Z.width = parseFloat(R.getAttribute("width"));
                Z.height = parseFloat(R.getAttribute("height"));
                T._layerSize = Z;
                Z = R.getAttribute("visible");
                T.visible = H8m.n8G("0", Z);
                Z = R.getAttribute("opacity") || 1;
                T._opacity = Z ? parseInt(H8m.G8G(255, parseFloat(Z))) : 255;
                T.offset = cc.p(parseFloat(R.getAttribute("x")) || 0, parseFloat(R.getAttribute("y")) || 0);
                var V = "";
                for (Z = 0; H8m.W8G(Z, E.childNodes.length); Z++)
                    V += E.childNodes[Z].nodeValue;
                V = V.trim();
                Z = E.getAttribute("compression");
                var U = E.getAttribute("encoding");
                if (Z && H8m.v8G("gzip", Z) && H8m.u8G("zlib", Z))
                    return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (Z) {
                case "gzip":
                    T._tiles = cc.unzipBase64AsArray(V, 4);
                    break;
                case "zlib":
                    Z = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(V, 1));
                    T._tiles = cc.uint8ArrayToUint32Array(Z.decompress());
                    break;
                case null:
                case "":
                    if (H8m.H8G("base64", U))
                        T._tiles = cc.Codec.Base64.decodeAsArray(V, 4);
                    else if (H8m.f8G("csv", U))
                        for (T._tiles = [], Z = V.split(","), E = 0; H8m.I8G(E, Z.length); E++)
                            T._tiles.push(parseInt(Z[E]));
                    else
                        for (Z = E.getElementsByTagName("tile"), T._tiles = [], E = 0; H8m.g4G(E, Z.length); E++)
                            T._tiles.push(parseInt(Z[E].getAttribute("gid")));
                    break;
                default:
                    H8m.K4G(this.layerAttrs, cc.TMX_LAYER_ATTRIB_NONE) && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported");
                }
                if (R = R.querySelectorAll("properties \x3e property")) {
                    E = {};
                    for (Z = 0; H8m.d4G(Z, R.length); Z++)
                        E[R[Z].getAttribute("name")] = R[Z].getAttribute("value");
                    T.properties = E;
                }
                this.setLayers(T);
            }
        if (Y = P.getElementsByTagName("objectgroup"))
            for (O = 0; H8m.t4G(O, Y.length); O++) {
                R = Y[O];
                T = new cc.TMXObjectGroup;
                T.groupName = R.getAttribute("name");
                T.setPositionOffset(cc.p(H8m.w4G(parseFloat(R.getAttribute("x")), this.getTileSize().width) || 0, H8m.e4G(parseFloat(R.getAttribute("y")), this.getTileSize().height) || 0));
                if (E = R.querySelectorAll("objectgroup \x3e properties \x3e property"))
                    for (Z = 0; H8m.Q4G(Z, E.length); Z++)
                        V = {}, V[E[Z].getAttribute("name")] = E[Z].getAttribute("value"), T.properties = V;
                if (R = R.querySelectorAll("object"))
                    for (Z = 0; H8m.r4G(Z, R.length); Z++) {
                        V = R[Z];
                        E = {};
                        E.name = V.getAttribute("name") || "";
                        E.type = V.getAttribute("type") || "";
                        E.x = parseInt(V.getAttribute("x") || 0) + T.getPositionOffset().x;
                        U = parseInt(V.getAttribute("y") || 0) + T.getPositionOffset().y;
                        E.width = parseInt(V.getAttribute("width")) || 0;
                        E.height = parseInt(V.getAttribute("height")) || 0;
                        E.y = H8m.N4G(parseInt(this.getMapSize().height * this.getTileSize().height), U, E.height);
                        if (U = V.querySelectorAll("properties \x3e property"))
                            for (var k9 = 0; H8m.n4G(k9, U.length); k9++)
                                E[U[k9].getAttribute("name")] = U[k9].getAttribute("value");
                        (U = V.querySelectorAll("polygon")) && H8m.G4G(0, U.length) && (U = U[0].getAttribute("points")) && (E.polygonPoints = this._parsePointsString(U));
                        (V = V.querySelectorAll("polyline")) && H8m.W4G(0, V.length) && (V = V[0].getAttribute("points")) && (E.polylinePoints = this._parsePointsString(V));
                        T.setObjects(E);
                    }
                this.setObjectGroups(T);
            }
        return P;
    },
    _parsePointsString: function(X) {
        if (!X)
            return null;
        var S = [];
        X = X.split(" ");
        for (var P = 0; H8m.v4G(P, X.length); P++) {
            var O = X[P].split(",");
            S.push({
                x: O[0],
                y: O[1]
            });
        }
        return S;
    },
    parseXMLString: function(X) {
        return this.parseXMLFile(X, !0);
    },
    getTileProperties: function() {
        return this._tileProperties;
    },
    setTileProperties: function(X) {
        this._tileProperties.push(X);
    },
    getCurrentString: function() {
        return this.currentString;
    },
    setCurrentString: function(X) {
        this.currentString = X;
    },
    getTMXFileName: function() {
        return this.tmxFileName;
    },
    setTMXFileName: function(X) {
        this.tmxFileName = X;
    },
    _internalInit: function(X, S) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = X;
        S && (this._resources = S);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMX_LAYER_ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0;
    }
});
w6b0K[q0K]._p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, H8m.j1P, _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, H8m.a1i, _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, H8m.J5P, _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, H8m.i8S, _p._getTileHeight, _p._setTileHeight);
delete w6b0K[q0K]._p;
cc.TMXMapInfo.create = function(X, S) {
    var P = new cc.TMXMapInfo;
    if (S) {
        if (P.initWithXML(X, S))
            return P;
    } else if (P.initWithTMXFile(X))
        return P;
    return H8m.H6P;
};
cc.loader.register([H8m.r2H, H8m.H6i], cc._txtLoader);
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = [];
    },
    getPositionOffset: function() {
        return this._positionOffset;
    },
    setPositionOffset: function(X) {
        this._positionOffset.x = X.x;
        this._positionOffset.y = X.y;
    },
    getProperties: function() {
        return this.properties;
    },
    setProperties: function(X) {
        this.properties.push(X);
    },
    getGroupName: function() {
        return this.groupName.toString();
    },
    setGroupName: function(X) {
        this.groupName = X;
    },
    propertyNamed: function(X) {
        return this.properties[X];
    },
    objectNamed: function(X) {
        if (this._objects && H8m.u4G(0, this._objects.length))
            for (var S = this._objects, P = 0, O = S.length; H8m.H4G(P, O); P++) {
                var Z = S[P].name;
                if (Z && H8m.f4G(Z, X))
                    return S[P];
            }
        return null;
    },
    getObjects: function() {
        return this._objects;
    },
    setObjects: function(X) {
        this._objects.push(X);
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _alphaFuncValue: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _subCacheCanvas: null,
    _subCacheContext: null,
    _subCacheCount: 0,
    _subCacheWidth: 0,
    _maxCachePixel: 1E7,
    _className: "TMXLayer",
    ctor: function() {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize = cc.size(0, 0);
        if (H8m.I4G(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            var X = cc._canvas,
                S = w6b0K[I0K]['createElement']("canvas");
            S.width = X.width;
            S.height = X.height;
            this._cacheCanvas = S;
            this._cacheContext = this._cacheCanvas.getContext("2d");
            var P = new cc.Texture2D;
            P.initWithElement(S);
            P.handleLoadedTexture();
            this._cacheTexture = P;
            this.width = X.width;
            this.height = X.height;
            this._cachedParent = this;
        }
    },
    setContentSize: function(X, S) {
        var P = this._contentSize;
        cc.Node.prototype.setContentSize.call(this, X, S);
        if (H8m.g7G(cc._renderType, cc._RENDER_TYPE_CANVAS)) {
            var O = this._cacheCanvas,
                Z = cc.CONTENT_SCALE_FACTOR();
            O.width = H8m.K7G(0, 1.5 * P.width * Z);
            O.height = H8m.d7G(0, 1.5 * P.height * Z);
            this._cacheContext.translate(0, O.height);
            P = this._cacheTexture._contentSize;
            P.width = O.width;
            P.height = O.height;
            P = H8m.t7G(O.width, O.height);
            if (H8m.w7G(P, this._maxCachePixel)) {
                this._subCacheCanvas || (this._subCacheCanvas = []);
                this._subCacheContext || (this._subCacheContext = []);
                this._subCacheCount = Math.ceil(H8m.e7G(P, this._maxCachePixel));
                P = this._subCacheCanvas;
                for (Z = 0; H8m.Q7G(Z, this._subCacheCount); Z++) {
                    P[Z] || (P[Z] = w6b0K[I0K]['createElement']("canvas"), this._subCacheContext[Z] = P[Z].getContext("2d"));
                    var Y = P[Z];
                    Y.width = this._subCacheWidth = Math.round(H8m.r7G(O.width, this._subCacheCount));
                    Y.height = O.height;
                }
                for (Z = this._subCacheCount; H8m.N7G(Z, P.length); Z++)
                    Y.width = 0, Y.height = 0;
            } else
                this._subCacheCount = 0;
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._cacheTexture;
    },
    visit: null,
    _visitForCanvas: function(X) {
        var S = X || cc._renderContext;
        if (this._visible) {
            S.save();
            this.transform(X);
            var P,
                O = this._children;
            if (this._cacheDirty) {
                var Z = cc.view;
                Z._setScaleXYForRenderTexture();
                var Y = this._cacheContext,
                    T = this._cacheCanvas;
                Y.clearRect(0, 0, T.width, -T.height);
                Y.save();
                Y.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
                if (O)
                    for (this.sortAllChildren(), P = 0; H8m.m7G(P, O.length); P++)
                        O[P] && O[P].visit(Y);
                Y.restore();
                if (H8m.A7G(0, this._subCacheCount))
                    for (O = this._subCacheWidth, Y = T.height, P = 0; H8m.E7G(P, this._subCacheCount); P++)
                        this._subCacheContext[P].drawImage(T, H8m.C7G(P, O), 0, O, Y, 0, 0, O, Y);
                Z._resetScale();
                this._cacheDirty = !1;
            }
            this.draw(X);
            S.restore();
        }
    },
    draw: null,
    _drawForCanvas: function(X) {
        X = X || cc._renderContext;
        var S = 0 | -this._anchorPointInPoints.x,
            P = 0 | -this._anchorPointInPoints.y,
            O = cc.view,
            Z = this._cacheCanvas;
        if (Z) {
            var Y = this._subCacheCount,
                T = H8m.h7G(Z.height, O._scaleY);
            if (H8m.y7G(0, Y))
                for (var Z = this._subCacheCanvas, R = 0; H8m.q7G(R, Y); R++) {
                    var E = Z[R];
                    X.drawImage(Z[R], 0, 0, E.width, E.height, S + H8m.l7G(R, this._subCacheWidth), -(P + T), H8m.X0G(E.width, O._scaleX), T);
                }
            else
                X.drawImage(Z, 0, 0, Z.width, Z.height, S, -(P + T), H8m.D0G(Z.width, O._scaleX), T);
        }
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height);
    },
    setLayerSize: function(X) {
        this._layerSize.width = X.width;
        this._layerSize.height = X.height;
    },
    _getLayerWidth: function() {
        return this._layerSize.width;
    },
    _setLayerWidth: function(X) {
        this._layerSize.width = X;
    },
    _getLayerHeight: function() {
        return this._layerSize.height;
    },
    _setLayerHeight: function(X) {
        this._layerSize.height = X;
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height);
    },
    setMapTileSize: function(X) {
        this._mapTileSize.width = X.width;
        this._mapTileSize.height = X.height;
    },
    _getTileWidth: function() {
        return this._mapTileSize.width;
    },
    _setTileWidth: function(X) {
        this._mapTileSize.width = X;
    },
    _getTileHeight: function() {
        return this._mapTileSize.height;
    },
    _setTileHeight: function(X) {
        this._mapTileSize.height = X;
    },
    getTiles: function() {
        return this.tiles;
    },
    setTiles: function(X) {
        this.tiles = X;
    },
    getTileset: function() {
        return this.tileset;
    },
    setTileset: function(X) {
        this.tileset = X;
    },
    getLayerOrientation: function() {
        return this.layerOrientation;
    },
    setLayerOrientation: function(X) {
        this.layerOrientation = X;
    },
    getProperties: function() {
        return this.properties;
    },
    setProperties: function(X) {
        this.properties = X;
    },
    initWithTilesetInfo: function(X, S, P) {
        var O = S._layerSize,
            Z = H8m.c0G(0.35, parseInt(O.width * O.height)) + 1,
            Y;
        X && (Y = cc.textureCache.addImage(X.sourceImage));
        return this.initWithTexture(Y, Z) ? (this.layerName = S.name, this._layerSize = O, this.tiles = S._tiles, this._minGID = S._minGID, this._maxGID = S._maxGID, this._opacity = S._opacity, this.properties = S.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = X, this._mapTileSize = P.getTileSize(), this.layerOrientation = P.orientation, X = this._calculateLayerOffset(S.offset), this.setPosition(cc.POINT_PIXELS_TO_POINTS(X)), this._atlasIndexArray = [], this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(cc.size(H8m.z0G(this._layerSize.width, this._mapTileSize.width), H8m.j0G(this._layerSize.height, this._mapTileSize.height)))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1;
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null);
    },
    getTileAt: function(X) {
        if (!X)
            throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        if (H8m.x0G(X.x, this._layerSize.width) || H8m.o0G(X.y, this._layerSize.height) || H8m.p0G(0, X.x) || H8m.Y0G(0, X.y))
            throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray)
            return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var S = null,
            P = this.getTileGIDAt(X);
        if (H8m.T0G(0, P))
            return S;
        var O = H8m.R0G(0, X.x + X.y * this._layerSize.width),
            S = this.getChildByTag(O);
        S || (P = this.tileset.rectForGID(P), P = cc.RECT_PIXELS_TO_POINTS(P), S = new cc.Sprite, S.initWithTexture(this.texture, P), S.batchNode = this, S.setPosition(this.getPositionAt(X)), S.vertexZ = this._vertexZForPos(X), S.anchorX = 0, S.anchorY = 0, S.opacity = this._opacity, X = this._atlasIndexForExistantZ(O), this.addSpriteWithoutQuad(S, X, O));
        return S;
    },
    getTileGIDAt: function(X) {
        if (!X)
            throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        if (H8m.M0G(X.x, this._layerSize.width) || H8m.V0G(X.y, this._layerSize.height) || H8m.s0G(0, X.x) || H8m.U0G(0, X.y))
            throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? H8m.b0G((this.tiles[0 | X.x + X.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK), 0) : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null);
    },
    getTileFlagsAt: function(X) {
        if (!X)
            throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        if (H8m.F0G(X.x, this._layerSize.width) || H8m.k3G(X.y, this._layerSize.height) || H8m.L3G(0, X.x) || H8m.i3G(0, X.y))
            throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? H8m.S3G((this.tiles[0 | X.x + X.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL), 0) : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null);
    },
    setTileGID: function(X, S, P) {
        if (!S)
            throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        if (H8m.P3G(S.x, this._layerSize.width) || H8m.a3G(S.y, this._layerSize.height) || H8m.O3G(0, S.x) || H8m.B3G(0, S.y))
            throw "cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray)
            return cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released"), null;
        if (H8m.Z3G(0, X) && H8m.J3G(X, this.tileset.firstGid))
            return cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + X), null;
        P = P || 0;
        this._setNodeDirtyForCache();
        var O = this.getTileFlagsAt(S),
            Z = this.getTileGIDAt(S);
        if (H8m.n3G(Z, X) || H8m.G3G(O, P))
            if (O = H8m.W3G((X | P), 0), H8m.v3G(0, X))
                this.removeTileAt(S);
            else if (H8m.u3G(0, Z))
                this._insertTileForGID(O, S);
            else {
                var Z = S.x + H8m.H3G(S.y, this._layerSize.width),
                    Y = this.getChildByTag(Z);
                Y ? (X = this.tileset.rectForGID(X), X = cc.RECT_PIXELS_TO_POINTS(X), Y.setTextureRect(X, !1), H8m.f3G(null, P) && this._setupTileSprite(Y, S, O), this.tiles[Z] = O) : this._updateTileForGID(O, S);
            }
    },
    removeTileAt: function(X) {
        if (!X)
            throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        if (H8m.I3G(X.x, this._layerSize.width) || H8m.g5G(X.y, this._layerSize.height) || H8m.K5G(0, X.x) || H8m.d5G(0, X.y))
            throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray)
            return cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released"), null;
        if (H8m.t5G(0, this.getTileGIDAt(X))) {
            H8m.w5G(cc._renderType, cc._RENDER_TYPE_CANVAS) && this._setNodeDirtyForCache();
            var S = H8m.e5G(0, X.x + X.y * this._layerSize.width);
            X = this._atlasIndexForExistantZ(S);
            this.tiles[S] = 0;
            this._atlasIndexArray.splice(X, 1);
            if (S = this.getChildByTag(S))
                cc.SpriteBatchNode.prototype.removeChild.call(this, S, !0);
            else if (H8m.Q5G(cc._renderType, cc._RENDER_TYPE_WEBGL) && this.textureAtlas.removeQuadAtIndex(X), this._children)
                for (var S = this._children, P = 0, O = S.length; H8m.r5G(P, O); P++) {
                    var Z = S[P];
                    if (Z) {
                        var Y = Z.atlasIndex;
                        H8m.N5G(Y, X) && (Z.atlasIndex = H8m.m5G(Y, 1));
                    }
                }
        }
    },
    getPositionAt: function(X) {
        var S = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            S = this._positionForOrthoAt(X);
            break;
        case cc.TMX_ORIENTATION_ISO:
            S = this._positionForIsoAt(X);
            break;
        case cc.TMX_ORIENTATION_HEX:
            S = this._positionForHexAt(X);
        }
        return cc.POINT_PIXELS_TO_POINTS(S);
    },
    getProperty: function(X) {
        return this.properties[X];
    },
    setupTiles: function() {
        H8m.A5G(cc._renderType, cc._RENDER_TYPE_CANVAS) ? this.tileset.imageSize = this._originalTexture.getContentSizeInPixels() : (this.tileset.imageSize = this.textureAtlas.texture.getContentSizeInPixels(), this.textureAtlas.texture.setAliasTexParameters());
        this._parseInternalProperties();
        H8m.E5G(cc._renderType, cc._RENDER_TYPE_CANVAS) && this._setNodeDirtyForCache();
        for (var X = this._layerSize.height, S = this._layerSize.width, P = 0; H8m.C5G(P, X); P++)
            for (var O = 0; H8m.h5G(O, S); O++) {
                var Z = this.tiles[O + H8m.y5G(S, P)];
                H8m.q5G(0, Z) && (this._appendTileForGID(Z, cc.p(O, P)), this._minGID = Math.min(Z, this._minGID), this._maxGID = Math.max(Z, this._maxGID));
            }
        H8m.l5G(this._maxGID, this.tileset.firstGid) && H8m.X6G(this._minGID, this.tileset.firstGid) || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported");
    },
    addChild: function(X, S, P) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.");
    },
    removeChild: function(X, S) {
        if (X)
            if (-1 === this._children.indexOf(X))
                cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                H8m.D6G(cc._renderType, cc._RENDER_TYPE_CANVAS) && this._setNodeDirtyForCache();
                var P = X.atlasIndex;
                this.tiles[this._atlasIndexArray[P]] = 0;
                this._atlasIndexArray.splice(P, 1);
                cc.SpriteBatchNode.prototype.removeChild.call(this, X, S);
            }
    },
    getLayerName: function() {
        return this.layerName;
    },
    setLayerName: function(X) {
        this.layerName = X;
    },
    _positionForIsoAt: function(X) {
        return cc.p(H8m.c6G(this._mapTileSize.width, 2, (this._layerSize.width + X.x - X.y - 1)), H8m.t6G(this._mapTileSize.height, 2, (2 * this._layerSize.height - X.x - X.y - 2)));
    },
    _positionForOrthoAt: function(X) {
        return cc.p(H8m.a6G(X.x, this._mapTileSize.width), H8m.O6G((this._layerSize.height - X.y - 1), this._mapTileSize.height));
    },
    _positionForHexAt: function(X) {
        return cc.p(H8m.B6G(X.x, this._mapTileSize.width, 3, 4), H8m.N6G((this._layerSize.height - X.y - 1), this._mapTileSize.height) + (H8m.m6G(1, X.x % 2) ? -this._mapTileSize.height / 2 : 0));
    },
    _calculateLayerOffset: function(X) {
        var S = cc.p(0, 0);
        switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ORTHO:
            S = cc.p(H8m.A6G(X.x, this._mapTileSize.width), -X.y * this._mapTileSize.height);
            break;
        case cc.TMX_ORIENTATION_ISO:
            S = cc.p(H8m.E6G(this._mapTileSize.width, 2, (X.x - X.y)), this._mapTileSize.height / 2 * (-X.x - X.y));
            break;
        case cc.TMX_ORIENTATION_HEX:
            H8m.v6G(0, X.x) && H8m.u6G(0, X.y) || cc.log("offset for hexagonal map not implemented yet");
        }
        return S;
    },
    _appendTileForGID: function(X, S) {
        var P = this.tileset.rectForGID(X),
            P = cc.RECT_PIXELS_TO_POINTS(P),
            O = H8m.H6G(0, S.x + S.y * this._layerSize.width),
            P = this._reusedTileWithRect(P);
        this._setupTileSprite(P, S, X);
        var Z = this._atlasIndexArray.length;
        this.insertQuadFromSprite(P, Z);
        this._atlasIndexArray.splice(Z, 0, O);
        return P;
    },
    _insertTileForGID: function(X, S) {
        var P = this.tileset.rectForGID(X),
            P = cc.RECT_PIXELS_TO_POINTS(P),
            O = H8m.f6G(0, S.x + S.y * this._layerSize.width),
            P = this._reusedTileWithRect(P);
        this._setupTileSprite(P, S, X);
        var Z = this._atlasIndexForNewZ(O);
        this.insertQuadFromSprite(P, Z);
        this._atlasIndexArray.splice(Z, 0, O);
        if (this._children)
            for (var Y = this._children, T = 0, R = Y.length; H8m.I6G(T, R); T++) {
                var E = Y[T];
                if (E) {
                    var V = E.atlasIndex;
                    H8m.g2G(V, Z) && (E.atlasIndex = V + 1);
                }
            }
        this.tiles[O] = X;
        return P;
    },
    _updateTileForGID: function(X, S) {
        var P = this.tileset.rectForGID(X),
            O = this._contentScaleFactor,
            P = cc.rect(H8m.K2G(P.x, O), H8m.d2G(P.y, O), H8m.t2G(P.width, O), H8m.w2G(P.height, O)),
            O = S.x + H8m.e2G(S.y, this._layerSize.width),
            P = this._reusedTileWithRect(P);
        this._setupTileSprite(P, S, X);
        var Z = this._atlasIndexForExistantZ(O);
        P.atlasIndex = Z;
        P.dirty = !0;
        P.updateTransform();
        this.tiles[O] = X;
        return P;
    },
    _parseInternalProperties: function() {
        var X = this.getProperty("cc_vertexz");
        if (X)
            if (H8m.Q2G("automatic", X)) {
                this._useAutomaticVertexZ = !0;
                var S = this.getProperty("cc_alpha_func"),
                    X = 0;
                S && (X = parseFloat(S));
                H8m.r2G(cc._renderType, cc._RENDER_TYPE_WEBGL) && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), S = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(S, X));
            } else
                this._vertexZvalue = parseInt(X, 10);
    },
    _setupTileSprite: function(X, S, P) {
        var O = S.x + H8m.N2G(S.y, this._layerSize.width);
        X.setPosition(this.getPositionAt(S));
        H8m.m2G(cc._renderType, cc._RENDER_TYPE_WEBGL) ? X.vertexZ = this._vertexZForPos(S) : X.tag = O;
        X.anchorX = 0;
        X.anchorY = 0;
        X.opacity = this._opacity;
        H8m.A2G(cc._renderType, cc._RENDER_TYPE_WEBGL) && (X.rotation = 0);
        X.setFlippedX(!1);
        X.setFlippedY(!1);
        H8m.E2G((P & cc.TMX_TILE_DIAGONAL_FLAG), 0) ? (X.anchorX = 0.5, X.anchorY = 0.5, X.x = this.getPositionAt(S).x + H8m.C2G(X.width, 2), X.y = this.getPositionAt(S).y + H8m.h2G(X.height, 2), S = H8m.y2G((P & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0), 0), H8m.q2G(S, cc.TMX_TILE_HORIZONTAL_FLAG) ? X.rotation = 90 : H8m.l2G(S, cc.TMX_TILE_VERTICAL_FLAG) ? X.rotation = 270 : (X.rotation = H8m.X9v(S, (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) ? 90 : 270, X.setFlippedX(!0))) : (H8m.D9v((P & cc.TMX_TILE_HORIZONTAL_FLAG), 0) && X.setFlippedX(!0), H8m.c9v((P & cc.TMX_TILE_VERTICAL_FLAG), 0) && X.setFlippedY(!0));
    },
    _reusedTileWithRect: function(X) {
        H8m.z9v(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (this._reusedTile ? (this._reusedTile.batchNode = null, this._reusedTile.setTextureRect(X, !1)) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this.texture, X, !1)), this._reusedTile.batchNode = this) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this._textureForCanvas, X, !1), this._reusedTile.batchNode = this, this._reusedTile.parent = this);
        return this._reusedTile;
    },
    _vertexZForPos: function(X) {
        var S = 0,
            P = 0;
        if (this._useAutomaticVertexZ)
            switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                P = this._layerSize.width + this._layerSize.height;
                S = -(H8m.j9v(P, (X.x + X.y)));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                S = -(H8m.x9v(this._layerSize.height, X.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value");
            }
        else
            S = this._vertexZvalue;
        return S;
    },
    _atlasIndexForExistantZ: function(X) {
        var S;
        if (this._atlasIndexArray)
            for (var P = this._atlasIndexArray, O = 0, Z = P.length; H8m.o9v(O, Z) && (S = P[O], H8m.p9v(S, X)); O++)
                ;
        "number" != typeof S && cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return O;
    },
    _atlasIndexForNewZ: function(X) {
        for (var S = this._atlasIndexArray, P = 0, O = S.length; H8m.Y9v(P, O) && !(H8m.T9v(X, S[P])); P++)
            ;
        return P;
    }
});
w6b0K[q0K]._p = cc.TMXLayer.prototype;
H8m.R9v(cc._renderType, cc._RENDER_TYPE_WEBGL) ? (_p.draw = cc.SpriteBatchNode.prototype.draw, _p.visit = cc.SpriteBatchNode.prototype.visit, _p.getTexture = cc.SpriteBatchNode.prototype.getTexture) : (_p.draw = _p._drawForCanvas, _p.visit = _p._visitForCanvas, _p.getTexture = _p._getTextureForCanvas);
cc.defineGetterSetter(_p, H8m.j8P, _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, H8m.f6H, _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, H8m.I1S, _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, H8m.J5P, _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, H8m.i8S, _p._getTileHeight, _p._setTileHeight);
delete w6b0K[q0K]._p;
cc.TMXLayer.create = function(X, S, P) {
    var O = new cc.TMXLayer;
    return O.initWithTilesetInfo(X, S, P) ? O : H8m.H6P;
};
cc.PointObject = cc.Class.extend({
    _ratio: H8m.H6P,
    _offset: H8m.H6P,
    _child: H8m.H6P,
    getRatio: function() {
        return this._ratio;
    },
    setRatio: function(X) {
        this._ratio = X;
    },
    getOffset: function() {
        return this._offset;
    },
    setOffset: function(X) {
        this._offset = X;
    },
    getChild: function() {
        return this._child;
    },
    setChild: function(X) {
        this._child = X;
    },
    initWithCCPoint: function(X, S) {
        this._ratio = X;
        this._offset = S;
        this._child = H8m.H6P;
        return !H8m.U7H;
    }
});
cc.PointObject.create = function(X, S) {
    var P = new cc.PointObject;
    P.initWithCCPoint(X, S);
    return P;
};
cc.ParallaxNode = cc.NodeRGBA.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function() {
        return this.parallaxArray;
    },
    setParallaxArray: function(X) {
        this.parallaxArray = X;
    },
    ctor: function() {
        cc.NodeRGBA.prototype.ctor.call(this);
        this.parallaxArray = [];
        this._lastPosition = cc.p(-100, -100);
    },
    addChild: function(X, S, P, O) {
        if (H8m.M9v(3, arguments.length))
            cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!X)
                throw "cc.ParallaxNode.addChild(): child should be non-null";
            var Z = cc.PointObject.create(P, O);
            Z.setChild(X);
            this.parallaxArray.push(Z);
            X.setPosition(H8m.V9v(this._position.x, P.x) + O.x, H8m.s9v(this._position.y, P.y) + O.y);
            cc.NodeRGBA.prototype.addChild.call(this, X, S, X.tag);
        }
    },
    removeChild: function(X, S) {
        for (var P = this.parallaxArray, O = 0; H8m.U9v(O, P.length); O++)
            if (H8m.b9v(P[O].getChild(), X)) {
                P.splice(O, 1);
                break;
            }
        cc.NodeRGBA.prototype.removeChild.call(this, X, S);
    },
    removeAllChildren: function(X) {
        this.parallaxArray.length = 0;
        cc.NodeRGBA.prototype.removeAllChildren.call(this, X);
    },
    visit: function() {
        var X = this._absolutePosition();
        if (!cc.pointEqualToPoint(X, this._lastPosition)) {
            for (var S = this.parallaxArray, P = 0, O = S.length; H8m.F9v(P, O); P++) {
                var Z = S[P];
                Z.getChild().setPosition(-X.x + X.x * Z.getRatio().x + Z.getOffset().x, -X.y + X.y * Z.getRatio().y + Z.getOffset().y);
            }
            this._lastPosition = X;
        }
        cc.NodeRGBA.prototype.visit.call(this);
    },
    _absolutePosition: function() {
        for (var X = this._position, S = this; H8m.k1v(null, S.parent);)
            S = S.parent, X = cc.pAdd(X, S.getPosition());
        return X;
    }
});
cc.ParallaxNode.create = function() {
    return new cc.ParallaxNode;
};
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new (w6b0K[q0K].AudioContext || w6b0K[q0K].webkitAudioContext || w6b0K[q0K].mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function(X) {
            this._events = {};
            this.src = X;
            this._volumeNode = _ctx.createGain ? _ctx.createGain() : _ctx.createGainNode();
            this._onSuccess1 = this._onSuccess.bind(this);
            this._onError1 = this._onError.bind(this);
        },
        _play: function(X) {
            var S = this._sourceNode = _ctx.createBufferSource(),
                P = this._volumeNode;
            S.buffer = this._buffer;
            P.gain.value = this._volume;
            S.connect(P);
            P.connect(_ctx.destination);
            S.loop = this._loop;
            this._stopped = this._paused = !1;
            S.start ? S.start(0, X) : S.noteGrainOn ? (P = S.buffer.duration, this.loop ? S.noteGrainOn(0, X, P) : S.noteGrainOn(0, X, H8m.L1v(P, X))) : S.start(1);
            this._pauseTime = 0;
        },
        _stop: function() {
            var X = this._sourceNode;
            this._stopped || (X.stop ? X.stop(0) : X.stop(0), this._stopped = !0);
        },
        play: function() {
            if (-1 == this._loadState)
                this._loadState = 0;
            else if (H8m.i1v(1, this._loadState)) {
                var X = this._sourceNode;
                if (this._stopped || !X || H8m.S1v(2, X.playbackState))
                    this.startTime = _ctx.currentTime, this._play(0);
            }
        },
        pause: function() {
            this._pauseTime = _ctx.currentTime;
            this._paused = !0;
            this._stop();
        },
        resume: function() {
            this._paused && this._play(this._buffer ? H8m.P1v((this._pauseTime - this.startTime), this._buffer.duration) : 0);
        },
        stop: function() {
            this._pauseTime = 0;
            this._paused = !1;
            this._stop();
        },
        load: function() {
            var X = this;
            if (H8m.a1v(1, X._loadState)) {
                X._loadState = -1;
                X.played = !1;
                X.ended = !0;
                var S = new XMLHttpRequest;
                S.open("GET", X.src, !0);
                S.responseType = "arraybuffer";
                S.onload = function() {
                    _ctx.decodeAudioData(S.response, X._onSuccess1, X._onError1);
                };
                S.send();
            }
        },
        addEventListener: function(X, S) {
            this._events[X] = S.bind(this);
        },
        removeEventListener: function(X) {
            delete this._events[X];
        },
        canplay: function() {
            return cc.sys._supportWebAudio;
        },
        _onSuccess: function(X) {
            this._buffer = X;
            X = this._events.success;
            var S = this._events.canplaythrough;
            X && X();
            S && S();
            H8m.O1v(0, this._loadState) && H8m.B1v("autoplay", this.autoplay) && !0 != this.autoplay || this._play();
            this._loadState = 1;
        },
        _onError: function() {
            var X = this._events.error;
            X && X();
            this._loadState = -2;
        },
        cloneNode: function() {
            var X = new cc.WebAudio(this.src);
            X.volume = this.volume;
            X._loadState = this._loadState;
            X._buffer = this._buffer;
            H8m.Z1v(0, X._loadState) && -1 != X._loadState || X.load();
            return X;
        }
    });
    w6b0K[q0K]._p = cc.WebAudio.prototype;
    cc.defineGetterSetter(_p, H8m.g6S, function() {
        return this._loop;
    }, function(X) {
        this._loop = X;
        this._sourceNode && (this._sourceNode.loop = X);
    });
    cc.defineGetterSetter(_p, H8m.b3S, function() {
        return this._volume;
    }, function(X) {
        this._volume = X;
        this._volumeNode.gain.value = X;
    });
    cc.defineGetterSetter(_p, H8m.w2P, function() {
        return this._paused;
    });
    cc.defineGetterSetter(_p, H8m.I1K, function() {
        var X = this._sourceNode;
        return !this._paused && (this._stopped || !X || H8m.J1v(H8m.v7H, X.playbackState));
    });
    cc.defineGetterSetter(_p, H8m.C5H, function() {
        var X = this._sourceNode;
        return X && H8m.n1v(H8m.s7H, X.playbackState);
    });
    delete w6b0K[q0K]._p;
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function() {
        this._soundSupported = H8m.G1v(0, cc._audioLoader._supportedAudioTypes.length);
        this._effectPauseCb && (this._effectPauseCb = this._effectPauseCb.bind(this));
    },
    willPlayMusic: function() {
        return !1;
    },
    getEffectsVolume: function() {
        return this._effectsVolume;
    },
    playMusic: function(X, S) {
        if (this._soundSupported) {
            var P = this._currMusic;
            P && this._stopAudio(P);
            H8m.W1v(X, this._currMusicPath) && (this._currMusic = P = this._getAudioByUrl(X), this._currMusicPath = X);
            P && (P.loop = S || !1, this._playMusic(P));
        }
    },
    _getAudioByUrl: function(X) {
        var S = cc.loader,
            P = S.getRes(X);
        P || (S.load(X), P = S.getRes(X));
        return P;
    },
    _playMusic: function(X) {
        X.ended || (X.stop ? X.stop() : (X.pause(), X.duration && (X.currentTime = X.duration)));
        this._musicPlayState = 2;
        X.play();
    },
    stopMusic: function(X) {
        if (H8m.v1v(0, this._musicPlayState)) {
            var S = this._currMusic;
            S && (this._stopAudio(S), X && cc.loader.release(this._currMusicPath), this._currMusicPath = this._currMusic = null, this._musicPlayState = 0);
        }
    },
    _stopAudio: function(X) {
        X && !X.ended && (X.stop ? X.stop() : (X.pause(), X.duration && (X.currentTime = X.duration)));
    },
    pauseMusic: function() {
        H8m.u1v(2, this._musicPlayState) && (this._currMusic.pause(), this._musicPlayState = 1);
    },
    resumeMusic: function() {
        H8m.H1v(1, this._musicPlayState) && (this._resumeAudio(this._currMusic), this._musicPlayState = 2);
    },
    _resumeAudio: function(X) {
        X && !X.ended && (X.resume ? X.resume() : X.play());
    },
    rewindMusic: function() {
        this._currMusic && this._playMusic(this._currMusic);
    },
    getMusicVolume: function() {
        return H8m.f1v(0, this._musicPlayState) ? 0 : this._currMusic.volume;
    },
    setMusicVolume: function(X) {
        H8m.I1v(0, this._musicPlayState) && (this._currMusic.volume = Math.min(Math.max(X, 0), 1));
    },
    isMusicPlaying: function() {
        return H8m.g8v(2, this._musicPlayState) && this._currMusic && !this._currMusic.ended;
    },
    _getEffectList: function(X) {
        var S = this._audioPool[X];
        S || (S = this._audioPool[X] = []);
        return S;
    },
    _getEffect: function(X) {
        var S;
        if (this._soundSupported) {
            for (var P = this._getEffectList(X), O = 0, Z = P.length; H8m.K8v(O, Z); O++) {
                var Y = P[O];
                if (Y.ended) {
                    S = Y;
                    S.currentTime = 0;
                    w6b0K[q0K]['chrome'] && S.load();
                    break;
                }
            }
            if (!S) {
                if (H8m.d8v(P.length, this._maxAudioInstance))
                    return cc.log("Error: " + X + " greater than " + this._maxAudioInstance), null;
                S = this._getAudioByUrl(X);
                if (!S)
                    return null;
                S = S.cloneNode(!0);
                this._effectPauseCb && S.addEventListener("pause", this._effectPauseCb);
                S.volume = this._effectsVolume;
                P.push(S);
            }
            return S;
        }
    },
    playEffect: function(X, S) {
        var P = this._getEffect(X);
        if (!P)
            return null;
        P.loop = S || !1;
        P.play();
        var O = this._audioID++;
        this._effects[O] = P;
        return O;
    },
    setEffectsVolume: function(X) {
        X = this._effectsVolume = Math.min(Math.max(X, 0), 1);
        var S = this._effects,
            P;
        for (P in S)
            S[P].volume = X;
    },
    pauseEffect: function(X) {
        (X = this._effects[X]) && !X.ended && X.pause();
    },
    pauseAllEffects: function() {
        var X = this._effects,
            S;
        for (S in X) {
            var P = X[S];
            P.ended || P.pause();
        }
    },
    resumeEffect: function(X) {
        this._resumeAudio(this._effects[X]);
    },
    resumeAllEffects: function() {
        var X = this._effects,
            S;
        for (S in X)
            this._resumeAudio(X[S]);
    },
    stopEffect: function(X) {
        this._stopAudio(this._effects[X]);
        delete this._effects[X];
    },
    stopAllEffects: function() {
        var X = this._effects,
            S;
        for (S in X)
            this._stopAudio(X[S]), delete X[S];
    },
    unloadEffect: function(X) {
        var S = cc.loader,
            P = this._effects,
            O = this._getEffectList(X);
        S.release(X);
        if (H8m.t8v(0, O.length)) {
            S = O[0].src;
            delete this._audioPool[X];
            for (var Z in P)
                H8m.w8v(P[Z].src, S) && (this._stopAudio(P[Z]), delete P[Z]);
        }
    },
    end: function() {
        this.stopMusic();
        this.stopAllEffects();
    },
    _pausePlaying: function() {
        var X = this._effects,
            S,
            P;
        for (P in X)
            !(S = X[P]) || S.ended || S.paused || (this._playings.push(S), S.pause());
        this.isMusicPlaying() && (this._playings.push(this._currMusic), this._currMusic.pause());
    },
    _resumePlaying: function() {
        for (var X = this._playings, S = 0, P = X.length; H8m.e8v(S, P); S++)
            this._resumeAudio(X[S]);
        X.length = 0;
    }
});
!cc.sys._supportWebAudio && H8m.Q8v(0, cc.sys._supportMultipleAudio) && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function(X) {
        this._stopAllEffects();
        this._super(X);
    },
    resumeMusic: function() {
        H8m.r8v(1, this._musicPlayState) && (this._stopAllEffects(), this._needToResumeMusic = !1, this._expendTime4Music = 0, this._super());
    },
    playEffect: function(X, S) {
        var P = function() {
                Z.loop = S || !1;
            },
            O = this._currEffect,
            Z = S ? this._getEffect(X) : this._getSingleEffect(X);
        if (!Z)
            return null;
        P();
        var Y = this._audioID++;
        this._effects[Y] = Z;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        O ? (H8m.N8v(O, Z) && this._waitingEffIds.push(this._currEffectId), this._waitingEffIds.push(Y), O.pause()) : (this._currEffect = Z, this._currEffectId = Y, Z.play());
        return Y;
    },
    pauseEffect: function(X) {
        cc.log("pauseEffect not supported in single audio mode!");
    },
    pauseAllEffects: function() {
        var S = this._waitingEffIds,
            P = this._pausedEffIds,
            O = this._currEffect;
        if (O) {
            var Z = function(X) {
                S.length = X;
            };
            for (var Y = 0, T = S.length; H8m.m8v(Y, T); Y++)
                P.push(S[Y]);
            Z(0);
            P.push(this._currEffectId);
            O.pause();
        }
    },
    resumeEffect: function(X) {
        cc.log("resumeEffect not supported in single audio mode!");
    },
    resumeAllEffects: function() {
        var S = function(X) {
                O.length = X;
            },
            P = this._waitingEffIds,
            O = this._pausedEffIds;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        for (var Z = 0, Y = O.length; H8m.A8v(Z, Y); Z++)
            P.push(O[Z]);
        S(0);
        !this._currEffect && H8m.E8v(0, P.length) && (P = P.pop(), O = this._effects[P]) && (this._currEffectId = P, this._currEffect = O, this._resumeAudio(O));
    },
    stopEffect: function(X) {
        var S = this._currEffect,
            P = this._waitingEffIds,
            O = this._pausedEffIds;
        S && H8m.C8v(this._currEffectId, X) ? this._stopAudio(S) : (S = P.indexOf(X), H8m.h8v(0, S) ? P.splice(S, 1) : (S = O.indexOf(X), H8m.y8v(0, S) && O.splice(S, 1)));
    },
    stopAllEffects: function() {
        this._stopAllEffects();
        !this._currEffect && this._needToResumeMusic && (this._resumeAudio(this._currMusic), this._musicPlayState = 2, this._needToResumeMusic = !1, this._expendTime4Music = 0);
    },
    unloadEffect: function(X) {
        var S = cc.loader,
            P = this._effects,
            O = this._effectCache4Single,
            Z = this._getEffectList(X),
            Y = this._currEffect;
        S.release(X);
        if (H8m.q8v(0, Z.length) || O[X]) {
            var T = function() {
                S = H8m.l8v(0, Z.length) ? Z[0].src : O[X].src;
            };
            T();
            delete this._audioPool[X];
            delete O[X];
            for (var R in P)
                H8m.X4v(P[R].src, S) && delete P[R];
            Y && H8m.D4v(Y.src, S) && this._stopAudio(Y);
        }
    },
    _getSingleEffect: function(S) {
        var P = function(X) {
                S = X;
            },
            O = function() {
                Y._isToPlay = !0;
            },
            Z = function(X) {
                S = X;
            },
            Y = this._effectCache4Single[S],
            T = this._waitingEffIds,
            R = this._pausedEffIds,
            E = this._effects;
        if (Y)
            Y.duration && (Y.currentTime = 0);
        else {
            Y = this._getAudioByUrl(S);
            if (!Y)
                return null;
            Y = Y.cloneNode(!0);
            this._effectPauseCb && Y.addEventListener("pause", this._effectPauseCb);
            Y.volume = this._effectsVolume;
            this._effectCache4Single[S] = Y;
        }
        Z(0);
        for (var V = T.length; H8m.c4v(S, V);)
            H8m.z4v(E[T[S]], Y) ? T.splice(S, 1) : S++;
        P(0);
        for (V = R.length; H8m.j4v(S, V);)
            H8m.x4v(E[R[S]], Y) ? R.splice(S, 1) : S++;
        O();
        return Y;
    },
    _stopAllEffects: function() {
        var S = this._currEffect,
            P = this._audioPool,
            O = this._effectCache4Single,
            Z = this._waitingEffIds,
            Y = this._pausedEffIds;
        if (S || H8m.o4v(0, Z.length) || H8m.p4v(0, Y.length)) {
            var T = function(X) {
                    Y.length = X;
                },
                R = function(X) {
                    Z.length = X;
                };
            for (var E in O) {
                var V = O[E];
                V.duration && (V.currentTime = V.duration);
            }
            R(0);
            T(0);
            for (E in P)
                for (O = P[E], Z = 0, Y = O.length; H8m.Y4v(Z, Y); Z++)
                    V = O[Z], V.loop = !1, V.duration && (V.currentTime = V.duration);
            S && this._stopAudio(S);
        }
    },
    _effectPauseCb: function() {
        if (!this._isHiddenMode) {
            var S = this._getWaitingEffToPlay();
            if (S)
                S._isToPlay ? (delete S._isToPlay, S.play()) : this._resumeAudio(S);
            else if (this._needToResumeMusic) {
                S = this._currMusic;
                if (S.duration) {
                    var P = function(X) {
                        S.currentTime = X;
                    };
                    var O = S.currentTime + this._expendTime4Music,
                        O = H8m.T4v(O, S.duration * (O / S.duration | 0));
                    P(O);
                }
                this._expendTime4Music = 0;
                this._resumeAudio(S);
                this._musicPlayState = 2;
                this._needToResumeMusic = !1;
            }
        }
    },
    _getWaitingEffToPlay: function() {
        var X = this._waitingEffIds,
            S = this._effects,
            P = this._currEffect,
            O = P ? H8m.R4v(P.currentTime, (P.startTime || 0)) : 0;
        for (this._expendTime4Music += O; H8m.M4v(0, X.length);) {
            var Z = X.pop();
            if (P = S[Z]) {
                if (P._isToPlay || P.loop || P.duration && H8m.V4v(P.currentTime + O, P.duration))
                    return this._currEffectId = Z, this._currEffect = P, !P._isToPlay && P.duration && (X = P.currentTime + O, X -= H8m.s4v(P.duration, (X / P.duration | 0)), P.currentTime = X), P._isToPlay = !1, P;
                P.duration && (P.currentTime = P.duration);
            }
        }
        return this._currEffect = this._currEffectId = null;
    },
    _pausePlaying: function() {
        var X = this._currEffect;
        this._isHiddenMode = !0;
        if (X = H8m.U4v(2, this._musicPlayState) ? this._currMusic : X)
            this._playings.push(X), X.pause();
    },
    _resumePlaying: function() {
        var X = this._playings;
        this._isHiddenMode = !1;
        H8m.b4v(0, X.length) && (this._resumeAudio(X[0]), X.length = 0);
    }
}));
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function() {
        return cc.loader.audioPath;
    },
    _load: function(S, P, O, Z, Y, T, R) {
        var E = this,
            V = cc.loader,
            U = cc.path,
            k9 = this._supportedAudioTypes,
            L9 = "";
        if (H8m.F4v(0, k9.length))
            return R("can not support audio!");
        if (-1 == Z)
            L9 = (U.extname(S) || "").toLowerCase(), E.audioTypeSupported(L9) || (L9 = k9[0], Z = 0);
        else if (H8m.k7v(Z, k9.length))
            L9 = k9[Z];
        else
            return R("can not found the resource of audio! Last match url is : " + S);
        if (H8m.L7v(0, Y.indexOf(L9)))
            return E._load(S, P, O, Z + 1, Y, T, R);
        S = U.changeExtname(S, L9);
        Y.push(L9);
        T = E._loadAudio(S, T, function(X) {
            if (X)
                return E._load(S, P, O, Z + 1, Y, T, R);
            R(null, T);
        });
        V.cache[P] = T;
    },
    audioTypeSupported: function(X) {
        return X ? H8m.i7v(0, this._supportedAudioTypes.indexOf(X.toLowerCase())) : !1;
    },
    _loadAudio: function(X, S, P) {
        for (var K6K in w6b0K[f0K]) {
            if (K6K.length == 9 && K6K.charCodeAt(8) == 116 && K6K.charCodeAt(7) == 110 && K6K.charCodeAt(0) == 117)
                break
        }
        ;
        var O = cc.WebAudio || Audio;
        H8m.S7v(2, arguments.length) ? (P = S, S = new O) : H8m.P7v(3, arguments.length) || S || (S = new O);
        S.src = X;
        S.preload = "auto";
        O = w6b0K[f0K][K6K];
        /Mobile/.test(O) && (/iPhone OS/.test(O) || /iPad/.test(O) || /Firefox/.test(O)) || /MSIE/.test(O) ? (S.load(), P(null, S)) : (S.addEventListener("canplaythrough", function() {
            P(null, S);
            this.removeEventListener("canplaythrough", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
        }, !1), S.addEventListener("error", function() {
            P("load " + X + " failed");
            this.removeEventListener("canplaythrough", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
        }, !1), S.load());
        return S;
    },
    load: function(X, S, P, O) {
        this._load(X, S, P, -1, [], null, O);
    }
};
cc._audioLoader._supportedAudioTypes = function() {
    var S = w6b0K[I0K]['createElement']("audio"),
        P = [];
    if (S.canPlayType) {
        var O = function(X) {
            X = S.canPlayType(X);
            return H8m.a7v("no", X) && H8m.O7v("", X);
        };
        O('audio/ogg; codecs\x3d"vorbis"') && P.push(".ogg");
        O("audio/mpeg") && P.push(".mp3");
        O('audio/wav; codecs\x3d"1"') && P.push(".wav");
        O("audio/mp4") && P.push(".mp4");
        (O("audio/x-m4a") || O("audio/aac")) && P.push(".m4a");
    }
    return P;
}();
cc.loader.register([H8m.s3S, H8m.z3S, H8m.Q3S, H8m.a5S, H8m.E3P], cc._audioLoader);
H8m.h6y();
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    cc.audioEngine._pausePlaying();
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    cc.audioEngine._resumePlaying();
});
SignalBinding.prototype = {
    active: !H8m.U7H,
    params: H8m.H6P,
    execute: function(X) {
        var S;
        this.active && this._listener && (X = this.params ? this.params.concat(X) : X, S = this._listener.apply(this.context, X), this._isOnce && this.detach());
        return S;
    },
    detach: function() {
        return this.isBound() ? this._signal.remove(this._listener, this.context) : H8m.H6P;
    },
    isBound: function() {
        return !!this._signal && !!this._listener;
    },
    isOnce: function() {
        return this._isOnce;
    },
    getListener: function() {
        return this._listener;
    },
    getSignal: function() {
        return this._signal;
    },
    _destroy: function() {
        delete this._signal;
        delete this._listener;
        delete this.context;
    },
    toString: function() {
        var X = ", active:",
            S = ", isBound:",
            P = "[SignalBinding isOnce:";
        return P + this._isOnce + S + this.isBound() + X + this.active + H8m.v9S;
    }
};
Signal.prototype = {
    VERSION: "::VERSION_NUMBER::",
    memorize: !1,
    _shouldPropagate: !0,
    active: !0,
    _registerListener: function(X, S, P, O) {
        var Z = this._indexOfListener(X, P);
        if (-1 !== Z) {
            if (X = this._bindings[Z], H8m.B7v(X.isOnce(), S))
                throw Error("You cannot add" + (S ? "" : "Once") + "() then add" + (S ? "Once" : "") + "() the same listener without removing the relationship first.");
        } else
            X = new SignalBinding(this, X, S, P, O), this._addBinding(X);
        this.memorize && this._prevParams && X.execute(this._prevParams);
        return X;
    },
    _addBinding: function(X) {
        var S = this._bindings.length;
        do --S;
        while (this._bindings[S] && H8m.Z7v(X._priority, this._bindings[S]._priority));
        this._bindings.splice(S + 1, 0, X);
    },
    _indexOfListener: function(X, S) {
        for (var P = this._bindings.length, O; P--;)
            if (O = this._bindings[P], H8m.J7v(O._listener, X) && H8m.n7v(O.context, S))
                return P;
        return -1;
    },
    has: function(X, S) {
        return -1 !== this._indexOfListener(X, S);
    },
    add: function(X, S, P) {
        validateListener(X, "add");
        return this._registerListener(X, !1, S, P);
    },
    addOnce: function(X, S, P) {
        validateListener(X, "addOnce");
        return this._registerListener(X, !0, S, P);
    },
    remove: function(X, S) {
        validateListener(X, "remove");
        var P = this._indexOfListener(X, S);
        -1 !== P && (this._bindings[P]._destroy(), this._bindings.splice(P, 1));
        return X;
    },
    removeAll: function() {
        for (var X = this._bindings.length; X--;)
            this._bindings[X]._destroy();
        this._bindings.length = 0;
    },
    getNumListeners: function() {
        return this._bindings.length;
    },
    halt: function() {
        this._shouldPropagate = !1;
    },
    dispatch: function(X) {
        if (this.active) {
            var S = Array.prototype.slice.call(arguments),
                P = this._bindings.length,
                O;
            this.memorize && (this._prevParams = S);
            if (P) {
                O = this._bindings.slice();
                this._shouldPropagate = !0;
                do P--;
                while (O[P] && this._shouldPropagate && !1 !== O[P].execute(S))
            }
        }
    },
    forget: function() {
        this._prevParams = null;
    },
    dispose: function() {
        this.removeAll();
        delete this._bindings;
        delete this._prevParams;
    },
    toString: function() {
        return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
    }
};
var signals = Signal;
H8m.u6y(Signal);
(function(X) {
    H8m.h6i === typeof define && define.amd ? define(function() {
        return signals;
    }) : H8m.l7H !== typeof module && module.exports ? module.exports = signals : X.signals = signals;
})(this);
var lg = lg || {};
lg.Preloader = cc.Scene.extend({
    _interval: null,
    _length: 0,
    _count: 0,
    _label: null,
    _className: "lg.Preloader",
    _logo: null,
    init: function() {
        var X = cc.director.getWinSize(),
            S = logoH,
            X = cc.p(H8m.G7v(X.width, 2), H8m.W7v(X.height, 2)),
            P = this._bgLayer = cc.LayerColor.create(cc.color(backgroundColor[0], backgroundColor[1], backgroundColor[2], 255));
        P.setPosition(0, 0);
        this.addChild(P, 0);
        this._logo = cc.Sprite.create(logoSrc);
        this._logo.setPosition(X);
        this._bgLayer.addChild(this._logo, 10);
        var O = this._label = cc.LabelTTF.create("Loading... 0%", "Arial", 14);
        O.setColor(cc.color(38, 192, 216));
        O.setPosition(cc.pAdd(X, cc.p(0, logoOnCenter ? 0 : -S / 2 - 10)));
        P.addChild(this._label, 10);
        return !0;
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3);
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%");
    },
    initWithResources: function(X, S) {
        "string" == typeof X && (X = [X]);
        this.resources = X || [];
        this.cb = S;
    },
    _startLoading: function() {
        var P = this;
        P.unschedule(P._startLoading);
        var O = P.resources;
        P._length = O.length;
        cc.loader.load(O, function(X, S) {
            P._count = S;
        }, function() {
            P.cb();
        });
        P.schedule(P._updatePercent);
    },
    _updatePercent: function() {
        var X = this._count,
            S = this._length,
            P;
        P = Math.min(H8m.v7v(X / S * 100, 0), 100);
        this._label.setString("Loading... " + P + "%");
        H8m.u7v(X, S) && this.unschedule(this._updatePercent);
    }
});
lg.preload = function(X, S) {
    if (H8m.H7v(null, X) || H8m.f7v(0, X.length))
        S();
    else {
        for (var P = !0, O = -1; ++O < X.length;)
            -1 == lg._resourcesLoaded.indexOf(X[O].src) && (lg._resourcesLoaded.push(X[O].src), P = !1);
        if (P)
            S();
        else
            return P = cc, P.loaderScene || (P.loaderScene = new lg.Preloader, P.loaderScene.init()), P.loaderScene.initWithResources(X, S), cc.director.runScene(P.loaderScene), P.loaderScene;
    }
};
H8m.y6y();
H8m.H6y();
H8m.b6y(H8m.e1i);
var TileValue = TileValue || {
    WALKABLE: H8m.U7H,
    BLOCK1: H8m.h7H,
    BLOCK2: H8m.s7H,
    BLOCK3: H8m.v7H,
    BLOCK4: H8m.q7H,
    BLOCK5: H8m.b7H
};
lg.TileMap = cc.Class.extend({
    id: "default",
    offsetX: 0,
    offsetY: 0,
    autoLayout: !1,
    _tileWidth: 0,
    _tileHeight: 0,
    _mapWidth: 0,
    _mapHeight: 0,
    _objectsMap: null,
    _objectsArr: null,
    setTileSize: function(X, S) {
        if (H8m.I7v(this._tileWidth, X) || H8m.g0v(this._tileHeight, S))
            this._tileWidth = X, this._tileHeight = S;
    },
    setMapSizePixel: function(X, S) {
        H8m.K0v(null, X) && (X = cc.visibleRect.width);
        H8m.d0v(null, S) && (S = cc.visibleRect.height);
        return this.setMapSize(Math.ceil(H8m.t0v(X, this._tileWidth)), Math.ceil(H8m.w0v(S, this._tileHeight)));
    },
    setMapSize: function(X, S) {
        var P = [[], []];
        if (H8m.e0v(this._mapWidth, X) && H8m.Q0v(this._mapHeight, S))
            return P;
        H8m.r0v(null, this._objectsArr) && (this._objectsArr = []);
        H8m.N0v(null, this._objectsMap) && (this._objectsMap = []);
        for (var O = this._mapWidth, Z = this._mapHeight, Y = -1, T = -1, R = Math.max(X, O), E = Math.max(S, Z); ++Y < R;) {
            H8m.m0v(null, this._objectsMap[Y]) && (this._objectsMap[Y] = []);
            for (T = -1; ++T < E;)
                H8m.A0v(Y, X) || H8m.E0v(T, S) ? (P[0] = P[0].concat(this._objectsMap[Y][T]), this.removeObjects(Y, T), delete this._objectsMap[Y][T]) : H8m.C0v(Y, O) && H8m.h0v(T, Z) || (this._objectsMap[Y][T] = [], P[1].push([Y, T]));
            H8m.y0v(0, this._objectsMap[Y].length) && delete this._objectsMap[Y];
        }
        this._mapWidth = X;
        this._mapHeight = S;
        return P;
    },
    clear: function(X) {
        if (H8m.q0v(0, this._objectsArr.length)) {
            void 0 === X && (X = !0);
            for (var S, P = 0; H8m.l0v(P, this._mapWidth); P++)
                for (var O = 0; H8m.X3v(O, this._mapHeight); O++) {
                    if (X) {
                        S = this._objectsMap[P][O];
                        for (var Z in S) {
                            var Y = S[Z];
                            H8m.D3v(Y, cc.Node) && Y.destroy();
                        }
                    }
                    this._objectsMap[P][O] = [];
                }
            this._objectsArr.length = 0;
        }
    },
    getPixelSize: function() {
        return cc.size(H8m.c3v(this._tileWidth, this._mapWidth), H8m.z3v(this._tileHeight, this._mapHeight));
    },
    getTileIndexX: function(X) {
        return Math.floor(H8m.j3v((X - this.offsetX), this._tileWidth));
    },
    getTileIndexY: function(X) {
        return Math.floor(H8m.x3v((X - this.offsetY), this._tileHeight));
    },
    getTiledPositionX: function(X) {
        return H8m.o3v((X + 0.5), this._tileWidth) + this.offsetX;
    },
    getTiledPositionY: function(X) {
        return H8m.p3v((X + 0.5), this._tileHeight) + this.offsetY;
    },
    getCoveredTiles: function(X, S) {
        var P = lg.getRect(X, !0);
        return this.getCoveredTiles1(P, S);
    },
    getCoveredTiles1: function(X, S) {
        S = !0 === S;
        for (var P = this.getTileIndexX(X.x), O = this.getTileIndexY(X.y), Z = this.getTileIndexX(X.x + X.width), Y = this.getTileIndexY(X.y + X.height), T = [], P = H8m.Y3v(P, 1), R = 0; ++P <= Z;)
            for (R = H8m.T3v(O, 1); ++R <= Y;)
                S ? T = T.concat(this.getObjects(P, R)) : T.push(cc.p(P, R));
        return T;
    },
    isValideTile: function(X, S) {
        return H8m.R3v(0, X) && H8m.M3v(X, this._mapWidth) && H8m.V3v(0, S) && H8m.s3v(S, this._mapHeight);
    },
    snapToTile: function(X, S, P, O) {
        if (H8m.U3v(X, cc.Node)) {
            var Z = null;
            if (void 0 === S || void 0 === P)
                Z = X.getPosition(), X.parent && (Z = X.parent.convertToWorldSpace(Z)), S = this.getTileIndexX(Z.x), P = this.getTileIndexY(Z.y);
            Z = cc.p(this.getTiledPositionX(S), this.getTiledPositionY(P));
            X.parent && (Z = X.parent.convertToNodeSpace(Z));
            X.setPosition(Z);
            !0 === O && X.setTileMap(this);
        }
    },
    snapAll: function() {
        for (var X = this._objectsArr.length, S = -1, P = null; ++S < X;)
            P = this._objectsArr[S], this.snapToTile(P);
    },
    addObject: function(X, S, P) {
        void 0 === S && (S = X.tx);
        void 0 === P && (P = X.ty);
        X.tx = S;
        X.ty = P;
        if (this.isValideTile(S, P) && !(-1 < this._objectsArr.indexOf(X))) {
            this._objectsArr.push(X);
            var O = this._objectsMap[S][P];
            if (H8m.b3v(X, cc.Node) && this.autoLayout) {
                S = H8m.F3v((S + (this._mapHeight - 1 - P) * this._mapWidth), MAX_IN_TILE);
                P = null;
                for (var Z = 0, Y = !1, T = 0; H8m.k5v(T, O.length); T++)
                    P = O[T], H8m.L5v(P, cc.Node) && (!Y && H8m.i5v(P.y, X.y) && (O.splice(T, 0, X), X.zIndex = Math.min(Z, MAX_IN_TILE) + S, Y = !0, Z++, T++), P.zIndex = Math.min(Z, MAX_IN_TILE) + S, Z++);
                Y || (O.push(X), X.zOrder = Math.min(Z, MAX_IN_TILE) + S);
            } else
                O.push(X);
        }
    },
    updateLayout: function(X, S) {
        if (this.isValideTile(X, S)) {
            var P = this._objectsMap[X][S];
            if (H8m.S5v(0, P.length)) {
                P.sort(this._sortByY);
                for (var O = null, Z = 0, Y = 0; H8m.P5v(Y, P.length); Y++)
                    O = P[Y], H8m.a5v(O, cc.Node) && (O.zIndex = Math.min(Z, MAX_IN_TILE) + zIndex0, Z++);
            }
        }
    },
    removeObject: function(X, S, P) {
        void 0 === S && (S = X.tx);
        void 0 === P && (P = X.ty);
        this.isValideTile(S, P) && (S = this._objectsMap[S][P], P = S.indexOf(X), -1 < P && S.splice(P, 1), P = this._objectsArr.indexOf(X), -1 < P && this._objectsArr.splice(P, 1));
    },
    removeObjects: function(X, S) {
        if (this.isValideTile(X, S))
            for (var P = this._objectsMap[X][S], O = null, O = -1; P.length;)
                O = P[0], O.tx = O.ty = -1, O = this._objectsArr.indexOf(O), -1 < O && this._objectsArr.splice(O, 1), P.splice(0, 1);
    },
    getObjects: function(X, S) {
        return this.isValideTile(X, S) ? this._objectsMap[X][S] : [];
    },
    getObjects1: function(X, S) {
        var P = this.getTileIndexX(X),
            O = this.getTileIndexY(S);
        return this.getObjects(P, O);
    },
    getAllObjects: function() {
        return this._objectsArr;
    },
    getTiles: function(X) {
        for (var S = [], P = -1, O = -1; ++P < this._mapWidth;)
            for (O = -1; ++O < this._mapHeight;)
                H8m.O5v(null, X) && !1 === X(this, P, O) || S.push(cc.p(P, O));
        return S;
    },
    getRow: function(X, S) {
        for (var P = -1, O = []; ++P < this._mapHeight;)
            O = !0 === S ? O.concat(this.getObjects(X, P)) : O.push(cc.p(X, P));
        return O;
    },
    getCol: function(X, S) {
        for (var P = -1, O = []; ++P < this._mapWidth;)
            O = !0 === S ? O.concat(this.getObjects(P, X)) : O.push(cc.p(P, X));
        return O;
    },
    isEmptyTile: function(X, S) {
        if (!this.isValideTile(X, S))
            return !1;
        var P = this.getObjects(X, S);
        return P ? H8m.B5v(0, P.length) : !1;
    },
    _sortByY: function(X, S) {
        if (H8m.Z5v(X.y, S.y))
            return -1;
        if (H8m.J5v(X.y, S.y))
            return 1;
    }
});
lg.TileMap.create = function(X) {
    var S = new lg.TileMap;
    S.id = X;
    return S;
};
H8m.f6y();
H8m.F6y();
H8m.l6y();
H8m.I6y(H8m.z1P);
H8m.X2y(H8m.e2H);
H8m.L2y();
H8m.D2y(H8m.H6P);
H8m.i2y(H8m.H6P);
H8m.d2y(H8m.u4S);
H8m.z2y(H8m.H6P);
H8m.P2y(H8m.H6P);
lg._scenesDict = {};
H8m.w2y();
H8m.a2y();
H8m.x2y();
H8m.e2y(H8m.H6P);
lg.init = function() {
    lg._inited || (lg._inited = !H8m.U7H, lg.assetsManager = lg.AssetsManager.create(), lg.inputManager = lg.InputManager.create(), cc.game.config.timeScale && cc.director.getScheduler().setTimeScale(cc.game.config.timeScale));
};
lg.registerScene = function(X, S, P) {
    lg.init();
    lg._scenesDict[X] = {
        scene: S,
        res: P
    };
};
lg.replaceScene = function(X) {
    var S = " firstly!",
        P = "Please register the scene: ",
        O = lg._scenesDict[X];
    if (H8m.n5v(H8m.H6P, O))
        throw P + X + S;
    lg.ObjectPool.release();
    lg.bulletCanvas && (lg.bulletCanvas = H8m.H6P);
    lg.currentSceneName = X;
    lg.inputManager.removeFromParent(!H8m.h7H);
    lg.currentScene = new O.scene;
    lg.preload(O.res, function() {
        lg.currentScene.addChild(lg.inputManager, H8m.x5P);
        cc.director.runScene(lg.currentScene);
        lg._checkDeviceOrientation();
    });
};
lg._tileMaps = {};
lg.getTileMap = function(X) {
    var S = " hasn't been defined, pls use lg.registerTileMap to define it firstly!",
        P = "The tileMap: ";
    if (H8m.l7H !== typeof lg._tileMaps[X])
        return lg._tileMaps[X];
    cc.log(P + X + S);
    return H8m.H6P;
};
lg.registerTileMap = function(X) {
    lg._tileMaps[X.id] = X;
};
lg.setSoundEnabled = function(X) {};
lg.getSoundEnabled = function() {};
lg.playMusic = function(X, S) {};
lg.playSound = function(X) {};
lg._checkDeviceOrientation = function() {
    var X = 1E6,
        S = "orientationchange",
        P = "onorientationchange";
    if (!lg._orientationTip && cc.sys.isMobile && cc.game.config.rotateImg) {
        lg._orientationTip = cc.LayerColor.create(cc.color(0, 0, 0), cc.visibleRect.width + 10, cc.visibleRect.height + 10);
        var O = cc.Sprite.create(cc.game.config.rotateImg);
        O.setPosition(cc.visibleRect.center);
        lg._orientationTip.__icon = O;
        lg._orientationTip.addChild(O);
        w6b0K[q0K]['addEventListener'](H8m.G5v(P, window) ? S : H8m.F2H, lg._showOrientaionTip, !H8m.U7H);
        lg._showOrientaionTip();
    }
    lg._orientationTip && (lg._orientationTip.removeFromParent(), lg.currentScene.addChild(lg._orientationTip, X));
};
H8m.o2y();
lg._showOrientaionTip = function() {
    for (var d6K in w6b0K[I0K]) {
        if (d6K.length == 4 && d6K.charCodeAt(3) == ((1.47E2, 1.311E3) < (1.41E3, 1.479E3) ? (0x255, 121) : (1.71E2, 40)) && d6K.charCodeAt((0x4D > (0x13B, 0xCC) ? (15., 6.5E1) : 30.0E1 <= (0x19A, 3.280E2) ? (2.73E2, 2) : (0x91, 45))) == 100 && d6K.charCodeAt(0) == 98)
            break
    }
    ;
    var X = H8m.W5v(H8m.h7i, Math.abs(w6b0K[q0K].orientation));
    lg._orientationTip.visible = H8m.v5v(cc.game.config.landscape, X);
    lg._orientationTip.__icon.rotation = X ? -H8m.h7i : H8m.U7H;
    w6b0K[I0K][d6K]['scrollTop'] = H8m.U7H;
    lg._orientationTip.visible ? (lg._oldGamePauseState = cc.director.isPaused(), cc.director.pause()) : lg._oldGamePauseState || cc.director.resume();
};
lg.getAngle = function(X, S, P) {
    return lg.getAngle1(H8m.u5v(S.x, X.x), H8m.H5v(S.y, X.y), P);
};
lg.getAngle1 = function(X, S, P) {
    void H8m.U7H === P && (P = !H8m.U7H);
    X = Math.atan2(X, S);
    H8m.f5v(H8m.U7H, X) && (X += H8m.I5v(H8m.s7H, Math.PI));
    P && (X *= RADIAN_TO_DEGREE);
    return X;
};
lg.getPointOnCircle = function(X, S) {
    S = -S * DEGREE_TO_RADIAN;
    return new cc.Point(H8m.g6v(X, Math.cos(S)), H8m.K6v(X, Math.sin(S)));
};
lg.getPosition = function(X, S) {
    var P = X.getPosition();
    !H8m.U7H === S && X.parent && (P = X.parent.convertToWorldSpace(P));
    return P;
};
lg.getRotation = function(X, S) {
    if (!H8m.U7H !== S)
        return X.rotation;
    for (var P = H8m.U7H, O = X; O;)
        P += O.rotation, O = O.parent;
    return P;
};
lg.getScale = function(X, S) {
    if (!H8m.U7H !== S)
        return cc.p(X.scaleX, X.scaleY);
    for (var P = H8m.h7H, O = H8m.h7H, Z = X; Z;)
        P *= Z.scaleX, O *= Z.scaleY, Z = Z.parent;
    return cc.p(P, O);
};
lg.getRect = function(X, S) {
    var P;
    if (X.getRect)
        return P = X.getRect(S);
    S = !1 !== S;
    P = X.getPosition();
    S && X.parent && (P = X.parent.convertToWorldSpace(P));
    var O = X.getContentSize(),
        Z = X.getAnchorPoint();
    return P = cc.rect(H8m.d6v(P.x, O.width * Z.x), H8m.t6v(P.y, O.height * Z.y), O.width, O.height);
};
lg.drawRect = function(X, S, P, O, Z) {
    H8m.w6v(null, S) && (S = cc.DrawNode.create(), lg.currentScene && lg.currentScene.addChild(S, 99999));
    H8m.e6v(null, P) && (P = 1);
    H8m.Q6v(null, O) && (O = cc.color(255, 0, 0, 255));
    var Y = cc.pAdd(cc.p(X.x, X.y), cc.p(X.width, X.height));
    S.drawRect(cc.p(X.x, X.y), Y, Z, P, O);
};
lg.ifTouched = function(X, S) {
    if (H8m.r6v(H8m.H6P, X) || !(H8m.N6v(X, cc.Node)))
        return !H8m.h7H;
    var P = X.convertToNodeSpace(S),
        O = lg.getRect(X);
    O.x = O.y = H8m.U7H;
    return cc.rectContainsPoint(O, P);
};
lg.ifCollide = function(X, S) {
    var P = lg.getRect(X, !H8m.U7H),
        O = lg.getRect(S, !H8m.U7H);
    return cc.rectIntersectsRect(P, O);
};
lg.isChildOf = function(X, S) {
    if (H8m.m6v(H8m.H6P, X) || H8m.A6v(H8m.H6P, S) || H8m.E6v(X, S))
        return !H8m.h7H;
    for (var P = X.parent; P;) {
        if (H8m.C6v(P, S))
            return !H8m.U7H;
        P = P.parent;
    }
    return !H8m.h7H;
};
lg.findParentWithClass = function(X, S) {
    for (var P = X; P;) {
        if (H8m.h6v(P, S))
            return P;
        P = P.parent;
    }
    return H8m.H6P;
};
lg.findChildWithClass = function(X, S) {
    for (var P = X.children, O = P.length, Z; O--;)
        if (Z = P[O], H8m.y6v(Z, S) || (Z = lg.findChildWithClass(Z, S)))
            return Z;
    return null;
};
lg.nameToObject = function(S, P) {
    if (void 0 == S || H8m.q6v("", S))
        return null;
    P = P || "function";
    for (var O = S.split("."), Z = window || this, Y = 0, T = O.length; H8m.l6v(Y, T); Y++)
        try {
            Z = Z[O[Y]];
        } catch (X) {
            break;
        }
    return typeof Z !== P ? null : Z;
};
lg.createBGLayer = function(X, S) {
    H8m.X2v(null, S) && (S = cc.color(255, 255, 255, 255));
    var P = cc.LayerColor.create(S, cc.visibleRect.width, cc.visibleRect.height);
    X.addChild(P, 0);
    return P;
};
Array.prototype.shuffle = function(X) {
    if (void 0 === X || H8m.D2v(0, X) || H8m.c2v(X, this.length))
        X = this.length;
    for (X -= 1; H8m.z2v(0, X); X--) {
        var S = H8m.j2v(0, cc.rand() % (X + 1)),
            P = this[X];
        this[X] = this[S];
        this[S] = P;
    }
};
lg.restrictValue = function(X, S, P) {
    X = Math.max(S, X);
    return X = Math.min(P, X);
};
lg.randInt = function(X, S) {
    return X + Math.floor(H8m.x2v(Math.random(), (S - X)));
};
lg.getRandomInArray = function(X) {
    if (H8m.o2v(null, X))
        return null;
    var S = lg.randInt(0, X.length);
    return X[S];
};
lg.getFileExtension = function(X) {
    X = X.substring(X.lastIndexOf(".") + 1, X.length);
    var S = X.indexOf(H8m.T9K);
    H8m.p2v(H8m.U7H, S) && (X = X.substring(H8m.U7H, S));
    return X;
};
lg.isImageFile = function(X) {
    X = lg.getFileExtension(X);
    return -H8m.h7H < cc.RESOURCE_TYPE.IMAGE.indexOf(X);
};
lg.copyProperties = function(S, P) {
    if (H8m.Y2v(H8m.H6P, S) && H8m.T2v(H8m.H6P, P))
        for (var O in S)
            try {
                P[O] = S[O];
            } catch (X) {}
};
lg.createDInts = function(X, S) {
    isNaN(S) && (S = H8m.U7H);
    for (var P = [], O = -H8m.h7H, Z = H8m.R2v(S, H8m.h7H), Y = S; ++O < X;)
        H8m.M2v(H8m.U7H, O % H8m.s7H) ? P.push(++Z) : P.push(--Y);
    return P;
};
var lg = lg || {},
    InputType = {
        press: H8m.t5H,
        up: H8m.H9i,
        click: H8m.F3i,
        move: H8m.P1K
    };
lg.InputManager = cc.Node.extend({
    enabled: !0,
    inTouching: !1,
    inDragging: !1,
    _masks: [],
    _callbacks: {},
    _globalListener: null,
    onEnter: function() {
        this._super();
        var P = this,
            O = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !1,
                onTouchBegan: function(X, S) {
                    P.inDragging = !1;
                    P.inTouching = !0;
                    P._dispatchOne(P, X, S, InputType.press);
                    return !0;
                },
                onTouchEnded: function(X, S) {
                    P.inDragging = !1;
                    P.inTouching = !1;
                    P._dispatchOne(P, X, S, InputType.up);
                    P._dispatchOne(P, X, S, InputType.click);
                },
                onTouchMoved: function(X, S) {
                    P.inDragging = !0;
                    P._dispatchOne(P, X, S, InputType.move);
                }
            });
        cc.eventManager.addListener(O, this);
    },
    onExit: function() {
        this._super();
        _masks = [];
        this.inTouching = !1;
        this._callbacks = {};
        cc.eventManager.removeAllListeners();
    },
    addMask: function(X) {
        -1 < this._masks.indexOf(X) || this._masks.push(X);
    },
    removeMask: function(X) {
        X = this._masks.indexOf(X);
        -1 < X && this._masks.splice(X, 1);
    },
    _compareRealZIndex: function(X, S) {
        if (!X.parent || !S.parent)
            return 1;
        if (H8m.V2v(X.parent, S.parent))
            return this._childIsOnFront(X, S);
        for (var P = null, O = 0, Z = [], Y = X.parent; Y;)
            Z.push(Y), Y = Y.parent;
        for (var T = [], Y = S.parent; Y;) {
            O = Z.indexOf(Y);
            if (-1 < O) {
                P = Y;
                break;
            }
            T.push(Y);
            Y = Y.parent;
        }
        Z = Z.slice(0, O);
        return this._childIsOnFront(Z[H8m.s2v(Z.length, 1)] || X, T[H8m.U2v(T.length, 1)] || S, P) ? 1 : -1;
    },
    _childIsOnFront: function(X, S, P) {
        H8m.b2v(null, P) && (P = X.parent);
        return H8m.F2v(P.children.indexOf(X), P.children.indexOf(S));
    },
    addListener: function(X, S, P, O) {
        if (H8m.k9A(null, S))
            throw "Event callback can not be null!";
        H8m.L9A(null, X) && (X = this);
        P = H8m.i9A(null, P) ? InputType.click : P;
        var Z = this._callbacks[X.__instanceId];
        H8m.S9A(null, Z) && (Z = [], this._callbacks[X.__instanceId] = Z, H8m.P9A(X, this) && this._createListener(X, !0));
        for (var Y = Z.length; Y--;)
            if (H8m.a9A(Z[Y].type, P) && H8m.O9A(Z[Y].func, S))
                return;
        Z.push({
            type: P,
            func: S,
            context: O || X
        });
    },
    removeListener: function(P, O, Z) {
        H8m.B9A(null, P) && (P = this);
        var Y = this._callbacks[P.__instanceId];
        Y && this.scheduleOnce(function() {
            var X = null,
                S = Y.length;
            if (O || Z)
                for (; S--;)
                    X = Y[S], (Z && H8m.Z9A(X.type, Z) || O && H8m.J9A(X.func, O)) && Y.splice(S, 1);
            H8m.n9A(0, Y.length) && (O || Z) || delete this._callbacks[P.__instanceId];
        }, 0.01);
    },
    handleTouchBegan: function(X, S) {
        if (!this.enabled)
            return !1;
        var P = S.getCurrentTarget();
        if (this._ifTargetIgnore(P, X))
            return !1;
        for (var O = X.getLocation(), Z = this._masks.length, Y = null, Y = null; Z--;)
            if (Y = this._masks[Z], H8m.G9A(P, Y) && !lg.isChildOf(P, Y) && !lg.isChildOf(Y, P) && !this._ifTargetIgnore(Y) && H8m.W9A(1, this._compareRealZIndex(Y, P)) && (Y = this._findRealTarget(Y, O)))
                return !1;
        lg.isButton(P) && (lg.buttonSound && lg.playSound(lg.buttonSound), this._setButtonState(P, ButtonState.DOWN));
        S.currentTarget = P;
        S.target = this._findRealTarget(P, O) || P;
        if ((H8m.v9A(P, cc.Layer) || H8m.u9A(P, lg.MovieClip)) && H8m.H9A(S.target, P))
            return !1;
        this._dispatch(P, X, S, InputType.press);
        return !0;
    },
    handleTouchEnded: function(X, S) {
        var P = S.getCurrentTarget();
        S.currentTarget = P;
        S.target = this._findRealTarget(P, X.getLocation()) || P;
        this._dispatch(P, X, S, InputType.up);
        var O = lg.ifTouched(P, X.getLocation());
        O && lg.isButton(P) && (P.isSelectable() ? P.isSelected() ? P.setState(ButtonState.UP) : P.setState(ButtonState.SELECTED) : P.setState(ButtonState.UP));
        O && this._dispatch(P, X, S, InputType.click);
    },
    handleTouchMoved: function(X, S) {
        var P = S.getCurrentTarget();
        lg.isButton(P) && (lg.ifTouched(P, X.getLocation()) ? this._setButtonState(P, ButtonState.DOWN) : this._setButtonState(P, ButtonState.UP));
        this._dispatch(P, X, S, InputType.move);
    },
    _createListener: function(P, O) {
        var Z = this;
        listener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: O,
            onTouchBegan: function(X, S) {
                return Z.handleTouchBegan(X, S);
            },
            onTouchEnded: function(X, S) {
                Z.handleTouchEnded(X, S);
            },
            onTouchMoved: function(X, S) {
                Z.handleTouchMoved(X, S);
            },
            onTouchCancelled: function(X, S) {
                Z.handleTouchEnded(X, S);
            }
        });
        cc.eventManager.addListener(listener, P);
    },
    _findRealTarget: function(X, S) {
        H8m.f9A(X, Array) || (X = [X]);
        for (var P = null, O = X.length; O--;)
            if (P = X[O], !this._ifTargetIgnore(P)) {
                if (H8m.I9A(0, P.children.length) && (this._temp = this._findRealTarget(P.children, S)))
                    return this._temp;
                if (lg.ifTouched(P, S))
                    return P;
            }
        return null;
    },
    _ifTargetIgnore: function(X, S) {
        return H8m.g1A(null, X) || !X.running || !this._ifTargetVisible(X) || X.isMouseEnabled && !1 === X.isMouseEnabled() || S && !lg.ifTouched(X, S.getLocation()) ? !0 : !1;
    },
    _ifTargetVisible: function(X) {
        for (; X;) {
            if (!X.visible)
                return !1;
            X = X.parent;
        }
        return !0;
    },
    _setButtonState: function(X, S) {
        X.isSelectable() && X.isSelected() && (S = H8m.K1A(S, ButtonState.UP) ? ButtonState.SELECTED : "selected_" + S);
        X.setState(S);
    },
    _dispatch: function(X, S, P, O) {
        for (; X;)
            this._dispatchOne(X, S, P, O), X = X.parent;
    },
    _dispatchOne: function(X, S, P, O) {
        var Z = this._callbacks[X.__instanceId];
        if (Z)
            for (var Y = null, T = Z.length; T--;)
                Y = Z[T], H8m.d1A(Y.type, O) && (P.currentTarget = X, Y.func.apply(Y.context, [S, P]));
    }
});
lg.InputManager.create = function() {
    var X = new lg.InputManager;
    X.init();
    return X;
};
H8m.Q2y();
F2C_ALIAS = {
    mc: "lg.MovieClip",
    btn: "lg.SimpleButton",
    button: "lg.Button",
    progress: "lg.ProgressBar",
    scrollPane: "lg.ScrollPane",
    scrollPane1: "lg.ScrollPane1"
};
lg.AssetsManager = cc.Class.extend({
    framesCache: null,
    displaysCache: null,
    displayDefineCache: null,
    mcsCache: null,
    subAnimsCache: null,
    fontsCache: null,
    init: function() {
        this.framesCache = {};
        this.displaysCache = {};
        this.displayDefineCache = {};
        this.mcsCache = {};
        this.subAnimsCache = {};
        this.fontsCache = {};
    },
    createDisplay: function(X, S, P, O, Z, Y) {
        if (H8m.t1A(null, X) || H8m.w1A(null, S))
            throw "Pleas give me plistFile and assetID!";
        this.addPlist(X);
        var T = !1;
        P ? T = !0 : P = S;
        var R = lg.nameToObject(P);
        if (H8m.e1A(null, R) && !T) {
            var T = !1,
                E = this.getDisplayDefine(X, S);
            H8m.Q1A(null, E) && (E = this.getMc(X, S), T = !0);
            E ? (P = E.type, R = lg.nameToObject(P), H8m.r1A(null, R) && (P = F2C_ALIAS[P], R = lg.nameToObject(P)), H8m.N1A(null, R) && (R = T ? lg.MovieClip : lg.Animator, P = T ? "lg.MovieClip" : "lg.Animator")) : T && (T = this.getSubAnims(X, S), T.length && (S = S + "$" + T[0], R = lg.MovieClip, P = "lg.MovieClip"));
            if (H8m.m1A(null, R))
                throw "There is no display with assetID: " + S + " in plist: " + X;
        }
        this._checkCreateFunc(R, P);
        T = null;
        !0 === O ? T = lg.ObjectPool.get(X, P, S).fetch(S, Z, Y) : (T = R.create(X, S), Y && T.attr(Y), Z && Z.addChild(T), T.clsName = P);
        return T;
    },
    cloneDisplay: function(X, S, P) {
        if (!(H8m.A1A(X, lg.TimeLine)))
            throw "cloneDisplay only support lg.TimeLine type!";
        S = this.createDisplay(X.plistFile, X.assetID, X.clsName, S, P ? X.parent : null);
        P && S.setPosition(X.getPosition());
        S.setScale(X.getScale());
        S.setRotation(X.rotation);
        S.zIndex = X.zIndex;
        return S;
    },
    _checkCreateFunc: function(X, S) {
        if (H8m.E1A(null, X))
            throw "The class: " + S + " is not found!";
        if (H8m.C1A(null, X.create))
            throw "Please implement  a create(plistFile, assetID) method for the target class: " + S;
    },
    addPlist: function(X) {
        if (H8m.h1A(null, X))
            cc.log("Plist File can't be null!");
        else {
            if ("undefined" !== typeof this.framesCache[X])
                return !1;
            var S = this._getFrameConfig(X);
            cc.spriteFrameCache.addSpriteFrames(X);
            var P = [],
                O = S.frames,
                Z;
            for (Z in O)
                P.push(Z);
            P.sort();
            this.framesCache[X] = P;
            if (S.hasOwnProperty("displays")) {
                P = S.displays;
                O = [];
                Z = null;
                if (P)
                    for (var Y in P)
                        O.push(Y), Z = P[Y], Z.anchors = this._parseFrames(Z.anchors, lg.Anchor), Z.colliders = this._parseFrames(Z.colliders, lg.Collider), this.displayDefineCache[X + Y] = Z, this._parseSubAnims(X, Y);
                this.displaysCache[X] = O;
            }
            if (S.hasOwnProperty("mcs")) {
                Y = S.mcs;
                for (var T in Y) {
                    O = Y[T];
                    P = {};
                    P.type = O.type;
                    P.totalFrames = O.totalFrames;
                    P.labels = O.labels;
                    P.anchorX = O.anchorX;
                    P.anchorY = O.anchorY;
                    P.rect = this._strToRect(O.rect);
                    P.anchors = this._parseFrames(O.anchors, lg.Anchor);
                    P.colliders = this._parseFrames(O.colliders, lg.Collider);
                    P.children = {};
                    Z = O.children;
                    for (var R in Z) {
                        var O = Z[R],
                            E = P.children[R] = {};
                        E.frames = this._strToArray(O.frames);
                        E["class"] = O["class"];
                        E.zIndex = parseInt(O.zIndex);
                        O.hasOwnProperty("text") && (E.text = O.text, E.align = O.align, E.width = O.width, E.height = O.height);
                    }
                    this.mcsCache[X + T] = P;
                    this._parseSubAnims(X, T);
                }
            }
            if (S.hasOwnProperty("fonts")) {
                var S = S.fonts,
                    V;
                for (V in S)
                    this.fontsCache[X + V] = S[V];
            }
            return !0;
        }
    },
    getFrameNames: function(X, S, P) {
        "undefined" === typeof this.framesCache[X] && this.addPlist(X);
        X = this.framesCache[X];
        if (H8m.y1A(null, X))
            return [];
        -1 == S && (S = 0);
        -1 == P && (P = H8m.q1A(X.length, 1));
        return X.slice(parseInt(S), parseInt(P) + 1);
    },
    getDisplayDefine: function(X, S) {
        var P = X + S;
        H8m.l1A(P, this.displayDefineCache) || this.addPlist(X);
        return this.displayDefineCache[P];
    },
    getDisplayNames: function(X) {
        "undefined" === typeof this.displaysCache[X] && this.addPlist(X);
        return this.displaysCache[X] || [];
    },
    getRandomDisplayName: function(X) {
        X = this.getDisplayNames(X);
        var S = Math.floor(H8m.X8A(Math.random(), X.length));
        return X[S];
    },
    getMc: function(X, S) {
        var P = X + S;
        H8m.D8A(P, this.mcsCache) || this.addPlist(X);
        return this.mcsCache[P];
    },
    getSubAnims: function(X, S) {
        return this.subAnimsCache[X + S] || [];
    },
    getFont: function(X, S) {
        var P = X + S;
        "undefined" === typeof this.fontsCache[P] && this.addPlist(X);
        return this.fontsCache[P];
    },
    _parseSubAnims: function(X, S) {
        var P = S.split("$"),
            O = P[0],
            P = P[1];
        if (O && P && H8m.c8A("", O) && H8m.z8A("", P)) {
            var O = X + O,
                Z = this.subAnimsCache[O];
            H8m.j8A(null, Z) && (Z = [], this.subAnimsCache[O] = Z);
            Z.push(P);
        }
    },
    _parseFrames: function(X, S) {
        var P = {};
        if (H8m.x8A(null, X))
            return P;
        for (var O in X)
            P[O] = this._strToArray(X[O], S);
        return P;
    },
    _strToArray: function(X, S) {
        for (var P = X.split("|"), O = -1, Z = []; ++O < P.length;) {
            var Y = P[O];
            H8m.o8A("null", Y) ? Z.push(null) : H8m.p8A("", Y) ? Z.push(Z[H8m.Y8A(O, 1)]) : S ? Z.push(new S(this._strToArray2(Y))) : Z.push(this._strToArray2(Y));
        }
        return Z;
    },
    _strToArray2: function(X) {
        X = X.split(",");
        for (var S = 0; H8m.T8A(S, X.length); S++)
            isNaN(parseInt(X[S], 10)) || (-1 < X[S].indexOf(".") ? X[S] = parseFloat(X[S]) : X[S] = parseInt(X[S]));
        return X;
    },
    _strToRect: function(X) {
        X = X.split(",");
        return cc.rect(parseFloat(X[0]), parseFloat(X[1]), parseFloat(X[2]), parseFloat(X[3]));
    },
    _getFrameConfig: function(X) {
        var S = cc.loader.getRes(X);
        if (!S)
            throw "Please load the resource first : " + X;
        var P = cc.spriteFrameCache;
        cc.loader.release(X);
        if (S._inited)
            return P._frameConfigCache[X] = S;
        var O = S.frames,
            Z = S.metadata || S.meta,
            Y = {},
            T = {},
            R = 0;
        Z && (R = Z.format, R = H8m.R8A(1, R.length) ? parseInt(R) : R, T.image = Z.textureFileName || Z.textureFileName || Z.image);
        for (var E in O) {
            var V = O[E];
            if (V) {
                Z = {};
                if (H8m.M8A(0, R)) {
                    Z.rect = cc.rect(V.x, V.y, V.width, V.height);
                    Z.rotated = !1;
                    Z.offset = cc.p(V.offsetX, V.offsetY);
                    var U = V.originalWidth,
                        V = V.originalHeight;
                    U && V || cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    U = Math.abs(U);
                    V = Math.abs(V);
                    Z.size = cc.size(U, V);
                } else if (H8m.V8A(1, R) || H8m.s8A(2, R))
                    Z.rect = P._rectFromString(V.frame), Z.rotated = V.rotated || !1, Z.offset = P._pointFromString(V.offset), Z.size = P._sizeFromString(V.sourceSize);
                else if (H8m.U8A(3, R)) {
                    var U = P._sizeFromString(V.spriteSize),
                        k9 = P._rectFromString(V.textureRect);
                    U && (k9 = cc.rect(k9.x, k9.y, U.width, U.height));
                    Z.rect = k9;
                    Z.rotated = V.textureRotated || !1;
                    Z.offset = P._pointFromString(V.spriteOffset);
                    Z.size = P._sizeFromString(V.spriteSourceSize);
                    Z.aliases = V.aliases;
                } else
                    U = V.frame, k9 = V.sourceSize, E = V.filename || E, Z.rect = cc.rect(U.x, U.y, U.w, U.h), Z.rotated = V.rotated || !1, Z.offset = cc.p(0, 0), Z.size = cc.size(k9.w, k9.h);
                Y[E] = Z;
            }
        }
        P._frameConfigCache[X] = {
            _inited: !0,
            frames: Y,
            meta: T
        };
        return S;
    }
});
lg.AssetsManager.create = function() {
    var X = new lg.AssetsManager;
    X.init();
    return X;
};
H8m.B2y();
lg.ColliderType = {
    rect: "Rect",
    circle: "Circle"
};
lg.Collider = cc.Class.extend({
    name: null,
    owner: null,
    type: lg.ColliderType.rect,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    rotation: 0,
    _bottomLeft: null,
    _localRect: null,
    ctor: function(X, S) {
        this.type = X[0];
        this.x = X[1];
        this.y = X[2];
        this.width = X[3];
        this.height = X[4];
        this.rotation = X[5];
        !1 === S ? (this._bottomLeft = cc.p(this.x, this.y), this.x += H8m.b8A(this.width, 2), this.y += H8m.F8A(this.height, 2)) : this._bottomLeft = cc.p(H8m.k4A(this.x, this.width / 2), H8m.L4A(this.y, this.height / 2));
        this._localRect = cc.rect(this._bottomLeft.x, this._bottomLeft.y, this.width, this.height);
    },
    clone: function() {
        var X = new lg.Collider([this.type, this.x, this.y, this.width, this.height, this.rotation]);
        X.name = this.name;
        X.owner = this.owner;
        return X;
    },
    checkCollision: function(X) {
        if (H8m.i4A(X.type, this.type) && H8m.S4A(this.type, lg.ColliderType.rect))
            return cc.rectIntersectsRect(this.getRect(), X.getRect());
    },
    getRect: function(X) {
        if (!1 === X)
            return this._localRect;
        X = this.owner.convertToWorldSpace(this._bottomLeft);
        var S = lg.getScale(this.owner, !0);
        return cc.rect(X.x, X.y, H8m.P4A(this.width, Math.abs(S.x)), H8m.a4A(this.height, Math.abs(S.y)));
    }
});
lg.Anchor = cc.Class.extend({
    x: H8m.U7H,
    y: H8m.U7H,
    zIndex: H8m.U7H,
    ctor: function(X) {
        this.x = X[H8m.U7H];
        this.y = X[H8m.h7H];
        H8m.O4A(2, X.length) && (this.zIndex = X[2]);
    }
});
lg.TimeLine = cc.Sprite.extend({
    onAnimationOver: null,
    autoDestroyWhenOver: !1,
    autoStopWhenOver: !1,
    autoHideWhenOver: !1,
    autoRecycle: !1,
    plistFile: null,
    currentFrame: 0,
    currentAnim: null,
    prevFrame: -1,
    totalFrames: 0,
    frameInterval: 0,
    loopStart: 0,
    loopEnd: 0,
    define: null,
    name: null,
    assetID: null,
    clsName: "lg.TimeLine",
    fps: 30,
    playing: !1,
    inRecycle: !1,
    _colliders: null,
    _mainCollider: null,
    _definedMainCollider: !1,
    _anchorBindings: null,
    _inited: !1,
    tx: 0,
    ty: 0,
    autoUpdateTileWhenMove: !0,
    tileValue: TileValue.WALKABLE,
    _tileMap: null,
    _tileInited: !1,
    _mouseEnabled: !0,
    _baseAssetID: null,
    _currentSubAnim: null,
    _subAnims: null,
    _animSequence: null,
    ctor: function(X, S) {
        cc.Sprite.prototype.ctor.call(this);
        if (!X || !S)
            throw "Please set plistFile and assetID to me!";
        this._anchorBindings = [];
        this._animSequence = [];
        this.onAnimationOver = new signals.Signal;
        this.setPlist(X, S);
    },
    setPlist: function(X, S) {
        if (H8m.B4A(null, X) || H8m.Z4A(null, S))
            throw "plistFile and assetID can not be null!";
        if (H8m.J4A(this.plistFile, X) || H8m.n4A(this.assetID, S) && H8m.G4A(this._baseAssetID, S)) {
            this.plistFile = X;
            lg.assetsManager.addPlist(X);
            var P = S.split("$");
            this._baseAssetID = P[0];
            this._subAnims = lg.assetsManager.getSubAnims(X, this._baseAssetID);
            P = P[1];
            H8m.W4A(null, P) && this._subAnims && (P = this._subAnims[0]);
            S = this._baseAssetID;
            P && (S = this._baseAssetID + "$" + P, this._currentSubAnim = P);
            this.assetID = S;
            if (this.define = this.getDefine()) {
                var P = this.define.anchorX,
                    O = this.define.anchorY;
                isNaN(P) || isNaN(O) || this.setAnchorPoint(P, O);
                this.onNewSheet();
                this.currentFrame = 0;
                this.renderFrame(this.currentFrame, !0);
                this._initColliders();
            } else
                cc.log("There is no display named: " + S + " in plist: " + X);
        }
    },
    getLabels: function(X) {
        return this.define.labels ? this.define.labels[X] : null;
    },
    hasLabel: function(X) {
        return H8m.v4A(null, this.getLabels(X));
    },
    getMainCollider: function() {
        return this._mainCollider;
    },
    getCollider: function(X) {
        return this._colliders && (X = this._colliders[X], H8m.u4A(null, X)) ? X = X[this.currentFrame] : null;
    },
    _initColliders: function() {
        this._mainCollider = null;
        this._colliders = {};
        var X = this.define.colliders;
        if (X) {
            var S = null,
                P;
            for (P in X) {
                this._colliders[P] = [];
                for (var O = X[P], Z = -1; ++Z < O.length;)
                    H8m.H4A(null, O[Z]) ? this._colliders[P][Z] = null : (S = this._colliders[P][Z] = O[Z].clone(), S.name = P, S.owner = this, H8m.f4A("main", P) && (this._mainCollider = S));
            }
        }
        this._definedMainCollider = H8m.I4A(null, this._mainCollider);
        this._definedMainCollider || (this._mainCollider = new lg.Collider(["Rect", 0, 0, this.width, this.height, 0], !1), this._mainCollider.name = "main", this._mainCollider.owner = this);
    },
    getRect: function(X) {
        return this._mainCollider.getRect(X);
    },
    getCenter: function(X) {
        X = this.getRect(X);
        return cc.p(X.x + H8m.g7A(X.width, 2), X.y + H8m.K7A(X.height, 2));
    },
    getAnchor: function(X) {
        return this.define.anchors && (X = this.define.anchors[X], H8m.d7A(null, X)) ? X = X[this.currentFrame] : null;
    },
    bindAnchor: function(X, S, P) {
        if (!this.define.anchors)
            return cc.log(this.assetID + ": there is no any anchor!"), !1;
        if (H8m.t7A(null, this.define.anchors[X]))
            return cc.log(this.assetID + ": there is no anchor named " + X), !1;
        if (-1 < this._anchorBindings.indexOf(S))
            return cc.log(this.assetID + ": anchor has been bound, " + X), !1;
        !1 !== P && this._anchorBindings.push(S);
        S.__anchor__ = X;
        this._updateAnchorNode(S, this.getAnchor(X));
        H8m.w7A(S.parent, this) && (S.removeFromParent(!1), this.addChild(S));
        return !0;
    },
    getCurrentLabel: function() {
        if (!this.define.labels)
            return null;
        var X = this.define.labels,
            S = null,
            P;
        for (P in X)
            if (S = X[P], H8m.e7A(this.currentFrame, S.start) && H8m.Q7A(this.currentFrame, S.end))
                return P;
        return null;
    },
    play: function() {
        this.loopStart = 0;
        this.loopEnd = H8m.r7A(this.totalFrames, 1);
        this.updatePlaying(!0);
        this._animSequence.length = 0;
    },
    playSequence: function(X) {
        if (H8m.N7A(null, X))
            return !1;
        H8m.m7A(X, Array) || (X = Array.prototype.slice.call(arguments));
        if (H8m.A7A(0, X.length))
            return !1;
        var S = this.gotoAndPlay(X.shift());
        this._animSequence = X;
        return S;
    },
    setSubAnim: function(X, S) {
        if (!X || H8m.E7A(0, X.length) || H8m.C7A(null, this._subAnims) || -1 == this._subAnims.indexOf(X))
            return !1;
        this._currentSubAnim = X;
        this.setPlist(this.plistFile, this._baseAssetID + "$" + X);
        !1 === S ? this.gotoAndStop(0) : this.gotoAndPlay(0);
        this._animSequence.length = 0;
        return !0;
    },
    gotoAndPlay: function(X) {
        if (isNaN(X)) {
            var S = this.getLabels(X);
            if (H8m.h7A(null, S)) {
                if (this.setSubAnim(X, !0))
                    return !0;
                this.play();
                return !1;
            }
            this.loopStart = S.start;
            this.loopEnd = S.end;
            this.currentFrame = this.loopStart;
            this.currentAnim = X;
        } else {
            if (!this.isValideFrame(X))
                return cc.log("The frame: " + X + " is out of range!"), !1;
            this.loopStart = 0;
            this.loopEnd = H8m.y7A(this.totalFrames, 1);
            this.currentFrame = X;
        }
        this.renderFrame(this.currentFrame);
        this.updatePlaying(!0);
        this._animSequence.length = 0;
        return !0;
    },
    stop: function() {
        this.updatePlaying(!1);
    },
    gotoAndStop: function(X) {
        if (isNaN(X)) {
            var S = this.getLabels(X);
            if (H8m.q7A(null, S))
                return this.setSubAnim(X, !1);
            this.currentAnim = X;
            X = S.start;
        } else
            this.currentAnim = null;
        if (!this.isValideFrame(X))
            return cc.log("The frame: " + X + " is out of range!"), !1;
        this.updatePlaying(!1);
        this.currentFrame = X;
        this.renderFrame(X);
        this._animSequence.length = 0;
        return !0;
    },
    setFPS: function(X) {
        H8m.l7A(this.fps, X) && (this.fps = X, this.updateSchedule());
    },
    updatePlaying: function(X) {
        H8m.X0A(this.playing, X) && (this.playing = X, this.updateSchedule());
    },
    updateSchedule: function() {
        this.playing ? H8m.D0A(1, this.totalFrames) && this.schedule(this.onFrame, H8m.c0A(1, this.fps), cc.REPEAT_FOREVER, 0) : this.unschedule(this.onFrame);
    },
    onFrame: function(X) {
        this._visible && !this.inRecycle && (this.renderFrame(this.currentFrame), this.currentFrame++, H8m.z0A(this.currentFrame, this.loopEnd) && (this.onAnimationOver.getNumListeners() && this.onAnimationOver.dispatch(this), this.autoDestroyWhenOver ? (this.updatePlaying(!1), this.destroy()) : this.autoStopWhenOver ? (this.currentFrame = this.loopEnd, this.updatePlaying(!1)) : this.autoHideWhenOver ? (this.currentFrame = this.loopEnd, this.updatePlaying(!1), this.visible = !1) : this._animSequence.length ? (X = this._animSequence.concat(), this.gotoAndPlay(X.shift()), this._animSequence = X) : this.currentFrame = this.loopStart));
    },
    isValideFrame: function(X) {
        return H8m.j0A(0, X) && H8m.x0A(X, this.totalFrames);
    },
    renderFrame: function(X, S) {
        if (H8m.o0A(this.prevFrame, X) || !0 == S)
            H8m.p0A(this.prevFrame, X) && (this.prevFrame = X), this._handleAnchorBindings(), this._updateCollider(), this.doRenderFrame(X);
    },
    doRenderFrame: function(X) {},
    _handleAnchorBindings: function() {
        for (var X = null, S = null, P = -1, O = this._anchorBindings.length; ++P < O;)
            X = this._anchorBindings[P], X.visible && (S = this.getAnchor(X.__anchor__), H8m.Y0A(null, S) && this._updateAnchorNode(X, S));
    },
    _updateAnchorNode: function(X, S) {
        H8m.T0A(null, S) && (X.x = S.x, X.y = S.y, X.zIndex = S.zIndex);
    },
    onEnter: function() {
        this._super();
        this.inRecycle = !1;
        this._tileMap && !this._tileInited && this._updateTileMap(!0);
        this._updateCollider();
        -1 < lg.languageIndex && this.name && -1 < this.name.indexOf("label__") && this.gotoAndStop(lg.languageIndex);
    },
    onExit: function() {
        this._super();
        this._tileMap && this._tileMap.removeObject(this);
        lg.inputManager.removeListener(this);
        this.onAnimationOver.removeAll();
    },
    getTileMap: function() {
        return this._tileMap;
    },
    setTileMap: function(X) {
        !X || H8m.R0A(X, lg.TileMap) || (X = lg.getTileMap(X));
        H8m.M0A(this._tileMap, X) && (this._tileMap && this._tileMap.removeObject(this), this._tileMap = X, H8m.V0A(null, this._tileMap) && this._parent && (this._updateTileMap(!0), this._updateCollider()));
    },
    _updateTileMap: function(X) {
        var S = this._position;
        this.parent && (S = this.parent.convertToWorldSpace(S));
        var P = this._tileMap.getTileIndexX(S.x),
            S = this._tileMap.getTileIndexY(S.y);
        this.setTile(P, S, X);
    },
    _updateCollider: function() {},
    setPosition: function(X, S) {
        var P = !1;
        void 0 === S ? (P = H8m.s0A(X.x, this._position._x) || H8m.U0A(X.y, this._position._y)) && this._super(X) : (P = H8m.b0A(X, this._position._x) || H8m.F0A(S, this._position._y)) && this._super(X, S);
        P && !this.inRecycle && (this.autoUpdateTileWhenMove && this._tileMap && this._updateTileMap(), this._updateCollider());
    },
    setTile: function(X, S, P) {
        if (!0 === P || H8m.k3A(X, this.tx) || H8m.L3A(S, this.ty)) {
            P = this.tx;
            var O = this.ty;
            this.tx = X;
            this.ty = S;
            this._tileMap && this._parent && (this._tileMap.removeObject(this, P, O), this.inRecycle || (this._tileMap.addObject(this), this._tileInited = !0));
        }
    },
    destroy: function() {
        this.autoRecycle && (this.inRecycle || lg.ObjectPool.get(this.plistFile, this.clsName, this.__pool__id__ || "").recycle(this));
        this.removeFromParent();
    },
    onRecycle: function() {
        this.inRecycle = !0;
        this.autoRecycle = !1;
        this.setScale(1);
        this.opacity = 255;
        this.rotation = 0;
        this.autoHideWhenOver = this.autoStopWhenOver = this.autoDestroyWhenOver = !1;
        this.gotoAndStop(0);
        this._tileMap && this._tileMap.removeObject(this);
        lg.inputManager.removeListener(this);
        this._tileInited = !1;
        this.setPosition(0, 0);
        this._animSequence.length = 0;
        for (var X = null, S = -1, P = this._anchorBindings.length; ++S < P;)
            X = this._anchorBindings[S], X.destroy ? X.destroy() : X.removeFromParent(!0), delete X.__anchor__;
        this._anchorBindings.length = 0;
    },
    isMouseEnabled: function() {
        return this._mouseEnabled;
    },
    setMouseEnabled: function(X) {
        this._mouseEnabled = X;
    },
    getDefine: function() {
        return null;
    },
    onNewSheet: function() {}
});
lg.TimeLine.create = function(X, S) {
    var P = new lg.TimeLine(X, S);
    P.clsName = H8m.n5H;
    return P;
};
w6b0K[q0K]._p = lg.TimeLine.prototype;
cc.defineGetterSetter(_p, H8m.F6P, _p.getMainCollider);
cc.defineGetterSetter(_p, H8m.P6i, _p.getCenter);
delete w6b0K[q0K]._p;
H8m.p2y();
lg.Animator = lg.TimeLine.extend({
    frameNames: H8m.H6P,
    onNewSheet: function() {
        var X = "There is no frame for display: ";
        this.frameNames = lg.assetsManager.getFrameNames(this.plistFile, this.define.start, this.define.end);
        this.totalFrames = this.frameNames.length;
        H8m.i3A(H8m.U7H, this.totalFrames) && cc.log(X + this.assetID);
    },
    doRenderFrame: function(X) {
        (X = cc.spriteFrameCache.getSpriteFrame(this.frameNames[X])) && this.setSpriteFrame(X);
    },
    getDefine: function() {
        return lg.assetsManager.getDisplayDefine(this.plistFile, this.assetID);
    }
});
lg.Animator.create = function(X, S) {
    var P = new lg.Animator(X, S);
    P.clsName = H8m.n2i;
    return P;
};
H8m.r2y();
lg.MovieClip = lg.TimeLine.extend({
    autoPlayChildren: !1,
    noOpacity: !0,
    _namedChildren: null,
    _theRect: null,
    replaceChild: function(X, S) {
        var P = this.define.children[X];
        if (H8m.S3A(null, P))
            cc.log("There is no child with named: " + X + "  in MovieClip: " + this.assetID);
        else {
            var O = this._namedChildren[X];
            O ? O.setPlist(this.plistFile, S) : P["class"] = S;
        }
    },
    onNewSheet: function() {
        for (var X in this._namedChildren)
            this._namedChildren[X].destroy(), delete this[X];
        this._namedChildren = {};
        this.totalFrames = this.define.totalFrames;
        this._theRect = cc.rect(this.define.rect);
        this.setContentSize(this._theRect.width, this._theRect.height);
    },
    onEnter: function() {
        this._super();
        this.setContentSize(this._theRect.width, this._theRect.height);
        this.opacity = 0;
    },
    doRenderFrame: function(X) {
        var S,
            P,
            O,
            Z;
        for (Z in this.define.children)
            if (P = this.define.children[Z], O = P.frames[X], S = this._namedChildren[Z], H8m.P3A(null, O))
                S && (S.visible = !1);
            else {
                H8m.a3A(null, S) && (H8m.O3A(null, P.text) ? (S = lg.Label.create(this.plistFile, P["class"]), S.params = P, S.setString(P.text)) : S = lg.assetsManager.createDisplay(this.plistFile, P["class"], null, !0), S.name = Z, this._namedChildren[Z] = S, this.autoPlayChildren && (this.playing ? S.gotoAndPlay(0) : S.gotoAndStop(0)), this[Z] = S, this.onNewChild(S));
                var Y = O[0],
                    T = O[1],
                    R = O[2],
                    E = O[3],
                    V = O[4];
                O = Math.round(H8m.B3A(255, O[5]));
                H8m.Z3A(Y, S.x) && (S.x = Y);
                H8m.J3A(T, S.y) && (S.y = T);
                H8m.n3A(R, S.rotation) && (S.rotation = R);
                H8m.G3A(E, S.scaleX) && (S.scaleX = E);
                H8m.W3A(V, S.scaleY) && (S.scaleY = V);
                !0 !== S.noOpacity && S.setOpacity && H8m.v3A(O, S.opacity) && (S.opacity = O);
                S.visible = !0;
                (S.autoPlayChildren = this.autoPlayChildren) && (this.playing ? S.play() : S.stop());
                H8m.u3A(S.parent, this) ? (S.removeFromParent(!1), this.addChild(S, P.zIndex)) : H8m.H3A(S.zIndex, P.zIndex) && (S.zIndex = P.zIndex);
            }
    },
    stop: function() {
        this._super();
        if (this.autoPlayChildren)
            for (var X in this._namedChildren) {
                var S = this._namedChildren[X];
                H8m.f3A(S, lg.TimeLine) && S.stop();
            }
    },
    play: function() {
        this._super();
        if (this.autoPlayChildren)
            for (var X in this._namedChildren) {
                var S = this._namedChildren[X];
                H8m.I3A(S, lg.TimeLine) && S.play();
            }
    },
    onNewChild: function(X) {},
    getDefine: function() {
        return lg.assetsManager.getMc(this.plistFile, this.assetID);
    },
    getChildByName: function(X, S) {
        void 0 === S && (S = !0);
        var P = this._namedChildren[X];
        if (P)
            return P;
        if (!S)
            return null;
        for (var O in this._namedChildren)
            if (P = this._namedChildren[O], P.getChildByName && (P = P.getChildByName(X, S)))
                return P;
    },
    getChildByAssetID: function(X) {
        var S = null,
            P;
        for (P in this._namedChildren)
            if (S = this._namedChildren[P], H8m.g5A(S.assetID, X))
                return S;
        return null;
    },
    getRect: function(X) {
        X = !1 !== X;
        if (!X)
            return this._mainCollider.getRect(!1);
        var S = this._mainCollider.width,
            P = this._mainCollider.height,
            O = cc.p(this._mainCollider._bottomLeft.x, this._mainCollider._bottomLeft.y);
        X = lg.getScale(this, X);
        H8m.K5A(0, X.x) && (O.x += S);
        H8m.d5A(0, X.y) && (O.y += P);
        O = this.convertToWorldSpace(O);
        return cc.rect(O.x, O.y, H8m.t5A(S, Math.abs(X.x)), H8m.w5A(P, Math.abs(X.y)));
    },
    getLabelText: function(X, S) {
        var P = this.getChildByName(X, void 0 === S ? !0 : S);
        return P && H8m.e5A(P, lg.Label) ? P.getString() : null;
    },
    setLabelText: function(X, S, P) {
        return (X = this.getChildByName(X, void 0 === P ? !0 : P)) && H8m.Q5A(X, lg.Label) ? (X.setString(S), X) : null;
    },
    onRecycle: function() {
        this._super();
        this.autoPlayChildren = !1;
    }
});
lg.MovieClip.create = function(X, S) {
    var P = new lg.MovieClip(X, S);
    P.clsName = H8m.P2P;
    return P;
};
H8m.Z2y();
lg.ProgressBarType = {
    HORIZONTAL: H8m.k7i,
    VERTICAL: H8m.i1S,
    RADIAL: H8m.q6H
};
lg.ProgressBar = lg.Animator.extend({
    noOpacity: !H8m.U7H,
    pBar: H8m.H6P,
    _type: lg.ProgressBarType.HORIZONTAL,
    _reversed: !H8m.h7H,
    _tween: H8m.H6P,
    onEnter: function() {
        this._super();
        this.setOpacity(H8m.U7H);
    },
    getPercentage: function() {
        return this.pBar ? this.pBar.percentage : H8m.U7H;
    },
    setPercentage: function(X) {
        this.pBar && (this.pBar.percentage = X);
    },
    getType: function() {
        return this._type;
    },
    setType: function(X) {
        H8m.r5A(this._type, X) && (this._type = X, this._updatePBar());
    },
    getReversed: function() {
        return this._reversed;
    },
    setReversed: function(X) {
        H8m.N5A(this._reversed, X) && (this._reversed = X, this._updatePBar(), this.percentage += H8m.h1S, this.percentage -= H8m.h1S);
    },
    tween: function(X, S, P) {
        H8m.m5A(H8m.H6P, this.pBar) && (this._tween && this.pBar.stopAction(this._tween), this._tween = cc.ProgressFromTo.create(P, X, S), this.pBar.runAction(this._tween));
    },
    stopTween: function() {
        this._tween && this.pBar && (this.pBar.stopAction(this._tween), this._tween = H8m.H6P);
    },
    doRenderFrame: function(X) {
        if (X = cc.spriteFrameCache.getSpriteFrame(this.frameNames[X]))
            X = cc.Sprite.create(X), H8m.A5A(null, this.pBar) ? (this.width = X.width, this.height = X.height, this.pBar = cc.ProgressTimer.create(X), this._updatePBar(), this.pBar.setAnchorPoint(this.getAnchorPoint()), this.pBar.setPosition(this.getAnchorPointInPoints()), this.addChild(this.pBar)) : this.pBar.setSprite(X);
    },
    _updatePBar: function() {
        if (H8m.E5A(H8m.H6P, this.pBar))
            if (H8m.C5A(this._type, lg.ProgressBarType.RADIAL))
                this.pBar.type = cc.PROGRESS_TIMER_TYPE_RADIAL, this.pBar.setReverseDirection(this._reversed), this.pBar.midPoint = cc.p(H8m.E1S, H8m.E1S);
            else {
                this.pBar.type = cc.PROGRESS_TIMER_TYPE_BAR;
                var X = H8m.h5A(this._type, lg.ProgressBarType.HORIZONTAL),
                    S = cc.p(H8m.U7H, H8m.U7H),
                    P = cc.p(X ? H8m.h7H : H8m.U7H, X ? H8m.U7H : H8m.h7H);
                this._reversed && (X ? S.x = H8m.h7H : S.y = H8m.h7H);
                this.pBar.midPoint = S;
                this.pBar.barChangeRate = P;
            }
    }
});
lg.ProgressBar.create = function(X, S) {
    var P = new lg.ProgressBar(X, S);
    P.clsName = H8m.D5P;
    return P;
};
w6b0K[q0K]._p = lg.ProgressBar.prototype;
cc.defineGetterSetter(_p, H8m.q2S, _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, H8m.M1P, _p.getType, _p.setType);
cc.defineGetterSetter(_p, H8m.N7P, _p.getReversed, _p.setReversed);
delete w6b0K[q0K]._p;
H8m.Y2y(H8m.e1i);
H8m.J2y();
lg.Label = cc.Sprite.extend({
    mlWidth: 0,
    mlHeight: 0,
    gapScale: 1,
    str: null,
    fontName: null,
    fontSize: 20,
    frames: [],
    chars: [],
    plistFile: null,
    name: null,
    params: null,
    noOpacity: !0,
    _charCanvas: null,
    _fontDefine: null,
    getString: function() {
        return this.str;
    },
    setString: function(X) {
        this.str = "" + X;
        this._updateStr();
    },
    getGapScale: function() {
        return this.gapScale;
    },
    setGapScale: function(X) {
        H8m.y5A(X, this.gapScale) && (this.gapScale = X, this.str && this._updateStr());
    },
    setFontName: function(X) {
        if (H8m.q5A(null, X) && (H8m.l5A(null, this.fontName) || H8m.X6A(this.fontName, X))) {
            this.fontName = X;
            this._fontDefine = lg.assetsManager.getFont(this.plistFile, this.fontName);
            if (H8m.D6A(null, this._fontDefine))
                throw "Can't find the font named: " + this.fontName;
            this.frames = lg.assetsManager.getFrameNames(this.plistFile, parseInt(this._fontDefine.start), parseInt(this._fontDefine.end));
            this.chars = this._fontDefine.chars;
            this.fontSize = parseInt(this._fontDefine.size);
        }
    },
    _updateStr: function() {
        if (H8m.c6A(null, this._charCanvas)) {
            var X = this.plistFile.replace("." + lg.getFileExtension(this.plistFile), ".png");
            this._charCanvas = new cc.SpriteBatchNode(X, this.str.length);
            this.addChild(this._charCanvas);
        }
        this._charCanvas.removeAllChildren();
        for (X = this.mlHeight = this.mlWidth = 0; H8m.z6A(X, this.str.length); X++) {
            var S = this.str[X];
            if (H8m.j6A("\n", S))
                if (H8m.x6A(" ", S))
                    this.mlWidth += SPACE_CHAR_GAP;
                else {
                    for (var P = -1, O = 0; H8m.o6A(O, this.chars.length); O++)
                        if (H8m.p6A(this.chars[O], S)) {
                            P = O;
                            break;
                        }
                    -1 == P ? cc.log("Not found the char: " + S + " in the fonts: " + this.fontName) : (S = cc.Sprite.create(cc.spriteFrameCache.getSpriteFrame(this.frames[P])), S.anchorX = this._fontDefine.anchorX, S.anchorY = this._fontDefine.anchorY, P = S.getContentSize(), S.x = this.mlWidth, S.y = 0, this.mlWidth += H8m.Y6A(P.width, this.gapScale), this.mlHeight = H8m.T6A(P.height, this.mlHeight) ? P.height : this.mlHeight, this._charCanvas.addChild(S));
                }
        }
        if (this.params)
            for (X = Math.max(H8m.R6A(this.mlWidth, this.params.width), H8m.M6A(this.mlHeight, this.params.height)), S = 0, H8m.V6A(1, X) && (P = H8m.s6A(1, X), this._charCanvas.scale = P, S = H8m.U6A(this.mlHeight, (1 - 1 / X), X), this.mlWidth *= P, this.mlHeight *= P), P = H8m.q6A((this.params.width - this.mlWidth), 2), X = this._charCanvas.childrenCount, O = null; X--;)
                O = this._charCanvas.children[X], H8m.l6A("center", this.params.align) && (O.x += P), O.y -= S;
        this._charCanvas.setContentSize(this.mlWidth, this.mlHeight);
        this.setContentSize(this.mlWidth, this.mlHeight);
        this.setOpacity(0);
    },
    getRect: function(X) {
        X = !1 !== X;
        var S = cc.rect(H8m.X2A(0.5, this.width, this.str.length), -this.params.height, this.width, this.height + 2);
        S.y += H8m.K2A((this.params.height - this.height) / 2, 1);
        if (!X)
            return S;
        X = S.width;
        var P = S.height,
            S = cc.p(S.x, S.y),
            S = this.convertToWorldSpace(S);
        return cc.rect(S.x, S.y, X, P);
    },
    destroy: function() {
        this.removeFromParent();
    }
});
lg.Label.create = function(X, S) {
    var P = new lg.Label;
    P.plistFile = X;
    lg.assetsManager.addPlist(X);
    P.setFontName(S);
    P.setAnchorPoint(H8m.U7H, H8m.U7H);
    return P;
};
var lg = lg || {},
    ButtonState = {
        UP: H8m.N2i,
        OVER: H8m.u6i,
        DOWN: H8m.j4S,
        SELECTED: H8m.n1K,
        SELECTED_OVER: H8m.d9i,
        SELECTED_DOWN: H8m.t7K,
        DISABLED: H8m.A7S
    };
lg._buttonDefine = {
    name: H8m.H6P,
    _state: H8m.H6P,
    onEnter: function() {
        this._super();
    },
    onExit: function() {
        this._super();
    },
    setState: function(X) {
        H8m.d2A(this._state, X) && (this._state = X, this.gotoAndStop(this._state) || (X = this.isSelected() ? ButtonState.SELECTED : ButtonState.UP, this.gotoAndStop(X) || this.gotoAndStop(H8m.U7H)));
    },
    getState: function() {
        return this._state;
    },
    isSelected: function() {
        return H8m.t2A(this._state, ButtonState.SELECTED) || H8m.w2A(this._state, ButtonState.SELECTED_OVER) || H8m.e2A(this._state, ButtonState.SELECTED_DOWN);
    },
    isSelectable: function() {
        return this.hasLabel(ButtonState.SELECTED);
    },
    setMouseEnabled: function(X) {
        if (H8m.Q2A(this.isMouseEnabled(), X))
            return !H8m.h7H;
        this.setState(X ? ButtonState.UP : ButtonState.DISABLED);
        return !H8m.U7H;
    },
    isMouseEnabled: function() {
        return H8m.r2A(this._state, ButtonState.DISABLED);
    }
};
lg.SimpleButton = lg.Animator.extend(lg._buttonDefine);
lg.SimpleButton.create = function(X, S) {
    var P = new lg.SimpleButton(X, S);
    P.clsName = H8m.a6S;
    P.setState(ButtonState.UP);
    return P;
};
lg.Button = lg.MovieClip.extend(lg._buttonDefine);
lg.Button.create = function(X, S) {
    var P = new lg.Button(X, S);
    P.clsName = H8m.G9P;
    P.setState(ButtonState.UP);
    return P;
};
lg.isButton = function(X) {
    return H8m.N2A(X, lg.SimpleButton) || H8m.m2A(X, lg.Button);
};
H8m.T2y();
lg.TiledImage = cc.SpriteBatchNode.extend({
    tileMap: null,
    tileWidthOffset: -1,
    tileHeightOffset: -1,
    _plistFile: null,
    _taID: null,
    _minWidth: 0,
    _minHeight: 0,
    _pool: null,
    init: function(X, S) {
        this._super(X, S);
        this.tileMap = lg.TileMap.create("tile_image_" + lg.randInt(0, 1E3));
        return !0;
    },
    setTileSource: function(X, S) {
        if (H8m.A2A(this._plistFile, X) || H8m.E2A(this._taID, S)) {
            this._plistFile = X;
            this._taID = S;
            this._pool = lg.ObjectPool.get(X, "lg.Animator");
            var P = lg.assetsManager.createDisplay(this._plistFile, this._taID).getContentSize();
            this.tileMap.setTileSize(P.width + this.tileWidthOffset, P.height + this.tileHeightOffset);
            H8m.C2A(0, this._minWidth * this._minHeight) && (H8m.h2A(0, this._children.length) ? this._updateTileImg() : this._updateSize());
        }
    },
    setMinSize: function(X, S) {
        H8m.y2A(0, (X - this._minWidth) * (S - this._minHeight)) && (this._minWidth = X, this._minHeight = S, this._plistFile && this._updateSize());
    },
    _updateTileImg: function() {
        for (var X = null, S = this._children.length, P = -1; ++P < S;)
            X = this._children[P], X.setPlist(this._plistFile, this._taID);
    },
    _updateSize: function() {
        var X = this.tileMap.setMapSizePixel(this._minWidth, this._minHeight),
            S,
            P = X[0].length;
        if (H8m.q2A(0, P)) {
            var O;
            for (S = -1; ++S < P;)
                O = X[0][S], O.destroy();
        }
        P = X[1].length;
        if (H8m.l2A(0, P))
            for (S = -1; ++S < P;)
                this._createTile(X[1][S][0], X[1][S][1]);
        this.setContentSize(this.tileMap.getPixelSize());
    },
    _createTile: function(X, S) {
        var P = this._pool.fetch(this._taID, this);
        P.setAnchorPoint(0.5, 0.5);
        this.tileMap.addObject(P, X, S);
        this.tileMap.snapToTile(P, X, S);
        return P;
    }
});
lg.TiledImage.create = function(X, S, P, O) {
    var Z = new lg.TiledImage,
        Y = X.replace("." + lg.getFileExtension(X), ".png");
    return Z.init(Y, 10) ? (Z.setTileSource(X, S), isNaN(P) || (P = cc.visibleRect.width), isNaN(O) || (O = cc.visibleRect.height), Z.setMinSize(P, O), Z) : null;
};
H8m.m2y();
lg.ScrollingBG = cc.Node.extend({
    source: H8m.H6P,
    assetID: H8m.H6P,
    bg0: H8m.H6P,
    bg1: H8m.H6P,
    _isTiled: H8m.H6P,
    _scrolling: !H8m.h7H,
    _paused: !H8m.h7H,
    _speedX: H8m.U7H,
    _speedY: H8m.U7H,
    _d: H8m.h7H,
    _size: H8m.H6P,
    init: function() {
        var X = "Not support source type!",
            S = "Please give a source!";
        if (this._super()) {
            if (H8m.X96(H8m.H6P, this.source))
                return cc.log(S), !H8m.h7H;
            if (H8m.D96(H8m.H6P, this.assetID))
                !H8m.U7H !== this._isTiled ? (this.bg0 = lg.assetsManager.createDisplay(this.source, this.assetID), this.bg1 = lg.assetsManager.createDisplay(this.source, this.assetID)) : (this.bg0 = lg.TiledImage.create(this.source, this.assetID), this.bg1 = lg.TiledImage.create(this.source, this.assetID));
            else if (this.source)
                if (lg.isImageFile(this.source))
                    this.bg0 = cc.Sprite.create(this.source), this.bg1 = cc.Sprite.create(this.source);
                else
                    return cc.log(X), !H8m.h7H;
            this.bg0.setAnchorPoint(H8m.U7H, H8m.U7H);
            this.bg1.setAnchorPoint(H8m.U7H, H8m.U7H);
            this.addChild(this.bg0);
            this.addChild(this.bg1);
            this._size = this.bg0.getContentSize();
            return !H8m.U7H;
        }
        return !H8m.h7H;
    },
    startXScroll: function(X) {
        H8m.c96(H8m.U7H, X) || this._scrolling || (this._scrolling = !H8m.U7H, this._speedX = X, this._speedY = H8m.U7H, this._d = H8m.z96(H8m.U7H, this._speedX) ? H8m.h7H : -H8m.h7H, this._resetScroll(), this._doScroll());
    },
    startYScroll: function(X) {
        H8m.j96(H8m.U7H, X) || this._scrolling || (this._scrolling = !H8m.U7H, this._speedY = X, this._speedX = H8m.U7H, this._d = H8m.x96(H8m.U7H, this._speedY) ? H8m.h7H : -H8m.h7H, this._resetScroll(), this._doScroll());
    },
    pauseScroll: function() {
        this._scrolling && !this._paused && (this._paused = !H8m.U7H, this.bg0.stopAllActions(), this.bg1.stopAllActions(), this.unscheduleAllCallbacks());
    },
    resumeScroll: function() {
        this._scrolling && this._paused && (this._paused = !1, H8m.o96(0, this._speedX) ? this._doScroll(H8m.p96(this._size.width, Math.abs(this.bg0.x))) : H8m.Y96(0, this._speedY) && this._doScroll(H8m.T96(this._size.height, Math.abs(this.bg0.y))));
    },
    _resetScroll: function() {
        this.bg0.setPosition(H8m.U7H, H8m.U7H);
        H8m.R96(0, this._speedX) ? this.bg1.x = -this._d * (H8m.M96(this._size.width, 1)) : this.bg1.y = -this._d * (H8m.V96(this._size.height, 1));
    },
    _doScroll: function(S) {
        if (H8m.s96(H8m.U7H, S)) {
            var P = H8m.U96(H8m.U7H, this._speedX);
            H8m.b96(null, S) && (S = P ? this._size.width : this._size.height);
            var O = H8m.F96(S, Math.abs(P ? this._speedX : this._speedY));
            S *= this._d;
            this.bg0.runAction(cc.MoveBy.create(O, cc.p(P ? S : H8m.U7H, P ? H8m.U7H : S)));
            this.bg1.runAction(cc.MoveBy.create(O, cc.p(P ? S : H8m.U7H, P ? H8m.U7H : S)));
            this.scheduleOnce(function() {
                if (this._scrolling && !this._paused) {
                    var X = this.bg0;
                    this.bg0 = this.bg1;
                    this.bg1 = X;
                    this._resetScroll();
                    this._doScroll();
                }
            }, O);
        }
    }
});
lg.ScrollingBG.create = function(X, S, P) {
    var O = new lg.ScrollingBG;
    O.source = X;
    O.assetID = S;
    O._isTiled = P;
    return O.init() ? O : H8m.H6P;
};
H8m.n2y();
lg.ObjectPool = cc.Class.extend({
    maxCount: 100,
    _clsName: null,
    _cls: null,
    _plistFile: null,
    _pool: null,
    _extraID: "",
    init: function(X, S, P) {
        if (this._plistFile && this._cls)
            return cc.log("The pool has been inited with cls: " + this._cls), !1;
        this._clsName = S;
        this._cls = lg.nameToObject(S);
        if (H8m.k16(null, this._cls))
            return cc.log("There is no class named: " + S), !1;
        this._plistFile = X;
        this._pool = [];
        void 0 !== P && (this.maxCount = P);
        return !0;
    },
    fetch: function(X, S, P) {
        if (H8m.L16(null, X))
            return cc.log("Please give me a assetID to fetch a object!"), null;
        var O = null;
        H8m.i16(0, this._pool.length) ? (O = this._pool.shift(), O.setPlist(this._plistFile, X)) : O = this._cls.create(this._plistFile, X);
        O.__pool__id__ = this._extraID;
        O.clsName = this._clsName;
        O.autoRecycle = !0;
        O.visible = !0;
        P ? "undefined" === typeof P.zIndex && (P.zIndex = 0) : P = {
            zIndex: 0
        };
        O.attr(P);
        S && S.addChild(O);
        return O;
    },
    recycle: function(X) {
        if (!(H8m.S16(X, this._cls)))
            cc.log("The object to recycle is not the same type with this pool: " + this._cls);
        else if (H8m.P16(this._pool.length, this.maxCount)) {
            if (X.onRecycle)
                X.onRecycle();
            this._pool.push(X);
        }
    },
    release: function() {
        this._pool.length = 0;
    }
});
lg.ObjectPool.all = {};
lg.ObjectPool.create = function(X, S, P) {
    var O = new lg.ObjectPool;
    return O.init(X, S, P) ? O : H8m.H6P;
};
lg.ObjectPool.get = function(X, S, P) {
    H8m.a16(H8m.H6P, S) && (S = H8m.n2i);
    H8m.O16(H8m.H6P, P) && (P = H8m.u4S);
    var O = X + S + P,
        Z = lg.ObjectPool.all[O];
    H8m.B16(H8m.H6P, Z) && (Z = lg.ObjectPool.create(X, S), Z._extraID = P, lg.ObjectPool.all[O] = Z);
    return Z;
};
lg.ObjectPool.release = function() {
    for (var X in lg.ObjectPool.all)
        lg.ObjectPool.all[X].release(), delete lg.ObjectPool.all[X];
};
H8m.R2y();
lg.GunParam = cc.Class.extend({
    bulletPlist: null,
    bulletID: null,
    targetMap: null,
    damage: 1,
    damageRadius: 0,
    speed: 600,
    interval: 0.15,
    count: 1,
    angleGap: 5,
    waveInterval: 0,
    countInWave: 6,
    fireSound: null,
    fireEffectID: null,
    hitEffectID: null,
    alwaysLive: !1,
    bulletPlayOnce: !1,
    isMissle: !1
});
lg.GunParam.create = function(X) {
    var S = new lg.GunParam;
    lg.copyProperties(X, S);
    return S;
};
lg.Gun = cc.Node.extend({
    owner: H8m.H6P,
    param: H8m.H6P,
    _firing: !H8m.h7H,
    _pool: H8m.H6P,
    _waveTime: H8m.U7H,
    _maxShootDistance: H8m.U7H,
    _targetMap: H8m.H6P,
    init: function() {
        this._super();
    },
    start: function() {
        this._firing || (this._firing = !0, this._pool = lg.ObjectPool.get(this.param.bulletPlist, "lg.Animator", "___bullet"), this._waveTime = H8m.Z16(this.param.interval, this.param.countInWave) + this.param.waveInterval, this._maxShootDistance = H8m.J16(1.5, Math.max(cc.visibleRect.width, cc.visibleRect.height)), H8m.n16(0, this.param.waveInterval) || H8m.G16(1, this.param.countInWave) ? (this.schedule(this._createBullet, this.param.interval), this._createBullet()) : this._waveFire());
    },
    end: function() {
        this._firing && (this._firing = !H8m.h7H, this.unschedule(this._createBullet), this.unschedule(this._createWave));
    },
    updateParam: function(X) {
        H8m.W16(H8m.H6P, X) && (lg.copyProperties(X, this.param), this.end(), this.start());
    },
    isFiring: function() {
        return this._firing;
    },
    _waveFire: function() {
        this._firing && (this._createWave(), this.schedule(this._createWave, this._waveTime, cc.REPEAT_FOREVER));
    },
    _createBullet: function() {
        var X = "Pls set batch canvas for me to show the bullet: lg.bulletCanvas!";
        if (H8m.v16(H8m.H6P, lg.bulletCanvas))
            cc.log(X);
        else {
            for (var S = this.parent.convertToWorldSpace(this.getPosition()), S = lg.bulletCanvas.convertToNodeSpace(S), P = lg.getRotation(this, !H8m.U7H), O = H8m.H6P, Z = -H8m.h7H, Y = H8m.U7H, O = H8m.U7H, T = lg.createDInts(this.param.count); ++Z < this.param.count;) {
                O = T[Z];
                Y = P + H8m.u16(O, this.param.angleGap);
                O = this._pool.fetch(this.param.bulletID, lg.bulletCanvas);
                O.owner = this.owner;
                O.param = this.param;
                O.targetMap = lg.getTileMap(this.param.targetMap);
                O.gotoAndPlay(H8m.U7H);
                O.autoStopWhenOver = this.param.bulletPlayOnce;
                O.setPosition(S);
                O.setRotation(Y);
                var R = this.param.damage;
                H8m.H16(R, Array) && (H8m.f16(1, R.length) ? R = R[0] : H8m.I16(2, R.length) && (R = lg.randInt(R[0], R[1])));
                O.damage = R;
                O.__speed = this.param.speed;
                O.__moveRotation = Y;
                lg.bulletCanvas._bullets.push(O);
            }
            this._showFireEffect(S, Y);
            this.param.fireSound && lg.playSound(this.param.fireSound);
        }
    },
    _createWave: function() {
        this.schedule(this._createBullet, this.param.interval, H8m.g86(this.param.countInWave, H8m.h7H));
    },
    _showFireEffect: function(X, S) {
        if (H8m.K86(H8m.H6P, this.param.fireEffectID) && H8m.d86(H8m.u4S, this.param.fireEffectID)) {
            var P = lg.assetsManager.createDisplay(this.param.bulletPlist, this.param.fireEffectID, H8m.H6P, !H8m.U7H, lg.bulletCanvas);
            P.zIndex = H8m.d6H;
            P.autoDestroyWhenOver = !H8m.U7H;
            P.setPosition(X);
            P.setRotation(S);
            P.gotoAndPlay(H8m.U7H);
        }
    }
});
lg.BulletCanvas = cc.SpriteBatchNode.extend({
    _bullets: null,
    _stageRect: null,
    onEnter: function() {
        this._super();
        this._bullets = [];
        this._stageRect = cc.rect(0, 0, cc.visibleRect.width, cc.visibleRect.height);
        this.scheduleUpdate();
    },
    update: function(X) {
        var S = this._bullets.length;
        if (H8m.t86(0, S))
            for (var P = null, O = null, Z = -1, Z = null, Y = !1, T = Y = null; S--;) {
                P = this._bullets[S];
                O = H8m.w86(P.__speed, X);
                P.setPosition(cc.pAdd(P.getPosition(), lg.getPointOnCircle(O, P.__moveRotation)));
                Z = lg.getRect(P, !0);
                Y = !1;
                O = null;
                cc.rectIntersectsRect(this._stageRect, Z) ? O = this._checkHittedTarget(P, Z, !1) : Y = !0;
                if (O && O.length) {
                    Y = lg.getPosition(P, !0);
                    T = lg.getRotation(P, !0);
                    Z = P.param.damageRadius;
                    H8m.e86(0, Z) && (Z = cc.rect(H8m.Q86(Y.x, Z / 2), H8m.r86(Y.y, Z / 2), Z, Z), O = this._checkHittedTarget(P, Z, !0));
                    for (var R, Z = O.length; Z--;)
                        R = O[Z], R.onHit && (R.dead = R.onHit(P));
                    this._showHitEffect(P, Y, T);
                    Y = !0;
                }
                Y && !P.param.alwaysLive && (P.destroy(), this._bullets.splice(S, 1));
            }
    },
    _checkHittedTarget: function(X, S, P) {
        var O = [],
            Z = null,
            Z = X.targetMap ? X.targetMap.getCoveredTiles1(S, !0) : X.owner.targets;
        if (!Z || !Z.length)
            return O;
        for (S = -1; ++S < Z.length;)
            if (target = Z[S], !(H8m.N86(target, X.owner) || !0 === target.dead || X.owner && H8m.m86(target.camp, X.owner.camp)) && X.mainCollider.checkCollision(target.mainCollider)) {
                if (!P)
                    return [target];
                O.push(target);
            }
        return O;
    },
    _showHitEffect: function(X, S, P) {
        H8m.A86(null, X.param.hitEffectID) && H8m.E86("", X.param.hitEffectID) && (X = lg.assetsManager.createDisplay(X.param.bulletPlist, X.param.hitEffectID, null, !0, this), X.zIndex = 999, X.autoDestroyWhenOver = !0, X.setPosition(S), X.setRotation(P), X.gotoAndPlay(0));
    }
});
lg.BulletCanvas.create = function(X) {
    return new lg.BulletCanvas(X, H8m.J7i);
};
lg.Gun.create = function(X) {
    var S = "Please give me a param defiled like: lg.GunParam!";
    if (H8m.C86(H8m.H6P, X))
        return cc.log(S), H8m.H6P;
    X = lg.GunParam.create(X);
    var P = new lg.Gun;
    P.param = X;
    P.init();
    return P;
};
var Global = Global || {};
H8m.A2y();
H8m.G2y(H8m.b7H);
H8m.E2y(H8m.X1i);
H8m.V2y();
H8m.C2y(H8m.b7H);
H8m.s2y(H8m.J7S);
H8m.u2y();
H8m.U2y(H8m.e1i);
H8m.H2y(H8m.r2P);
H8m.q2y(H8m.Y9i);
H8m.F2y(H8m.G6H);
H8m.I2y(H8m.G6H);
H8m.X9O(H8m.P0S);
H8m.L9O(H8m.P0S);
H8m.K9O(H8m.h7H);
H8m.c9O(H8m.h7H);
H8m.S9O(H8m.m0K);
H8m.t9O(H8m.U7H);
H8m.j9O();
H8m.w9O();
H8m.a9O(H8m.O4i);
H8m.e9O();
H8m.O9O(H8m.H6P);
H8m.Q9O(H8m.W0K);
H8m.p9O(H8m.v7H);
H8m.Z9O(H8m.z0H);
H8m.N9O(H8m.H7H);
H8m.T9O(H8m.X4i);
H8m.n9O(H8m.S2H);
H8m.A9O(H8m.z1i);
H8m.M9O(H8m.U7H);
BOMBS_PROP = {
    Bomb0: {
        damage: H8m.O9i,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb1: {
        damage: H8m.O4i,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb2: {
        damage: H8m.r8i,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb3: {
        damage: H8m.J7i,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb4: {
        damage: H8m.l0S,
        killNow: !H8m.h7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb5: {
        damage: H8m.I4S,
        killNow: !H8m.h7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb6: {
        damage: H8m.q7S,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb7: {
        damage: H8m.z0P,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb8: {
        damage: H8m.d3P,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb9: {
        damage: H8m.B0K,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb10: {
        damage: H8m.P4K,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb11: {
        damage: H8m.P4K,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb12: {
        damage: H8m.P4K,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb13: {
        damage: H8m.P4K,
        killNow: !H8m.U7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.h7H,
        splash: !H8m.h7H
    },
    Bomb14: {
        damage: H8m.U7H,
        killNow: !H8m.h7H,
        isIce: !H8m.h7H,
        isBounce: !H8m.U7H,
        splash: !H8m.h7H
    }
};
H8m.W9O();
H8m.V9O();
H8m.C9O();
H8m.v9O();
H8m.s9O();
H8m.h9O();
BOMBS = H8m.r9S.split(H8m.g8P);
H8m.u9O();
Global.zBomb = {
    Bomb0: {
        type: H8m.U7H,
        damage: H8m.e1i
    },
    Bomb1: {
        type: H8m.h7H,
        damage: H8m.e1i
    },
    Bomb2: {
        type: H8m.s7H,
        damage: H8m.e1i
    },
    Bomb3: {
        type: H8m.v7H,
        damage: H8m.X1i
    },
    Bomb4: {
        type: H8m.q7H,
        damage: H8m.X1i
    },
    Bomb5: {
        type: H8m.b7H,
        damage: H8m.Y9i
    },
    Bomb6: {
        type: H8m.H7H,
        damage: H8m.Y9i
    },
    Bomb7: {
        type: H8m.y7H,
        damage: H8m.i9i
    },
    Bomb8: {
        type: H8m.F7H,
        damage: H8m.i9i
    },
    Bomb9: {
        type: H8m.f7H,
        damage: H8m.O4i
    },
    Bomb10: {
        type: H8m.e1i,
        damage: H8m.H8i
    },
    Bomb11: {
        type: H8m.F9i,
        damage: H8m.J7i
    },
    Bomb12: {
        type: H8m.l9i
    },
    Bomb13: {
        type: H8m.b9i
    },
    Bomb14: {
        type: H8m.f9i
    },
    Bomb15: {
        type: H8m.u9i,
        damage: H8m.O4i
    },
    Bomb16: {
        type: H8m.U9i
    },
    Bomb17: {
        type: H8m.v9i
    }
};
H8m.U9O();
H8m.y9O();
var music = {
        ready: H8m.o2P,
        battle: H8m.s1K,
        explosion: H8m.L7S,
        gameover: H8m.W9S
    },
    res;
H8m.H9O(H8m.U5P);
var PlayCover = lg.MovieClip.extend({
    _instance: H8m.H6P,
    onEnter: function() {
        this._super();
        lg.inputManager.addListener(this, this.onItemTouched);
    },
    onItemTouched: function(X, S) {
        var P = "resumeBtn";
        H8m.h86(P, S.name) && (Global.gamePause = !H8m.h7H, this.setVisible(!H8m.h7H), ControlBar.getInstance().pauseBtn.setState(ButtonState.SELECTED));
    },
    show: function() {
        H8m.y86(H8m.H6P, this.getParent()) && lg.currentScene.addChild(this, H8m.x5P);
        this.setVisible(!H8m.U7H);
    }
});
PlayCover.create = function() {
    var X = "PlayCover";
    return new PlayCover(res.ui_plist, X);
};
PlayCover.getInstance = function() {
    H8m.q86(H8m.H6P, this._instance) && (this._instance = PlayCover.create());
    return this._instance;
};
var ControlBar = lg.MovieClip.extend({
    pauseBtn: H8m.H6P,
    moreBtn: H8m.H6P,
    lastActionTime: -H8m.h7H,
    inIdle: !H8m.h7H,
    _soundBeforePause: !H8m.U7H,
    _intstacne: H8m.H6P,
    onEnter: function() {
        var P = "pauseBtn";
        this._super();
        this.pauseBtn = this.getChildByName(P);
        this.bg.visible = !H8m.h7H;
        this.continu.visible = !H8m.h7H;
        this.menu1.visible = !H8m.h7H;
        this.moress.visible = !H8m.h7H;
        this.label__6.visible = !H8m.h7H;
        lg.inputManager.addListener(this.moress, function(X, S) {
            SG.redirectToPortal();
        });
        var O = this;
        lg.inputManager.addListener(this.continu, function(X, S) {
            O.pauseBtn.setState(ButtonState.SELECTED);
            O.onPause(O);
        });
        lg.inputManager.addListener(this.menu1, function(X, S) {
            O.pauseBtn.setState(ButtonState.SELECTED);
            O.onPause(O);
            lg.replaceScene(H8m.A5P);
        });
        lg.inputManager.addListener(this.pauseBtn, function(X, S) {
            O.onPause(O);
        });
        this.pauseBtn.setVisible(H8m.l86(H8m.s9S, lg.currentSceneName));
        H8m.X46(H8m.s9S, lg.currentSceneName) && this.pauseBtn.setState(ButtonState.SELECTED);
    },
    onPause: function(X) {
        var S = function() {
            Global.gamePause = !X.pauseBtn.isSelected();
        };
        S();
        Global.gamePause ? (a10Enabled && GameAPI.GameBreak.request(function() {
            cc.log("start ad");
        }, function() {
            cc.log("end ad");
        }), cc.director.pause(), this.bg.visible = !0, this.continu.visible = !0, this.menu1.visible = !0, this.moress.visible = !0, this.label__6.visible = !0, X._soundBeforePause = lg.getSoundEnabled(), lg.setSoundEnabled(!1)) : (cc.director.resume(), this.bg.visible = !1, this.continu.visible = !1, this.menu1.visible = !1, this.moress.visible = !1, this.label__6.visible = !1, lg.setSoundEnabled(X._soundBeforePause));
    }
});
ControlBar.create = function() {
    var X = "ControlBar",
        S = new ControlBar(res.ui2_plist, X);
    return this._instance = S;
};
ControlBar.getInstance = function() {
    return this._instance;
};
var MainMenu = lg.MovieClip.extend({
    _startBtn: H8m.H6P,
    onEnter: function() {
        var X = "moreBtn",
            S = "startBtn";
        this._super();
        this._startBtn = this.getChildByName(S);
        lg.playMusic(music.battle, !H8m.U7H);
        lg.inputManager.addListener(this.getChildByName(S), function() {
            lg.replaceScene(H8m.j8K);
            didClickedPlay();

        });
        lg.inputManager.addListener(this.getChildByName(X), function() {
            //SG.redirectToPortal();
        });
    }
});
MainMenu.create = function(X, S) {
    return new MainMenu(X, S);
};
MainMenu.scene = function() {
    var X = "MainMenu",
        S = cc.Scene.create(),
        P = MainMenu.create(res.ui3_plist, X);
    S.addChild(P, H8m.h7H);
    S.addChild(ControlBar.create(), H8m.s7H);
    return S;
};
var LinkFinder = {
        map: H8m.H6P,
        blocks: H8m.H6P,
        findLink: function(X, S, P, O) {
            var Z = H8m.H6P,
                Z = H8m.D46(X, P) || H8m.c46(S, O) ? LinkFinder._checkDirectLink(X, S, P, O) : LinkFinder._checkOneLink(X, S, P, O);
            H8m.z46(H8m.H6P, Z) && (Z = LinkFinder._checkTwoLink(X, S, P, O));
            return Z;
        },
        shuffle: function(X) {
            var S = function() {
                    Z = -H8m.h7H;
                },
                P = this.map.getAllObjects(),
                O = P.concat(),
                Z = -H8m.h7H;
            if (this.blocks && this.blocks.length)
                for (O = []; ++Z < P.length;) {
                    var Y = P[Z];
                    -H8m.h7H == this.blocks.indexOf(Y) && O.push(Y);
                }
            O.shuffle();
            S();
            for (P = H8m.j46(O.length, H8m.s7H); ++Z < P;) {
                var Y = O[Z],
                    T = O[Z + P],
                    R = cc.p(Y.getPosition());
                !H8m.h7H !== X ? (Y.runAction(cc.MoveTo.create(H8m.C1S, T.getPosition())), T.runAction(cc.MoveTo.create(H8m.C1S, R))) : (Y.setPosition(T.getPosition()), T.setPosition(R));
            }
        },
        findAvailableLink: function(S) {
            var P = "Dead map!!!!",
                O = function(X) {
                    Z = X[Math.floor(H8m.x46(V.length, Math.random()))];
                },
                Z = this.map.getAllObjects(),
                Y = Z.length;
            if (H8m.o46(H8m.U7H, Y))
                return H8m.H6P;
            for (var T, R, E = H8m.H6P, V = [], U = H8m.H6P, k9 = H8m.U7H; H8m.p46(k9, Y - H8m.h7H); k9++)
                if (T = Z[k9], !(this.blocks && -H8m.h7H < this.blocks.indexOf(T))) {
                    var L9 = H8m.Y46(H8m.U7H, V.length);
                    H8m.T46(H8m.H6P, U) && (U = T);
                    for (var K9 = k9 + H8m.h7H; H8m.R46(K9, Y); K9++)
                        if (R = Z[K9], !(this.blocks && -H8m.h7H < this.blocks.indexOf(R)))
                            if (H8m.M46(R.assetID, T.assetID)) {
                                if (LinkFinder.findLink(T.tx, T.ty, R.tx, R.ty))
                                    return [T, R];
                                L9 && V.push(R);
                            } else
                                L9 && H8m.V46(H8m.H6P, E) && LinkFinder.findLink(T.tx, T.ty, R.tx, R.ty) && (E = R);
                }
            if (H8m.s46(H8m.U7H, V.length))
                return H8m.H6P;
            O(V);
            Y = cc.p(Z.getPosition());
            if (H8m.U46(H8m.H6P, E)) {
                E = this._findEmptyNeighbor(U.tx, U.ty);
                if (H8m.b46(H8m.H6P, E))
                    throw P;
                Y = cc.p(this.map.getTiledPositionX(E.x), this.map.getTiledPositionY(E.y));
                Z.parent && (Y = Z.parent.convertToNodeSpace(Y));
                !H8m.U7H === S ? Z.runAction(cc.MoveTo.create(H8m.C1S, Y)) : Z.setPosition(Y);
            } else
                !H8m.U7H === S ? (Z.runAction(cc.MoveTo.create(H8m.C1S, E.getPosition())), E.runAction(cc.MoveTo.create(H8m.C1S, Y))) : (Z.setPosition(E.getPosition()), E.setPosition(Y));
            return [U, Z];
        },
        _findEmptyNeighbor: function(X, S) {
            for (var P = H8m.H6P, O = H8m.U7H; H8m.F46(H8m.q7H, O) && (P = EIGHT_DIRECTIONS[O], P = cc.p(X + P[H8m.U7H], S + P[H8m.h7H]), !this.map.isEmptyTile(P.x, P.y)); O++)
                ;
            return P;
        },
        _checkDirectLink: function(X, S, P, O) {
            if (H8m.k76(X, P) && H8m.L76(S, O))
                return H8m.H6P;
            if (H8m.i76(X, P)) {
                for (var Z = !H8m.U7H, Y = H8m.S76(H8m.U7H, O - S) ? H8m.h7H : -H8m.h7H, T = S + Y; H8m.P76(T, O);) {
                    if (!this.map.isEmptyTile(X, T)) {
                        var R = function() {
                            Z = !H8m.h7H;
                        };
                        R();
                        break;
                    }
                    T += Y;
                }
                if (Z)
                    return [new cc.p(X, S), new cc.p(P, O)];
            }
            if (H8m.a76(S, O)) {
                var E = function() {
                        Y = H8m.O76(H8m.U7H, P - X) ? H8m.h7H : -H8m.h7H;
                    },
                    V = function() {
                        Z = !H8m.U7H;
                    };
                V();
                E();
                for (T = X + Y; H8m.B76(T, P);) {
                    if (!this.map.isEmptyTile(T, S)) {
                        var U = function() {
                            Z = !H8m.h7H;
                        };
                        U();
                        break;
                    }
                    T += Y;
                }
                if (Z)
                    return [new cc.p(X, S), new cc.p(P, O)];
            }
            return H8m.H6P;
        },
        _checkOneLink: function(X, S, P, O) {
            if (H8m.Z76(X, P) || H8m.J76(S, O))
                return H8m.H6P;
            if (this.map.isEmptyTile(X, O)) {
                var Z = LinkFinder._checkDirectLink(X, S, X, O);
                if (Z && (Z = LinkFinder._checkDirectLink(X, O, P, O)))
                    return [new cc.p(X, S), new cc.p(X, O), new cc.p(P, O)];
            }
            return this.map.isEmptyTile(P, S) && (Z = LinkFinder._checkDirectLink(X, S, P, S)) && (Z = LinkFinder._checkDirectLink(P, S, P, O)) ? [new cc.p(X, S), new cc.p(P, S), new cc.p(P, O)] : H8m.H6P;
        },
        _checkTwoLink: function(X, S, P, O) {
            if (H8m.n76(X, P) && H8m.G76(S, O))
                return H8m.H6P;
            var Z = H8m.W76(H8m.U7H, P - X) ? H8m.h7H : -H8m.h7H,
                Y = H8m.v76(H8m.U7H, O - S) ? H8m.h7H : -H8m.h7H,
                T = LinkFinder._twoLinkSearch(X, S, P, O, Z, Y);
            H8m.u76(H8m.H6P, T) && (T = LinkFinder._twoLinkSearch(X, S, P, O, -Z, -Y));
            H8m.H76(H8m.H6P, T) && T.unshift(new cc.p(X, S));
            return T;
        },
        _twoLinkSearch: function(X, S, P, O, Z, Y) {
            for (var T = H8m.H6P, R = X + Z, E = S + Y, V = !H8m.h7H, U = !H8m.h7H; !V || !U;) {
                if (!V && (V = !this.map.isEmptyTile(R, S), !V)) {
                    T = LinkFinder._checkOneLink(R, S, P, O);
                    if (H8m.f76(H8m.H6P, T))
                        break;
                    R += Z;
                }
                if (!U && (U = !this.map.isEmptyTile(X, E), !U)) {
                    T = LinkFinder._checkOneLink(X, E, P, O);
                    if (H8m.I76(H8m.H6P, T))
                        break;
                    E += Y;
                }
            }
            return T;
        }
    },
    Zombie = lg.MovieClip.extend({
        prop: H8m.H6P,
        health: H8m.J7i,
        speed: H8m.i9i,
        damage: H8m.O9i,
        coins: H8m.X1i,
        bomber: !H8m.h7H,
        dead: !H8m.h7H,
        startX: H8m.U7H,
        thisFPS: H8m.O9i,
        inAttacking: !H8m.h7H,
        walkAction: H8m.H6P,
        onEnter: function(X) {
            var S = "walk",
                P = function() {
                    firtsTime = !H8m.U7H === X;
                };
            P();
            lg.copyProperties(this.prop, this);
            this.autoPlayChildren = !H8m.U7H;
            this.inAttacking = this.dead = !H8m.h7H;
            this._super();
            this.setPosition(this.startX, Global.earthPositon);
            this.setScaleX(-H8m.h7H);
            this.setScaleY(H8m.h7H);
            this.gotoAndPlay(S);
            if (Global.bing)
                this.onGo(!H8m.U7H);
            else
                this.onGo(!H8m.h7H);
        },
        onGo: function(P) {
            this.stopAllActions();
            var O;
            P ? (this.setFPS(H8m.g06(this.thisFPS, 2)), P = H8m.K06((cc.visibleRect.width - this.x), Global.BingMove), O = 0.5) : (this.setFPS(this.thisFPS), P = H8m.d06((cc.visibleRect.width - this.x), this.speed), O = 1);
            P = cc.MoveTo.create(P, cc.p(H8m.t06(cc.visibleRect.width, 100, 40 * Math.random()), Global.earthPositon));
            var Z = cc.CallFunc.create(function() {
                var X = "attack";
                if (H8m.a06(H8m.g5S, this.assetID)) {
                    this.attack();
                    this.dead = !H8m.U7H;
                    this._explode();
                    var S = Global.zombies.indexOf(this);
                    -H8m.h7H < S && Global.zombies.splice(S, H8m.h7H);
                    this.destroy();
                } else
                    this.dead || Global.gamePause || Global.gameOver || (this.inAttacking = !H8m.U7H, this.gotoAndPlay(X), this.schedule(this.attack, O, cc.REPEAT_FOREVER));
            }, this);
            this.walkAction = cc.Sequence.create(P, Z);
            this.runAction(this.walkAction);
        },
        onRecycle: function() {
            this._super();
            Global.onZombieDead.dispatch(this);
        },
        attack: function() {
            Global.ShieldBool || this.dead || Global.ZombiePause || (Global.health -= this.damage);
        },
        hit: function(S) {
            S && this._explode(S);
            try {
                if (this.dead)
                    return !H8m.U7H;
                var P = S.damage;
                H8m.O06(H8m.U7H, P) && (this.health -= P, this.bomber || this._playDamageTxt(H8m.S3P + P), H8m.B06(H8m.U7H, this.health) && (this.health = H8m.U7H, this.dead = !H8m.U7H, this.scheduleOnce(function() {
                    this._playDeathAnim();
                    this.destroy();
                    var X = Global.zombies.indexOf(this);
                    -H8m.h7H < X && Global.zombies.splice(X, H8m.h7H);
                    Global.score += this.coins;
                }, H8m.V1S)));
            } catch (X) {
                var O = "aaa";
                alert(X, O);
            }
            return this.dead;
        },
        _playDamageTxt: function(S) {
            var P = "DamageAnim";
            try {
                var O = function() {
                    Z.autoDestroyWhenOver = !H8m.U7H;
                };
                var Z = lg.assetsManager.createDisplay(res.effect_plist, P, H8m.H6P, !H8m.U7H, this, {
                    zIndex: H8m.J7i
                });
                O();
                Z.setPosition(cc.pAdd(this.getPosition(), cc.p(H8m.U7H, H8m.O4i)));
                Z.gotoAndPlay(H8m.U7H);
                Z.setLabelText(H8m.D3i, S, !H8m.U7H);
            } catch (X) {
                var Y = "ccc";
                alert(X, Y);
            }
        },
        _playDeathAnim: function() {
            var S = "deathAnim01";
            try {
                var P = function() {
                    O.autoDestroyWhenOver = !H8m.U7H;
                };
                var O = lg.assetsManager.createDisplay(res.zombies_plist, S, H8m.H6P, !H8m.U7H, this._parent, {
                    zIndex: this.zIndex + H8m.h7H,
                    autoPlayChildren: !H8m.U7H
                });
                O.setScaleX(this.getScaleX());
                O.setScaleY(this.getScaleY());
                O.setPosition(cc.pAdd(this.getPosition(), cc.p(H8m.U7H, H8m.U7H)));
                O.setFPS(H8m.O4i);
                O.play();
                P();
            } catch (X) {
                var Z = "bbb";
                alert(X, Z);
            }
        },
        _explode: function(S) {
            var P = "explode1";
            try {
                if (H8m.Z06(H8m.H6P, S) || H8m.J06(H8m.u9i, S.type)) {
                    var O = function() {
                        Z.autoDestroyWhenOver = !H8m.U7H;
                    };
                    lg.playSound(music.explosion);
                    var Z = lg.assetsManager.createDisplay(res.effect_plist, P, H8m.H6P, !H8m.U7H, this._parent, {
                        zIndex: H8m.a9K
                    });
                    Z.setScale(this.getScaleY());
                    S ? (Z.setPosition(S.getPosition()), S.destroy()) : Z.setPosition(cc.pAdd(this.getPosition(), cc.p(H8m.U7H, H8m.Y9i)));
                    Z.play();
                    O();
                }
            } catch (X) {
                var Y = "aacaafsd";
                alert(X, Y);
            }
        }
    });
Zombie.create = function(X, S) {
    var P = new Zombie(X, S);
    P.clsName = H8m.O5i;
    return P;
};
var ZombieWave = cc.Node.extend({
    stopping: !H8m.U7H,
    typeArr: H8m.H6P,
    newLevel: H8m.h7H,
    sumZombie: H8m.U7H,
    fun: H8m.H6P,
    init: function(S, P) {
        var O = function() {
            T = H8m.n06(H8m.H6P, P) ? Global.zLevels : Global.zLevels.slice(H8m.G06(P, H8m.h7H), P);
        };
        this._super();
        var Z,
            Y;
        this.typeArr = [];
        this.fun = S;
        var T;
        O();
        for (var R, E, V, U = H8m.U7H; H8m.W06(U, T.length); U++) {
            var k9 = function(X) {
                Z = X[U];
            };
            k9(T);
            for (var L9 = H8m.U7H; H8m.v06(L9, Z.length); L9++)
                for (Y = Global.zWaves[H8m.u06(Z[L9], H8m.h7H)], R = Y.count; H8m.H06(H8m.h7H, R);)
                    E = Y.interval.split(H8m.W0P), E = lg.randInt(parseInt(E[H8m.U7H]), parseInt(E[H8m.h7H])), H8m.f06(H8m.h7H, Y.count) && (E += Y.waveInterval), V = Y.type.split(H8m.W0P), V = H8m.I06(parseInt(lg.getRandomInArray(V)), H8m.h7H), this.typeArr.push({
                        type: Global.zEnemies[V],
                        date: E
                    }), R--;
        }
        this.sumZombie = this.typeArr.length;
    },
    start: function() {
        this.stopping && (this.stopping = !H8m.h7H, this.nextZombie());
    },
    stop: function() {
        this.stopping || (this.stopping = !H8m.U7H);
    },
    nextZombie: function() {
        if (Global.gameOver || Global.gamePause)
            this.scheduleOnce(function() {
                this.nextZombie();
            }, H8m.s7H);
        else if (!(this.stopping || H8m.g36(H8m.U7H, this.typeArr.length))) {
            var X = this.typeArr.shift();
            H8m.K36(H8m.H6P, this.fun) && this.fun(X.type);
            this.scheduleOnce(function() {
                this.nextZombie();
            }, X.date);
        }
    },
    addZ: function(X) {}
});
ZombieWave.create = function(X, S) {
    var P = new ZombieWave;
    P.init(X, S);
    return P;
};
var NewBombs = cc.Node.extend({
    init: function(X) {
        this.nextLevel(X);
    },
    nextLevel: function(S, P) {
        try {
            for (var O = LEVELS[H8m.d36(S, H8m.h7H)], Z = O[H8m.U7H], Y = O[H8m.h7H], T = O[H8m.v7H], R = O[H8m.q7H], E = [], V = H8m.t36(H8m.q7H, Math.round(Z / H8m.s7H)), U = H8m.w36(H8m.q7H, Math.round(Y / H8m.s7H)), k9 = V; H8m.e36(k9, V + Z - H8m.h7H); k9++)
                for (var L9 = U; H8m.Q36(L9, U + Y - H8m.h7H); L9++)
                    E.push([k9, L9]);
            E.shuffle();
            for (var K9 = E.slice(H8m.U7H, O[H8m.s7H]), c9 = H8m.r36(O[H8m.s7H], H8m.s7H), Z = [], t9, S9, Y = Y = H8m.U7H; H8m.N36(Y, O[H8m.s7H] / H8m.s7H); Y++)
                S9 = Math.round(H8m.m36(Math.random(), c9)), t9 = H8m.A36(null, P) && H8m.E36(0, P.length) && H8m.C36(1, S9) ? P.shift() : Math.round(T + H8m.h36(Math.random(), (R - T))), Z.push(t9), Z.push(t9);
            Z.shuffle();
            for (var j9 = [], Y = H8m.U7H; H8m.y36(Y, O[H8m.s7H]); Y++)
                j9.push([Z[Y], K9[Y]]);
        } catch (X) {
            alert(X, fuck);
        }
        return j9;
    }
});
NewBombs.create = function(X) {
    var S = new NewBombs;
    S.init(X);
    return S;
};
var SelectLevel = lg.MovieClip.extend({
    onEnter: function() {
        this._super();
        lg.inputManager.addListener(this.backssss, function(X, S) {
            lg.replaceScene(H8m.A5P);
        });
        for (var P = H8m.h7H, O; H8m.q36(H8m.e9i, P);)
            O = this.getChildByName(H8m.G2H + P), H8m.l36(P, Global.level2) ? (lg.inputManager.addListener(O, function(X, S) {
                Global.level = parseInt(this.name.substring(1, this.name.length));
                lg.replaceScene(H8m.c2P);
                SG_Hooks.selectLevel(Global.level);
            }), O.setState(ButtonState.UP)) : O.setState(ButtonState.SELECTED), P++;
    }
});
SelectLevel.create = function(X, S) {
    return new SelectLevel(X, S);
};
SelectLevel.scene = function() {
    var X = "SelectLevel",
        S = cc.Scene.create(),
        P = SelectLevel.create(res.ui2_plist, X);
    S.addChild(P);
    return S;
};
var ShopWin = lg.MovieClip.extend({
    buy: H8m.H6P,
    listbg: H8m.H6P,
    BuyMove: !H8m.h7H,
    bar: H8m.H6P,
    onEnter: function() {
        var T = "Listbg",
            R = "scoreTxtg",
            E = "buy",
            V = 610,
            U = 680,
            k9 = "ShopBar",
            L9 = "buyPandel",
            K9 = function() {
                Global.data = [];
            };
        this._super();
        this.buy = lg.MovieClip.create(res.ui_plist, L9);
        this.buy.y = -H8m.h6S;
        lg.inputManager.addListener(this.buy, this.onBuyBGDown, InputType.press);
        this.bar = lg.MovieClip.create(res.ui_plist, k9);
        this.bar.y = U;
        this.bar.x = V;
        this.addChild(this.bar, H8m.J7i);
        var c9 = this.bar,
            t9 = this.buy;
        lg.inputManager.addListener(this.buy, function(X, S) {
            if (BuyMove) {
                var P = this.y += X.getDelta().y;
                this.y = H8m.X56(H8m.e1i, P) ? H8m.e1i : -H8m.h6S > P ? -H8m.h6S : P;
                c9.y = this.y * -(H8m.D56((this.height - 190), (660 - c9.height))) + 630 - c9.height;
            }
        }, InputType.move);
        lg.inputManager.addListener(this.buy, this.onBuyBGUp, InputType.up);
        this.addChild(this.buy, H8m.h7H);
        lg.inputManager.addListener(this.bar, this.onBuyBGDown, InputType.press);
        lg.inputManager.addListener(this.bar, this.onBuyBGUp, InputType.up);
        lg.inputManager.addListener(this.bar, function(X, S) {
            var P = 325,
                O = ((2.74E2, 0x10C) >= (96.80E1, 4.76E2) ? 230 : (59.40E1, 0x109) > 122. ? (0x13C, 670) : (130., 71.0E1));
            if (BuyMove) {
                var Z = this.y += X.getDelta().y;
                this.y = H8m.c56(O, Z) ? O : H8m.z56(P, Z) ? P : Z;
                t9.y = this.y * -(H8m.j56((660 - this.height), (t9.height - 170))) + t9.height - 660;
            }
        }, InputType.move);
        var S9 = H8m.h7H,
            j9 = Global.PropsLevel[H8m.x56(Global.level, H8m.h7H)],
            a9 = [];
        K9();
        for (var o9 = this.buy, T9 = this; H8m.o56(H8m.H7H, S9);) {
            var A9 = j9[H8m.p56(S9, H8m.h7H)];
            this.buy.setLabelText(H8m.P7i + S9, A9[H8m.U7H]);
            this.buy.getChildByName(E + S9);
            a9.push(A9[H8m.h7H]);
            this.buy.setLabelText(R + S9, H8m.U7H);
            lg.inputManager.addListener(this.buy.getChildByName(E + S9), function(X, S) {
                var P = "win1",
                    O = this.name.substr(H8m.v7H, H8m.h7H),
                    Z = o9.getLabelText(H8m.P7i + O),
                    Y = parseInt(o9.getLabelText(R + O));
                if (H8m.Y56(Global.score, H8m.h7H * Z))
                    a9[H8m.T56(O, 1)] -= 1, Global.score -= H8m.R56(1, Z), o9.setLabelText("scoreTxtg" + O, 1 + Y), Z = lg.assetsManager.createDisplay(res.effect_plist, "LinkEffect", null, !0), o9.addChild(Z, 1E3), Z.autoDestroyWhenOver = !0, Z.setPosition(o9["scoreTxtg" + O].getPosition()), Z.x += 10, Z.y -= 10, Z.play(), F9.setLabelText("scoreTxt", Global.score), Global.data.push(parseInt(this.name.substr(3, 1)) + 11);
                else
                    T9.onPlayeffects(P);
            });
            S9++;
        }
        this.listbg = lg.assetsManager.createDisplay(res.ui3_plist, T, H8m.H6P, !H8m.U7H);
        this.listbg.y -= H8m.b7H;
        var F9 = this.listbg;
        lg.inputManager.addListener(this.listbg.back, function(X, S) {
            SG_Hooks.start();
            lg.replaceScene(H8m.s9S);
        });
        this.listbg.setLabelText(H8m.P7i, Global.score);
        this.addChild(this.listbg, H8m.s7H);
    },
    onPlayeffects: function(X) {
        var S = function() {
            X.autoDestroyWhenOver = !H8m.U7H;
        };
        X = lg.assetsManager.createDisplay(res.effect_plist, X, H8m.H6P, !H8m.U7H);
        this.addChild(X, H8m.a9K);
        X.setFPS(H8m.e1i);
        S();
        X.setPosition(cc.p(H8m.M56(cc.visibleRect.width, 2), H8m.V56(cc.visibleRect.height, 2)));
        X.play();
    },
    onBuyBGDown: function(X, S) {
        var P = function() {
            BuyMove = !H8m.U7H;
        };
        P();
    },
    onBuyBGUp: function(X, S) {
        var P = function() {
            BuyMove = !H8m.h7H;
        };
        P();
    }
});
ShopWin.create = function(X, S) {
    return new ShopWin(X, S);
};
ShopWin.scene = function() {
    var X = "ShopWin",
        S = cc.Scene.create(),
        P = ShopWin.create(res.ui3_plist, X);
    P.x = -H8m.b7H;
    S.addChild(P, H8m.h7H);
    S.addChild(ControlBar.create(), H8m.s7H);
    return S;
};
LINK_COLOR = cc.color(H8m.s0K, H8m.s0K, H8m.s0K, H8m.z0P);
var Game = cc.Layer.extend({
    onLevelInit: H8m.H6P,
    ui: H8m.H6P,
    _house: H8m.H6P,
    _healthBar: H8m.H6P,
    _bombs: H8m.H6P,
    _bomb0: H8m.H6P,
    _bomb1: H8m.H6P,
    _tileMap: H8m.H6P,
    _clickRect: H8m.H6P,
    _maxBombs: H8m.U7H,
    _totalBombs: H8m.U7H,
    _bombsLeft: H8m.U7H,
    _pathCanvas: H8m.H6P,
    _mapCenter: H8m.H6P,
    _lastClickTime: -H8m.h7H,
    _faultTimes: H8m.U7H,
    _needCheckDead: !H8m.h7H,
    _hint0: H8m.H6P,
    _hint1: H8m.H6P,
    _showingHint: !H8m.h7H,
    _textAnim: H8m.H6P,
    _basket: H8m.H6P,
    _allBombTypes: H8m.H6P,
    _fruitsPool: H8m.H6P,
    _zombieWave: H8m.H6P,
    _newBombs: H8m.H6P,
    _dian: H8m.H6P,
    onEnter: function() {
        var S = "plat",
            P = "healthBar",
            O = "house",
            Z = 918,
            Y = "hahahaha",
            T = function() {
                Global.gameOver = !H8m.h7H;
            },
            R = function() {
                Global.bing = !H8m.h7H;
            },
            E = function() {
                Global.ZombiePause = !H8m.h7H;
            },
            V = function(X) {
                Global.health = X.maxHealth;
            },
            U = function() {
                Global.ShieldBool = !H8m.h7H;
            },
            k9 = function() {
                Global.zombies = [];
            };
        this._super();
        this._zombieWave = ZombieWave.create(this.addZombies, Global.level);
        this.addChild(this._zombieWave);
        this._newBombs = NewBombs.create(Global.level);
        lg.inputManager.addListener(this, this.handleSimpleTouch);
        this._tileMap = lg.getTileMap(H8m.v2H);
        LinkFinder.map = this._tileMap;
        this._maxBombs = H8m.s56(this._tileMap._mapWidth, this._tileMap._mapHeight);
        if (this.ui) {
            var L9 = lg.Animator.create(res.effect_plist, Y);
            this.addChild(L9);
            L9.setPosition(H8m.P0H, Z);
            L9.play();
            this._house = this.ui.getChildByName(O);
            this._healthBar = this.ui.getChildByName(P);
            L9 = this.ui.getChildByName(S);
            L9.removeFromParent(!H8m.h7H);
            this.addChild(L9, H8m.q7H);
            this.ui.setLabelText(H8m.P7i, Global.score + H8m.u4S);
        }
        this._pathCanvas = cc.DrawNode.create();
        this.addChild(this._pathCanvas, H8m.Y7i);
        this._mapCenter = cc.p(Math.floor(H8m.U56(this._tileMap._mapWidth, H8m.s7H)), Math.floor(H8m.b56(this._tileMap._mapHeight, H8m.s7H)));
        k9();
        this._bombs = [H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P, H8m.H6P];
        T();
        U();
        E();
        R();
        this.resetGame(!H8m.U7H);
        this._zombieWave.start();
        V(Global);
        Global.onZombieDead = new signals.Signal;
        Global.onZombieDead.add(this._removeZombie, this);
        this.schedule(function() {
            this.ui.healthBar2.setScaleX(H8m.F56(this._zombieWave.typeArr.length, this._zombieWave.sumZombie));
            this.ui.g.x = H8m.k66(this._zombieWave.typeArr.length, this._zombieWave.sumZombie, this.ui.healthBar2.width) + 190;
        }, H8m.h7H);
        this.scheduleUpdate();
    },
    onExit: function() {
        this._super();
        Global.onZombieDead.remove(this._removeZombie, this);
    },
    update: function(S) {
        if (!Global.gamePause && !Global.gameOver)
            try {
                this.ui.setLabelText(H8m.P7i, Global.score);
                var P = this._findTargetZombie();
                if (H8m.D66(H8m.H6P, P) && H8m.c66(H8m.U7H, this._zombieWave.typeArr.length))
                    this.stopAllActions(), Global.gameOver || this.ShowNextWin();
                else {
                    if (Global.zombies.length) {
                        var O = function() {
                            S = -H8m.h7H;
                        };
                        var P = H8m.H6P,
                            Z;
                        O();
                        for (var Y = H8m.U7H, T; ++S < Global.zombies.length;)
                            P = Global.zombies[S], Z = P.getPosition(), Y = Math.floor(H8m.z66((Z.x - Global.bombSlotGap), Global.bombSlotGap)), H8m.j66(Y, this._bombs.length) && (T = this._bombs[Y]) && T.__ready__to__kill && H8m.x66(cc.pDistance(Z, T.getPosition()), Global.bombCollidSize) && (this._doKill(T, P), this._bombs[S] = null);
                    }
                    H8m.o66(H8m.U7H, Global.health) && (Global.health = H8m.U7H, this._gameOver(!H8m.U7H));
                    this._healthBar.setScaleX(H8m.p66(Global.health, Global.maxHealth));
                }
            } catch (X) {
                var R = "\u554a\u554a\u554a";
                alert(X, R);
            }
    },
    resetGame: function(P) {
        try {
            this._tileMap.clear(!H8m.U7H);
            this._hint0 = this._hint1 = H8m.H6P;
            H8m.Y66(Global.level, LEVELS.length) && (Global.level = LEVELS.length);
            this._needCheckDead = !H8m.U7H;
            if (this.onLevelInit)
                this.onLevelInit();
            var O = LEVELS[H8m.T66(Global.level, H8m.h7H)],
                Z = Math.min(H8m.R66(this._tileMap._mapWidth, H8m.s7H), O[H8m.U7H]),
                Y = Math.min(H8m.M66(this._tileMap._mapHeight, H8m.s7H), O[H8m.h7H]);
            this._bombsLeft = this._totalBombs = Math.min(H8m.V66(Z, Y), O[H8m.s7H]);
            var T = H8m.s66(this._bombsLeft, FRUIT_COME_IN_TIME) + H8m.h1S;
            this._bomb0 = this._bomb1 = H8m.H6P;
            var R = Global.data;
            R.shuffle();
            var E = H8m.U66(H8m.H6P, R) ? this._newBombs.nextLevel(Global.level, R) : this._newBombs.nextLevel(Global.level);
            this.schedule(function() {
                var X = "1\u7a7a",
                    S = E.shift();
                H8m.b66(H8m.H6P, S) && alert(X);
                this.addBomb(BOMBS[S[H8m.U7H]], S[H8m.h7H][H8m.U7H], S[H8m.h7H][H8m.h7H]);
            }, FRUIT_COME_IN_TIME, H8m.F66(this._totalBombs, H8m.h7H));
            this.scheduleOnce(function() {
                this._ShowTip();
            }, T);
        } catch (X) {
            var V = "\x3d,\x3d";
            alert(X, V);
        }
    },
    addZombies: function(S) {
        var P = "2\u7a7a";
        H8m.k26(H8m.H6P, S) && alert(P);
        if (!Global.gameOver && !Global.gamePause)
            try {
                var O = function(X) {
                    Z.y = X.earthPositon;
                };
                var Z = lg.assetsManager.createDisplay(res.zombies_plist, S.assetID, H8m.O5i, !H8m.U7H, this, {
                    zIndex: H8m.e1i,
                    startX: H8m.U7H,
                    thisFPS: S.walkFPS,
                    bomber: H8m.L26(H8m.g5S, S.assetID) ? !H8m.U7H : !H8m.h7H,
                    prop: S,
                    coins: S.coins,
                    health: S.maxHealth,
                    damage: S.damage,
                    speed: S.speed,
                    zIndex: H8m.e1i,
                    startX: H8m.U7H
                });
                Z.setFPS(S.walkFPS);
                Z.setScaleX(-H8m.f1S);
                Z.setScaleY(H8m.f1S);
                O(Global);
                Global.zombies.push(Z);
            } catch (X) {
                var Y = "fu";
                alert(X, Y);
            }
    },
    addBomb: function(S, P, O) {
        var Z = 0.9,
            Y = "static";
        try {
            var T = lg.assetsManager.createDisplay(res.bombs_plist, S, H8m.H6P, !H8m.U7H, this, {
                zIndex: H8m.J7i
            });
            T.setFPS(H8m.e9i);
            T.gotoAndStop(Y);
            this._tileMap.snapToTile(T, P, O, !H8m.U7H);
            T.setScale(Z);
        } catch (X) {
            alert(X);
        }
    },
    ShowNextWin: function() {
        var O = "LevelConmplete";
        didEndGame();
        try {
            var Z = function() {
                    T.autoStopWhenOver = !H8m.U7H;
                },
                Y = function() {
                    Global.gameOver = !H8m.U7H;
                };
            Y();
            this._freezeZombies();
            this.stopAllActions();
            this._hideHint();
            var T = lg.assetsManager.createDisplay(res.effect_plist, O, H8m.H6P, !H8m.U7H);
            this.addChild(T, H8m.a9K);
            T.setPosition(cc.p(cc.visibleRect.width + 180, H8m.i26(cc.visibleRect.height, 2)));
            Z();
            T.play();
            this.scheduleOnce(function() {
                var X = "WinPanel",
                    S = function() {
                        Global.level2 = Global.level + H8m.h7H;
                    },
                    P = lg.assetsManager.createDisplay(res.ui2_plist, X, H8m.H6P, !H8m.U7H);
                this.addChild(P, H8m.H5P);
                P.setLabelText(H8m.P7i, Global.score + H8m.u4S);
                lg.inputManager.addListener(P.moressa, function() {
                    //SG.redirectToPortal();
                });
                S();
                cc.sys.localStorage.setItem(LevelKey, Global.level2);
                cc.sys.localStorage.setItem(ScoreKey, Global.score);
                H8m.S26(H8m.e9i, Global.level) ? (lg.inputManager.addListener(P.replayBtn, function() {
                    lg.replaceScene(H8m.s9S);
                }), lg.inputManager.addListener(P.nextBtn, function() {
                    Global.level += H8m.h7H;
                    lg.replaceScene(H8m.c2P);
                })) : (lg.inputManager.addListener(P.replayBtn, function() {
                    lg.replaceScene(H8m.s9S);
                }), P.nextBtn.visible = !H8m.h7H);
            }, H8m.m4i);
        } catch (X) {
            alert(X, H8m.d4K);
        }
    },
    boss: H8m.H6P,
    handleSimpleTouch: function(S, P) {
        if (Global.gameOver || Global.gamePause)
            return !H8m.U7H;
        try {
            var O = S.getLocation(),
                Z = this._tileMap.getObjects1(O.x, O.y);
            if (H8m.P26(H8m.U7H, Z.length))
                return !H8m.h7H;
            this._lastClickTime = Date.now();
            var Y = Z[H8m.U7H];
            H8m.a26(Y, this._hint0) && H8m.O26(Y, this._hint1) || this._hideHint();
            H8m.B26(H8m.H6P, this._bomb0) ? (this._bomb0 = Y, this._showSelectedEffect()) : H8m.Z26(this._bomb0, Y) && (this._bomb1 = Y, O = H8m.H6P, H8m.J26(this._bomb0.assetID, this._bomb1.assetID) && (O = LinkFinder.findLink(this._bomb0.tx, this._bomb0.ty, this._bomb1.tx, this._bomb1.ty), H8m.n26(H8m.H6P, O) && (this._showLinkedPath(O), this._showBombAnim(), this._bombsLeft -= H8m.s7H, H8m.G26(H8m.U7H, this._bombsLeft) && this._gameOver(!H8m.h7H), this._needCheckDead = !H8m.U7H, this._faultTimes = H8m.U7H, this._hideHint(), this.checkDeadMap(), this._ShowTip())), H8m.W26(H8m.H6P, O) ? (this._clickRect.setPosition(this._bomb1.getPosition()), this._bomb0 = this._bomb1, ++this._faultTimes >= MAX_FAULT_TIMES && (this._faultTimes = H8m.U7H, this._showHint())) : (this._clickRect.setVisible(!H8m.h7H), this._bomb0 = H8m.H6P), this._bomb1 = H8m.H6P);
        } catch (X) {
            var T = ((0xD5, 46.) < 22. ? (69.9E1, 0x7D) : (96, 51.) < 82.7E1 ? (0x172, 335) : (117, 0x1D3));
            alert(X, T);
        }
        return !H8m.U7H;
    },
    _ShowTip: function() {
        this.checkDeadMap();
        try {
            H8m.v26(2, KOOOO) && H8m.u26(null, this._hint0) && H8m.H26(null, this._hint1) ? (H8m.f26(null, this._dian) && this.removeChild(this._dian), this._dian = lg.assetsManager.createDisplay(res.effect_plist, "dian", null, !0), this.addChild(this._dian, 999990), this._dian.setPosition(this._hint0.getPosition()), this._dian.play(), this._dian.runAction(cc.RepeatForever.create(cc.Sequence.create(cc.MoveTo.create(1, this._hint1.getPosition()), cc.MoveTo.create(1, this._hint0.getPosition())))), KOOOO++) : (this.removeChild(this._dian), cc.sys.localStorage.setItem("KO", KOOOO));
        } catch (X) {
            alert(X);
        }
    },
    addZombie0: function() {
        if (!(Global.gameOver || Global.gamePause || Global.ZombiePause)) {
            var X = lg.assetsManager.createDisplay(res.zombies_plist, H8m.d1K, H8m.O5i, !H8m.U7H, this, {
                zIndex: H8m.e1i,
                startX: H8m.U7H,
                bomber: !H8m.h7H,
                prop: ZOMBIES0[H8m.I26(Global.level, H8m.h7H)]
            });
            Global.zombies.push(X);
            return X;
        }
    },
    addZombie1: function() {
        if (Global.gameOver || Global.gamePause || Global.ZombiePause)
            return H8m.H6P;
        try {
            var S = Global.zEnemies[H8m.U7H],
                P = lg.assetsManager.createDisplay(res.zombies_plist, S.assetID, H8m.O5i, !H8m.h7H, this, {
                    zIndex: H8m.e1i,
                    startX: H8m.U7H,
                    thisFPS: S.walkFPS,
                    bomber: !H8m.U7H,
                    prop: S,
                    coins: S.coins,
                    health: S.maxHealth,
                    damage: S.damage,
                    speed: S.speed,
                    zIndex: H8m.e1i,
                    startX: H8m.U7H
                });
            P.setScaleX(-H8m.f1S);
            P.setScaleY(H8m.f1S);
            Global.zombies.push(P);
        } catch (X) {
            var O = 379;
            alert(X, O);
        }
        return P;
    },
    checkDeadMap: function() {
        var X = LinkFinder.findAvailableLink(!H8m.h7H);
        X && (this._hint0 = X[H8m.U7H], this._hint1 = X[H8m.h7H]);
    },
    _showHint: function() {
        if (!this._showingHint && this._hint0 && this._hint1) {
            this._showingHint = !H8m.U7H;
            var X = cc.RepeatForever.create(cc.Sequence.create(cc.FadeOut.create(H8m.C1S), cc.FadeIn.create(H8m.V1S)));
            this._hint0.runAction(X);
            X = cc.RepeatForever.create(cc.Sequence.create(cc.FadeOut.create(H8m.C1S), cc.FadeIn.create(H8m.V1S)));
            this._hint1.runAction(X);
        }
    },
    _hideHint: function() {
        this._showingHint && (this._showingHint = !H8m.h7H, this._hint0 && (this._hint0.setOpacity(H8m.s0K), this._hint0.stopAllActions()), this._hint1 && (this._hint1.setOpacity(H8m.s0K), this._hint1.stopAllActions()), this._hint1 = this._hint0 = H8m.H6P);
    },
    _gameOver: function(S) {
        var P = '================!!!!!!!!!!!!!!!==============',
            O = "ResultPanel";
        if (!Global.gameOver) {
            var Z = function(X) {
                Global.gameOver = X;
            };
            Z(S);
            this._hideHint();
            this.stopAllActions();
            this._clickRect && this._clickRect.setVisible(!H8m.h7H);
            var Y = this;
            S ? (S = lg.assetsManager.createDisplay(res.ui2_plist, O, H8m.H6P, !H8m.U7H), this.addChild(S, H8m.H5P), cc.sys.localStorage.setItem(ScoreKey, Global.score), S.setLabelText(H8m.P7i, Global.score + H8m.u4S), console.log(P), lg.inputManager.addListener(S.getChildByName(H8m.b9S), function() {
                lg.replaceScene(H8m.A5P);
                 SG_Hooks.didEndGame();
            }), lg.inputManager.addListener(S.replayBtn, function() {
                lg.replaceScene(H8m.c2P);
                                console.log("222");

            }), lg.inputManager.addListener(S.moreBtn, function() {
                //SG.redirectToPortal();
            }), this._freezeZombies()) : this.scheduleOnce(function() {
                Y.resetGame(!H8m.h7H);
            }, H8m.E1S);
            
        }
    },
    _showTextAnim: function(X) {
        var S = "GameOverText",
            P = "ReadyText",
            O = 3E4,
            Z = "TextAnim";
        H8m.g9H(H8m.H6P, this._textAnim) && (this._textAnim = lg.assetsManager.createDisplay(res.effect_plist, Z, H8m.H6P, !H8m.U7H), this.addChild(this._textAnim, O), this._textAnim.setPosition(cc.visibleRect.center), this._textAnim.setFPS(H8m.e9i), this._textAnim.autoStopWhenOver = !H8m.U7H);
        this._textAnim.gotoAndPlay(H8m.h7H);
        this._textAnim.replaceChild(H8m.k0P, X);
        H8m.K9H(P, X) ? lg.playSound(music.ready) : H8m.d9H(S, X) && lg.playSound(music.gameover);
    },
    _showSparkleEffect: function(P, O) {
        this.scheduleOnce(function() {
            var X = function() {
                    S.autoDestroyWhenOver = !H8m.U7H;
                },
                S = lg.assetsManager.createDisplay(res.effect_plist, H8m.K6H, H8m.H6P, !H8m.U7H);
            this.addChild(S, H8m.a9K);
            S.setFPS(H8m.i9i);
            X();
            S.setPosition(P);
            S.play();
        }, O);
    },
    _showSelectedEffect: function() {
        var X = ((72, 0x1A3) >= (0x8D, 0x7A) ? (0xE8, 2.2) : (1.17E3, 14.66E2)),
            S = "ClickRect";
        if (H8m.t9H(H8m.H6P, this._clickRect)) {
            this._clickRect = lg.assetsManager.createDisplay(res.effect_plist, S, H8m.H6P, !H8m.U7H);
            this.addChild(this._clickRect, H8m.a9K);
            var P = cc.ScaleTo.create(H8m.V1S, X, X),
                O = cc.ScaleTo.create(H8m.V1S, H8m.s7H, H8m.s7H);
            this._clickRect.runAction(cc.RepeatForever.create(cc.Sequence.create(P, O)));
        }
        this._clickRect.setVisible(!H8m.U7H);
        this._clickRect.setPosition(this._bomb0.getPosition());
    },
    _showLinkedPath: function(X) {
        var S = cc.Sprite.create();
        this.addChild(S);
        for (var P, O, S = H8m.h7H; H8m.w9H(S, X.length - H8m.h7H); S++)
            P = X[H8m.e9H(S, H8m.h7H)], O = X[S], P = cc.p(this._tileMap.getTiledPositionX(P.x), this._tileMap.getTiledPositionY(P.y)), O = cc.p(this._tileMap.getTiledPositionX(O.x), this._tileMap.getTiledPositionY(O.y)), this._linksss(P, O);
    },
    _linksss: function(X, S) {
        var P,
            O;
        if (H8m.Q9H(X.x, S.x))
            if (P = H8m.r9H(X.y, S.y), O = parseInt(H8m.N9H(Math.abs(P), H8m.h7i)), H8m.m9H(H8m.U7H, P))
                for (var Z = H8m.U7H; H8m.A9H(Z, O); Z++)
                    P = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), P.rotation = 180, P.autoDestroyWhenOver = !0, P.setFPS(30), P.setPosition(cc.p(X.x, X.y + H8m.E9H(95, Z))), P.play(), this.addChild(P);
            else
                for (Z = H8m.U7H; H8m.C9H(Z, O); Z++)
                    P = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), P.autoDestroyWhenOver = !0, P.setFPS(30), P.setPosition(cc.p(X.x, H8m.h9H(X.y, 95 * Z))), P.play(), this.addChild(P);
        else if (P = H8m.y9H(X.x, S.x), O = parseInt(H8m.q9H(Math.abs(P), H8m.h7i)), H8m.l9H(H8m.U7H, P))
            for (Z = H8m.U7H; H8m.X1H(Z, O); Z++)
                P = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), P.rotation = 90, P.autoDestroyWhenOver = !0, P.setFPS(30), P.setPosition(cc.p(H8m.D1H(X.x, 95 * Z), X.y)), P.play(), this.addChild(P);
        else
            for (Z = H8m.U7H; H8m.c1H(Z, O); Z++)
                P = lg.assetsManager.createDisplay(res.effect_plist, "links", null, !0), P.rotation = 270, P.autoDestroyWhenOver = !0, P.setFPS(30), P.setPosition(cc.p(X.x + H8m.z1H(95, Z), X.y)), P.play(), this.addChild(P);
    },
    _showBombAnim: function() {
        var S = 900,
            P = ((43.80E1, 7.86E2) >= (0x17, 66.) ? (0x10E, 1001) : (1.244E3, 27) >= 87.60E1 ? "P" : (5.38E2, 0x13B));
        if (!Global.gameOver)
            try {
                var O = function(X) {
                    R.prop = X.zBomb[Y.assetID];
                };
                this._bomb0.setTileMap(H8m.H6P);
                this._bomb0.zIndex = P;
                this._bomb1.setTileMap(H8m.H6P);
                this._bomb1.zindex = P;
                var Z = new cc.Point(H8m.j1H((this._bomb0.getPositionX() + this._bomb1.getPositionX()), H8m.s7H), H8m.x1H((this._bomb0.getPositionY() + this._bomb1.getPositionY()), H8m.s7H)),
                    Y = this._bomb0,
                    T = this._bomb1;
                this._showSparkleEffect(Z, H8m.U7H);
                var R = lg.assetsManager.createDisplay(res.bombs_plist, Y.assetID + H8m.o1S, H8m.H6P, !H8m.U7H, this, {
                    zIndex: S,
                    __ready__to__kill: !H8m.h7H
                });
                lg.copyProperties(Global.zBomb[Y.assetID], R);
                O(Global);
                R.gotoAndStop(H8m.U7H);
                R.setPosition(Z);
                this._collectBomb(R);
                Y.destroy();
                T.destroy();
            } catch (X) {
                var E = "629";
                alert(X, E);
            }
    },
    _collectBomb: function(S) {
        try {
            var P = this._findTargetZombie(),
                O = H8m.H6P;
            if (H8m.o1H(H8m.q7H, S.type) || H8m.p1H(H8m.b7H, S.type) || H8m.Y1H(H8m.f9i, S.type) || H8m.T1H(H8m.H6P, P)) {
                for (var Z = -H8m.h7H, Y = H8m.H6P, T; ++Z < this._bombs.length;)
                    if (T = H8m.R1H((Z + H8m.h7H), Global.bombSlotGap), H8m.M1H(H8m.H6P, this._bombs[Z])) {
                        if (H8m.V1H(H8m.H6P, P) || H8m.s1H(P.getPositionX() + H8m.F1S * P.speed, T - Global.bombCollidSize)) {
                            O = cc.p(T, Global.earthPositon);
                            this._bombs[Z] = S;
                            break;
                        }
                        H8m.U1H(H8m.H6P, Y) && (Y = Z);
                    }
                H8m.b1H(H8m.H6P, O) && H8m.F1H(H8m.H6P, Y) && (O = cc.p(H8m.k8H((Y + H8m.h7H), Global.bombSlotGap), Global.earthPositon), this._bombs[Y] = S);
                P = H8m.L8H(H8m.H6P, O) ? this.addZombie1(!H8m.U7H) : H8m.H6P;
            } else
                H8m.i8H(12, S.type) ? O = cc.p(H8m.S8H(cc.visibleRect.width / 2, 30), P.getPositionY()) : H8m.P8H(13, S.type) ? O = cc.p(H8m.a8H(cc.visibleRect.width / 2, 30), P.getPositionY() + 20) : H8m.O8H(15, S.type) ? O = cc.p(H8m.B8H(cc.visibleRect.width, 2), P.getPositionY() + 20) : H8m.Z8H(16, S.type) ? O = cc.p(cc.visibleRect.width, P.getPositionY()) : H8m.J8H(17, S.type) && (O = cc.p(H8m.n8H(cc.visibleRect.width, 100), P.getPositionY() + 100));
            P && (O = cc.pAdd(P.getPosition(), cc.p(H8m.G8H(0.6 * P.speed, 20), H8m.W8H(100, P.getScaleY()))), P.__in__kill = !0);
            H8m.v8H(H8m.H6P, O) ? S && S.destroy() : (S.setScale(H8m.F1S), S.runAction(cc.MoveTo.create(H8m.F1S, O)), this.scheduleOnce(function() {
                var X = function() {
                    S.__ready__to__kill = !H8m.U7H;
                };
                X();
                P ? this._doKill(S, P, O) : S.zIndex = H8m.v7H;
            }, H8m.F1S));
        } catch (X) {
            var R = "751";
            alert(X, R);
        }
    },
    _doKill: function(R, E, V) {
        var U = "Bomb17flash",
            k9 = "Bomb16flash",
            L9 = "Bomb15flash",
            K9 = "Bomb12flash";
        try {
            if (E.__in__kill = !H8m.h7H, H8m.u8H(H8m.f9i, R.type))
                R.setFPS(H8m.O4i), R.gotoAndPlay(H8m.U7H), R.autoDestroyWhenOver = !H8m.U7H, this.scheduleOnce(function() {
                    var S = (6. >= (12.57E2, 2.44E2) ? 'o' : 0xF0 > (14, 12.) ? (125., 1080) : 142.0E1 <= (0x1F5, 29.6E1) ? "o" : (1.431E3, 0x1FC)),
                        P = function(X) {
                            E.zIndex = X;
                        };
                    P(H8m.a9K);
                    var O = cc.RotateBy.create(H8m.h7H, S),
                        Z = cc.MoveTo.create(H8m.E1S, cc.p(E.getPositionX() + H8m.O4i, E.getPositionY() + H8m.J7i)),
                        Y = cc.MoveTo.create(H8m.E1S, cc.p(E.getPositionX() + H8m.B0K, E.getPositionY() + H8m.n5i)),
                        T = cc.CallFunc.create(E.destroy, E);
                    E.runAction(cc.Sequence.create(cc.Spawn.create(O, Z, Y), T));
                }, H8m.C1S), this._removeZombie(E);
            else if (H8m.H8H(H8m.l9i, R.type)) {
                var c9 = function() {
                        Global.bing = !H8m.U7H;
                    },
                    t9 = function() {
                        Global.ZombiePause = !H8m.h7H;
                    };
                c9();
                for (var S9 = Global.zombies.length; S9--;)
                    Global.zombies[S9].play(), Global.zombies[S9].onGo(!0);
                t9();
                this.scheduleOnce(function() {
                    if (Global.bing && !Global.gameOver && !Global.ZombiePause) {
                        var X = function() {
                            Global.bing = !1;
                        };
                        for (var S = Global.zombies.length; S--;)
                            Global.zombies[S].onGo(!1), Global.zombies[S].play();
                        X();
                    }
                }, Global.BingDate);
                this._playBoEffect(K9, V);
                R && R.destroy();
            } else if (H8m.f8H(H8m.b9i, R.type))
                Global.ZombiePause = !0, this._freezeZombies(), Global.bing = !1, this.scheduleOnce(function() {
                    if (Global.ZombiePause && !Global.gameOver && !Global.bing) {
                        var X = function() {
                            Global.ZombiePause = !1;
                        };
                        for (var S = Global.zombies.length; S--;)
                            Global.zombies[S].onGo(!1), Global.zombies[S].play();
                        X();
                    }
                }, Global.PauseDate), this._playBoEffect("Bomb13flash", V), R && R.destroy();
            else if (H8m.I8H(H8m.u9i, R.type)) {
                for (S9 = Global.zombies.length; S9--;)
                    Global.zombies[S9].hit(R);
                this._playBoEffect(L9, V);
                R && R.destroy();
            } else if (H8m.g4H(H8m.U9i, R.type))
                Global.ShieldBool = !H8m.U7H, this.scheduleOnce(function() {
                    var X = function() {
                        Global.ShieldBool = !H8m.h7H;
                    };
                    X();
                }, Global.Shield), this._playBoEffect(k9, V), R && R.destroy();
            else if (H8m.K4H(H8m.v9i, R.type)) {
                var j9 = function() {
                        o9.autoDestroyWhenOver = !H8m.U7H;
                    },
                    a9 = function() {
                        Global.health = H8m.d4H(Global.health + Global.Blood, Global.maxHealth) ? Global.maxHealth : Global.health + Global.Blood;
                    };
                a9();
                var o9 = lg.assetsManager.createDisplay(res.effect_plist, U, H8m.H6P, !H8m.U7H, this, {
                    zIndex: H8m.J7i
                });
                j9();
                o9.setPosition(V);
                o9.gotoAndPlay(H8m.U7H);
                o9.txtMc.setLabelText(H8m.D3i, Global.Blood, !H8m.U7H);
                R && R.destroy();
            } else
                E.hit(R);
        } catch (X) {
            var T9 = (1.288E3 < (94., 133.5E1) ? (0x12A, 819) : (75, 0x87));
            alert(X, T9);
        }
    },
    _playBoEffect: function(X, S) {
        var P = function() {
                O.autoDestroyWhenOver = !H8m.U7H;
            },
            O = lg.assetsManager.createDisplay(res.effect_plist, X, H8m.H6P, !H8m.U7H);
        this.addChild(O, H8m.a9K);
        O.setFPS(H8m.i9i);
        P();
        O.setPosition(S);
        O.play();
    },
    _removeZombie: function(X) {
        X = Global.zombies.indexOf(X);
        -H8m.h7H < X && Global.zombies.splice(X, H8m.h7H);
    },
    _findTargetZombie: function() {
        var S = function(X) {
            P = X;
        };
        if (H8m.t4H(H8m.U7H, Global.zombies.length))
            return H8m.H6P;
        for (var P = H8m.H6P, O, Z = Global.zombies.length; Z--;)
            if (O = Global.zombies[Z], H8m.w4H(H8m.H6P, P) || H8m.e4H(O.getPositionX(), P.getPositionX()))
                S(O);
        return P;
    },
    _freezeZombies: function() {
        for (var X = Global.zombies.length; X--;)
            Global.zombies[X].stopAllActions(), Global.zombies[X].stop();
    }
});
Game.create = function(X) {
    var S = new Game;
    S.ui = X;
    return S && S.init() ? S : H8m.H6P;
};
Game.scene = function() {
    var X = "BattlePanel",
        S = cc.Scene.create(),
        P = lg.MovieClip.create(res.ui2_plist, X);
    S.addChild(P);
    P = Game.create(P);
    S.addChild(P);
    S.game = P;
    S.addChild(ControlBar.create(), H8m.v7H);
    lg.assetsManager.addPlist(res.zombies_plist);
    lg.assetsManager.addPlist(res.bombs_plist);
    lg.assetsManager.addPlist(res.effect_plist);
    return S;
};
var AppVersion = H8m.K2H,
    compress = !H8m.h7H,
    a10Enabled = !H8m.h7H,
    a10Remote = !H8m.h7H,
    whiteBackground = !H8m.h7H,
    backgroundColor = whiteBackground ? [H8m.s0K, H8m.s0K, H8m.s0K] : [H8m.U7H, H8m.U7H, H8m.U7H],
    logoSrc = a10Enabled ? H8m.y3P : H8m.u0i,
    logoW = H8m.u8K,
    logoH = a10Enabled ? H8m.h7i : H8m.m1i,
    logoOnCenter = !H8m.h7H,
    myLanguage = H8m.k3i.split(H8m.g8P);
if (a10Enabled)
    try {
        GameAPI.loadAPI(function(X) {
            var S = "A10 api loaded!";
            console.log(S);
        });
    } catch (X) {
        console.log(X);
    }
var sgLanguage = H8m.H6P;
cc.game.onStart = function() {
    SG_Hooks.setOrientationHandler(lg._checkDeviceOrientation);
    SG_Hooks.setResizeHandler(lg._checkDeviceOrientation);
    lg.language = sgLanguage;
    for (var X = 0; H8m.Q4H(X, myLanguage.length);)
        H8m.r4H(myLanguage[X], lg.language) && (lg.languageIndex = X), X++;
    cc.log(myLanguage.join(""), lg.language, lg.languageIndex);
    res = {
        bombs_plist: "res/en/bombs1.json",
        bombs_png: "res/en/bombs1.png",
        effect_plist: "res/en/effect.json",
        effect_png: "res/en/effect.png",
        zombies_plist: "res/en/zombies.json",
        zombies_png: "res/en/zombies.png",
        ui_plist: "res/en/ui1.json",
        ui_png: "res/en/ui1.png",
        ui2_plist: "res/en/ui2.json",
        ui2_png: "res/en/ui2.png",
        ui3_plist: "res/en/ui3.json",
        ui3_png: "res/en/ui3.png",
        logo: "res/logo1.png"
    };
    var S = [res.ui_plist, res.ui_png, res.ui2_plist, res.ui2_png, res.ui3_plist, res.ui3_png],
        P = [res.bombs_plist, res.bombs_png, res.effect_plist, res.effect_png, res.zombies_plist, res.zombies_png],
        X = S.concat(P),
        O = w6b0K[I0K]['getElementById']("gameCanvas");
    cc.view.setDesignResolutionSize(O.width, O.height, cc.ResolutionPolicy.SHOW_ALL);
    cc.view.resizeWithBrowserSize(!0);
    lg.registerScene("mainMenu", MainMenu.scene, S);
    lg.registerScene("mainGame", Game.scene, P);
    lg.registerScene("mainLevel", SelectLevel.scene, S);
    lg.registerScene("mainShop", ShopWin.scene, S);
    Global.score = H8m.N4H(null, cc.sys.localStorage.getItem(ScoreKey)) ? 0 : parseInt(cc.sys.localStorage.getItem(ScoreKey));
    Global.level2 = H8m.m4H(null, cc.sys.localStorage.getItem(LevelKey)) ? 1 : parseInt(cc.sys.localStorage.getItem(LevelKey));
    KOOOO = H8m.A4H(null, cc.sys.localStorage.getItem("KO")) ? 0 : parseInt(cc.sys.localStorage.getItem("KO"));
    S = lg.TileMap.create("bombs");
    S.setTileSize(98, 98);
    S.setMapSize(8, 8);
    S.offsetX = -72;
    S.offsetY = -92;
    lg.registerTileMap(S);
    startWithScene("mainMenu", X);
};
;

